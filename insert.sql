CREATE EXTENSION IF NOT EXISTS "vector";

CREATE TABLE IF NOT EXISTS embeddings (
                                          id SERIAL PRIMARY KEY,
                                          embedding vector,
                                          text text,
                                          created_at timestamptz DEFAULT now()
    );

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

create table problems
(
    problem_id         uuid not null default uuid_generate_v4()
        primary key,
    acceptance_rate    numeric(5, 2) default 0 check(acceptance_rate>=0.0 and acceptance_rate <= 100.00),
    average_rating     numeric(5, 2) default 0 check(average_rating >= 0.0 and average_rating <= 5.0),
    description        text default '',
    problem_level      varchar(20) check(problem_level in ('easy','medium','hard')) default 'easy',
    problem_name       varchar(255) not null,
    score              integer,
    is_available       boolean       default false,
    is_published       boolean       default false,
    problem_structure text
);

alter table problems
    owner to postgres;

create table solutions
(
    author_id  uuid,
    content    text,
    problem_id uuid not null
        constraint fkrm3misp2p4syk4tcnefnqspbl
            references problems,
    primary key (problem_id)
);

alter table solutions
    owner to postgres;

create table hints
(
    level      integer not null,
    content    text,
    problem_id uuid    not null
        constraint fks7m1vov834a6stk5o5gg70ask
            references problems,
    primary key (level, problem_id)
);

alter table hints
    owner to postgres;

create table programming_language
(
    programming_language_id integer not null
        primary key,
    long_name               varchar(50),
    short_name              varchar(20)
);

alter table programming_language
    owner to postgres;

create table default_code
(
    code        text,
    language_id integer not null
        constraint fka8c6jrkgcbeexifxoaa7w80h2
            references programming_language,
    problem_id  uuid    not null
        constraint fkcxolaif2yhkurw5v9lrbkty4u
            references problems,
    primary key (language_id, problem_id)
);

alter table default_code
    owner to postgres;

create table problem_submissions
(
    submission_id        uuid not null default uuid_generate_v4()
        primary key,
    code                 text,
    programming_language varchar(50),
    score_achieved       integer,
    submit_order         integer,
    user_id              uuid,
    problem_id           uuid
        constraint fkatyso4hx6mtu96ixk88g328er
            references problems,
    is_solved            boolean,
    created_at           timestamp(6) default current_timestamp
);

alter table problem_submissions
    owner to postgres;

create table problem_run_code
(
    run_code_id          uuid not null default uuid_generate_v4()
        primary key,
    code                 text,
    programming_language varchar(50),
    score_achieved       integer,
    user_id              uuid,
    problem_id           uuid
        constraint fk8li9cde1nrixxl9ciymf5u4j
            references problems
);

alter table problem_run_code
    owner to postgres;

create table test_cases
(
    testcase_id    uuid not null default uuid_generate_v4()
        primary key,
    input          text,
    output         text,
    user_id        uuid,
    testcase_order integer,
    problem_id     uuid not null
        constraint fkk0300c33ccc0im12utqoxu0m6
            references problems
);

alter table test_cases
    owner to postgres;

create table test_case_outputs
(
    token             uuid,
    result_status     varchar(30),
    runtime           real,
    submission_output text,
    memory            real,
    submission_id     uuid not null
        constraint fkniol765wvj61q9t6lrlhhx091
            references problem_submissions,
    testcase_id       uuid not null
        constraint fkawdt7u0ci9lvfrnphpho4p6xd
            references test_cases,
    primary key (submission_id, testcase_id)
);

alter table test_case_outputs
    owner to postgres;

create table test_case_run_code_outputs
(
    result_status       character varying(30),
    runtime             real,
    submission_output   text,
    token               uuid,
    run_code_id         uuid NOT NULL default uuid_generate_v4()
        constraint fkqk1slm0542aw7no8dvm68t0s
            references problem_run_code,
    testcase_id         uuid NOT NULL default uuid_generate_v4()
        constraint fke8fk765lvj2kta83rtpc7hb8
            references test_cases,
    compile_output      text,
    error               text,
    memory_usage        text,
    message             text,
    status_id           integer,
    constraint test_case_run_code_outputs_pkey
        primary key (run_code_id, testcase_id)
);

alter table test_case_run_code_outputs
    owner to postgres;

create table exercises
(
    exercise_id   uuid not null default uuid_generate_v4()
        primary key,
    description   text,
    exercise_name varchar(255),
	passing_score int
);

alter table exercises
    owner to postgres;

create table medals
(
    medal_id    uuid         not null default uuid_generate_v4()
        primary key,
    bonus_score integer,
    image       text,
    medal_name  varchar(255) not null,
    type        varchar(20)
);

alter table medals
    owner to postgres;

create table achievements
(
    user_id       uuid not null,
    achieved_date timestamp(6) with time zone,
    medal_id      uuid not null
        constraint fkn3w49fym60qqsvsectfeeojck
            references medals,
    primary key (medal_id, user_id)
);

alter table achievements
    owner to postgres;

create table leaderboard
(
    user_id        uuid not null,
    score          bigint not null default 0,
    leaderboard_id uuid not null
        primary key,
    advanced       integer,
    beginner       integer,
    intermediate   integer,
    total_course   integer,
    easy           integer,
    hard           integer,
    medium         integer,
    total_problem  integer,
    type           varchar(255)
);

alter table leaderboard
    owner to postgres;

create table notifications
(
    id           uuid not null
        primary key,
    message      text default '',
    recipient_id uuid,
    timestamp    timestamp(6) with time zone default current_timestamp,
    title        varchar(255) default '',
    type         smallint
        constraint notifications_type_check
            check ((type >= 0) AND (type <= 3)),
    mark_as_read boolean default false
);

alter table notifications
    owner to postgres;


create table questions
(
    question_id      uuid not null default uuid_generate_v4()
        primary key,
    correct_answer   varchar(255),
    created_at       timestamp(6) with time zone default current_timestamp,
    question_content text,
    question_type    char check(question_type in ('S','M')),
    status           varchar(10) check (status in ('active', 'unavailable')),
    updated_at       timestamp(6) with time zone
);

alter table questions
    owner to postgres;

create table options
(
    option_order integer not null,
    content      varchar(255),
    question_id  uuid    not null
        constraint fkjglnbyg0fqsplv75m2oi42ji1
            references questions,
    primary key (option_order, question_id)
);

alter table options
    owner to postgres;

create table question_list
(
    exercise_id uuid not null default uuid_generate_v4()
        constraint fki72qnw59jeo39x6v1uhe0wb51
            references exercises,
    question_id uuid not null
        constraint fkabppvo14rfcil3brx1s9begg2
            references questions
);

alter table question_list
    owner to postgres;

create table report_options
(
    report_option_id uuid not null default uuid_generate_v4()
        primary key,
    handle_action    varchar(255),
    report_reason    varchar(255),
    type             varchar(20)
);

alter table report_options
    owner to postgres;

create table streak_records
(
    user_id      uuid not null
        primary key,
    last_access  timestamp(6) with time zone,
    status       varchar(10),
    streak_score integer,
    medal_id     uuid
        constraint fkejivk072an77tukw69rx6vplu
            references medals
);

alter table streak_records
    owner to postgres;

create table topics
(
    topic_id        uuid default uuid_generate_v4() not null
        primary key,
    content         text,
    number_of_likes bigint default 0,
    post_reach      varchar(10) check (post_reach in ('public', 'private')) default 'public',
    title           varchar(255),
    user_id         varchar(255)
);



alter table topics
    owner to postgres;

create table comments
(
    comment_id         uuid not null
        primary key,
    content            text,
    number_of_likes bigint default 0,
    created            timestamp(6) with time zone default current_timestamp,
    last_modified      timestamp(6) with time zone,
    user_id            uuid,
    parent_comment_id  uuid
        constraint fkst79ninfcw8cbrihoedh118xk
            references comments,
    replied_comment_id uuid
        constraint fkbd3tl8jha2ib2812q9p9yxcmo
            references comments,
    topic_id           uuid
        constraint fkhanwncw4vn5t5syodhdma5sip
            references topics
);

alter table comments
    owner to postgres;

create table comment_reactions
(
    user_id            uuid not null,
    comment_comment_id uuid not null
        constraint fkq6o8wtr8e4nhe4ya9yhnm4mli
            references comments,
    primary key (comment_comment_id, user_id),
    active boolean default true
);

alter table comment_reactions
    owner to postgres;


create table comment_reports
(
    owner_id         uuid not null,
    content          text,
    status           varchar(10),
    user_id          uuid,
    destination_id   uuid not null
        constraint fksscjqt1wyjomldmqvx7u6iqhy
            references comments,
    report_option_id uuid not null
        constraint fkfkwxdv8wp5h56wq69jnp5ux3g
            references report_options,
    primary key (destination_id, owner_id, report_option_id)
);

alter table comment_reports
    owner to postgres;

create table courses
(
    course_id      uuid default uuid_generate_v4() not null
        primary key,
    course_name    varchar(255),
    description    text,
    level          varchar(20) check(level in ('Beginner','Intermediate','Advanced')),
    price          numeric(11, 2) default 0.00,
    unit_price     varchar(10) default 'VNĐ',
    user_id        uuid,
    topic_id       uuid
        constraint uk23uffat5pnitvcg67ugi4kvck
            unique
        constraint fklljvfay1x0yv1gm2xmd6s7j9b
            references topics,
    average_rating double precision,
    review_count   integer default 0,
	score          integer
);

alter table courses
    owner to postgres;

create table lessons
(
    lesson_id    uuid default uuid_generate_v4() not null
        primary key,
    content      text,
    description  text,
    lesson_name  varchar(255),
    lesson_order integer not null default 1,
    problem_id   uuid,
    course_id    uuid                            not null
        constraint fk2uhy91p0gnptep0xxwaal7gnu
            references courses,
    exercise_id  uuid
        constraint uker6gswadtti4suc2pq8wbq94a
            unique
        constraint fkkm6c9l61pmyo1j6a8rpivr85m
            references exercises
);

alter table lessons
    owner to postgres;

create table learning_lesson
(
    learning_id        uuid not null default uuid_generate_v4()
        primary key,
    is_done_practice   boolean,
    is_done_theory     boolean,
    last_accessed_date timestamp(6) with time zone,
    status             varchar(10) check(status in ('New','Done','Learning')),
    user_id            uuid,
    lesson_id          uuid
        constraint fktl0duxtv32rt2myr59sv7d3r3
            references lessons
);

alter table learning_lesson
    owner to postgres;

create table assignments
(
    assignment_id uuid not null default uuid_generate_v4()
        primary key,
    score         numeric(4, 2),
    submit_date   timestamp(6) with time zone,
    submit_order  integer,
    exercise_id   uuid
        constraint fkadkhyietaewgkc3cj0tr8kfon
            references exercises,
    learning_id   uuid not null
        constraint fka5frurhonloarunth7ldi7ahb
            references learning_lesson
);

alter table assignments
    owner to postgres;

create table assignment_details
(
    submit_order  integer not null,
    answer        varchar(20),
    unit_score    numeric(4, 2),
    assignment_id uuid    not null
        constraint fkt8xkuef7x94oj86nfxgq85yg9
            references assignments,
    question_id   uuid    not null
        constraint fk2ymomgwidfms2ucwbdqrevu9x
            references questions,
    primary key (assignment_id, submit_order)
);

alter table assignment_details
    owner to postgres;

create table other_object_reports
(
    owner_id         uuid not null,
    content          text,
    status           varchar(10),
    user_id          uuid,
    destination_id   uuid not null
        constraint fkg6fa7rtsqjtg9imov1j508ors
            references topics,
    report_option_id uuid not null
        constraint fk9ajip7upweyynaymq36mt7mo4
            references report_options,
    primary key (destination_id, owner_id, report_option_id)
);

alter table other_object_reports
    owner to postgres;

create table reviews
(
    review_id uuid    not null default uuid_generate_v4()
        primary key,
    comment   text,
    rating    integer not null check (rating >= 0 and rating <= 5),
    user_uuid   uuid,
    user_uid varchar,
    create_at timestamp(6) with time zone default current_timestamp,
    last_modified_at timestamp(6) with time zone,
    course_id uuid    not null
        constraint fkl9h49973yigjg39ov07a9mog6
            references courses
);

alter table reviews
    owner to postgres;
create table certificates
(
    certificate_id  uuid not null
        primary key,
    certificate_url text,
    completed_date  timestamp(6) with time zone default current_timestamp
);

alter table certificates
    owner to postgres;

create table user_courses
(
    user_uid           uuid not null,
    last_accessed_date timestamp(6) with time zone,
    progress_percent   numeric(5, 2) check ((progress_percent>= 0.00) and (progress_percent <= 100.00)),
    status             varchar(10),
    latest_lesson_id   uuid,
    enroll_using_subscription boolean default FALSE,
    access_status varchar(20),
    course_id          uuid not null
        constraint fkcve18frw4nbxwrq0qh78dgipc
            references courses,
    certificate_id     uuid
        constraint ukc837lk3wvu491io9pfiauof89
            unique
        constraint fk44luvbgh95mw3c0yarrbpfv9t
            references certificates,
    primary key (course_id, user_uid)
);

alter table user_courses
    owner to postgres;

create table categories
(
    category_id   integer      not null
        primary key,
    category_name varchar(100) not null,
    parent_id     integer
        constraint fkcidcf2xf6eebpieowr7m02pg5
            references categories
);

alter table categories
    owner to postgres;

create table course_category
(
    course_id   uuid    not null
        constraint fkl4r5vdloyu8rtqoh4ei49y2x2
            references courses,
    category_id integer not null
        constraint fky6fhus0rcvwiik7rk5l99j3j
            references categories
);

alter table course_category
    owner to postgres;

create table question_category
(
    question_id uuid    not null
        constraint fkssojn51nglg3ydh1lwbk62hyr
            references questions,
    category_id integer not null
        constraint fkpo1ya01k2p6b6b03b4elbvow6
            references categories
);

alter table question_category
    owner to postgres;

create table sections
(
    section_id integer not null
        primary key,
    name       varchar(255)
);

alter table sections
    owner to postgres;

create table course_section
(
    course_id  uuid    not null
        constraint fk61t4e9fdsniv4cui65oih8sr3
            references courses,
    section_id integer not null
        constraint fkidr2cur1nxr2hy5pnf9rsplwi
            references sections
);

alter table course_section
    owner to postgres;

create table problem_category
(
    category_id integer not null,
    problem_id  uuid    not null
        constraint fk2rg82j2evmwbfrglcpvhwpxfa
            references problems,
    primary key (category_id, problem_id)
);

alter table problem_category
    owner to postgres;



create table course_summary
(
    course_id       uuid not null
        primary key
        constraint fk_c_cs
            references courses,
    course_name     varchar(255),
    summary_content text
);

alter table course_summary
    owner to postgres;

create table problem_comments
(
    comment_id          uuid not null default uuid_generate_v4()
        primary key,
    content               text,
    is_modified         boolean,
    number_of_likes     INTEGER,
    created_at          timestamp(6) with time zone,
    last_modified_at    timestamp(6) with time zone,
    user_uuid           uuid,
    user_uid            varchar,
    problem_id  uuid    not null
        constraint fkju03qoqky593eka4s5okbssn5
            references problems,
    parent_comment_id   uuid
        constraint fkfppcc9srw5ppiweo0qjvbls6a
            references problem_comments,
    replied_comment_id  uuid
        constraint fk9rxtnbox2bfnt1582r6apsnls
            references problem_comments
);

alter table problem_comments
    owner to postgres;

create table problem_comment_reactions
(
    user_uuid uuid not null,
    problem_comment_comment_id uuid not null
        constraint fka45m53xgm1j7twrchtcvg5cax
            references problem_comments,
    primary key (user_uuid, problem_comment_comment_id)
);

alter table problem_comment_reactions
    owner to postgres;

create table vnpay_payment_premium_package
(
    payment_premium_package_id uuid not null default uuid_generate_v4()
        primary key,
    user_uuid uuid,
    user_uid text,
    start_date timestamp(6) with time zone,
    end_date timestamp(6) with time zone,
    package_type text,
    status text,
    duration integer
);

alter table vnpay_payment_premium_package
    owner to postgres;

create table vnpay_payment
(
    payment_id uuid not null default uuid_generate_v4()
        primary key,
    user_uid varchar,
    user_uuid uuid not null,
    transaction_status text,
    response_code text,
    total_payment_amount float4,
    currency text,
    paid_amount float4,
    bank_code text,
    transaction_reference text,
    created_at timestamp(6) with time zone,
    received_at timestamp(6) with time zone,
    bank_transaction_no text,
    transaction_no text,
    order_description text,
    payment_for text,
    payment_premium_package_id uuid
        constraint uk4l2cq58r9gpl4h1f315p8e3ng
            unique
        constraint fkl1j58k29u0wph49ltbulycpwe
            references vnpay_payment_premium_package
);

alter table vnpay_payment
    owner to postgres;


create table vnpay_payment_courses
(
    course_id uuid not null,
    user_uid text,
    payment_id uuid
        constraint fkqbo2u2em1wlor0eeu9alboqoy
            references vnpay_payment,
    primary key (course_id, user_uid)
);

alter table vnpay_payment_courses
    owner to postgres;

create table view_solution_behaviors
(
    id         integer generated by default as identity
        primary key,
    created_at timestamp(6),
    problem_id uuid,
    user_id    uuid
);

alter table view_solution_behaviors
    owner to postgres;

INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('dbfea360-dda9-46a5-9487-ea624080bb60', 'What is Stack Data Structure? A Complete Tutorial', null, null, 'Stack', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('5fe612b4-3998-44c7-85b2-2e4e973a38a7', 'The logical thinking and problem-solving skills through practical programming exercises. You’ll learn how to analyze problems, design algorithms, and optimize solution. By the end of the course, you’ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications.', null, null, 'Logic Building Problems', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('f8a1c71a-39ef-406f-b5e3-93b5c4deb5bc', 'A foundational understanding of Data Structures and Algorithms (DSA). You’ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you’ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews.', null, null, 'Introduction to DSA', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('ed7db5f2-03dc-4a0c-a7c6-5549b1c5c090', 'The fundamentals and applications of the matrix as a data structure. You’ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming.', null, null, 'Matrix Data Structure Guide', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('067b8270-f488-41b8-a741-9d118e9dc6c4', 'An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving.', null, null, 'Linked List Data Structure Guide', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('5df3554d-160e-45b9-989a-ebd58ee65235', 'A detailed guide to mastering heaps, including min-heaps and max-heaps. Learn heap operations like insertion, deletion, and heapify, along with their applications in priority queues, sorting algorithms, and efficient problem-solving. Essential for optimizing tasks involving hierarchical data.', null, null, 'Heap Data Structure Guide', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('f16f21af-1f53-4b7d-be4f-368c17574f02', 'A concise guide to understanding and applying recursion in programming. Covers key concepts like base cases, recursive calls, and stack behavior, along with examples in problems such as factorials, Fibonacci sequences, tree traversals, and divide-and-conquer algorithms. Perfect for building efficient and elegant solution.', null, null, 'Guide on Recursive Algorithms', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('dd29f271-a9df-4fcc-a742-127dd269f84b', 'An essential guide to exploring graph algorithms and their applications. Covers fundamental concepts like BFS, DFS, shortest path algorithms (Dijkstra, Bellman-Ford), and minimum spanning trees (Kruskal, Prim). Ideal for solving complex network-based problems in various domains.', null, null, 'Guide on Graph Algorithms', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('a926fe6d-ded3-4127-9558-599fa430e1f6', 'A practical guide to greedy algorithms, focusing on solving optimization problems step-by-step. Learn key strategies with examples like activity selection, Huffman coding, and Kruskal’s algorithm. Perfect for building efficient and straightforward solution.', null, null, 'Guide on Greedy Algorithms', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('0a489a2f-a622-4ba9-a94d-70d5624e1309', 'A comprehensive guide to dynamic programming, covering principles like overlapping subproblems and optimal substructure. Master classic problems such as knapsack, longest common subsequence, and matrix chain multiplication. Ideal for tackling complex optimization challenges.', null, null, 'Dynamic Programming Guide', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('95795791-8e54-4cce-8272-c06c15df68fc', 'An essential guide to bitwise operations and their applications in algorithm design. Covers AND, OR, XOR, shifts, and tricks for solving problems like subsets, power-of-two checks, and fast calculations. Perfect for low-level optimization and competitive programming.', null, null, 'Bitwise Algorithms Guide', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('01e7b3b3-a36a-4679-b082-14c2ad622628', 'Introduction to Queue Data Structure', null, null, 'Queue', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('d9fbda58-f71b-4567-affe-4fbab0933feb', 'What is Stack Data Structure? A Complete Tutorial', null, null, 'Stack', null);


INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'Matrix Data Structure Guide', 'The fundamentals and applications of the matrix as a data structure. You’ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming.', 'Beginner', 100000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'ed7db5f2-03dc-4a0c-a7c6-5549b1c5c090', null, null, 10);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('58220cca-f7ec-4188-9921-18e6ea20e4d7', 'Guide on Recursive Algorithms', 'A concise guide to understanding and applying recursion in programming. Covers key concepts like base cases, recursive calls, and stack behavior, along with examples in problems such as factorials, Fibonacci sequences, tree traversals, and divide-and-conquer algorithms. Perfect for building efficient and elegant solution.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'f16f21af-1f53-4b7d-be4f-368c17574f02', null, null, 20);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'The Logic Building Problems', 'Logical thinking and problem-solving skills through practical programming exercises. You’ll learn how to analyze problems, design algorithms, and optimize solution. By the end of the course, you’ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications.', 'Beginner', 100000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '5fe612b4-3998-44c7-85b2-2e4e973a38a7', null, null, 30);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'Guide on Graph Algorithms', 'An essential guide to exploring graph algorithms and their applications. Covers fundamental concepts like BFS, DFS, shortest path algorithms (Dijkstra, Bellman-Ford), and minimum spanning trees (Kruskal, Prim). Ideal for solving complex network-based problems in various domains.', 'Intermediate', 50000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'dd29f271-a9df-4fcc-a742-127dd269f84b', null, null, 10);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'Introduction to DSA II', 'A foundational understanding of Data Structures and Algorithms (DSA). You’ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you’ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews.', 'Beginner', 100000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'f8a1c71a-39ef-406f-b5e3-93b5c4deb5bc', null, null, 20);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('95713603-63d1-4b75-8a89-1acdc0977459', 'Stack', 'The Stack lesson series offers a comprehensive introduction to one of the fundamental data structures in programming. You''ll explore how a Stack operates based on the LIFO (Last In, First Out) principle, perform core operations such as push, pop, and peek, and apply these concepts to real-world problems like validating parentheses, converting expressions, or building a browser''s backtracking system. This series is ideal for beginners and those looking to strengthen their understanding of data structures.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'd9fbda58-f71b-4567-affe-4fbab0933feb', null, null, 20);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('a24c71fe-2e77-4352-8449-a448ace4d400', 'Bitwise Algorithms Guide', 'An essential guide to bitwise operations and their applications in algorithm design. Covers AND, OR, XOR, shifts, and tricks for solving problems like subsets, power-of-two checks, and fast calculations. Perfect for low-level optimization and competitive programming.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '95795791-8e54-4cce-8272-c06c15df68fc', null, null, 10);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'Dynamic Programming Guide', 'A comprehensive guide to dynamic programming, covering principles like overlapping subproblems and optimal substructure. Master classic problems such as knapsack, longest common subsequence, and matrix chain multiplication. Ideal for tackling complex optimization challenges.', 'Advanced', 100000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '0a489a2f-a622-4ba9-a94d-70d5624e1309', null, null, 30);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'Linked List Data Structure Guide', 'An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving.', 'Beginner', 50000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '067b8270-f488-41b8-a741-9d118e9dc6c4', null, null, 40);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('c9b04774-3a81-43ab-ace6-5242360d9e07', 'Queue', 'The Queue lesson series dives into the mechanics of this fundamental data structure, which follows the FIFO (First In, First Out) principle. You’ll learn how to perform operations such as enqueue, dequeue, and peek, while also exploring its variations like Circular Queues and Priority Queues. Practical applications, including task scheduling, buffering, and breadth-first search algorithms, will help solidify your understanding. This series is perfect for beginners and anyone looking to master essential programming concepts.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '01e7b3b3-a36a-4679-b082-14c2ad622628', null, null, 50);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', e'Introduction to DSA I
', 'A foundational understanding of Data Structures and Algorithms (DSA). You’ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you’ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'dbfea360-dda9-46a5-9487-ea624080bb60', null, null, 20);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('e9d2858c-482e-4b04-8317-b93ce60c3581', 'Heap Data Structure Guide', 'A detailed guide to mastering heaps, including min-heaps and max-heaps. Learn heap operations like insertion, deletion, and heapify, along with their applications in priority queues, sorting algorithms, and efficient problem-solving. Essential for optimizing tasks involving hierarchical data.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '5df3554d-160e-45b9-989a-ebd58ee65235', null, null, 20);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score) VALUES ('f19021ae-42fd-4c25-814c-f06027de04a9', 'Guide on Greedy Algorithms', 'A practical guide to greedy algorithms, focusing on solving optimization problems step-by-step. Learn key strategies with examples like activity selection, Huffman coding, and Kruskal’s algorithm. Perfect for building efficient and straightforward solution.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'a926fe6d-ded3-4127-9558-599fa430e1f6', null, null, 30);

INSERT INTO public.courses (course_id, average_rating, course_name, description, level, price, review_count, unit_price, topic_id, user_id, score) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', null, 'DSA Masterclass', 'Basic to Advanced DSA', 'Advanced', 100000.00, null, 'VND', null, null, 30);
INSERT INTO public.courses (course_id, average_rating, course_name, description, level, price, review_count, unit_price, topic_id, user_id, score) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', null, 'TAOCP 1', 'Basic to Advanced TAOCP Part 1', 'Advanced', 50000.00, null, 'VND', null, null, 30);
INSERT INTO public.courses (course_id, average_rating, course_name, description, level, price, review_count, unit_price, topic_id, user_id, score) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', null, 'TAOCP 2', 'Basic to Advanced TAOCP Part 2', 'Advanced', 100000.00, null, 'VND', null, null, 30);
INSERT INTO public.courses (course_id, average_rating, course_name, description, level, price, review_count, unit_price, topic_id, user_id, score) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', null, 'TAOCP 3', 'Basic to Advanced TAOCP Part 3', 'Advanced', 200000.00, null, 'VND', null, null, 30);
INSERT INTO public.courses (course_id, average_rating, course_name, description, level, price, review_count, unit_price, topic_id, user_id, score) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', null, 'TAOCP 4', 'Basic to Advanced TAOCP Part 4', 'Advanced', 300000.00, null, 'VND', null, null, 30);
INSERT INTO public.courses (course_id, average_rating, course_name, description, level, price, review_count, unit_price, topic_id, user_id, score) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', null, 'TAOCP 5', 'Basic to Advanced TAOCP Part 5', 'Advanced', 400000.00, null, 'VND', null, null, 30);
INSERT INTO public.courses (course_id, average_rating, course_name, description, level, price, review_count, unit_price, topic_id, user_id, score) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', null, 'TAOCP 6', 'Basic to Advanced TAOCP Part 6', 'Advanced', 500000.00, null, 'VND', null, null, 30);
INSERT INTO public.courses (course_id, average_rating, course_name, description, level, price, review_count, unit_price, topic_id, user_id, score) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', null, 'TAOCP 7', 'Basic to Advanced TAOCP Part 7', 'Advanced', 1000000.00, null, 'VND', null, null, 30);

INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '', 'Stack');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '', 'Queue');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('853e7ebc-48f7-4f47-aa0f-7cd103b4e503', '', 'Linked List');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('73a96fec-0145-4ffd-b7c0-ee6d6ff34aef', '', 'Array');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('fa41a74d-5590-49a6-84f7-ad1ceed83eaf', '', 'The Logic Building Problems');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('8f893dfd-b897-4bd5-9c29-097703871710', '', 'Introduction to DSA');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('19759307-a805-4bfd-b1a3-648921705a71', '', 'Matrix Data Structure Guide');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('e73a74e2-29d5-4617-aa46-84c970dbba55', '', 'Linked List Data Structure Guide');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('52aae031-0311-4a7d-b6ba-939bd82fbbff', '', 'Heap Data Structure Guide');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('404d18fc-dd60-448d-bd5f-cb0f8c217553', '', 'Guide on Recursive Algorithms');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('53495d50-8eb3-4188-8976-44ad88b30cb6', '', 'Guide on Graph Algorithms');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('28239350-2d7a-4ab2-8f97-137146a725ca', '', 'Guide on Greedy Algorithms');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('3dea63cf-4407-413b-82be-5cba86b4e6bc', '', 'Dynamic Programming Guide');
INSERT INTO public.exercises (exercise_id, description, exercise_name) VALUES ('3de5e4c5-3fe6-4fa5-be9e-63966e2d63b7', '', 'Bitwise Algorithms Guide');

INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('dfa51df3-225e-42c9-82b4-7ffd179ced23', '2', '2024-12-23 14:19:14.661456 +00:00', 'How are elements stored in an array?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('f2d6151a-0fba-4117-934f-9f0496ea456d', '1', '2024-12-23 16:05:33.703857 +00:00', 'What is the time complexity of accessing an element in an array?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('707fc477-b79b-4065-b220-a79199e534ca', '2', '2024-12-23 16:05:38.507629 +00:00', 'Which of the following operations is not efficient in an array?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('a6330516-d682-4807-90c0-5893c31a2a77', '2', '2024-12-23 16:05:44.210787 +00:00', 'What is the space complexity of an array with n elements?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('c4bf4382-3d91-4f88-84ff-6e73b3c58a59', '1', '2024-12-23 16:05:50.300063 +00:00', 'In a singly linked list, what information does each node contain?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('e00b2dbc-bf57-46fd-ba89-0d58ff3e751f', '1', '2024-12-23 16:05:50.300063 +00:00', 'What is the time complexity of inserting an element at the beginning of a linked list?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('e43c4cb2-0cdd-43c9-b608-99f705d3a897', '2', '2024-12-23 16:05:58.506602 +00:00', 'Which of the following operations is more efficient in a linked list compared to an array?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('7192dff8-d333-42a7-86ed-43f14f041587', '2', '2024-12-23 16:05:58.506602 +00:00', 'What is the space complexity of a linked list with n elements?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27', '2', '2024-12-23 16:05:58.506602 +00:00', 'Which principle does a queue operate on?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('50b51410-e800-4ef0-8433-06aa3575b95d', '2', '2024-12-23 16:05:58.506602 +00:00', 'Which method is used to add an element to a queue?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('5d0938d2-2457-4491-a759-3b32818c164d', '2', '2024-12-23 16:05:58.506602 +00:00', 'Which method is used to remove an element from a queue?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('962c9fc6-db27-4ed1-8a05-eae5e2dab1e0', '1', '2024-12-23 16:06:05.315234 +00:00', 'What is the time complexity of enqueue operation in a queue?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('d4c17fd9-83bc-4b1e-bfd7-114cfd755ce5', '1', '2024-12-23 16:06:05.315234 +00:00', 'Which principle does a stack operate on?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('bdeb7a18-1e34-49d2-8f04-9fcf91561bd0', '1', '2024-12-23 16:06:05.315234 +00:00', 'Which method is used to remove an element from a stack?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('f95e89ba-00d1-4e45-b566-a43aa34202f3', '1', '2024-12-23 16:06:14.614514 +00:00', 'Which method is used to add an element to a stack?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('e6d03d99-6e22-4fb0-97c8-2d18131b8555', '1', '2024-12-23 16:06:22.484900 +00:00', 'What is the time complexity of push operation in a stack?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('a5fb678a-0546-40f4-b17c-7e95a12fd6fd', '3', '2024-12-23 16:06:22.484900 +00:00', 'Which of the following problems is commonly used to test logical thinking?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('46f75789-7fc5-44bd-a19a-de98668d4393', '2', '2024-12-23 16:08:21.577441 +00:00', 'What is the most important step when solving logical problems?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('1352cb96-7ad9-4a91-af36-102cb37966fd', '1', '2024-12-23 16:10:21.272876 +00:00', 'Which of the following is a common approach to solve logical problems?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('99e0a84b-3a47-415d-b2a0-9335394d9ad3', '2', '2024-12-23 16:10:27.576521 +00:00', 'What is the key to solving complex logical problems?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('d7cfdfe2-3a50-4c99-85fa-ce0dc633498f', '1', '2024-12-23 16:10:27.576521 +00:00', 'What does DSA stand for?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('43dcf436-65e4-472d-9ece-17234c1bde58', '2', '2024-12-23 16:10:33.042012 +00:00', 'Why is learning DSA important in programming?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('e423c8a6-60f2-4e45-b71f-08ca35678003', '2', '2024-12-23 16:10:33.042012 +00:00', 'Which of the following is a fundamental concept in DSA?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('4661f08e-36f8-4599-9ec2-a18e6e837316', '2', '2024-12-23 16:10:37.787124 +00:00', 'What is the primary goal of studying DSA?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b', '2', '2024-12-23 16:10:37.787124 +00:00', 'What is a matrix?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('0a8f8813-b742-46e6-9f1a-e4499f6ccadb', '3', '2024-12-23 16:10:45.125857 +00:00', 'What is the time complexity of multiplying two matrices?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('1a50cda2-bf99-467d-a835-394783c20787', '4', '2024-12-23 16:10:45.125857 +00:00', 'Which of the following operations is not efficient on a matrix?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('8d26a566-aa07-414e-ace1-a7b21bb7074c', '3', '2024-12-23 16:10:45.125857 +00:00', 'What is the space complexity of a matrix with n rows and m columns?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('f4b27993-6b3b-4c08-9028-bf4dc40504bd', '3', '2024-12-23 16:10:45.125857 +00:00', 'In a doubly linked list, what information does each node contain?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('7d7f8f96-947c-4bdd-9a44-dc13ac5804a6', '2', '2024-12-23 16:10:45.125857 +00:00', 'What is the time complexity of traversing a linked list?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('626da05f-e658-4fe0-b7e9-9deba29e4d9e', '4', '2024-12-23 16:10:51.325304 +00:00', 'Which of the following operations is more efficient in a doubly linked list compared to a singly linked list?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('e801c3ac-7931-4a9e-8ef9-c36093c14894', '2', '2024-12-23 16:10:51.325304 +00:00', 'What is the space complexity of a doubly linked list with n elements?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('4481dc50-aadc-41e8-b380-43eb9a3980ce', '2', '2024-12-23 16:10:51.325304 +00:00', 'What property must a heap satisfy?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('4854185c-c851-4865-b287-200036252a7f', '3', '2024-12-23 16:10:51.325304 +00:00', 'What is the time complexity of inserting an element into a heap?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('ba2381e4-26d3-4324-a620-ee7c330f048b', '3', '2024-12-23 16:10:51.325304 +00:00', 'Which of the following operations is not efficient on a heap?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('1f837751-5482-4cc6-abaf-9f1b484ab0c9', '2', '2024-12-23 16:10:51.325304 +00:00', 'What is the space complexity of a heap with n elements?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('1c708886-b0db-4910-b14a-97c860599c31', '1', '2025-01-16 12:49:41.834480 +00:00', 'What does FIFO stand for?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('1470e07c-d79d-452d-ac5b-b131cccc2dae', '4', '2025-01-16 12:49:41.834480 +00:00', 'Which data structure is ideal for implementing task scheduling?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('4de9f1b5-4908-44c1-be16-0bd72e917a55', '3', '2025-01-16 12:49:41.834480 +00:00', 'Which type of Queue allows insertion at both ends?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('41178b65-991e-478c-9f3b-873efbf30b56', '4', '2025-01-16 12:49:41.834480 +00:00', 'In which scenario is a Queue most commonly used?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('44c275b0-f360-4676-8664-010bc0565861', '4', '2025-01-16 12:49:41.834480 +00:00', 'Which of the following is NOT a type of Queue?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('04b149c8-95ec-454c-9e6f-6d215d7c5d01', '3', '2025-01-16 12:49:41.834480 +00:00', 'What happens when you try to dequeue from an empty Queue?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('25ff1ed8-1171-4361-b5b1-df695e19c44c', '3', '2025-01-16 12:58:46.979356 +00:00', 'Which of the following is an example of a Stack?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('c39095ad-0a08-4a7a-9f05-a4c6a319f170', '2', '2025-01-16 12:58:46.979356 +00:00', 'In a stack, what does the peek operation do?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('72ce8429-4c6f-46ff-9029-6fc69150ce4a', '1', '2025-01-16 12:58:46.979356 +00:00', 'What is the space complexity of a stack?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('20453226-4074-4f81-a5d7-832f55181149', '2', '2025-01-16 12:49:41.834480 +00:00', 'What is the key principle of a Queue?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('501b8db5-5608-412d-a0a2-a44572085c80', '1', '2025-01-16 12:49:41.834480 +00:00', 'Which of the following is an example of a Queue?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('76d412d0-9dbd-40ce-9fc5-da9b057e5c08', '3', '2025-01-16 12:49:41.834480 +00:00', 'Which operation removes an item from the front of the Queue?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('973a3348-e394-4d3f-a597-35158aa51c74', '1', '2025-01-16 12:49:41.834480 +00:00', 'What is the time complexity of enqueue and dequeue operations in a Queue?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('2114e6b6-1510-4b2f-b379-ed01f9e2b2f3', '4', '2025-01-16 12:58:46.979356 +00:00', 'Which data structure works on Last In First Out (LIFO)?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('35eb528d-f31b-4d02-8f35-083fb12d4b9c', '4', '2025-01-16 12:58:46.979356 +00:00', 'Which operation inserts an element into a stack?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('5ada76a4-9e1c-4f93-8e26-653430a2eb10', '1', '2025-01-16 12:58:46.979356 +00:00', 'What is the initial condition of a stack?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('684fb820-a370-4d34-954f-ddaa11b4f0b4', '3', '2025-01-16 12:58:46.979356 +00:00', 'Which operation removes the top element from a stack?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('720aea7e-824a-46cd-acae-627157c68c16', '4', '2025-01-16 12:58:46.979356 +00:00', 'Which operation is not possible in a stack?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd', '2', '2025-01-16 12:58:46.979356 +00:00', 'What happens when a stack is full and a push operation is attempted?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('7e482eb8-a094-48b3-97a6-6c253045b3e0', '1', '2025-01-16 12:58:46.979356 +00:00', 'Which of these is an application of stack?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('d04af04d-8330-4b16-be86-313bb1df0cac', '3', '2025-01-16 12:58:46.979356 +00:00', 'What is the time complexity of a stack push operation?', 'S', 'active', null);
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at) VALUES ('f0a148ac-4c4e-4306-8957-d9de760351e8', '2', '2025-01-16 12:58:46.979356 +00:00', 'Which data structure can be used for undo operations in text editors?', 'S', 'active', null);



INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'In arbitrary order', 'dfa51df3-225e-42c9-82b4-7ffd179ced23');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'In contiguous memory locations', 'dfa51df3-225e-42c9-82b4-7ffd179ced23');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'In reverse order', 'dfa51df3-225e-42c9-82b4-7ffd179ced23');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'In random order', 'dfa51df3-225e-42c9-82b4-7ffd179ced23');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', 'f2d6151a-0fba-4117-934f-9f0496ea456d');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'f2d6151a-0fba-4117-934f-9f0496ea456d');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', 'f2d6151a-0fba-4117-934f-9f0496ea456d');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', 'f2d6151a-0fba-4117-934f-9f0496ea456d');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Deleting an element from the end', '707fc477-b79b-4065-b220-a79199e534ca');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Accessing an element by index', '707fc477-b79b-4065-b220-a79199e534ca');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Searching for an element', '707fc477-b79b-4065-b220-a79199e534ca');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Inserting an element at the beginning', '707fc477-b79b-4065-b220-a79199e534ca');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', 'a6330516-d682-4807-90c0-5893c31a2a77');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', 'a6330516-d682-4807-90c0-5893c31a2a77');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'a6330516-d682-4807-90c0-5893c31a2a77');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', 'a6330516-d682-4807-90c0-5893c31a2a77');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Data and a pointer to the next node', 'c4bf4382-3d91-4f88-84ff-6e73b3c58a59');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Only a pointer', 'c4bf4382-3d91-4f88-84ff-6e73b3c58a59');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Only data', 'c4bf4382-3d91-4f88-84ff-6e73b3c58a59');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Data and a pointer to the previous node', 'c4bf4382-3d91-4f88-84ff-6e73b3c58a59');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'e00b2dbc-bf57-46fd-ba89-0d58ff3e751f');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', 'e00b2dbc-bf57-46fd-ba89-0d58ff3e751f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', 'e00b2dbc-bf57-46fd-ba89-0d58ff3e751f');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', 'e00b2dbc-bf57-46fd-ba89-0d58ff3e751f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Searching for an element', 'e43c4cb2-0cdd-43c9-b608-99f705d3a897');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Accessing an element by index', 'e43c4cb2-0cdd-43c9-b608-99f705d3a897');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Deleting an element from the end', 'e43c4cb2-0cdd-43c9-b608-99f705d3a897');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Inserting an element at the beginning', 'e43c4cb2-0cdd-43c9-b608-99f705d3a897');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', '7192dff8-d333-42a7-86ed-43f14f041587');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '7192dff8-d333-42a7-86ed-43f14f041587');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '7192dff8-d333-42a7-86ed-43f14f041587');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '7192dff8-d333-42a7-86ed-43f14f041587');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'FILO (First In Last Out)', 'ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'LILO (Last In Last Out)', 'ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'FIFO (First In First Out)', 'ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'LIFO (Last In First Out)', 'ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'enqueue()', '50b51410-e800-4ef0-8433-06aa3575b95d');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'add()', '50b51410-e800-4ef0-8433-06aa3575b95d');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'insert()', '50b51410-e800-4ef0-8433-06aa3575b95d');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'push()', '50b51410-e800-4ef0-8433-06aa3575b95d');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'remove()', '5d0938d2-2457-4491-a759-3b32818c164d');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'delete()', '5d0938d2-2457-4491-a759-3b32818c164d');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'dequeue()', '5d0938d2-2457-4491-a759-3b32818c164d');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'pop()', '5d0938d2-2457-4491-a759-3b32818c164d');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '962c9fc6-db27-4ed1-8a05-eae5e2dab1e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '962c9fc6-db27-4ed1-8a05-eae5e2dab1e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', '962c9fc6-db27-4ed1-8a05-eae5e2dab1e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '962c9fc6-db27-4ed1-8a05-eae5e2dab1e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'FIFO (First In First Out)', 'd4c17fd9-83bc-4b1e-bfd7-114cfd755ce5');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'LILO (Last In Last Out)', 'd4c17fd9-83bc-4b1e-bfd7-114cfd755ce5');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'LIFO (Last In First Out)', 'd4c17fd9-83bc-4b1e-bfd7-114cfd755ce5');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'FILO (First In Last Out)', 'd4c17fd9-83bc-4b1e-bfd7-114cfd755ce5');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'delete()', 'bdeb7a18-1e34-49d2-8f04-9fcf91561bd0');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'remove()', 'bdeb7a18-1e34-49d2-8f04-9fcf91561bd0');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'pop()', 'bdeb7a18-1e34-49d2-8f04-9fcf91561bd0');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'dequeue()', 'bdeb7a18-1e34-49d2-8f04-9fcf91561bd0');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'add()', 'f95e89ba-00d1-4e45-b566-a43aa34202f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'push()', 'f95e89ba-00d1-4e45-b566-a43aa34202f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'enqueue()', 'f95e89ba-00d1-4e45-b566-a43aa34202f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'insert()', 'f95e89ba-00d1-4e45-b566-a43aa34202f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', 'e6d03d99-6e22-4fb0-97c8-2d18131b8555');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', 'e6d03d99-6e22-4fb0-97c8-2d18131b8555');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', 'e6d03d99-6e22-4fb0-97c8-2d18131b8555');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'e6d03d99-6e22-4fb0-97c8-2d18131b8555');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Counting prime numbers', 'a5fb678a-0546-40f4-b17c-7e95a12fd6fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Binary search', 'a5fb678a-0546-40f4-b17c-7e95a12fd6fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Traveling salesman problem', 'a5fb678a-0546-40f4-b17c-7e95a12fd6fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Quick sort', 'a5fb678a-0546-40f4-b17c-7e95a12fd6fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Writing code quickly', '46f75789-7fc5-44bd-a19a-de98668d4393');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Understanding the problem and designing the algorithm', '46f75789-7fc5-44bd-a19a-de98668d4393');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Using existing libraries', '46f75789-7fc5-44bd-a19a-de98668d4393');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Optimizing the code', '46f75789-7fc5-44bd-a19a-de98668d4393');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Random guessing', '1352cb96-7ad9-4a91-af36-102cb37966fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Divide and conquer', '1352cb96-7ad9-4a91-af36-102cb37966fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Ignoring the problem', '1352cb96-7ad9-4a91-af36-102cb37966fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Using brute force', '1352cb96-7ad9-4a91-af36-102cb37966fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Using complex data structures', '99e0a84b-3a47-415d-b2a0-9335394d9ad3');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Writing long code', '99e0a84b-3a47-415d-b2a0-9335394d9ad3');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Breaking down the problem into smaller parts', '99e0a84b-3a47-415d-b2a0-9335394d9ad3');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Memorizing solution', '99e0a84b-3a47-415d-b2a0-9335394d9ad3');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Digital Structure and Algorithm', 'd7cfdfe2-3a50-4c99-85fa-ce0dc633498f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Data Storage and Access', 'd7cfdfe2-3a50-4c99-85fa-ce0dc633498f');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Data System and Analysis', 'd7cfdfe2-3a50-4c99-85fa-ce0dc633498f');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Data Structure and Algorithm', 'd7cfdfe2-3a50-4c99-85fa-ce0dc633498f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'To increase debugging skills', '43dcf436-65e4-472d-9ece-17234c1bde58');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'To optimize algorithms and program performance', '43dcf436-65e4-472d-9ece-17234c1bde58');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'To increase the use of libraries', '43dcf436-65e4-472d-9ece-17234c1bde58');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'To increase coding speed', '43dcf436-65e4-472d-9ece-17234c1bde58');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Scripting', 'e423c8a6-60f2-4e45-b71f-08ca35678003');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Data abstraction', 'e423c8a6-60f2-4e45-b71f-08ca35678003');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Functional programming', 'e423c8a6-60f2-4e45-b71f-08ca35678003');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Object-oriented programming', 'e423c8a6-60f2-4e45-b71f-08ca35678003');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'To write more lines of code', '4661f08e-36f8-4599-9ec2-a18e6e837316');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'To learn new programming languages', '4661f08e-36f8-4599-9ec2-a18e6e837316');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'To understand how to organize and manipulate data efficiently', '4661f08e-36f8-4599-9ec2-a18e6e837316');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'To create graphical user interfaces', '4661f08e-36f8-4599-9ec2-a18e6e837316');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'A binary tree', '8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'A one-dimensional array', '8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'A two-dimensional array', '8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'A linked list', '8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(n)', '0a8f8813-b742-46e6-9f1a-e4499f6ccadb');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(log n)', '0a8f8813-b742-46e6-9f1a-e4499f6ccadb');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(n^3)', '0a8f8813-b742-46e6-9f1a-e4499f6ccadb');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n^2)', '0a8f8813-b742-46e6-9f1a-e4499f6ccadb');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Inserting an element in the middle', '1a50cda2-bf99-467d-a835-394783c20787');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Accessing an element by index', '1a50cda2-bf99-467d-a835-394783c20787');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Adding two matrices', '1a50cda2-bf99-467d-a835-394783c20787');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Transposing a matrix', '1a50cda2-bf99-467d-a835-394783c20787');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '8d26a566-aa07-414e-ace1-a7b21bb7074c');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '8d26a566-aa07-414e-ace1-a7b21bb7074c');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(n*m)', '8d26a566-aa07-414e-ace1-a7b21bb7074c');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '8d26a566-aa07-414e-ace1-a7b21bb7074c');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Only data', 'f4b27993-6b3b-4c08-9028-bf4dc40504bd');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Data and pointers to both the previous and next nodes', 'f4b27993-6b3b-4c08-9028-bf4dc40504bd');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Data and a pointer to the previous node', 'f4b27993-6b3b-4c08-9028-bf4dc40504bd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Data and a pointer to the next node', 'f4b27993-6b3b-4c08-9028-bf4dc40504bd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '7d7f8f96-947c-4bdd-9a44-dc13ac5804a6');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '7d7f8f96-947c-4bdd-9a44-dc13ac5804a6');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '7d7f8f96-947c-4bdd-9a44-dc13ac5804a6');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', '7d7f8f96-947c-4bdd-9a44-dc13ac5804a6');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Traversing the list in reverse order', '626da05f-e658-4fe0-b7e9-9deba29e4d9e');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Inserting an element at the beginning', '626da05f-e658-4fe0-b7e9-9deba29e4d9e');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Deleting an element from the end', '626da05f-e658-4fe0-b7e9-9deba29e4d9e');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Accessing an element by index', '626da05f-e658-4fe0-b7e9-9deba29e4d9e');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', 'e801c3ac-7931-4a9e-8ef9-c36093c14894');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'e801c3ac-7931-4a9e-8ef9-c36093c14894');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', 'e801c3ac-7931-4a9e-8ef9-c36093c14894');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', 'e801c3ac-7931-4a9e-8ef9-c36093c14894');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Recursive property', '4481dc50-aadc-41e8-b380-43eb9a3980ce');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Balanced tree property', '4481dc50-aadc-41e8-b380-43eb9a3980ce');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Determinant property', '4481dc50-aadc-41e8-b380-43eb9a3980ce');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Complete binary tree property', '4481dc50-aadc-41e8-b380-43eb9a3980ce');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '4854185c-c851-4865-b287-200036252a7f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '4854185c-c851-4865-b287-200036252a7f');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', '4854185c-c851-4865-b287-200036252a7f');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '4854185c-c851-4865-b287-200036252a7f');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Deleting the root element', 'ba2381e4-26d3-4324-a620-ee7c330f048b');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Accessing the root element', 'ba2381e4-26d3-4324-a620-ee7c330f048b');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Searching for an element', 'ba2381e4-26d3-4324-a620-ee7c330f048b');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Inserting an element', 'ba2381e4-26d3-4324-a620-ee7c330f048b');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '1f837751-5482-4cc6-abaf-9f1b484ab0c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '1f837751-5482-4cc6-abaf-9f1b484ab0c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '1f837751-5482-4cc6-abaf-9f1b484ab0c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', '1f837751-5482-4cc6-abaf-9f1b484ab0c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Random Access', '20453226-4074-4f81-a5d7-832f55181149');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'FIFO', '20453226-4074-4f81-a5d7-832f55181149');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'None of the above', '20453226-4074-4f81-a5d7-832f55181149');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'LIFO', '20453226-4074-4f81-a5d7-832f55181149');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'insert', '76d412d0-9dbd-40ce-9fc5-da9b057e5c08');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'pop', '76d412d0-9dbd-40ce-9fc5-da9b057e5c08');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'dequeue', '76d412d0-9dbd-40ce-9fc5-da9b057e5c08');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'enqueue', '76d412d0-9dbd-40ce-9fc5-da9b057e5c08');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Call Center System', '501b8db5-5608-412d-a0a2-a44572085c80');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Tree', '501b8db5-5608-412d-a0a2-a44572085c80');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Stack', '501b8db5-5608-412d-a0a2-a44572085c80');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Binary Search Tree', '501b8db5-5608-412d-a0a2-a44572085c80');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '973a3348-e394-4d3f-a597-35158aa51c74');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n^2)', '973a3348-e394-4d3f-a597-35158aa51c74');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(n)', '973a3348-e394-4d3f-a597-35158aa51c74');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(log n)', '973a3348-e394-4d3f-a597-35158aa51c74');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'First In First Out', '1c708886-b0db-4910-b14a-97c860599c31');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'None of the above', '1c708886-b0db-4910-b14a-97c860599c31');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Last In First Out', '1c708886-b0db-4910-b14a-97c860599c31');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'File Input File Output', '1c708886-b0db-4910-b14a-97c860599c31');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Queue', '1470e07c-d79d-452d-ac5b-b131cccc2dae');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Binary Tree', '1470e07c-d79d-452d-ac5b-b131cccc2dae');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Hash Table', '1470e07c-d79d-452d-ac5b-b131cccc2dae');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Stack', '1470e07c-d79d-452d-ac5b-b131cccc2dae');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Stack', '4de9f1b5-4908-44c1-be16-0bd72e917a55');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Priority Queue', '4de9f1b5-4908-44c1-be16-0bd72e917a55');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Deque', '4de9f1b5-4908-44c1-be16-0bd72e917a55');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Circular Queue', '4de9f1b5-4908-44c1-be16-0bd72e917a55');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Breadth-First Search', '41178b65-991e-478c-9f3b-873efbf30b56');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Undo operations in editors', '41178b65-991e-478c-9f3b-873efbf30b56');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Evaluating expressions', '41178b65-991e-478c-9f3b-873efbf30b56');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Task scheduling', '41178b65-991e-478c-9f3b-873efbf30b56');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Circular Queue', '44c275b0-f360-4676-8664-010bc0565861');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Priority Queue', '44c275b0-f360-4676-8664-010bc0565861');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Deque', '44c275b0-f360-4676-8664-010bc0565861');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Binary Search Queue', '44c275b0-f360-4676-8664-010bc0565861');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Adds a default value', '04b149c8-95ec-454c-9e6f-6d215d7c5d01');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Dequeues another element', '04b149c8-95ec-454c-9e6f-6d215d7c5d01');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Throws an exception or error', '04b149c8-95ec-454c-9e6f-6d215d7c5d01');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Ignores the operation', '04b149c8-95ec-454c-9e6f-6d215d7c5d01');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Queue', '25ff1ed8-1171-4361-b5b1-df695e19c44c');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Binary Search Tree', '25ff1ed8-1171-4361-b5b1-df695e19c44c');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Browser back button', '25ff1ed8-1171-4361-b5b1-df695e19c44c');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Tree', '25ff1ed8-1171-4361-b5b1-df695e19c44c');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Pop', '35eb528d-f31b-4d02-8f35-083fb12d4b9c');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Enqueue', '35eb528d-f31b-4d02-8f35-083fb12d4b9c');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Peek', '35eb528d-f31b-4d02-8f35-083fb12d4b9c');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Push', '35eb528d-f31b-4d02-8f35-083fb12d4b9c');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Dequeue', '684fb820-a370-4d34-954f-ddaa11b4f0b4');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Push', '684fb820-a370-4d34-954f-ddaa11b4f0b4');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Pop', '684fb820-a370-4d34-954f-ddaa11b4f0b4');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Peek', '684fb820-a370-4d34-954f-ddaa11b4f0b4');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(n^2)', 'd04af04d-8330-4b16-be86-313bb1df0cac');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'd04af04d-8330-4b16-be86-313bb1df0cac');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(1)', 'd04af04d-8330-4b16-be86-313bb1df0cac');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(log n)', 'd04af04d-8330-4b16-be86-313bb1df0cac');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Array', '2114e6b6-1510-4b2f-b379-ed01f9e2b2f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Queue', '2114e6b6-1510-4b2f-b379-ed01f9e2b2f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Tree', '2114e6b6-1510-4b2f-b379-ed01f9e2b2f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Stack', '2114e6b6-1510-4b2f-b379-ed01f9e2b2f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Recursion', '7e482eb8-a094-48b3-97a6-6c253045b3e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Breadth First Search', '7e482eb8-a094-48b3-97a6-6c253045b3e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Sorting', '7e482eb8-a094-48b3-97a6-6c253045b3e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Graph traversal', '7e482eb8-a094-48b3-97a6-6c253045b3e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Inserts an element at the top', 'c39095ad-0a08-4a7a-9f05-a4c6a319f170');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Returns the top element without removing it', 'c39095ad-0a08-4a7a-9f05-a4c6a319f170');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Checks if the stack is full', 'c39095ad-0a08-4a7a-9f05-a4c6a319f170');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Removes the top element', 'c39095ad-0a08-4a7a-9f05-a4c6a319f170');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'The stack is resized', '9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Stack underflow occurs', '9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Stack overflow occurs', '9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'The element is added', '9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'The stack is empty', '5ada76a4-9e1c-4f93-8e26-653430a2eb10');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'The stack is full', '5ada76a4-9e1c-4f93-8e26-653430a2eb10');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'The stack is half full', '5ada76a4-9e1c-4f93-8e26-653430a2eb10');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'The stack has one element', '5ada76a4-9e1c-4f93-8e26-653430a2eb10');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Tree', 'f0a148ac-4c4e-4306-8957-d9de760351e8');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Stack', 'f0a148ac-4c4e-4306-8957-d9de760351e8');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Queue', 'f0a148ac-4c4e-4306-8957-d9de760351e8');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Array', 'f0a148ac-4c4e-4306-8957-d9de760351e8');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(n)', '72ce8429-4c6f-46ff-9029-6fc69150ce4a');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(log n)', '72ce8429-4c6f-46ff-9029-6fc69150ce4a');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(n^2)', '72ce8429-4c6f-46ff-9029-6fc69150ce4a');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(1)', '72ce8429-4c6f-46ff-9029-6fc69150ce4a');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Peek', '720aea7e-824a-46cd-acae-627157c68c16');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Pop', '720aea7e-824a-46cd-acae-627157c68c16');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Push', '720aea7e-824a-46cd-acae-627157c68c16');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Traversal', '720aea7e-824a-46cd-acae-627157c68c16');


INSERT INTO public.question_list (exercise_id, question_id) VALUES ('73a96fec-0145-4ffd-b7c0-ee6d6ff34aef', '707fc477-b79b-4065-b220-a79199e534ca');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('73a96fec-0145-4ffd-b7c0-ee6d6ff34aef', 'a6330516-d682-4807-90c0-5893c31a2a77');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('73a96fec-0145-4ffd-b7c0-ee6d6ff34aef', 'dfa51df3-225e-42c9-82b4-7ffd179ced23');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('73a96fec-0145-4ffd-b7c0-ee6d6ff34aef', 'f2d6151a-0fba-4117-934f-9f0496ea456d');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('853e7ebc-48f7-4f47-aa0f-7cd103b4e503', '7192dff8-d333-42a7-86ed-43f14f041587');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('853e7ebc-48f7-4f47-aa0f-7cd103b4e503', 'c4bf4382-3d91-4f88-84ff-6e73b3c58a59');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('853e7ebc-48f7-4f47-aa0f-7cd103b4e503', 'e00b2dbc-bf57-46fd-ba89-0d58ff3e751f');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('853e7ebc-48f7-4f47-aa0f-7cd103b4e503', 'e43c4cb2-0cdd-43c9-b608-99f705d3a897');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '50b51410-e800-4ef0-8433-06aa3575b95d');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '5d0938d2-2457-4491-a759-3b32818c164d');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '962c9fc6-db27-4ed1-8a05-eae5e2dab1e0');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', 'ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', 'bdeb7a18-1e34-49d2-8f04-9fcf91561bd0');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', 'd4c17fd9-83bc-4b1e-bfd7-114cfd755ce5');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', 'e6d03d99-6e22-4fb0-97c8-2d18131b8555');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', 'f95e89ba-00d1-4e45-b566-a43aa34202f3');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('fa41a74d-5590-49a6-84f7-ad1ceed83eaf', '1352cb96-7ad9-4a91-af36-102cb37966fd');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('fa41a74d-5590-49a6-84f7-ad1ceed83eaf', '46f75789-7fc5-44bd-a19a-de98668d4393');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('fa41a74d-5590-49a6-84f7-ad1ceed83eaf', '99e0a84b-3a47-415d-b2a0-9335394d9ad3');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('fa41a74d-5590-49a6-84f7-ad1ceed83eaf', 'a5fb678a-0546-40f4-b17c-7e95a12fd6fd');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('8f893dfd-b897-4bd5-9c29-097703871710', '43dcf436-65e4-472d-9ece-17234c1bde58');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('8f893dfd-b897-4bd5-9c29-097703871710', '4661f08e-36f8-4599-9ec2-a18e6e837316');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('8f893dfd-b897-4bd5-9c29-097703871710', 'd7cfdfe2-3a50-4c99-85fa-ce0dc633498f');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('8f893dfd-b897-4bd5-9c29-097703871710', 'e423c8a6-60f2-4e45-b71f-08ca35678003');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('19759307-a805-4bfd-b1a3-648921705a71', '0a8f8813-b742-46e6-9f1a-e4499f6ccadb');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('19759307-a805-4bfd-b1a3-648921705a71', '1a50cda2-bf99-467d-a835-394783c20787');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('19759307-a805-4bfd-b1a3-648921705a71', '8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('19759307-a805-4bfd-b1a3-648921705a71', '8d26a566-aa07-414e-ace1-a7b21bb7074c');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('e73a74e2-29d5-4617-aa46-84c970dbba55', '626da05f-e658-4fe0-b7e9-9deba29e4d9e');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('e73a74e2-29d5-4617-aa46-84c970dbba55', '7d7f8f96-947c-4bdd-9a44-dc13ac5804a6');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('e73a74e2-29d5-4617-aa46-84c970dbba55', 'e801c3ac-7931-4a9e-8ef9-c36093c14894');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('e73a74e2-29d5-4617-aa46-84c970dbba55', 'f4b27993-6b3b-4c08-9028-bf4dc40504bd');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('52aae031-0311-4a7d-b6ba-939bd82fbbff', '1f837751-5482-4cc6-abaf-9f1b484ab0c9');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('52aae031-0311-4a7d-b6ba-939bd82fbbff', '4481dc50-aadc-41e8-b380-43eb9a3980ce');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('52aae031-0311-4a7d-b6ba-939bd82fbbff', '4854185c-c851-4865-b287-200036252a7f');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('52aae031-0311-4a7d-b6ba-939bd82fbbff', 'ba2381e4-26d3-4324-a620-ee7c330f048b');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '20453226-4074-4f81-a5d7-832f55181149');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '76d412d0-9dbd-40ce-9fc5-da9b057e5c08');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '501b8db5-5608-412d-a0a2-a44572085c80');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '973a3348-e394-4d3f-a597-35158aa51c74');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '1c708886-b0db-4910-b14a-97c860599c31');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '1470e07c-d79d-452d-ac5b-b131cccc2dae');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '4de9f1b5-4908-44c1-be16-0bd72e917a55');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '41178b65-991e-478c-9f3b-873efbf30b56');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '44c275b0-f360-4676-8664-010bc0565861');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '04b149c8-95ec-454c-9e6f-6d215d7c5d01');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '25ff1ed8-1171-4361-b5b1-df695e19c44c');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '35eb528d-f31b-4d02-8f35-083fb12d4b9c');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '684fb820-a370-4d34-954f-ddaa11b4f0b4');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', 'd04af04d-8330-4b16-be86-313bb1df0cac');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '2114e6b6-1510-4b2f-b379-ed01f9e2b2f3');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '7e482eb8-a094-48b3-97a6-6c253045b3e0');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', 'c39095ad-0a08-4a7a-9f05-a4c6a319f170');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '5ada76a4-9e1c-4f93-8e26-653430a2eb10');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', 'f0a148ac-4c4e-4306-8957-d9de760351e8');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '72ce8429-4c6f-46ff-9029-6fc69150ce4a');
INSERT INTO public.question_list (exercise_id, question_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '720aea7e-824a-46cd-acae-627157c68c16');


INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('bc7282ef-2185-47e3-acbc-5b5597cbbbfc', e'****Examples :****





```
Input:  1/2 + 3/2
Output: 2/1

Input:  1/3 + 3/9
Output: 2/3

Input:  1/5 + 3/15
Output: 2/5
```







****Algorithm to add two fractions****





* Find a common denominator by finding the LCM (Least Common Multiple) of the two denominators.
* Change the

  [fractions](https://www.geeksforgeeks.org/fractions/)
  to have the same denominator and add both terms.
* Reduce the final fraction obtained into its simpler form by dividing both numerator and denominator by their largest common factor.





C++

````
// C++ program to add 2 fractions
#include<bits/stdc++.h>
using namespace std;

// Function to return gcd of a and b
int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b%a, a);
}

// Function to convert the obtained fraction
// into it\'s simplest form
void lowest(int &den3, int &num3)
{
    // Finding gcd of both terms
    int common_factor = gcd(num3,den3);

// Converting both terms into simpler
    // terms by dividing them by common factor
    den3 = den3/common_factor;
    num3 = num3/common_factor;
}

//Function to add two fractions
void addFraction(int num1, int den1, int num2,
                 int den2, int &num3, int &den3)
{
    // Finding gcd of den1 and den2
    den3 = gcd(den1,den2);

// Denominator of final fraction obtained
    // finding LCM of den1 and den2
    // LCM * GCD = a * b
    den3 = (den1*den2) / den3;

// Changing the fractions to have same denominator
    // Numerator of the final fraction obtained
    num3 = (num1)*(den3/den1) + (num2)*(den3/den2);

// Calling function to convert final fraction
    // into it\'s simplest form
    lowest(den3,num3);
}

// Driver program
int main()
{
    int num1=1, den1=500, num2=2, den2=1500, den3, num3;
    addFraction(num1, den1, num2, den2, num3, den3);
    printf("%d/%d + %d/%d is equal to %d/%d\\n", num1, den1,
                                   num2, den2, num3, den3);
    return 0;
}

````

Java

````
// Java program to add 2 fractions

class GFG{
// Function to return gcd of a and b
static int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b%a, a);
}

// Function to convert the obtained fraction
// into it\'s simplest form
static void lowest(int den3, int num3)
{
    // Finding gcd of both terms
    int common_factor = gcd(num3,den3);

// Converting both terms into simpler
    // terms by dividing them by common factor
    den3 = den3/common_factor;
    num3 = num3/common_factor;
    System.out.println(num3+"/"+den3);
}

//Function to add two fractions
static void addFraction(int num1, int den1,
                        int num2, int den2)
{
    // Finding gcd of den1 and den2
    int den3 = gcd(den1,den2);

// Denominator of final fraction obtained
    // finding LCM of den1 and den2
    // LCM * GCD = a * b
    den3 = (den1*den2) / den3;

// Changing the fractions to have same denominator
    // Numerator of the final fraction obtained
    int num3 = (num1)*(den3/den1) + (num2)*(den3/den2);

// Calling function to convert final fraction
    // into it\'s simplest form
    lowest(den3,num3);
}

// Driver program
public static void main(String[] args)
{
    int num1=1, den1=500, num2=2, den2=1500;
    System.out.print(num1+"/"+den1+" + "+num2+"/"+den2+" is equal to ");
    addFraction(num1, den1, num2, den2);
}
}
// This code is contributed by mits

````

Python3

````
# Python3 program to add 2 fractions

# Function to return gcd of a and b
def gcd(a, b):
    if (a == 0):
        return b;
    return gcd(b % a, a);

# Function to convert the obtained
# fraction into it\'s simplest form
def lowest(den3, num3):

    # Finding gcd of both terms
    common_factor = gcd(num3, den3);

    # Converting both terms
    # into simpler terms by
    # dividing them by common factor
    den3 = int(den3 / common_factor);
    num3 = int(num3 / common_factor);
    print(num3, "/", den3);

# Function to add two fractions
def addFraction(num1, den1, num2, den2):

    # Finding gcd of den1 and den2
    den3 = gcd(den1, den2);

    # Denominator of final
    # fraction obtained finding
    # LCM of den1 and den2
    # LCM * GCD = a * b
    den3 = (den1 * den2) / den3;

    # Changing the fractions to
    # have same denominator Numerator
    # of the final fraction obtained
    num3 = ((num1) * (den3 / den1) +
            (num2) * (den3 / den2));

    # Calling function to convert
    # final fraction into it\'s
    # simplest form
    lowest(den3, num3);

# Driver Code
num1 = 1; den1 = 500;
num2 = 2; den2 = 1500;

print(num1, "/", den1, " + ", num2, "/",
      den2, " is equal to ", end = "");
addFraction(num1, den1, num2, den2);

# This code is contributed by mits

````

C#

````
// C# program to add 2 fractions

class GFG{
// Function to return gcd of a and b
static int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b%a, a);
}

// Function to convert the obtained fraction
// into it\'s simplest form
static void lowest(int den3, int num3)
{
    // Finding gcd of both terms
    int common_factor = gcd(num3,den3);

// Converting both terms into simpler
    // terms by dividing them by common factor
    den3 = den3/common_factor;
    num3 = num3/common_factor;
    System.Console.WriteLine(num3+"/"+den3);
}

//Function to add two fractions
static void addFraction(int num1, int den1, int num2, int den2)
{
    // Finding gcd of den1 and den2
    int den3 = gcd(den1,den2);

// Denominator of final fraction obtained
    // finding LCM of den1 and den2
    // LCM * GCD = a * b
    den3 = (den1*den2) / den3;

// Changing the fractions to have same denominator
    // Numerator of the final fraction obtained
    int num3 = (num1)*(den3/den1) + (num2)*(den3/den2);

// Calling function to convert final fraction
    // into it\'s simplest form
    lowest(den3,num3);
}

// Driver program
public static void Main()
{
    int num1=1, den1=500, num2=2, den2=1500;
    System.Console.Write(num1+"/"+den1+" + "+num2+"/"+den2+" is equal to ");
    addFraction(num1, den1, num2, den2);
}
}
// This code is contributed by mits

````

JavaScript

````
<script>

// Javascript program to add 2 fractions

// Function to return gcd of a and b

const gcd = (a, b) => {
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

// Function to convert the
// obtained fraction into
// it\'s simplest form

const lowest = (den3, num3) => {
    // Finding gcd of both terms
    let common_factor = gcd(num3, den3);

// Converting both terms
    // into simpler terms by
    // dividing them by common factor

    den3 = parseInt(den3 / common_factor);
    num3 = parseInt(num3 / common_factor);

    document.write(`${num3}/${den3}`)
}


// Function to add two fractions
const addFraction = (num1, den1, num2, den2) => {
    // Finding gcd of den1 and den2
    let den3 = gcd(den1, den2);

// Denominator of final
    // fraction obtained finding
    // LCM of den1 and den2
    // LCM * GCD = a * b
    den3 = (den1 * den2) / den3;

// Changing the fractions to
    // have same denominator Numerator
    // of the final fraction obtained
    let num3 = ((num1) * (den3 / den1) +
            (num2) * (den3 / den2));

// Calling function to convert
    // final fraction into it\'s
    // simplest form
    lowest(den3, num3);
}

// Driver Code
let num1 = 1;
let den1 = 500;
let num2 = 2;
let den2 = 1500;

document.write(`${num1}/${den1} + ${num2}/${den2} is equal to `);

addFraction(num1, den1, num2, den2);

// This code is contributed by _saurabh_jaiswal

</script>

````

PHP

````
<?php
// PHP program to add
// 2 fractions

// Function to return
// gcd of a and b
function gcd($a, $b)
{
    if ($a == 0)
        return $b;
    return gcd($b % $a, $a);
}

// Function to convert the
// obtained fraction into
// it\'s simplest form
function lowest(&$den3, &$num3)
{
    // Finding gcd of both terms
    $common_factor = gcd($num3, $den3);

// Converting both terms
    // into simpler terms by
    // dividing them by common factor

    $den3 = (int)$den3 / $common_factor;
    $num3 = (int) $num3 / $common_factor;
}

// Function to add
// two fractions
function addFraction($num1, $den1, $num2,
                     $den2, &$num3, &$den3)
{
    // Finding gcd of den1 and den2
    $den3 = gcd($den1, $den2);

// Denominator of final
    // fraction obtained finding
    // LCM of den1 and den2
    // LCM * GCD = a * b
    $den3 = ($den1 * $den2) / $den3;

// Changing the fractions to
    // have same denominator Numerator
    // of the final fraction obtained
    $num3 = ($num1) * ($den3 / $den1) +
            ($num2) * ($den3 / $den2);

// Calling function to convert
    // final fraction into it\'s
    // simplest form
    lowest($den3, $num3);
}

// Driver Code
$num1 = 1; $den1 = 500;
$num2 = 2; $den2 = 1500;
$den3; $num3;
addFraction($num1, $den1, $num2,
            $den2, $num3, $den3);
echo $num1, "/", $den1, " + ",
     $num2,"/", $den2, " is equal to ",
               $num3, "/", $den3, "\\n";

// This code is contributed by aj_36
?>

````

****Output :****


```
1/500 + 2/1500 is equal to 1/300
```

****Time Complexity:****
O(log(min(a, b)), where a and b are two integers.


****Auxiliary Space:****
O(1), no extra space required so it is a constant.
', 'Add two fraction a/b and c/d and print answer in simplest form.', 'Program to add two fractions', 2, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('aad6df64-c3f4-40e1-961b-817fa187f81f', e'
****Examples:****


```
Input: n = 15
Output: false
Divisors of 15 are 1, 3 and 5. Sum of
divisors is 9 which is not equal to 15.
Input: n = 6
Output: true
Divisors of 6 are 1, 2 and 3. Sum of
divisors is 6.


```




Recommended Practice

[Perfect Number](https://www.geeksforgeeks.org/problems/perfect-number3759/1/)


[Try It!](https://www.geeksforgeeks.org/problems/perfect-number3759/1/)


A

****Simple Solution****
is to go through every number from 1 to n-1 and check if it is a divisor. Maintain sum of all divisors. If sum becomes equal to n, then return true, else return false.



An

****Efficient Solution****
is to go through numbers till square root of n. If a number ‘i’ divides n, then add both ‘i’ and n/i to sum.



Below is the implementation of efficient solution.





C++
---

















```
// C++ program to check if a given number is perfect
// or not
#include<iostream>
using namespace std;

// Returns true if n is perfect
bool isPerfect( long long int n)
{
// To store sum of divisors
long long int sum = 1;

// Find all divisors and add them
for ( long long int i=2; i*i<=n; i++)
{
if (n%i==0)
{
if (i*i!=n)
sum = sum + i + n/i;
else
sum=sum+i;
}
}
// If sum of divisors is equal to
// n, then n is a perfect number
if (sum == n && n != 1)
return true ;

return false ;
}

// Driver program
int main()
{
cout << "Below are all perfect numbers till 10000\\n" ;
for ( int n =2; n<10000; n++)
if (isPerfect(n))
cout << n << " is a perfect number\\n" ;

return 0;
}
```





Java
----

















```
// Java program to check if a given
// number is perfect or not
import java.io.*;
public class GFG
{

// Returns true if n is perfect
static boolean isPerfect( int n)
{
// To store sum of divisors
int sum = 1 ;

// Find all divisors and add them
for ( int i = 2 ; i * i <= n; i++)
{
if (n % i== 0 )
{
if (i * i != n)
sum = sum + i + n / i;
else
sum = sum + i;
}
}
// If sum of divisors is equal to
// n, then n is a perfect number
if (sum == n && n != 1 )
return true ;

return false ;
}

// Driver program
public static void main (String[] args)
{
System.out.println( "Below are all perfect" +
"numbers till 10000" );
for ( int n = 2 ; n < 10000 ; n++)
if (isPerfect(n))
System.out.println( n +
" is a perfect number" );
}
}

// This code is contributed by mits
```





Python3
-------

















```
# Python3 code to check if a given
# number is perfect or not

# Returns true if n is perfect
def isPerfect( n ):

# To store sum of divisors
sum = 1

# Find all divisors and add them
i = 2
while i * i < = n:
if n % i = = 0 :
sum = sum + i + n / i
i + = 1

# If sum of divisors is equal to
# n, then n is a perfect number

return ( True if sum = = n and n! = 1 else False )

# Driver program
print ( "Below are all perfect numbers till 10000" )
n = 2
for n in range ( 10000 ):
if isPerfect (n):
print (n , " is a perfect number" )

# This code is contributed by "Sharad_Bhardwaj".
```





C#
--

















```
// C# program to check if a given
// number is perfect or not

class GFG
{

// Returns true if n is perfect
static bool isPerfect( int n)
{
// To store sum of divisors
int sum = 1;

// Find all divisors and add them
for ( int i = 2; i * i <= n; i++)
{
if (n % i==0)
{
if (i * i != n)
sum = sum + i + n / i;
else
sum = sum + i;
}
}
// If sum of divisors is equal to
// n, then n is a perfect number
if (sum == n && n != 1)
return true ;

return false ;
}

// Driver program
static void Main()
{
System.Console.WriteLine( "Below are all perfect" +
"numbers till 10000" );
for ( int n = 2; n < 10000; n++)
if (isPerfect(n))
System.Console.WriteLine( n +
" is a perfect number" );
}
}

// This code is contributed by chandan_jnu
```





Javascript
----------

















```
<script>

// Javascript program to check if a given number is perfect
// or not

// Returns true if n is perfect
function isPerfect(n)
{
// To store sum of divisors
sum = 1;

// Find all divisors and add them
for (let i=2; i*i<=n; i++)
{
if (n%i==0)
{
if (i*i!=n)
sum = sum + i + n/i;
else
sum=sum+i;
}
}
// If sum of divisors is equal to
// n, then n is a perfect number
if (sum == n && n != 1)
return true ;

return false ;
}

// Driver program

document.write( "Below are all perfect numbers till 10000" + "<br>" );
for (let n =2; n<10000; n++)
if (isPerfect(n))
document.write(n + " is a perfect number" + "<br>" );

// This code is contributed by Mayank Tyagi

</script>
```





PHP
---

















```
<?php
// PHP program to check if a given number
// is perfect or not

// Returns true if n is perfect
function isPerfect( $n )
{
// To store sum of divisors
$sum = 1;

// Find all divisors and add them
for ( $i = 2; $i * $i <= $n ; $i ++)
{
if ( $n % $i == 0)
{
if ( $i * $i != $n )
$sum = $sum + $i + (int)( $n / $i );
else
$sum = $sum + $i ;
}
}
// If sum of divisors is equal to
// n, then n is a perfect number
if ( $sum == $n && $n != 1)
return true;

return false;
}

// Driver Code
echo "Below are all perfect numbers till 10000\\n" ;
for ( $n = 2; $n < 10000; $n ++)
if (isPerfect( $n ))
echo "$n is a perfect number\\n" ;

// This code is contributed by mits
?>
```







**Output**
```
Below are all perfect numbers till 10000
6 is a perfect number
28 is a perfect number
496 is a perfect number
8128 is a perfect number



```

****Time Complexity:****
O(log(n))

', 'A number is a perfect number if is equal to sum of its proper divisors, that is, sum of its positive divisors excluding the number itself. Write a function to check if a given number is perfect or not.', 'Perfect Number', 3, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('b1a2bec7-f49b-4d01-a799-d27664456f71', e'A number is called as a

****Jumping Number****
if all adjacent digits in it differ by

****1****
. The difference between

****‘9****
’ and

****‘0’****
is not considered as 1.



All single digit numbers are considered as Jumping Numbers. For example 7, 8987 and 4343456 are

****Jumping numbers****
but 796 and 89098 are not.



Given a positive number

****x****
, print all

****Jumping Numbers****
smaller than or equal to

****x****
. The numbers can be printed in any order.


****Example:****

```
Input: x = 20
Output:  0 1 2 3 4 5 6 7 8 9 10 12

Input: x = 105
Output:  0 1 2 3 4 5 6 7 8 9 10 12
         21 23 32 34 43 45 54 56 65
         67 76 78 87 89 98 101

Note: Order of output doesn\'t matter,
                                                                                                                                    i.e. numbers can be printed in any order
```


One

****Simple Solution****
is to traverse all

[numbers](https://www.geeksforgeeks.org/numbers/)
from

****0****
to

****x****
. For every traversed number, check if it is a Jumping number. If

****yes****
, then print it. Otherwise ignore it.


C++14

````
#include <bits/stdc++.h>

using namespace std;

void print_sieve(int& x)
{
    int i,temp,digit;
    bool check;

    for(i=0;i<=x;i++)
    {
        if(i<10)
        {
            cout<<i<<" ";
            continue;
        }
        check=1;
        temp=i;
        digit=temp%10;
        temp/=10;
        while(temp)
        {
            if(abs(digit-temp%10)!=1)
            {
                check=0;
                break;
            }
            digit=temp%10;
            temp/=10;
        }
        if(check)
        cout<<i<<" ";
    }
}

int main()
{
    int x=105;
    print_sieve(x);

    return 0;
}

````

Java

````
// Java program to implement
// the above approach
import java.util.*;
import java.lang.*;
import java.io.*;

class GFG
{
  public static void print_sieve(int x)
  {
    int i, temp, digit;
    int check;

    for(i = 0; i <= x; i++)
    {
      if(i < 10)
      {
        System.out.print(i + " ");
        continue;
      }
      check = 1;
      temp = i;
      digit = temp % 10;
      temp /= 10;
      while(temp != 0)
      {
        if(Math.abs(digit - temp % 10) != 1)
        {
          check = 0;
          break;
        }
        digit = temp % 10;
        temp /= 10;
      }
      if(check != 0)
        System.out.print(i + " ");
    }
  }

  // Driver Code
  public static void main(String[] args)
  {
    int x = 105;
    print_sieve(x);
  }
}

// This code is contributed by Pushpesh Raj.

````

Python

````
# Python3 program to implement the approach

# Function to print the jumping numbers
# in the range [0, x]
def print_sieve(x):

    # iterating over all the numbers
    # in the range [0, x]
    for i in range(x + 1):
        if(i < 10):

            # all numbers in [0, 9] are
            # jumping numbers
            print(i, end=" ")
            continue

        # the variable check tracks if
        # the number is valid
        check = 1
        temp = i
        digit = temp % 10
        temp //= 10
        while(temp > 0):

            if(abs(digit - temp % 10) != 1):

                check = 0
                break

            digit = temp % 10
            temp //= 10

        # printing i if check is 1
        if(check):
            print(i, end=" ")

# Driver Code
x = 105
print_sieve(x)

# This code is contributed by phasing17

````

C#

````
// C# program to implement
// the above approach
using System;

class GFG
{

  static void print_sieve(int x)
  {
    int i, temp, digit;
    int check;

    for(i = 0; i <= x; i++)
    {
      if(i < 10)
      {
        Console.Write(i + " ");
        continue;
      }
      check = 1;
      temp = i;
      digit = temp % 10;
      temp /= 10;
      while(temp != 0)
      {
        if(Math.Abs(digit - temp % 10) != 1)
        {
          check = 0;
          break;
        }
        digit = temp % 10;
        temp /= 10;
      }
      if(check != 0)
        Console.Write(i + " ");
    }
  }

  // Driver Code
  public static void Main()
  {
    int x = 105;
    print_sieve(x);
  }
}

// This code is contributed by code_hunt.

````

JavaScript

````
<script>

function print_sieve(x)
{
    let i,temp,digit;
    let check;

    for(i = 0; i <= x; i++)
    {
        if(i < 10)
        {
            document.write(i," ");
            continue;
        }
        check = 1;
        temp = i;
        digit = temp % 10;
        temp = Math.floor(temp / 10);
        while(temp)
        {
            if(Math.abs(digit - temp % 10) != 1)
            {
                check = 0;
                break;
            }
            digit = temp % 10;
            temp = Math.floor(temp / 10);
        }
        if(check)
            document.write(i," ");
    }
}

let x = 105;
print_sieve(x);

// This code is contributed by shinjanpatra

</script>

````




**Output**
```
0 1 2 3 4 5 6 7 8 9 10 12 21 23 32 34 43 45 54 56 65 67 76 78 87 89 98 101
```

*****Time Complexity:*****
O(x)



*****Auxiliary Space:*****
O(1)


An

****Efficient Solution****
can solve this problem in

****O(k)****
time where

****k****
is number of Jumping Numbers smaller than or equal to

****x****
. The idea is use

[BFS](https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/)
or

[DFS](https://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/)
.



Assume that we have a graph where the starting node is

****0****
and we need to traverse it from the start node to all the reachable nodes.


With the restrictions given in the graph about the jumping numbers, what do you think should be the restrictions defining the next transitions in the graph.


```
Lets take a example for input x = 90

Start node = 0
From 0, we can move to 1 2 3 4 5 6 7 8 9
[these are not in our range so we don\'t add it]

Now from 1, we can move to 12 and 10
From 2, 23 and 21
From 3, 34 and 32
.
.
.
.
.
.
and so on.
```


Below is BFS based implementation of above idea.


C++

````
// Finds and prints all jumping numbers smaller than or
// equal to x.
#include <bits/stdc++.h>
using namespace std;

// Prints all jumping numbers smaller than or equal to x starting
// with \'num\'. It mainly does BFS starting from \'num\'.
void bfs(int x, int num)
{
    // Create a queue and enqueue \'i\' to it
    queue<int> q;
    q.push(num);

    // Do BFS starting from i
    while (!q.empty()) {
        num = q.front();
        q.pop();

        if (num <= x) {
            cout << num << " ";
            int last_dig = num % 10;

            // If last digit is 0, append next digit only
            if (last_dig == 0)
                q.push((num * 10) + (last_dig + 1));

            // If last digit is 9, append previous digit only
            else if (last_dig == 9)
                q.push((num * 10) + (last_dig - 1));

            // If last digit is neither 0 nor 9, append both
            // previous and next digits
            else {
                q.push((num * 10) + (last_dig - 1));
                q.push((num * 10) + (last_dig + 1));
            }
        }
    }
}

// Prints all jumping numbers smaller than or equal to
// a positive number x
void printJumping(int x)
{
    cout << 0 << " ";
    for (int i = 1; i <= 9 && i <= x; i++)
        bfs(x, i);
}

// Driver program
int main()
{
    int x = 40;
    printJumping(x);
    return 0;
}

````

Java

````
// Finds and prints all jumping numbers smaller than or
// equal to x.
import java.util.*;
import java.lang.*;
import java.io.*;

class GFG {

    // Prints all jumping numbers smaller than or equal to x starting
    // with \'num\'. It mainly does BFS starting from \'num\'.
    public void bfs(int x, int num)
    {
        // Create a queue and enqueue \'i\' to it
        Queue<Integer> q = new LinkedList<Integer>();
        q.add(num);

        // Do BFS starting from i
        while (!q.isEmpty()) {
            num = q.peek();
            q.poll();
            if (num <= x) {
                System.out.print(num + " ");
                int last_digit = num % 10;

                // If last digit is 0, append next digit only
                if (last_digit == 0) {
                    q.add((num * 10) + (last_digit + 1));
                }

                // If last digit is 9, append previous digit only
                else if (last_digit == 9) {
                    q.add((num * 10) + (last_digit - 1));
                }

                // If last digit is neither 0 nor 9, append both
                // previous and next digits
                else {
                    q.add((num * 10) + (last_digit - 1));
                    q.add((num * 10) + (last_digit + 1));
                }
            }
        }
    }

    // Prints all jumping numbers smaller than or equal to
    // a positive number x
    public void printJumping(int x)
    {
        System.out.print("0 ");

        for (int i = 1; i <= 9 && i <= x; i++) {
            this.bfs(x, i);
        }
    }

    // Driver program
    public static void main(String[] args) throws IOException
    {
        int x = 40;
        GFG obj = new GFG();
        obj.printJumping(x);
    }
}

````

Python

````
# Class queue for use later
class Queue:
    def __init__(self):
        self.lst = []

    def is_empty(self):
        return self.lst == []

    def enqueue(self, elem):
        self.lst.append(elem)

    def dequeue(self):
        return self.lst.pop(0)

# Prints all jumping numbers smaller than or equal to
# x starting with \'num\'. It mainly does BFS starting
# from \'num\'.
def bfs(x, num):

    # Create a queue and enqueue i to it
    q = Queue()
    q.enqueue(num)

    # Do BFS starting from 1
    while (not q.is_empty()):
        num = q.dequeue()

        if num<= x:
            print(str(num), end =\' \')
            last_dig = num % 10

            # If last digit is 0, append next digit only
            if last_dig == 0:
                q.enqueue((num * 10) + (last_dig + 1))

            # If last digit is 9, append previous digit
            # only
            elif last_dig == 9:
                q.enqueue((num * 10) + (last_dig - 1))

            # If last digit is neither 0 nor 9, append
            # both previous digit and next digit
            else:
                q.enqueue((num * 10) + (last_dig - 1))
                q.enqueue((num * 10) + (last_dig + 1))

# Prints all jumping numbers smaller than or equal to
# a positive number x
def printJumping(x):
    print (str(0), end =\' \')
    for i in range(1, 10):
        bfs(x, i)

# Driver Program ( Change value of x as desired )
x = 40
printJumping(x)

# This code is contributed by Saket Modi

````

C#

````
// C# program to finds and prints all jumping
// numbers smaller than or equal to x.
using System;
using System.Collections.Generic;

class GFG
{

    // Prints all jumping numbers smaller than or
    // equal to x starting with \'num\'. It mainly
    // does BFS starting from \'num\'.
    public void bfs(int x, int num)
    {
        // Create a queue and enqueue \'i\' to it
        Queue<int> q = new Queue<int>();
        q.Enqueue(num);

        // Do BFS starting from i
        while (q.Count!=0)
        {
            num = q.Peek();
            q.Dequeue();
            if (num <= x)
            {
                Console.Write(num + " ");
                int last_digit = num % 10;

                // If last digit is 0, append next digit only
                if (last_digit == 0)
                {
                    q.Enqueue((num * 10) + (last_digit + 1));
                }

                // If last digit is 9, append previous digit only
                else if (last_digit == 9)
                {
                    q.Enqueue((num * 10) + (last_digit - 1));
                }

                // If last digit is neither 0 nor 9, append both
                // previous and next digits
                else
                {
                    q.Enqueue((num * 10) + (last_digit - 1));
                    q.Enqueue((num * 10) + (last_digit + 1));
                }
            }
        }
    }

    // Prints all jumping numbers smaller than or equal to
    // a positive number x
    public void printJumping(int x)
    {
        Console.Write("0 ");

        for (int i = 1; i <= 9 && i <= x; i++)
        {
            this.bfs(x, i);
        }
    }

    // Driver code
    public static void Main(String[] args)
    {
        int x = 40;
        GFG obj = new GFG();
        obj.printJumping(x);
    }
}

// This code has been contributed by 29AjayKumar

````

JavaScript

````
<script>

// Finds and prints all jumping numbers
// smaller than or equal to x.

// Prints all jumping numbers smaller than
// or equal to x starting with \'num\'. It
// mainly does BFS starting from \'num\'.
function bfs(x, num)
{

    // Create a queue and enqueue \'i\' to it
    let q = [];
    q.push(num);

    // Do BFS starting from i
    while (q.length != 0)
    {
        num = q.shift();

        if (num <= x)
        {
            document.write(num + " ");
            let last_digit = num % 10;

            // If last digit is 0, append next digit only
            if (last_digit == 0)
            {
                q.push((num * 10) + (last_digit + 1));
            }

            // If last digit is 9, append previous
            // digit only
            else if (last_digit == 9)
            {
                q.push((num * 10) + (last_digit - 1));
            }

            // If last digit is neither 0 nor 9,
            // append both previous and next digits
            else
            {
                q.push((num * 10) + (last_digit - 1));
                q.push((num * 10) + (last_digit + 1));
            }
        }
    }
}

// Prints all jumping numbers smaller
// than or equal to a positive number x
function printJumping(x)
{
    document.write("0 ");

    for(let i = 1; i <= 9 && i <= x; i++)
    {
        bfs(x, i);
    }
}

// Driver code
let x = 40;
printJumping(x);

// This code is contributed by rag2127

</script>

````




**Output**
```
0 1 10 12 2 21 23 3 32 34 4 5 6 7 8 9
```

*****Time Complexity:*****
O(k) time where

****k****
is number of Jumping Numbers smaller than or equal to

****x****


*****Auxiliary Space:*****
O(1)


Thanks to Gaurav Ahirwar for above solution.


****Exercise:****


1. Change the above solution to use DFS instead of BFS.
2. Extend your solution to print all numbers in sorted order instead of any order.
3. Further extend the solution to print all numbers in a given range.

****DFS based solution:****


In the

[DFS](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)
based approach we start building our numbers from single digits , i.e. from 1 – 9. Then we check for next possible digit and if possible we call the dfs for those numbers, increasing the number of digits with each call.


****Algorithm:****

```
1. We will start from every possible single digit, i.e. from 1 to 9
2. In the dfs we first write the base case, then
3. We print the current number
4. We get the last digit of current number and
  check the possibilities for the next digit.
  The next digit can either be last digit + 1 or last digit - 1
5. If the last digit is either 0 or 9 we have only one option for
  next number, else both the options are possible.
```


See

****C++ implementation****
of above approach:


C++

````
// C++ implementation of the above approach
#include <bits/stdc++.h>
using namespace std;
#define ll long long

void dfs(ll cnum, const ll& num)
{
    if (cnum > num) // base case
        return;

    cout << cnum << " "; // print the current number

    int l_dig = cnum % 10; // get the last digit of current number

    // for the next digit we have two options
    ll first = cnum * 10 + l_dig + 1;
    ll second = cnum * 10 + l_dig - 1;

    if (l_dig == 0) // here as second option will give us a
                    // -ve number we will skip it
        dfs(first, num);
    else if (l_dig == 9) // here as first option will give
                         // us a -ve number we will skip it
        dfs(second, num);
    else // else we call on both the options
    {
        dfs(first, num);
        dfs(second, num);
    }
}

void PrintJumping(long long X)
{
    cout << 0 << " ";
    for (ll i = 1; i <= 9; i++) {
        dfs(i, X); // generate all the numbers starting
                   // from i
    }
}

int main()
{

    long long X = 40;
    PrintJumping(X);
    return 0;
}
// This code is contributed by Abhijeet Kumar(abhijeet19403)

````

Java

````
// Java implementation of the above approach
import java.util.*;

class gfg2 {
    static void dfs(long cnum, long num)
    {
        if (cnum > num) // base case
            return;

        System.out.print(cnum
                         + " "); // print the current number

        int l_dig = (int)(cnum % 10); // get the last digit
                                      // of current number

        // for the next digit we have two options
        long first = cnum * 10 + l_dig + 1;
        long second = cnum * 10 + l_dig - 1;

        if (l_dig == 0) // here as second option will give
                        // us a -ve number we will skip it
            dfs(first, num);
        else if (l_dig
                 == 9) // here as first option will give
                       // us a -ve number we will skip it
            dfs(second, num);
        else // else we call on both the options
        {
            dfs(first, num);
            dfs(second, num);
        }
    }

    static void PrintJumping(long X)
    {
        System.out.print(0 + " ");
        for (long i = 1L; i <= 9; i++) {
            dfs(i, X); // generate all the numbers starting
                       // from i
        }
    }
    public static void main(String[] args)
    {
        long X = 40;
        PrintJumping(X);
    }
}
// This code is contributed by karandeep1234

````

Python

````
# Python3 implementation of the above approach
def dfs(cnum, num):
    # base case
    if cnum > num:
        return

    # print the current number
    print(cnum, end=" ")

    # get the last digit of the current number
    l_dig = cnum % 10

    # for the next digit we have two options
    first = cnum * 10 + l_dig + 1
    second = cnum * 10 + l_dig - 1

    # here as second option will give us a -ve number
    # we will skip it
    if l_dig == 0:
        dfs(first, num)
    # here as first option will give us a -ve number
    # we will skip it
    elif l_dig == 9:
        dfs(second, num)
    # else we will call on both the options
    else:
        dfs(first, num)
        dfs(second, num)

# Print Jumping numbers
def PrintJumping(X):
    print(0, end=" ")
    for i in range(1, 10):
        dfs(i, X)

# Driver code
if __name__ == \'__main__\':
    X = 40
    PrintJumping(X)

    # This code is contributed by factworx412

````

C#

````
// C# implementation of the above approach
using System;

class GFG {
  static void dfs(long cnum, long num)
  {
    if (cnum > num) // base case
      return;

    Console.Write(cnum
                  + " "); // print the current number

    int l_dig = (int)(cnum % 10); // get the last digit
    // of current number

    // for the next digit we have two options
    long first = cnum * 10 + l_dig + 1;
    long second = cnum * 10 + l_dig - 1;

    if (l_dig == 0) // here as second option will give
      // us a -ve number we will skip it
      dfs(first, num);
    else if (l_dig
             == 9) // here as first option will give
      // us a -ve number we will skip it
      dfs(second, num);
    else // else we call on both the options
    {
      dfs(first, num);
      dfs(second, num);
    }
  }

  static void PrintJumping(long X)
  {
    Console.Write(0 + " ");
    for (long i = 1L; i <= 9; i++) {
      dfs(i, X); // generate all the numbers starting
      // from i
    }
  }
  static void Main(string[] args)
  {
    long X = 40;
    PrintJumping(X);
  }
}

// This code is contributed by karandeep1234

````

JavaScript

````
    // Javascript implementation of the above approach
    function dfs(cnum, num)
    {
        if (cnum > num) // base case
            return;

        console.log(cnum+" "); // print the current number

        let l_dig = cnum % 10; // get the last digit of current number

        // for the next digit we have two options
        let first = cnum * 10 + l_dig + 1;
        let second = cnum * 10 + l_dig - 1;

        if (l_dig == 0) // here as second option will give us a
                        // -ve number we will skip it
            dfs(first, num);
        else if (l_dig == 9) // here as first option will give
                            // us a -ve number we will skip it
            dfs(second, num);
        else // else we call on both the options
        {
            dfs(first, num);
            dfs(second, num);
        }
    }

    function PrintJumping(X)
    {
        console.log(0+" ");
        for(let i = 1; i <= 9; i++) {
            dfs(i, X); // generate all the numbers starting
                    // from i
        }
    }

        let X = 40;
        PrintJumping(X);

    // This code is contributed by Aman Kumar.

````




**Output**
```
0 1 12 10 2 23 21 3 34 32 4 5 6 7 8 9
```

****Time Complexity:****
O(k)


Here k is the total number of jumping numbers.


****Auxiliary Space:****
O(len(N))


Here len(N) is the maximum length from all the jumping numbers, the extra space is used due to recursive function call stack.

', '', 'Print all Jumping Numbers smaller than or equal to a given value', 4, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('023ee905-49cc-4ff9-b0f6-57f68b7a1d9a', e'

[****LCM****](https://www.geeksforgeeks.org/lcm-least-common-multiple/)
of two numbers is the smallest number which can be divided by both numbers.


> ****Input****
> : a = 12, b = 18
>
>
>
> ****Output****
> : 36
>
>
>
> 36 is the smallest number divisible by both 12 and 18
>
>
> ****Input****
> : a = 5, b = 11
>
>
>
> ****Output****
> : 55
>
>
>
> 55 is the smallest number divisible by both 5 and 11


A

****simple solution****
is to

[find all prime factors](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)
of both numbers, then find union of all factors present in both

[numbers](https://www.geeksforgeeks.org/numbers/)
. Finally, return the product of elements in union.


An

****efficient solution****
is based on the below formula for LCM of two numbers ‘a’ and ‘b’.


![relation---------between---------hcf---------and---------lcm_________](https://media.geeksforgeeks.org/wp-content/uploads/20241122160112040184/relation---------between---------hcf---------and---------lcm_________.webp)
> a x b = LCM(a, b) \\* GCD (a, b)
>
>
>
>
>
> LCM(a, b) = (a x b) / GCD(a, b)


We have discussed

[function to find GCD of two numbers](https://www.geeksforgeeks.org/c-program-find-gcd-hcf-two-numbers/)
. Using GCD, we can find LCM.


Below is the implementation of the above idea:



C++

````
// C++ program to find LCM of two numbers
#include <iostream>
using namespace std;

// Recursive function to return gcd of a and b
long long gcd(long long int a, long long int b)
{
  if (b == 0)
    return a;
  return gcd(b, a % b);
}

// Function to return LCM of two numbers
long long lcm(int a, int b)
{
    return (a / gcd(a, b)) * b;
}

// Driver program to test above function
int main()
{
    int a = 15, b = 20;
    cout <<"LCM of " << a << " and "
         << b << " is " << lcm(a, b);
    return 0;
}

````

C

````
// C program to find LCM of two numbers
#include <stdio.h>

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

// Function to return LCM of two numbers
int lcm(int a, int b)
{
    return (a / gcd(a, b)) * b;
}

// Driver program to test above function
int main()
{
    int a = 15, b = 20;
    printf("LCM of %d and %d is %d ", a, b, lcm(a, b));
    return 0;
}

````

Java

````
// Java program to find LCM of two numbers.
import java.io.*;
public class Test
{
    // Recursive method to return gcd of a and b
    static int gcd(int a, int b)
    {
        if (a == 0)
            return b;
        return gcd(b % a, a);
    }

    // method to return LCM of two numbers
    static int lcm(int a, int b)
    {
        return (a / gcd(a, b)) * b;
    }

    // Driver method
    public static void main(String[] args)
    {
        int a = 15, b = 20;
        System.out.println("LCM of " + a +
                           " and " + b +
                      " is " + lcm(a, b));
    }
}

````

Python

````
# Python program to find LCM of two numbers

# Recursive function to return gcd of a and b
def gcd(a,b):
    if a == 0:
        return b
    return gcd(b % a, a)

# Function to return LCM of two numbers
def lcm(a,b):
    return (a // gcd(a,b))* b

# Driver program to test above function
a = 15
b = 20
print(\'LCM of\', a, \'and\', b, \'is\', lcm(a, b))

# This code is contributed by Danish Raza

````

C#

````
// C# program to find LCM
// of two numbers.
using System;
class GFG {

    // Recursive method to
    // return gcd of a and b
    static int gcd(int a, int b)
    {
        if (a == 0)
            return b;
        return gcd(b % a, a);
    }

    // method to return
    // LCM of two numbers
    static int lcm(int a, int b)
    {
        return (a / gcd(a, b)) * b;
    }

    // Driver method
    public static void Main()
    {
        int a = 15, b = 20;
        Console.WriteLine("LCM of " + a +
         " and " + b + " is " + lcm(a, b));
    }
}

// This code is contributed by anuj_67.

````

JavaScript

````
<script>

// Javascript program to find LCM of two numbers

// Recursive function to return gcd of a and b
function gcd(a, b)
{
if (b == 0)
    return a;
return gcd(b, a % b);
}

// Function to return LCM of two numbers
function lcm(a, b)
{
    return (a / gcd(a, b)) * b;
}

// Driver program to test above function

    let a = 15, b = 20;
    document.write("LCM of " + a + " and "
    + b + " is " + lcm(a, b));


// This code is contributed by Mayank Tyagi

</script>

````

PHP

````
<?php
// PHP program to find LCM of two numbers

// Recursive function to
// return gcd of a and b
function gcd( $a, $b)
{
   if ($a == 0)
        return $b;
    return gcd($b % $a, $a);
}

// Function to return LCM
// of two numbers
function lcm( $a, $b)
{
    return ($a / gcd($a, $b)) * $b;
}

    // Driver Code
    $a = 15;
    $b = 20;
    echo "LCM of ",$a, " and "
         ,$b, " is ", lcm($a, $b);

// This code is contributed by anuj_67.
?>

````




**Output**
```
LCM of 15 and 20 is 60
```

****Time Complexity:****
O(log(min(a,b))



****Auxiliary Space:****
O(log(min(a,b))


****Another Efficient Approach: Using conditional for loop****

C++

````
// C++ program to find LCM of 2 numbers
#include <bits/stdc++.h>
using namespace std;

// Function to return LCM of two numbers
int LCM(int a, int b)
{
    int greater = max(a, b);
    int smallest = min(a, b);
    for (int i = greater; ; i += greater) {
        if (i % smallest  == 0)
            return i;
    }
}

// Driver program to test above function
int main()
{
    int a = 10, b = 5;
    cout << "LCM of " << a << " and "
         << b << " is " << LCM(a, b);
    return 0;
}

````

Java

````
// Java program to find LCM of 2 numbers

import java.util.Scanner;

public class LCM {
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        int a = 10;
        int b = 5;
        int lcm = findLCM(a, b);
        System.out.println("LCM of " + a + " and " + b
                           + " is " + lcm);
        sc.close();
    }
    // Function to return LCM of two numbers
    public static int findLCM(int a, int b)
    {
        int greater = Math.max(a, b);
        int smallest = Math.min(a, b);
        for (int i = greater;; i += greater) {
            if (i % smallest == 0)
                return i;
        }
    }
}

````

Python

````
# Python program to find LCM of two numbers

# Function to return LCM of two numbers
def LCM(a, b):
    greater = max(a, b)
    smallest = min(a, b)
    for i in range(greater, a*b+1, greater):
        if i % smallest == 0:
            return i

# Driver program to test above function
if __name__ == \'__main__\':
    a = 10
    b = 5
    print("LCM of", a, "and", b, "is", LCM(a, b))

````

C#

````
// C# program to find LCM of 2 numbers
using System;

class LCMProgram
{

  // Function to return LCM of two numbers
  static int LCM(int a, int b)
  {
    int greater = Math.Max(a, b);
    int smallest = Math.Min(a, b);
    for (int i = greater;; i += greater) {
      if (i % smallest == 0)
        return i;
    }
  }

  // Driver program to test above function
  static void Main()
  {
    int a = 10, b = 5;
    Console.WriteLine("LCM of " + a + " and " + b
                      + " is " + LCM(a, b));
  }
}

````

JavaScript

````
// Javascript program to find LCM of two numbers

// Function to return LCM of two numbers
function LCM(a, b){
    let greater = Math.max(a, b);
    let smallest = Math.min(a, b);
    for(let i = greater; i <= a*b; i+=greater){
        if(i % smallest == 0){
            return i;
        }
    }
}

// Driver program to test above function
let a = 10;
let b = 5;
console.log("LCM of", a, "and", b, "is", LCM(a, b));

````




**Output**
```
LCM of 10 and 5 is 10
```

****Time Complexity:****
O(min(a,b))



****Auxiliary Space:****
O(1)
', 'LCM of two numbers is the smallest number which can be divided by both numbers.', 'Program to find LCM of two numbers', 5, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('995fe7e2-ea73-4f91-8cbc-00bcdc769c4d', e'Given two numbers

****a****
and

****b****
, the task is to find the

[GCD](https://www.geeksforgeeks.org/greatest-common-divisor-gcd/)
of the two numbers.


****Note:****
The GCD (Greatest Common Divisor) or HCF (Highest Common Factor) of two numbers is the largest number that divides both of them.



![gcd](https://media.geeksforgeeks.org/wp-content/uploads/20240920171939/gcd.webp)




****Examples:****

> ****Input:****
> a = 20, b = 28
>
>
>
> ****Output:****
> 4
>
>
>
> ****Explanation:****
> The factors of 20 are 1, 2, 4, 5, 10 and 20. The factors of 28 are 1, 2, 4, 7, 14 and 28. Among these factors, 1, 2 and 4 are the common factors of both 20 and 28. The greatest among the common factors is 4.
>
>
> ****Input:****
> a = 60, b = 36
>
>
>
> ****Output:****
> 12

Naive Approach for GCD of two numbers:
--------------------------------------

> The basic idea is to find the minimum of the two numbers and find its highest factor which is also a factor of the other
>
> [number](https://www.geeksforgeeks.org/numbers/)
> .


Below is the code implementation of the above idea:



C++

````
// C++ program to find GCD of two numbers

#include <bits/stdc++.h>
using namespace std;

// Function to return gcd of a and b
int gcd(int a, int b)
{
    // Find Minimum of a and b
    int result = min(a, b);
    while (result > 0) {
        if (a % result == 0 && b % result == 0) {
            break;
        }
        result--;
    }

    // Return gcd of a and b
    return result;
}

// Driver code
int main()
{
    int a = 98, b = 56;
    cout << "GCD of " << a << " and " << b << " is "
         << gcd(a, b);
    return 0;
}

````

C

````
// C program to find GCD of two numbers

#include <math.h>
#include <stdio.h>

// Function to return gcd of a and b
int gcd(int a, int b)
{
    // Find Minimum of a and b
    int result = ((a < b) ? a : b);
    while (result > 0) {
        if (a % result == 0 && b % result == 0) {
            break;
        }
        result--;
    }

    // Return gcd of a and b
    return result;
}

// Driver code
int main()
{
    int a = 98, b = 56;
    printf("GCD of %d and %d is %d ", a, b, gcd(a, b));
    return 0;
}

````

Java

````
// Java program to find GCD of two numbers
import java.io.*;

public class GFG {

    // Function to return gcd of a and b
    static int gcd(int a, int b)
    {
        // Find Minimum of a and b
        int result = Math.min(a, b);
        while (result > 0) {
            if (a % result == 0 && b % result == 0) {
                break;
            }
            result--;
        }

        // Return gcd of a and b
        return result;
    }

    // Driver code
    public static void main(String[] args)
    {
        int a = 98, b = 56;
        System.out.print("GCD of " + a + " and " + b
                         + " is " + gcd(a, b));
    }
}

````

Python

````
# Python program to find GCD of two numbers


# Function to find gcd of two numbers
def gcd(a, b):

    # Find minimum of a and b
    result = min(a, b)

    while result:
        if a % result == 0 and b % result == 0:
            break
        result -= 1

    # Return the gcd of a and b
    return result


# Driver Code
if __name__ == \'__main__\':
    a = 98
    b = 56
    print(f"GCD of {a} and {b} is {gcd(a, b)}")

````

C#

````
// C# program to find GCD of two numbers

using System;
public class GFG {

    // Function to return gcd of a and b
    static int gcd(int a, int b)
    {
        // Find Minimum of a and b
        int result = Math.Min(a, b);
        while (result > 0) {
            if (a % result == 0 && b % result == 0) {
                break;
            }
            result--;
        }

        // Return gcd of a and b
        return result;
    }

    // Driver code
    public static void Main(string[] args)
    {
        int a = 98, b = 56;
        Console.WriteLine("GCD of " + a + " and " + b
                          + " is " + gcd(a, b));
    }
}

````

JavaScript

````
// Javascript program to find GCD of two numbers
// Function to return gcd of a and b
function gcd(a,b)
{
    // Find Minimum of a and b
    let result = Math.min(a, b);
    while (result > 0) {
        if (a % result == 0 && b % result == 0) {
            break;
        }
        result--;
    }

    // Return gcd of a and b
    return result;
}

// Driver program to test above function
let a = 98;
let b = 56;
console.log("GCD of ",a," and ",b," is ",gcd(a, b));

````




**Output**
```
GCD of 98 and 56 is 14
```

****Time Complexity:****
O(min(a,b))



****Auxiliary Space:****
O(1)


[Euclidean algorithm](https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended)
for GCD of two numbers:
--------------------------------------------------------------------------------------------------------------------


The idea of this algorithm is, the GCD of two numbers doesn’t change if the smaller number is subtracted from the bigger number. This is the

****Euclidean algorithm by subtraction****
. It is a process of repeat subtraction, carrying the result forward each time until the result is equal to any one number being subtracted.


****Pseudo-code:****

> gcd(a, b):
>
>
>
> if a = b:
>
>
>
> return a
>
>
>
> if a > b:
>
>
>
> return gcd(a – b, b)
>
>
>
> else:
>
>
>
> return gcd(a, b – a)


Below is the implementation of the above approach.



C++

````
// C++ program to find GCD of two numbers
// code is updated by himanshug9119 - linkedin URL -
// https://www.linkedin.com/in/himanshug9119/
#include <bits/stdc++.h>
using namespace std;

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    // Everything divides 0
    if (a == 0)
        return b;
    if (b == 0)
        return a;

    // Base case
    if (a == b)
        return a;

    // a is greater
    if (a > b)
        return gcd(a - b, b);
    return gcd(a, b - a);
}

// Driver code
int main()
{
    int a = 98, b = 56;
    cout << "GCD of " << a << " and " << b << " is "
         << gcd(a, b);
    return 0;
}

````

C

````
// C program to find GCD of two numbers

#include <stdio.h>

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    // Everything divides 0
    if (a == 0)
        return b;
    if (b == 0)
        return a;

    // Base case
    if (a == b)
        return a;

    // a is greater
    if (a > b)
        return gcd(a - b, b);
    return gcd(a, b - a);
}

// Driver code
int main()
{
    int a = 98, b = 56;
    printf("GCD of %d and %d is %d ", a, b, gcd(a, b));
    return 0;
}

````

Java

````
// Java program to find GCD of two numbers

import java.io.*;

class Test {

    // Recursive function to return gcd of a and b
    static int gcd(int a, int b)
    {
        // Everything divides 0
        if (a == 0)
            return b;
        if (b == 0)
            return a;

        // Base case
        if (a == b)
            return a;

        // a is greater
        if (a > b)
            return gcd(a - b, b);
        return gcd(a, b - a);
    }

    // Driver code
    public static void main(String[] args)
    {
        int a = 98, b = 56;
        System.out.println("GCD of " + a + " and " + b
                           + " is " + gcd(a, b));
    }
}

````

Python

````
# Python program to find GCD of two numbers


# Recursive function to return gcd of a and b
def gcd(a, b):

    # Everything divides 0
    if (a == 0):
        return b
    if (b == 0):
        return a

    # Base case
    if (a == b):
        return a

    # a is greater
    if (a > b):
        return gcd(a-b, b)
    return gcd(a, b-a)


# Driver code
if __name__ == \'__main__\':
    a = 98
    b = 56
    if(gcd(a, b)):
        print(\'GCD of\', a, \'and\', b, \'is\', gcd(a, b))
    else:
        print(\'not found\')

# This code is contributed by Danish Raza

````

C#

````
// C# program to find GCD of two numbers

using System;

class GFG {

    // Recursive function to return gcd of a and b
    static int gcd(int a, int b)
    {
        // Everything divides 0
        if (a == 0)
            return b;
        if (b == 0)
            return a;

        // Base case
        if (a == b)
            return a;

        // a is greater
        if (a > b)
            return gcd(a - b, b);

        return gcd(a, b - a);
    }

    // Driver code
    public static void Main()
    {
        int a = 98, b = 56;
        Console.WriteLine("GCD of " + a + " and " + b
                          + " is " + gcd(a, b));
    }
}

// This code is contributed by anuj_67.

````

JavaScript

````
// Javascript program to find GCD of two numbers

// Recursive function to return gcd of a and b
function gcd(a, b)
{
    // Everything divides 0
    if (a == 0)
    return b;
    if (b == 0)
    return a;

    // Base case
    if (a == b)
        return a;

    // a is greater
    if (a > b)
        return gcd(a-b, b);
    return gcd(a, b-a);
}

// Driver program to test above function

    let a = 98, b = 56;
    console.log("GCD of "+ a + " and " + b + " is " + gcd(a, b));

// This code is contributed by Mayank Tyagi

````

PHP

````
<?php
// PHP program to find GCD
// of two numbers

// Recursive function to return gcd of a and b
function gcd($a, $b)
{
    // Everything divides 0
    if ($a == 0)
       return $b;
    if ($b == 0)
       return $a;

    // Base case
    if($a == $b)
        return $a ;

    // a is greater
    if($a > $b)
        return gcd( $a-$b , $b ) ;

    return gcd( $a , $b-$a ) ;
}

// Driver code
$a = 98 ;
$b = 56 ;

echo "GCD of $a and $b is ", gcd($a , $b) ;

// This code is contributed by Anivesh Tiwari
?>

````




**Output**
```
GCD of 98 and 56 is 14
```

****Time Complexity:****
O(min(a,b))



****Auxiliary Space:****
O(min(a,b)) because it uses internal stack data structure in recursion.


****Optimization by checking divisibility:****
----------------------------------------------


The above method can be optimized based on the following idea:


> If we notice the previous approach, we can see at some point, one number becomes a factor of the other so instead of repeatedly subtracting till both become equal, we can check if it is a factor of the other.

****Illustration:****


See the below illustration for a better understanding:


> Consider a = 98 and b = 56
>
>
> ****a = 98, b = 56:****
>
> * a > b so put a = a-b and b remains same. So  a = 98-56 = 42  & b= 56.
>
> ****a = 42, b = 56:****
>
> * Since b > a, we check if b%a=0. Since answer is no, we proceed further.
> * Now b>a. So b = b-a and a remains same. So b = 56-42 = 14 & a= 42.
>
> ****a = 42, b = 14:****
>
> * Since a>b, we check if a%b=0. Now the answer is yes.
> * So we print smaller among a and b as H.C.F . i.e. 42 is  3 times of 14.
>
>
> So
>
> ****HCF****
> is 14.


Below is the implementation of the above approach:


C++

````
// C++ program to find GCD of two numbers

#include <bits/stdc++.h>
using namespace std;

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    // Everything divides 0
    if (a == 0)
        return b;
    if (b == 0)
        return a;

    // Base case
    if (a == b)
        return a;

    // a is greater
    if (a > b) {
        if (a % b == 0)
            return b;
        return gcd(a - b, b);
    }
    if (b % a == 0)
        return a;
    return gcd(a, b - a);
}

// Driver code
int main()
{
    int a = 98, b = 56;
    cout << "GCD of " << a << " and " << b << " is "
         << gcd(a, b);
    return 0;
}

````

Java

````
public class GCD {
    // Recursive function to return gcd of a and b
    static int gcd(int a, int b) {
        // Everything divides 0
        if (a == 0)
            return b;
        if (b == 0)
            return a;

        // Base case
        if (a == b)
            return a;

        // a is greater
        if (a > b) {
            if (a % b == 0)
                return b;
            return gcd(a - b, b);
        }
        if (b % a == 0)
            return a;
        return gcd(a, b - a);
    }

    // Driver code
    public static void main(String[] args) {
        int a = 98, b = 56;
        System.out.println("GCD of " + a + " and " + b + " is " + gcd(a, b));
    }
}
// This code is contributed by rambabuguphka

````

Python

````
def gcd(a, b):
    # Everything divides 0
    if a == 0:
        return b
    if b == 0:
        return a

    # Base case
    if a == b:
        return a

    # a is greater
    if a > b:
        if a % b == 0:
            return b
        return gcd(a - b, b)
    if b % a == 0:
        return a
    return gcd(a, b - a)

# Driver code
a = 98
b = 56
print(f"GCD of {a} and {b} is {gcd(a, b)}")

````

C#

````
using System;

public class GFG
{
    // Recursive function to return gcd of a and b
    static int GCD(int a, int b)
    {
        // Everything divides 0
        if (a == 0)
            return b;
        if (b == 0)
            return a;

        // Base case
        if (a == b)
            return a;

        // a is greater
        if (a > b)
        {
            if (a % b == 0)
                return b;
            return GCD(a - b, b);
        }
        if (b % a == 0)
            return a;
        return GCD(a, b - a);
    }

    // Main method
    public static void Main(string[] args)
    {
        int a = 98, b = 56;
        Console.WriteLine("GCD of " + a + " and " + b + " is " + GCD(a, b));
    }
}

// This code is add by Avinash Wani

````

JavaScript

````
// Recursive function to return gcd of a and b
function gcd(a, b) {
    // Everything divides 0
    if (a === 0) {
        return b;
    }
    if (b === 0) {
        return a;
    }

    // Base case
    if (a === b) {
        return a;
    }

    // a is greater
    if (a > b) {
        if (a % b === 0) {
            return b;
        }
        return gcd(a - b, b);
    }
    if (b % a === 0) {
        return a;
    }
    return gcd(a, b - a);
}

// Driver code
let a = 98;
let b = 56;
console.log(`GCD of ${a} and ${b} is ${gcd(a, b)}`);

````




**Output**
```
GCD of 98 and 56 is 14
```

****Time Complexity:****
O(min(a, b))



****Auxiliary Space:****
O(1)


****Optimization using division:****
------------------------------------

> Instead of the Euclidean algorithm by subtraction, a better approach can be used. We don’t perform subtraction here. we continuously divide the bigger number by the smaller number. More can be learned about this
>
> ****efficient solution****
> by using the modulo operator in
>
> [Euclidean algorithm](https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended)
> .


Below is the implementation of the above approach.


C++

````
// C++ program to find GCD of two numbers
#include <iostream>
using namespace std;
// Recursive function to return gcd of a and b in single line
int gcd(int a, int b)
{
    return b == 0 ? a : gcd(b, a % b);
}

// Driver program to test above function
int main()
{
    int a = 98, b = 56;
    cout<<"GCD of "<<a<<" and "<<b<<" is "<<gcd(a, b);
    return 0;
}

````

C

````
// C program to find GCD of two numbers
#include <stdio.h>

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

// Driver program to test above function
int main()
{
    int a = 98, b = 56;
    printf("GCD of %d and %d is %d ", a, b, gcd(a, b));
    return 0;
}

````

Java

````
// Java program to find GCD of two numbers
import java.io.*;

class Test
{
    // Recursive function to return gcd of a and b
    static int gcd(int a, int b)
    {
      if (b == 0)
        return a;
      return gcd(b, a % b);
    }

    // Driver method
    public static void main(String[] args)
    {
        int a = 98, b = 56;
        System.out.println("GCD of " + a +" and " + b + " is " + gcd(a, b));
    }
}

````

Python

````
# Recursive function to return gcd of a and b
def gcd(a,b):

    # Everything divides 0
    if (b == 0):
         return a
    return gcd(b, a%b)

# Driver program to test above function
a = 98
b = 56
if(gcd(a, b)):
    print(\'GCD of\', a, \'and\', b, \'is\', gcd(a, b))
else:
    print(\'not found\')

# This code is contributed by Danish Raza

````

C#

````
// C# program to find GCD of two
// numbers
using System;

class GFG {

    // Recursive function to return
    // gcd of a and b
    static int gcd(int a, int b)
    {
       if (b == 0)
          return a;
       return gcd(b, a % b);
    }

    // Driver method
    public static void Main()
    {
        int a = 98, b = 56;
        Console.WriteLine("GCD of "
          + a +" and " + b + " is "
                      + gcd(a, b));
    }
}

// This code is contributed by anuj_67.

````

JavaScript

````
<script>

// Javascript program to find GCD of two number

// Recursive function to return gcd of a and b

function gcd(a, b){

  // Everything divides 0
  if(b == 0){
    return a;
  }

  return gcd(b, a % b);
}

// Driver code
let a = 98;
let b = 56;

document.write(`GCD of ${a} and ${b} is ${gcd(a, b)}`);

// This code is contributed by _saurabh_jaiswal

</script>

````

PHP

````
<?php
// PHP program to find GCD
// of two numbers

// Recursive function to
// return gcd of a and b
function gcd($a, $b)
{
    // Everything divides 0
    if($b==0)
        return $a ;

    return gcd( $b , $a % $b ) ;
}

// Driver code
$a = 98 ;
$b = 56 ;

echo "GCD of $a and $b is ", gcd($a , $b) ;

// This code is contributed by Anivesh Tiwari
?>

````




**Output**
```
GCD of 98 and 56 is 14
```

****Complexity Analysis:****

****Time Complexity:****
O(log(min(a,b)))


* The derivation for this is obtained from the analysis of the worst-case scenario.
* What we do is we ask what are the 2 least numbers that take 1 step, those would be (1,1). If we want to increase the number of steps to 2 while keeping the numbers as low as possible as we can take the numbers to be (1,2). Similarly, for 3 steps, the numbers would be (2,3), 4 would be (3,5), 5 would be (5,8).
* So we can notice a pattern here, for the nth step the numbers would be (fib(n), fib(n+1)). So the worst-case time complexity would be O(n) where

  ****a ? fib(n)****
  and

  ****b ? fib(n+1)****
  .
* Now Fibonacci series is an exponentially growing series where the ratio of n

  th
  /(n-1)

  th
  term approaches (sqrt(5)+1)/2 which is also called the golden ratio. So we can see that the time complexity of the algorithm increases linearly as the terms grow exponentially hence the time complexity would be

  ****log(min(a,b))****
  .

****Auxiliary Space:****
O(log(min(a,b))


****Iterative implementation for GCD of two numbers using Euclidean Algorithm:****
----------------------------------------------------------------------------------


Below is the iterative way to find the GCD of two numbers using Euclidean algorithm.


C++

````
// C++ program to find GCD of two numbers
#include <bits/stdc++.h>
using namespace std;

// Iterative function to return gcd of a and b
int gcd(int a, int b)
{
    while (a > 0 && b > 0) {
        if (a > b) {
            a = a % b;
        }
        else {
            b = b % a;
        }
    }
    if (a == 0) {
        return b;
    }
    return a;
}

// Driver code
int main()
{
    int a = 98, b = 56;
    cout << "GCD of " << a << " and " << b << " is "
         << gcd(a, b);
    return 0;
}

````

C

````
// C program to find GCD of two numbers
#include <stdio.h>

// Iterative function to return gcd of a and b
int gcd(int a, int b)
{
    while (a > 0 && b > 0) {
        if (a > b) {
            a = a % b;
        }
        else {
            b = b % a;
        }
    }
    if (a == 0) {
        return b;
    }
    return a;
}

// Driver code
int main()
{
    int a = 98, b = 56;
    printf("GCD of %d and %d is %d ", a, b, gcd(a, b));
    return 0;
}

````

Java

````
// Java program to find GCD of two numbers
import java.io.*;

class Test {

    // Iterative function to return gcd of a and b
    static int gcd(int a, int b)
    {
        while (a > 0 && b > 0) {
            if (a > b) {
                a = a % b;
            }
            else {
                b = b % a;
            }
        }
        if (a == 0) {
            return b;
        }
        return a;
    }

    // Driver code
    public static void main(String[] args)
    {
        int a = 98, b = 56;
        System.out.println("GCD of " + a + " and " + b
                           + " is " + gcd(a, b));
    }
}

````

Python

````
# Itervative function to return gcd of a and b


def gcd(a, b):

    # Everything divides 0
    while(a > 0 and b > 0):
        if (a > b):
            a = a % b
        else:
            b = b % a

    if (a == 0):
        return b
    return a


# Driver code
if __name__ == \'__main__\':
    a = 98
    b = 56
    if(gcd(a, b)):
        print(\'GCD of\', a, \'and\', b, \'is\', gcd(a, b))
    else:
        print(\'not found\')

````

C#

````
// C# program to find GCD of two numbers
using System;

class GFG {

    // Iterative function to return gcd of a and b
    static int gcd(int a, int b)
    {
        while (a > 0 && b > 0) {
            if (a > b) {
                a = a % b;
            }
            else {
                b = b % a;
            }
        }
        if (a == 0) {
            return b;
        }
        return a;
    }

    // Driver code
    public static void Main()
    {
        int a = 98, b = 56;
        Console.WriteLine("GCD of " + a + " and " + b
                          + " is " + gcd(a, b));
    }
}

// This code is contributed by anuj_67.

````

JavaScript

````
// Javascript program to find GCD of two number

// Recursive function to return gcd of a and b

function gcd(a, b){

  // Everything divides 0
      while (a > 0 && b > 0) {
        if (a > b) {
            a = a % b;
        }
        else {
            b = b % a;
        }
    }
    if (a == 0) {
        return b;
    }
    return a;
}

// Driver code
let a = 98;
let b = 56;

console.log(`GCD of ${a} and ${b} is ${gcd(a, b)}`);

// This code is contributed by _saurabh_jaiswal

````




**Output**
```
GCD of 98 and 56 is 14
```

****Time Complexity:****
O(log(min(a,b)))



****Auxiliary Space:****
O(1)


### GCD of two numbers using inbuilt function:


Languages like C++ have inbuilt functions to calculate GCD of two numbers.


Below is the implementation using inbuilt functions.


C++

````
// c++ program to find gcd using inbuilt functions
#include <algorithm>
#include <iostream>
using namespace std;

int main()
{
    int a = 98, b = 56;
    cout << "The gcd of a and b is " << __gcd(a, b) << endl;
    return 0;
}

````

Java

````
// JAVA program to find gcd using inbuilt functions
import java.math.BigInteger;
import java.util.*;

public class GFG {
    public static void main(String[] args)
    {
        int a = 98, b = 56;
        int gcd = gcd(a, b);
        System.out.println("The gcd of a and b is " + gcd);
    }

    public static int gcd(int a, int b)
    {
        BigInteger bigA = BigInteger.valueOf(Math.abs(a));
        BigInteger bigB = BigInteger.valueOf(Math.abs(b));
        BigInteger gcd = bigA.gcd(bigB);
        return gcd.intValue();
    }
}
// This code is contributed by Taranpreet Singh.

````

Python

````
# Python program to find gcd using inbuilt function using math library
import math

#Driver code
if __name__ == \'__main__\':
  a = 98
  b = 56
  gcd_result = math.gcd(a, b) # inbuilt function gcd() using math library

  print("The gcd of a and b is", gcd_result)

# This code is contributed by guptapratik

````

C#

````
using System;

class Program
{
    static void Main()
    {
        int a = 98, b = 56;
        Console.WriteLine($"The gcd of a and b is {GCD(a, b)}");
    }

    static int GCD(int a, int b)
    {
        return Math.Abs(b == 0 ? a : GCD(b, a % b));
    }
}

````

JavaScript

````
function gcd(a, b) {
    if (b === 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}

// Example usage
const a = 98;
const b = 56;
console.log("The gcd of a and b is " + gcd(a, b));


// Contributed By Siddhesh22

````




**Output**
```
The gcd of a and b is 14

```

****Time Complexity:****
O(log(min(a, b)))



****Auxiliary Space:****
O(1)

', '', 'Program to Find GCD or HCF of Two Numbers', 6, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('ddbdf68b-6bcc-4c3f-8472-f24f5f5d1320', e'Given a positive integer

****n****
, find its square root. If

****n****
is not a perfect square, then return

****floor****
of

****√n****
.


****Examples :****


> ****Input:****
> n = 4
>
>
>
> ****Output:****
> 2
>
>
>
> ****Explanation:****
> The square root of 4 is 2.
>
>
> ****Input:****
> n = 11
>
>
>
> ****Output:****
> 3
>
>
>
> ****Explanation:****
> The square root of 11 lies in between 3 and 4 so floor of the square root is 3.

Table of Content

* [[Naive Approach] Using a loop – O(sqrt(n)) Time and O(1) Space](#approach-1-using-a-loop-on-time-and-o1-space)
* [[Expected Approach] Using Binary Search – O(logn) Time and O(1) Space](#approach-2-using-binary-search-ologn-time-and-o1-space)
* [[Alternate Approach] Using Built In functions – O(logn) Time and O(1) Space](#approach-3-using-built-in-functions-ologn-time-and-o1-space)
* [[Alternate Approach] Using Formula Used by Pocket Calculators – O(1) Time and O(1) Space](#approach-4-using-formula-used-by-pocket-calculators-o1-time-and-o1-space)
### [Naive Approach] Using a loop – O(sqrt(n)) Time and O(1) Space


As, we know that square root of a positive integer is always

****greater****
than or

****equal****
to one. So we start iterating from

****1****
and calculate the square of each number. We continue the iteration until we reach to an

****integer****
whose square is

****greater****
than the given integer, then the integer just

****before****
it will be our answer.


C++

````
// C++ program to find the square root of
// given integer using a loop

#include <iostream>
using namespace std;

int floorSqrt(int n) {

    // Start iteration from 1 until the
    // square of a number exceeds n
    int res = 1;
    while(res*res <= n){
        res++;
    }

    // return the largest integer whose
    // square is less than or equal to n
    return res - 1;
}

int main() {
    int n = 11;
    cout << floorSqrt(n);
    return 0;
}

````

C

````
// C program to find the square root of
// given integer using a loop

#include <stdio.h>

int floorSqrt(int n) {

    // Start iteration from 1 until the
    // square of a number exceeds n
    int res = 1;
    while (res * res <= n) {
        res++;
    }

    // return the largest integer whose
    // square is less than or equal to n
    return res - 1;
}

int main() {
    int n = 11;
    printf("%d", floorSqrt(n));
    return 0;
}

````

Java

````
// Java program to find the square root of
// given integer using a loop

class GfG {

    static int floorSqrt(int n) {

        // Start iteration from 1 until the
        // square of a number exceeds n
        int res = 1;
        while (res * res <= n) {
            res++;
        }

        // return the largest integer whose
        // square is less than or equal to n
        return res - 1;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(floorSqrt(n));
    }
}

````

Python

````
# Python program to find the square root of
# given integer using a loop

def floorSqrt(n):

    # Start iteration from 1 until the
    # square of a number exceeds n
    res = 1
    while res * res <= n:
        res += 1

    # return the largest integer whose
    # square is less than or equal to n
    return res - 1

if __name__ == "__main__":
    n = 11
    print(floorSqrt(n))

````

C#

````
// C# program to find the square root of
// given integer using a loop

using System;

class GfG {

    static int floorSqrt(int n) {

        // Start iteration from 1 until the
        // square of a number exceeds n
        int res = 1;
        while (res * res <= n) {
            res++;
        }

        // return the largest integer whose
        // square is less than or equal to n
        return res - 1;
    }

    static void Main() {
        int n = 11;
        Console.WriteLine(floorSqrt(n));
    }
}

````

JavaScript

````
// JavaScript program to find the square root of
// given integer using a loop

function floorSqrt(n) {

    // Start iteration from 1 until the
    // square of a number exceeds n
    let res = 1;
    while (res * res <= n) {
        res++;
    }

    // return the largest integer whose
    // square is less than or equal to n
    return res - 1;
}

// Driver Code
let n = 11;
console.log(floorSqrt(n));

````




**Output**
```
3
```
### [Expected Approach] Using Binary Search – O(logn) Time and O(1) Space

> The square root of an integer follows a
>
> ****monotonic****
> pattern, because as we
>
> ****increase****
> any number, it’s square also
>
> ****increases****
> . If the square of a number is
>
> ****greater****
> than given integer, then square root will definitely exist
>
> ****before****
> this number. Conversely, if the square of a number is
>
> ****less****
> than or
>
> ****equal****
> to
>
> ****n****
> , then either this number is the square root or it lies after this number.
>
>
>
> Therefore, we can use
>
> [binary search](https://www.geeksforgeeks.org/binary-search/)
> to find the square root of n. I
>
> ****nitial search****
> space will be 1 to the given integer itself, because square root of any positive integer always exists within this range.












C++

````
// C++ program to find the square root of given integer
// using binary search

#include <iostream>
using namespace std;

int floorSqrt(int n) {

    // Initial search space
    int lo = 1, hi = n;
    int res = 1;

    while(lo <= hi) {
        int mid = lo + (hi - lo)/2;

        // If square of mid is less than or equal to n
        // update the result and search in upper half
        if(mid*mid <= n) {
            res = mid;
            lo = mid + 1;
        }

        // If square of mid exceeds n,
          // search in the lower half
        else {
            hi = mid - 1;
        }
    }

    return res;
}

int main() {
    int n = 11;
    cout << floorSqrt(n);
    return 0;
}

````

C

````
// C program to find the square root of given integer
// using binary search

#include <stdio.h>

int floorSqrt(int n) {

    // Initial search space
    int lo = 1, hi = n;
    int res = 1;

    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;

        // If square of mid is less than or equal to n
        // update the result and search in upper half
        if (mid * mid <= n) {
            res = mid;
            lo = mid + 1;
        }

        // If square of mid exceeds n,
        // search in the lower half
        else {
            hi = mid - 1;
        }
    }

    return res;
}

int main() {
    int n = 11;
    printf("%d", floorSqrt(n));
    return 0;
}

````

Java

````
// Java program to find the square root of given integer
// using binary search

class GfG {

    static int floorSqrt(int n) {

        // Initial search space
        int lo = 1, hi = n;
        int res = 1;

        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;

            // If square of mid is less than or equal to n
            // update the result and search in upper half
            if (mid * mid <= n) {
                res = mid;
                lo = mid + 1;
            }

            // If square of mid exceeds n,
            // search in the lower half
            else {
                hi = mid - 1;
            }
        }

        return res;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(floorSqrt(n));
    }
}

````

Python

````
# Python program to find the square root of given integer
# using binary search

def floorSqrt(n):

    # Initial search space
    lo = 1
    hi = n
    res = 1

    while lo <= hi:
        mid = lo + (hi - lo) // 2

        # If square of mid is less than or equal to n
        # update the result and search in upper half
        if mid * mid <= n:
            res = mid
            lo = mid + 1

        # If square of mid exceeds n,
        # search in the lower half
        else:
            hi = mid - 1

    return res

if __name__ == "__main__":
    n = 11
    print(floorSqrt(n))

````

C#

````
// C# program to find the square root of given integer
// using binary search

using System;

class GfG {

    static int floorSqrt(int n) {

        // Initial search space
        int lo = 1, hi = n;
        int res = 1;

        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;

            // If square of mid is less than or equal to n
            // update the result and search in upper half
            if (mid * mid <= n) {
                res = mid;
                lo = mid + 1;
            }

            // If square of mid exceeds n,
            // search in the lower half
            else {
                hi = mid - 1;
            }
        }

        return res;
    }

    static void Main() {
        int n = 11;
        Console.WriteLine(floorSqrt(n));
    }
}

````

JavaScript

````
// JavaScript program to find the square root of given integer
// using binary search

function floorSqrt(n) {

    // Initial search space
    let lo = 1, hi = n;
    let res = 1;

    while (lo <= hi) {
        let mid = lo + Math.floor((hi - lo) / 2);

        // If square of mid is less than or equal to n
        // update the result and search in upper half
        if (mid * mid <= n) {
            res = mid;
            lo = mid + 1;
        }

        // If square of mid exceeds n,
        // search in the lower half
        else {
            hi = mid - 1;
        }
    }

    return res;
}

let n = 11;
console.log(floorSqrt(n));

````




**Output**
```
3
```
### [Alternate Approach] Using Built In functions – O(logn) Time and O(1) Space


We can directly use built in functions to find square root of an integer.


C++

````
// C++ program to find the square root of given
// integer using built in square root function

#include <iostream>
#include <cmath>
using namespace std;

int floorSqrt(int n) {

      // Square root using sqrt function, it returns
      // the double value, which is casted to integer
      int res = sqrt(n);
      return res;
}

int main() {
    int n = 11;
    cout << floorSqrt(n);
    return 0;
}

````

C

````
// C program to find the square root of given
// integer using built in square root function

#include <stdio.h>
#include <math.h>

int floorSqrt(int n) {

    // Square root using sqrt function, it returns
    // the double value, which is casted to integer
    int res = sqrt(n);
    return res;
}

int main() {
    int n = 11;
    printf("%d", floorSqrt(n));
    return 0;
}

````

Java

````
// Java program to find the square root of given
// integer using built in square root function

class GfG {

    static int floorSqrt(int n) {

        // Square root using sqrt function, it returns
        // the double value, which is casted to integer
        int res = (int)Math.sqrt(n);
        return res;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(floorSqrt(n));
    }
}

````

Python

````
# Python program to find the square root of given
# integer using built in square root function

import math

def floorSqrt(n):

    # Square root using sqrt function, it returns
    # the double value, which is casted to integer
    res = int(math.sqrt(n))
    return res

if __name__ == "__main__":
    n = 11
    print(floorSqrt(n))

````

C#

````
// C# program to find the square root of given
// integer using built in square root function

using System;

class GfG {

    static int floorSqrt(int n) {

        // Square root using sqrt function, it returns
        // the double value, which is casted to integer
        int res = (int)Math.Sqrt(n);
        return res;
    }

    static void Main() {
        int n = 11;
        Console.WriteLine(floorSqrt(n));
    }
}

````

JavaScript

````
// JavaScript program to find the square root of given
// integer using built in square root function

function floorSqrt(n) {

    // Square root using sqrt function, it returns
    // the double value, which is casted to integer
    let res = Math.floor(Math.sqrt(n));
    return res;
}

let n = 11;
console.log(floorSqrt(n));

````




**Output**
```
3
```
### [Alternate Approach] Using Formula Used by Pocket Calculators – O(1) Time and O(1) Space

[Pocket calculator](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Exponential_identity)
uses the mathematical formula

****√n = e****
****1/2 \\* ln(n)****
to compute the square root of an integer n. Below is mathematical proof of this formula:


> Let’s say square root of n is x:
>
>
>
> ****x = √n****
>
>
> Squaring both the sides:
>
>
>
> x
>
> 2 =
> n
>
>
>
> Taking log on both the sides:
>
>
>
> => ln(x
>
> 2
> ) = ln(n)
>
>
>
> => 2\\*ln(x) = ln(n)
>
>
>
> => ln(x) = 1/2 \\* ln(n)
>
>
>
> To isolate x, exponentiate both sides with base e:
>
>
>
> => x = e
>
> 1/2 \\* ln(n)
>
>
> x is the square root of n:
>
>
>
> ****√n****
> = e
>
> 1/2 \\* ln(n)


Because of the way computations are done in computers in case of decimals, the result from the expression may be slightly less than the actual square root. Therefore, we will also consider the

****next integer****
after the calculated result as a potential answer.


C++

````
// C++ program to find the square root of given integer
// using mathematical formula

#include <iostream>
#include <cmath>
using namespace std;

int floorSqrt(int n) {

      // Calculating square root using mathematical formula
    int res = exp(0.5 * log(n));

    // If square of  res + 1 is less than or equal to n
      // then, it will be our answer
    if ((res + 1) * (res + 1) <= n) {
        res++;
    }

    return res;
}

int main() {
    int n = 11;
    cout << floorSqrt(n);
    return 0;
}

````

C

````
// C program to find the square root of given integer
// using mathematical formula

#include <stdio.h>
#include <math.h>

int floorSqrt(int n) {

    // Calculating square root using mathematical formula
    int res = exp(0.5 * log(n));

    // If square of res + 1 is less than or equal to n
    // then, it will be our answer
    if ((res + 1) * (res + 1) <= n) {
        res++;
    }

    return res;
}

int main() {
    int n = 11;
    printf("%d", floorSqrt(n));
    return 0;
}

````

Java

````
// Java program to find the square root of given integer
// using mathematical formula

class GfG {

    static int floorSqrt(int n) {

        // Calculating square root using mathematical formula
        int res = (int)Math.exp(0.5 * Math.log(n));

        // If square of res + 1 is less than or equal to n
        // then, it will be our answer
        if ((res + 1) * (res + 1) <= n) {
            res++;
        }

        return res;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(floorSqrt(n));
    }
}

````

Python

````
# Python program to find the square root of given integer
# using mathematical formula

import math

def floorSqrt(n):

    # Calculating square root using mathematical formula
    res = int(math.exp(0.5 * math.log(n)))

    # If square of res + 1 is less than or equal to n
    # then, it will be our answer
    if (res + 1) ** 2 <= n:
        res += 1

    return res

if __name__ == "__main__":
    n = 11
    print(floorSqrt(n))

````

C#

````
// C# program to find the square root of given integer
// using mathematical formula

using System;

class GfG {

    static int floorSqrt(int n) {

        // Calculating square root using mathematical formula
        int res = (int)Math.Exp(0.5 * Math.Log(n));

        // If square of res + 1 is less than or equal to n
        // then, it will be our answer
        if ((long)(res + 1) * (res + 1) <= n) {
            res++;
        }

        return res;
    }

    static void Main() {
        int n = 11;
        Console.WriteLine(floorSqrt(n));
    }
}

````

JavaScript

````
// JavaScript program to find the square root of given integer
// using mathematical formula

function floorSqrt(n) {

    // Calculating square root using mathematical formula
    let res = Math.floor(Math.exp(0.5 * Math.log(n)));

    // If square of res + 1 is less than or equal to n
    // then, it will be our answer
    if ((res + 1) * (res + 1) <= n) {
        res++;
    }

    return res;
}

let n = 11;
console.log(floorSqrt(n));

````




**Output**
```
3

```', '', 'Square root of an integer', 7, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('d1958775-d3e0-4bf8-b656-d1136cdb0e05', e'Given the number

****n****
(n >=0), find its

[factorial](https://www.geeksforgeeks.org/factorial/)
. Factorial of n is defined as 1 x 2 x … x n. For n = 0, factorial is 1. We are going to discuss iterative and recursive programs in this post.


****Examples:****

> ****Input****
> : n = 5
>
>
>
> ****Output****
> : 120
>
>
>
> ****Explanation****
> : 5! = 5 \\* 4 \\* 3 \\* 2 \\* 1 = 120
>
>
> ****Input****
> : n = 4
>
>
>
> ****Output****
> : 24
>
>
>
> ****Explanation****
> : 4! = 4 \\* 3 \\* 2 \\* 1 = 24
>
>
> ****Input****
> : n = 0
>
>
>
> ****Output****
> : 1
>
>
> ****Input****
> : n = 1
>
>
>
> ****Output****
> : 1

### ****Iterative Solution****


The idea is simple, we initialize result as 1. Then run a loop from 1 to n and multiply every number with n.



> ****Illustration for n = 4****
>
>
> Initialize res = 1
>
>
>
> Run a loop for i = 2 to 4
>
>
>
> i = 2 : res = res \\* 2 = 2
>
>
>
> i = 3 : res = res \\* 3 = 6
>
>
>
> i = 4 : res = res \\* 4 = 24

C++

````
// C++ program for factorial of a number
#include <iostream>
using namespace std;

// function to find factorial of given number
int factorial(int n)
{
    int res = 1;
    for (int i = 2; i <= n; i++)
        res *= i;
    return res;
}

// Driver code
int main()
{
    int num = 5;
    cout << "Factorial of " << num << " is " << factorial(num) << endl;
    return 0;
}

````

C

````
#include <stdio.h>

// function to find factorial of given number
int factorial(int n)
{
    int res = 1, i;
    for (i = 2; i <= n; i++)
        res *= i;
    return res;
}

int main()
{
    int num = 5;
    printf("Factorial of %d is %d", num, factorial(num));
    return 0;
}

````

Java

````
// Java program to find factorial of given number
class GfG {

    // Method to find factorial of the given number
    static int factorial(int n)
    {
        int res = 1;
        for (int i = 2; i <= n; i++)
            res *= i;
        return res;
    }

    // Driver method
    public static void main(String[] args)
    {
        int num = 5;
        System.out.println("Factorial of " + num + " is "
                           + factorial(5));
    }
}

````

Python

````
# Python 3 program to find
# factorial of given number
def factorial(n):

    res = 1

    for i in range(2, n + 1):
        res *= i
    return res


# Driver Code
num = 5
print("Factorial of", num, "is", factorial(num))

````

C#

````
// C# program to find
// factorial of given number
using System;

class Test {
    // Method to find factorial
    // of given number
    static int factorial(int n)
    {
        int res = 1;

        for (int i = 2; i <= n; i++)
            res *= i;
        return res;
    }

    // Driver method
    public static void Main()
    {
        int num = 5;
        Console.WriteLine("Factorial of " + num + " is "
                          + factorial(5));
    }
}

````

JavaScript

````
// JavaScript program to find factorial of given number

// Method to find factorial of the given number
function factorial(n)
{
    let res = 1;
    for (let i = 2; i <= n; i++)
        res *= i;
    return res;
}

// Driver method
let num = 5;
console.log("Factorial of " + num + " is " + factorial(5));

````

PHP

````
<?php
// function to find factorial of given number
function factorial($n)
{
    $res = 1;
    for ($i = 2; $i <= $n; $i++) {
        $res *= $i;
    }
    return $res;
}

// Driver code
$num = 5;
echo "Factorial of $num is " . factorial($num) . "\\n";
?>

````




**Output**
```
Factorial of 5 is 120

```

****Time Complexity:****
O(n), since we are running a loop from 1 to n.



****Auxiliary Space:****
O(1)


### ****Recursive Solution****


Let us first see how we can break factorial(n) into smaller problem and then define recurrance.


> * ****n!****
>   = n \\* (n – 1) \\* (n – 2) …. 2 \\* 1
> * ****(n – 1)!****
>   = (n – 1) \\* (n – 2) … 2 \\* 1
>
>
> From the above two equations, we can say that n
>
> ****! = n \\* (n – 1)!****
>
>
>
>
> Since the problem can be broken down into The idea is to define a recursive function, say
>
> ****factorial(n)****
> to calculate the
>
> [factorial](https://www.geeksforgeeks.org/factorial/)
> of number
>
> ****n****
> . According to the value of n, we can have two cases:
>
>
> ****if****
> n
>
> ****= 0 or n = 1 :****
>
>
>
> factorial(n) = 1
>
>
>
> ****Else****
> :
>
>
>
> factorial(n) = n \\* factorial(n – 1).

****Illustration:****

![factorial](https://media.geeksforgeeks.org/wp-content/uploads/20240924132748/factorial.webp)




Below is the implementation of the above approach:


C++

````
// C++ program to find factorial of given number
#include <iostream>
using namespace std;

// Function to find factorial
// of given number
int factorial(int n)
{
    if (n == 0 || n == 1)
        return 1;
    return n * factorial(n - 1);
}

// Driver code
int main()
{
    int num = 5;
    cout << "Factorial of " << num << " is " << factorial(num) << endl;
    return 0;
}

````

C

````
// C program to find factorial of given number
#include <stdio.h>

// function to find factorial of given number
int factorial(int n)
{
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}

int main()
{
    int num = 5;
    printf("Factorial of %d is %d", num, factorial(num));
    return 0;
}

````

Java

````
// Java program to find factorial of given number
class Test {

    // Method to find factorial of the given number
    static int factorial(int n)
    {
        int res = 1, i;
        for (i = 2; i <= n; i++)
            res *= i;
        return res;
    }

    // Driver method
    public static void main(String[] args)
    {
        int num = 5;
        System.out.println("Factorial of " + num + " is "
                           + factorial(5));
    }
}

````

Python

````
# Python 3 program to find
# factorial of given number
def factorial(n):

    if n == 0:
        return 1

    return n * factorial(n - 1)


# Driver Code
num = 5
print(f"Factorial of {num} is {factorial(num)}")

````

C#

````
// C# program to find factorial
// of given number
using System;

class Test {
    // method to find factorial
    // of given number
    static int factorial(int n)
    {
        if (n == 0)
            return 1;

        return n * factorial(n - 1);
    }

    // Driver method
    public static void Main()
    {
        int num = 5;
        Console.WriteLine("Factorial of " + num + " is "
                          + factorial(5));
    }
}

````

JavaScript

````
// Javascript to find factorial
// of given number

// function to find factorial
// of given number
function factorial(n)
{
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}

// Driver Code
let num = 5;
console.log("Factorial of " + num + " is "
            + factorial(num));

````

PHP

````
<?php
// PHP program to find factorial
// of given number

// function to find factorial
// of given number
function factorial($n)
{
    if ($n == 0)
        return 1;
    return $n * factorial($n - 1);
}

    // Driver Code
    $num = 5;
    echo "Factorial of ", $num, " is ", factorial($num);

?>

````




**Output**
```
Factorial of 5 is 120

```

****Time Complexity:****
O(n), since the function is being called n times



****Auxiliary Space:****
O(n), In the worst case, the recursion stack space would be full with all the function calls waiting to get completed and that would make it an O(n) recursion stack space.


****Which approach is better – iterative or recursive?****


Iterative approach is better as the recursive approach requires extra space for recursion call stack and overhead of recursion calls. However writing a recursive code is always a fun exercise.


****How do we handle large numbers?****


One simple improvement that we can do is use long long in C/C++ and long in Java/C#, but that does not help much as factorials are really large numbers and causes overflow for small values. Please refer
', '', 'Factorial of a Number', 8, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('770b0b45-edf6-4bc7-9880-e2727206798f', e'
Given two positive numbers x and y, check if y is a power of x or not.


**Examples :**

> **Input:**
> x = 10, y = 1
>
>
> **Output:**
> True
>
>
> x^0 = 1
>
> **Input:**
> x = 10, y = 1000
>
>
> **Output:**
> True
>
>
> x^3 = 1
>
> **Input:**
> x = 10, y = 1001
>
>
> **Output:**
> False

Recommended Practice

[Check if a number is power of another number](https://www.geeksforgeeks.org/problems/check-if-a-number-is-power-of-another-number5442/1/)


[Try It!](https://www.geeksforgeeks.org/problems/check-if-a-number-is-power-of-another-number5442/1/)


A simple solution is to repeatedly compute the powers of x. If a power becomes equal to y, then y is a power, else not.

C++
---

















```
// C++ program to check if a number is power of
// another number
#include <bits/stdc++.h>
using namespace std;

/* Returns 1 if y is a power of x */
bool isPower( int x, long int y)
{
// The only power of 1 is 1 itself
if (x == 1)
return (y == 1);

// Repeatedly compute power of x
long int pow = 1;
while ( pow < y)
pow *= x;

// Check if power of x becomes y
return ( pow == y);
}

/* Driver program to test above function */
int main()
{
cout << isPower(10, 1) << endl;
cout << isPower(1, 20) << endl;
cout << isPower(2, 128) << endl;
cout << isPower(2, 30) << endl;
return 0;
}
```





Java
----

















```
// Java program to check if a number is power of
// another number
public class Test {
// driver method to test power method
public static void main(String[] args)
{
// check the result for true/false and print.
System.out.println(isPower( 10 , 1 ) ? 1 : 0 );
System.out.println(isPower( 1 , 20 ) ? 1 : 0 );
System.out.println(isPower( 2 , 128 ) ? 1 : 0 );
System.out.println(isPower( 2 , 30 ) ? 1 : 0 );
}
/* Returns true if y is a power of x */
public static boolean isPower( int x, int y)
{
// The only power of 1 is 1 itself
if (x == 1 )
return (y == 1 );

// Repeatedly compute power of x
int pow = 1 ;
while (pow < y)
pow = pow * x;

// Check if power of x becomes y
return (pow == y);
}
}

// This code is contributed by Jyotsna.
```





Python3
-------

















```
# python program to check
# if a number is power of
# another number

# Returns true if y is a
# power of x
def isPower (x, y):

# The only power of 1
# is 1 itself
if (x = = 1 ):
return (y = = 1 )

# Repeatedly compute
# power of x
pow = 1
while ( pow < y):
pow = pow * x

# Check if power of x
# becomes y
return ( pow = = y)


# Driver Code
# check the result for
# true/false and print.
if (isPower( 10 , 1 )):
print ( 1 )
else :
print ( 0 )

if (isPower( 1 , 20 )):
print ( 1 )
else :
print ( 0 )
if (isPower( 2 , 128 )):
print ( 1 )
else :
print ( 0 )
if (isPower( 2 , 30 )):
print ( 1 )
else :
print ( 0 )

# This code is contributed
# by Sam007.
```





C#
--

















```
// C# program to check if a number
// is power of another number
using System;

class GFG
{

// Returns true if y is a power of x
public static bool isPower ( int x, int y)
{
// The only power of 1 is 1 itself
if (x == 1)
return (y == 1);

// Repeatedly compute power of x
int pow = 1;
while (pow < y)
pow = pow * x;

// Check if power of x becomes y
return (pow == y);
}

// Driver Code
public static void Main ()
{
//check the result for true/false and print.
Console.WriteLine(isPower(10, 1) ? 1 : 0);
Console.WriteLine(isPower(1, 20) ? 1 : 0);
Console.WriteLine(isPower(2, 128) ? 1 : 0);
Console.WriteLine(isPower(2, 30) ? 1 : 0);
}

}

// This code is contributed by Sam007
```





PHP
---

















```
<?php
// PHP program to check if a
// number is power of another number

/* Returns 1 if y is a power of x */
function isPower( $x , $y )
{
// The only power of 1 is 1 itself
if ( $x == 1)
return ( $y == 1 ? 1 : 0);

// Repeatedly comput power of x
$pow = 1;
while ( $pow < $y )
$pow *= $x ;

// Check if power of x becomes y
return ( $pow == $y ? 1 : 0);
}

// Driver Code
echo isPower(10, 1) . "\\n" ;
echo isPower(1, 20) . "\\n" ;
echo isPower(2, 128) . "\\n" ;
echo isPower(2, 30) . "\\n" ;

// This code is contributed by mits
?>
```





Javascript
----------

















```
<script>

// JavaScript program to check if a number
// is power of another number

/* Returns true if y is a power of x */
function isPower(x, y)
{
// The only power of 1 is 1 itself
if (x == 1)
return (y == 1);

// Repeatedly compute power of x
let pow = 1;
while (pow < y)
pow = pow * x;

// Check if power of x becomes y
return (pow == y);
}


// Driver Code

//check the result for true/false and print.
document.write((isPower(10, 1) ? 1 : 0) + "<br/>" );
document.write((isPower(1, 20) ? 1 : 0) + "<br/>" );
document.write((isPower(2, 128) ? 1 : 0) + "<br/>" );
document.write((isPower(2, 30) ? 1 : 0) + "<br/>" );

</script>
```







**Output**
```
1
0
1
0
```

**Time complexity:**
O(Log
x
y)


**Auxiliary space:**
O(1)

**Optimization:**


We can optimize above solution to work in O(Log Log y). The idea is to do squaring of power instead of multiplying it with x, i.e., compare y with x^2, x^4, x^8, …etc. If x becomes equal to y, return true. If x becomes more than y, then we do binary search for power of x between previous power and current power, i.e., between x^i and x^(i/2).


Following are detailed step.

```
1) Initialize pow = x, i = 1
2) while (pow < y)
   {
      pow = pow*pow
      i *= 2
   }
3) If pow == y
     return true;
4) Else construct an array of powers
   from x^i to x^(i/2)
5) Binary Search for y in array constructed
   in step 4. If not found, return false.
   Else return true.
```

**Alternate Solution :**


The idea is to take log of y in base x. If it turns out to be an integer, we return true. Else false.

C++
---

















```
// CPP program to check given number y
// is power of x
#include <iostream>
#include <math.h>
using namespace std;

bool isPower( int x, int y)
{
// logarithm function to calculate value
float res1 = log (y) / log (x);
return res1== floor (res1);
}

// Driven program
int main()
{
cout << isPower(2, 128) << endl;
return 0;
}
//This code is contributed by Anand Agarwal
```





Java
----

















```
// Java program to check given
// number y is power of x

class GFG
{
static boolean isPower( int x,
int y)
{
// logarithm function to
// calculate value
float res1 = ( float )(Math.log(y) /
Math.log(x));

return (res1% 1 == 0 );
}

// Driver Code
public static void main(String args[])
{
if (isPower( 2 , 128 ))
System.out.println( "1" );
else
System.out.println( "0" );
}
}

// This code is contributed by Sam007
// This code is Corrected by Anand Agarwal
```





Python3
-------

















```
# Python program to check if given number y
# is power of x
import math

def is_power(x, y):
# logarithm function to calculate value
res1 = math.log(y) / math.log(x)
res2 = math.log(y) / math.log(x) # Note: this is float

# compare to the result1 or result2 both are equal
return res1 = = res2

# Driven program
if __name__ = = "__main__" :
print (is_power( 2 , 128 ))
```





C#
--

















```
using System;

namespace ConsoleApp1
{
class Program
{

// Function to check if a number is power of another number
static bool IsPower( int x, int y)
{

// Use logarithm function to calculate the value
double res1 = Math.Log(y) / Math.Log(x);

// Note : this is double
double res2 = Math.Log(y) / Math.Log(x);

// Compare the result1 or result2, they should be equal
return (res1 == res2);
}

static void Main( string [] args)
{
// Check if 128 is power of 2
if (IsPower(2, 128))
Console.WriteLine( "1" );
else
Console.WriteLine( "0" );
}
}
}

// This code is contributed by vinayetbi1.
```





PHP
---

















```
<?php
// PHP program to check
// given number y
function isPower( $x , $y )
{
// logarithm function to
// calculate value
$res1 = log( $y ) / log( $x );

// Note : this is double
$res2 = log( $y ) / log( $x );

// compare to the result1 or
// result2 both are equal
return ( $res1 == $res2 );
}

// Driver Code
echo isPower(2, 128) ;

// This code is contributed by Sam007
?>
```





Javascript
----------

















```
// JavaScript program to check given number y
// is power of x

function isPower(x, y) {
// logarithm function to calculate value
const res1 = Math.log(y) / Math.log(x);
const res2 = Math.log(y) / Math.log(x);

// compare to the result1 or result2 both are equal
return (res1 === res2);
}

// Driven program
console.log(isPower(2, 128));
```







**Output**
```
1
```

**Time complexity**
: O(log Y)


**Auxiliary space**
: O(1)', '', 'Check if a number is a power of another number', 9, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('3346a2ba-c1c6-4b4f-bde7-37811686b1c0', e'
Given a number

****N****
, print all numbers in the range from 1 to N having exactly 3 divisors.


****Examples:****


> ****Input:****
> N = 16
>
>
>
> ****Output:****
> 4 9
>
>
>
> ****Explanation****
> : 4 and 9 have exactly three divisors.
>
>
> ****Input:****
> N = 49
>
>
>
> ****Output:****
> 4 9 25 49
>
>
>
> ****Explanation:****
> 4, 9, 25 and 49 have exactly three divisors.

Recommended Practice

[3 Divisors](https://practice.geeksforgeeks.org/problems/3-divisors3942/1)


[Try It!](https://practice.geeksforgeeks.org/problems/3-divisors3942/1)


****Mathematical approach to find Numbers with exactly 3 divisors:****
----------------------------------------------------------------------


To solve the problem follow the below idea:


> ****Idea:****
> After having a close look at the examples mentioned above, you have noticed that all the required numbers are perfect squares and that too of only prime numbers.
>
>
> ****Proof:****
> Suppose the number is N, and it is a perfect square with square root X such that X is prime.
>
>
> Now if we find the factors of N, it will always have following combinations:
>
>
> * 1\\*N
> * X\\*X
>
>
> Therefore the required numbers will have only three numbers as their divisors:
>
>
> * 1,
> * that number itself, and
> * just a single divisor in between 1 and the number.

****Algorithm:****
We can generate all primes within a set using any sieve method efficiently and then we should take all primes i, such that

****i\\*i <=N****
.


Follow the below steps to solve the problem:


* Generate the prime numbers from 1 to N using any sieve method efficiently
* Print all the prime numbers(X) between 1 to N, such as X

  2
  is less than or equal to N


Below is the implementation of the above approach:


C++

````
// C++ program to print all
// three-primes smaller than
// or equal to N using Sieve
// of Eratosthenes
#include <bits/stdc++.h>
using namespace std;

// Generates all primes upto N and
// prints their squares
void numbersWith3Divisors(int N)
{
    bool prime[N + 1];
    memset(prime, true, sizeof(prime));
    prime[0] = prime[1] = 0;

    for (int p = 2; p * p <= N; p++) {
        // If prime[p] is not changed,
        // then it is a prime
        if (prime[p] == true) {
            // Update all multiples of p
            for (int i = p * 2; i <= N; i += p)
                prime[i] = false;
        }
    }

    // Print squares of primes upto n.
    cout << "Numbers with 3 divisors :\\n";
    for (int i = 0; i * i <= N; i++)
        if (prime[i])
            cout << i * i << " ";
}

// Driver code
int main()
{
    int N = 96;

    // Function call
    numbersWith3Divisors(N);

    return 0;
}

````

Java

````
// Java program to print all
// three-primes smaller than
// or equal to N using Sieve
// of Eratosthenes
import java.io.*;
import java.util.*;

class GFG {

    // Generates all primes upto N
    // and prints their squares
    static void numbersWith3Divisors(int N)
    {
        boolean[] prime = new boolean[N + 1];
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;

        for (int p = 2; p * p <= N; p++) {

            // If prime[p] is not changed,
            // then it is a prime
            if (prime[p] == true) {
                // Update all multiples of p
                for (int i = p * 2; i <= N; i += p)
                    prime[i] = false;
            }
        }

        // print squares of primes upto n
        System.out.println("Numbers with 3 divisors : ");
        for (int i = 0; i * i <= N; i++)
            if (prime[i])
                System.out.print(i * i + " ");
    }

    // Driver code
    public static void main(String[] args)
    {
        int N = 96;

        // Function call
        numbersWith3Divisors(N);
    }
}

// Contributed by Pramod Kumar

````

Python

````
# Python3 program to print
# all three-primes smaller than
# or equal to n using Sieve
# of Eratosthenes

# Generates all primes upto n
# and prints their squares


def numbersWith3Divisors(N):

    prime = [True]*(N+1)
    prime[0] = prime[1] = False
    p = 2
    while (p*p <= N):

        # If prime[p] is not changed,
        # then it is a prime
        if (prime[p] == True):

            # Update all multiples of p
            for i in range(p*2, N+1, p):
                prime[i] = False
        p += 1

    # print squares of primes upto n.
    print("Numbers with 3 divisors :")
    i = 0
    while (i*i <= N):
        if (prime[i]):
            print(i*i, end=" ")
        i += 1


# Driver code
if __name__ == "__main__":
    N = 96

    # Function call
    numbersWith3Divisors(N)

# This code is contributed by mits

````

C#

````
// C# program to print all
// three-primes smaller than
// or equal to n using Sieve
// of Eratosthenes

class GFG {

    // Generates all primes upto n
    // and prints their squares
    static void numbersWith3Divisors(int N)
    {
        bool[] prime = new bool[N + 1];
        prime[0] = prime[1] = true;

        for (int p = 2; p * p <= N; p++) {

            // If prime[p] is not changed,
            // then it is a prime
            if (prime[p] == false) {
                // Update all multiples of p
                for (int i = p * 2; i <= N; i += p)
                    prime[i] = true;
            }
        }

        // print squares of primes upto n
        System.Console.WriteLine(
            "Numbers with 3 divisors : ");
        for (int i = 0; i * i <= N; i++)
            if (!prime[i])
                System.Console.Write(i * i + " ");
    }

    // Driver code
    public static void Main()
    {
        int N = 96;

        // Function call
        numbersWith3Divisors(N);
    }
}

// This code is Contributed by mits

````

JavaScript

````
// Javascript program to print all
    // three-primes smaller than
    // or equal to n using Sieve
    // of Eratosthenes

    // Generates all primes upto n and
    // prints their squares
    function numbersWith3Divisors(n)
    {
        let prime = new Array(n+1);
        prime.fill(true);
        prime[0] = prime[1] = 0;

        for (let p = 2; p*p <= n; p++)
        {
            // If prime[p] is not changed,
            // then it is a prime
            if (prime[p] == true)
            {
               // Update all multiples of p
               for (let i = p*2; i <= n; i += p)
                  prime[i] = false;
            }
        }

        // print squares of primes upto n.
        document.write("Numbers with 3 divisors :" + "</br>");
        for (let i = 0;  i*i <= n ; i++)
            if (prime[i])
              document.write(i*i + " ");
    }

    // sieve();
    let n = 96;
    numbersWith3Divisors(n);

     // This code is contributed by mukesh07.

````

PHP

````
<?php
// PHP program to print all three-primes
// smaller than or equal to n using Sieve
// of Eratosthenes

// Generates all primes upto n and
// prints their squares
function numbersWith3Divisors($N)
{
    $prime = array_fill(0, $N + 1, true);
    $prime[0] = $prime[1] = false;

    for ($p = 2; $p * $p <= $N; $p++)
    {
        // If prime[p] is not changed,
        // then it is a prime
        if ($prime[$p] == true)
        {
        // Update all multiples of p
        for ($i = $p * 2; $i <= $N; $i += $p)
            $prime[$i] = false;
        }
    }

    // print squares of primes upto n.
    echo "Numbers with 3 divisors :\\n";
    for ($i = 0; $i * $i <= $N ; $i++)
        if ($prime[$i])
        echo $i * $i . " ";
}

// Driver Code
$N = 96;

// Function call
numbersWith3Divisors($N);

// This code is contributed by mits
?>

````




**Output**
```
Numbers with 3 divisors :
4 9 25 49
```

****Time Complexity:****
O(N\\*log(log(N)))



****Auxiliary Space:****
O(N)


****Numbers with exactly 3 divisors using constant space:****
-------------------------------------------------------------

> Run a loop from 2 to sqrt(N) and check if the current element is prime or not, if it is so then print that number, but this method will increase the time complexity of the solution


Follow the below steps to solve the problem:


* Start a loop for integer

  ****i****
  from

  ****2****
  to

  ****N.****
* Check if

  ****i****
  is prime or not, which can be done easily using the

  [****isPrime(n)****](https://www.geeksforgeeks.org/prime-numbers)

  method.
* If

  ****i****
  is prime, check if its square is less than or equal to the given number. This will be reviewed only for squares of prime numbers, therefore reducing the number of checks.
* If the above condition is satisfied, the number will be printed and the loop will continue till

  ****i <= n.****


Below is the implementation of the above approach:


C++

````
// C++ program to print all
// three-primes smaller than
// or equal to n without using
// extra space
#include <bits/stdc++.h>
using namespace std;

void numbersWith3Divisors(int);
bool isPrime(int);

// Generates all primes upto n and
// prints their squares
void numbersWith3Divisors(int N)
{
    cout << "Numbers with 3 divisors : " << endl;

    for (int i = 2; i * i <= N; i++) {

        // Check prime
        if (isPrime(i)) {
                // Print numbers in
                // the order of
                // occurrence
                cout << i * i << " ";
        }
    }
}

// Check if a number is prime or not
bool isPrime(int N)
{
    for (int i = 2; i * i <= N; i++) {
        if (N % i == 0)
            return false;
    }
    return true;
}

// Driver code
int main()
{
    int N = 122;

    // Function call
    numbersWith3Divisors(N);

    return 0;
}

// This code is contributed by vishu2908

````

Java

````
// Java program to print all
// three-primes smaller than
// or equal to N without using
// extra space
import java.util.*;

class GFG {

    // 3 divisor logic implementation
    // check if a number is
    // prime or not
    // if it is a prime then
    // check if its square
    // is less than or equal to
    // the given number
    static void numbersWith3Divisors(int N)
    {
        System.out.println("Numbers with 3 divisors : ");

        for (int i = 2; i * i <= N; i++) {

            // Check prime
            if (isPrime(i)) {
                    // Print numbers in
                    // the order of
                    // occurrence
                    System.out.print(i * i + " ");
            }
        }
    }

    // Check if a number is prime or not
    public static boolean isPrime(int N)
    {
        for (int i = 2; i * i <= N; i++) {
            if (N % i == 0)
                return false;
        }
        return true;
    }

    // Driver code
    public static void main(String[] args)
    {
        int N = 122;

        // Function call
        numbersWith3Divisors(N);
    }
}

// Contributed by Parag Pallav Singh

````

Python

````
# Python3 program to print all
# three-primes smaller than
# or equal to N without using
# extra space

# 3 divisor logic implementation
# check if a number is  prime or
# not if it is a prime then check
# if its square is less than or
# equal to the given number


def numbersWith3Divisors(N):

    print("Numbers with 3 divisors : ")

    i = 2
    while i * i <= N:

        # Check prime
        if (isPrime(i)):
                # Print numbers in the order
                # of occurrence
                print(i * i, end=" ")

        i += 1

# Check if a number is prime or not


def isPrime(N):

    i = 2
    while i * i <= N:
        if N % i == 0:
            return False

        i += 1

    return True


# Driver code
if __name__ == "__main__":
    N = 122

    # Function call
    numbersWith3Divisors(N)

# This code is contributed by divyesh072019

````

C#

````
// C# program to print all
// three-primes smaller than
// or equal to N without using
// extra space
using System;

class GFG {

    // 3 divisor logic implementation
    // check if a number is prime or
    // not if it is a prime then check
    // if its square is less than or
    // equal to the given number
    static void numbersWith3Divisors(int N)
    {
        Console.WriteLine("Numbers with 3 divisors : ");

        for (int i = 2; i * i <= N; i++) {

            // Check prime
            if (isPrime(i)) {
                    // Print numbers in the order
                    // of occurrence
                    Console.Write(i * i + " ");
            }
        }
    }

    // Check if a number is prime or not
    public static bool isPrime(int N)
    {
        for (int i = 2; i * i <= N; i++) {
            if (N % i == 0)
                return false;
        }
        return true;
    }

    // Driver code
    static void Main()
    {
        int N = 122;

        // Function call
        numbersWith3Divisors(N);
    }
}

// This code is contributed by divyeshrabadiya07

````

JavaScript

````
// Javascript program to print all
    // three-primes smaller than
    // or equal to n without using
    // extra space

      // 3 divisor logic implementation
    // check if a number is prime or
    // not if it is a prime then check
    // if its square is less than or
    // equal to the given number
    function numbersWith3Divisors(n)
    {
        document.write("Numbers with 3 divisors : ");

        for(let i = 2; i * i <= n; i++)
        {

            // Check prime
            if (isPrime(i))
            {
                    // Print numbers in the order
                    // of occurrence
                    document.write(i * i + " ");
            }
        }
    }

    // Check if a number is prime or not
    function isPrime(n)
    {
        if (n == 0 || n == 1)
            return false;

        for(let i = 2; i * i <= n; i++)
        {
            if (n % i == 0)
                return false;
        }
        return true;
    }

    let n = 122;

    numbersWith3Divisors(n);

// This code is contributed by suresh07.

````




**Output**
```
Numbers with 3 divisors :
4 9 25 49 121
```

****Time Complexity:****
O(sqrt N

2
)



****Auxiliary Space:****
O(1)


', '', 'Find numbers from 1 to N with exactly 3 divisors', 10, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('723f7734-7503-4850-8863-e4f4887152a7', e'
A

[****prime number****](https://www.geeksforgeeks.org/prime-numbers/)
is a natural number greater than 1 that has exactly two factors:

****1****
and

****itself****
. This article explores the properties of prime numbers, various methods to check for primality, and related problems.


> ****Input****
> : n = 10
>
>
>
> ****Output****
> : False
>
>
>
> 10 is divisible by 2 and 5
>
>
> ****Input****
> : n = 11
>
>
>
> ****Output****
> : True
>
>
>
> 11 is divisible by 1 and 11 only
>
>
> ****Input****
> : n = 1
>
>
>
> ****Output****
> : False
>
>
>
> [1 is neither composite nor prime](https://www.geeksforgeeks.org/is-1-a-prime-number-or-a-composite-number/)
>
> ****Input****
> : n = 0
>
>
>
> ****Output****
> : False
>
>
>
> [0 is neither composite nor prime](https://www.geeksforgeeks.org/is-0-a-prime-number/)

Table of Content

* [Different Methods to Check for Prime Number](#what-is-prime-number)

+ [[Naive Approach] Basic Trial Division Method – O(n) time and O(1) space](#naive-approach-basic-trial-division-method)
+ [[Efficient Approach – 1] Trial Division Method – O(√n) time and O(1) space](#efficient-approach-1-trial-division-method)
+ [[Expected Approach – 2] Optimized Trial Division Method – O(√n) time and O(1) space](#expected-approach-2-optimized-trial-division-method)

* [Primality Testing Methods](#primality-testing-methods)
* [Sieve Algorithms for Prime Number Generation](#sieve-algorithms-for-prime-number-generation)
* [Prime Number Algorithms and Related Problems](#prime-number-algorithms-and-related-problems)

Different Methods to Check for Prime Number
-------------------------------------------


To check if a number is prime, we can use the key property of prime numbers that is, a prime number has exactly two factors, 1 and itself. If a number has more than two factors, it is not considered prime. There are several approaches to check if a number is prime, each varying in complexity and efficiency. Lets explore these approaches one by one.



### [Naive Approach] Basic Trial Division Method – O(n) time and O(1) space

> The simplest method to check if a number
>
> ****n****
> is prime by checking every number from
>
> ****2****
> to
>
> ****n-1.****
> If the number
>
> ****n****
> is divisible by any of these, it’s not prime.


Step-by-step approach:


* If

  ****n****
  is less than 2, return

  ****false****
  (0 and 1 are not prime).
* Loop through numbers from

  ****2****
  to

  ****n-1.****
  + If

    ****n****
    is divisible by any of these numbers, return

    ****false****
    .
* If no divisors are found, return

  ****true****
  .


Below is the implementation of the above approach:


C++

````
#include <iostream>
using namespace std;

// Function to check whether a number is prime or not
bool isPrime(int n) {
    if (n <= 1)
        return false;

    // Check divisibility from 2 to n-1
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            return false;

    return true;
}

int main() {
    int n = 11;
    cout << isPrime(n);
    return 0;
}

````

C

````
#include <stdio.h>
#include <stdbool.h>

// Function to check whether a number is prime or not
bool isPrime(int n) {
    if (n <= 1)
        return false;

    // Check divisibility from 2 to n-1
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            return false;

    return true;
}

int main() {
    int n = 11;
    printf("%d", isPrime(n));
    return 0;
}

````

Java

````
public class GfG {

    // Function to check whether a number is prime or not
    static boolean isPrime(int n) {
        if (n <= 1)
            return false;

        // Check divisibility from 2 to n-1
        for (int i = 2; i < n; i++)
            if (n % i == 0)
                return false;

        return true;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(isPrime(n));
    }
}

````

Python

````
# Function to check whether a number is prime or not
def is_prime(n):
    if n <= 1:
        return False

    # Check divisibility from 2 to n-1
    for i in range(2, n):
        if n % i == 0:
            return False

    return True

n = 11
print(is_prime(n))

````

C#

````
using System;

class GfG {
    // Function to check whether a number is prime or not
    static bool IsPrime(int n) {
        if (n <= 1)
            return false;

        // Check divisibility from 2 to n-1
        for (int i = 2; i < n; i++)
            if (n % i == 0)
                return false;

        return true;
    }

    static void Main(string[] args) {
        int n = 11;
        Console.WriteLine(IsPrime(n));
    }
}

````

JavaScript

````
// Function to check whether a number is prime or not
function isPrime(n) {
    if (n <= 1)
        return false;

    // Check divisibility from 2 to n-1
    for (let i = 2; i < n; i++)
        if (n % i === 0)
            return false;

    return true;
}

let n = 11;
console.log(isPrime(n));

````




**Output**
```
1
```

****Time Complexity:****
O(n)



****Auxiliary Space:****
O(1)


### [Efficient Approach – 1] Trial Division Method – O(√n) time and O(1) space

> There is an observation that if we take any number
>
> ****n****
> and find its divisors then divisors would appear in pairs. For example, if
>
> ****4****
> is a divisor of
>
> ****28****
> , then
>
> ****28/4=7****
> is also a divisor. So we have the pair (4,7).
>
>
> This means that for any divisor
>
> ****d****
> of
>
> ****n****
> , there is a corresponding divisor
>
> ****n/d****
> . If
>
> ****d****
> is less than or equal to the
>
> ****√n****
> , then
>
> ****n/d****
> will be greater than or equal to the
>
> ****√n****
> . Therefore, we only need to check for divisors up to the
>
> ****√n****
> . If
>
> ****n****
> has a divisor larger than its square root, the paired divisor must be smaller than the square root, which we would have already checked.


For example, if

****n = 36****
, its square root is

****6****
. The divisors are

****1,2,3,4,6,9,12,18,36****
. We only need to check

****1,2,3,4,6****
because any larger divisor will have a smaller paired divisor that we’ve already checked.


Below is the implementation of the above approach:


C++14

````
#include <iostream>
#include <cmath>
using namespace std;

// Function to check whether a number is prime or not
bool isPrime(int n) {

    // Numbers less than or equal to 1 are not prime
    if (n <= 1)
        return false;

    // Check divisibility from 2 to the square root of n
    for (int i = 2; i <= sqrt(n); i++)
        if (n % i == 0)
            return false;

    // If no divisors were found, n is prime
    return true;
}

int main() {
    int n = 11;
    cout << isPrime(n);
    return 0;
}

````

C

````
#include <stdio.h>
#include <stdbool.h>
#include <math.h>

// Function to check whether a number is prime or not
bool isPrime(int n) {
    // Numbers less than or equal to 1 are not prime
    if (n <= 1)
        return false;

    // Check divisibility from 2 to the square root of n
    for (int i = 2; i <= sqrt(n); i++)
        if (n % i == 0)
            return false;

    // If no divisors were found, n is prime
    return true;
}

int main() {
    int n = 11;
    printf("%d", isPrime(n));
    return 0;
}

````

Java

````
class Main {

    // Function to check whether a number is prime or not
    static boolean isPrime(int n) {

        // Numbers less than or equal to 1 are not prime
        if (n <= 1)
            return false;

        // Check divisibility from 2 to the square root of n
        for (int i = 2; i <= Math.sqrt(n); i++)
            if (n % i == 0)
                return false;

        // If no divisors were found, n is prime
        return true;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(isPrime(n));
    }
}

````

Python

````
import math

# Function to check whether a number is prime or not
def is_prime(n):

    # Numbers less than or equal to 1 are not prime
    if n <= 1:
        return False

    # Check divisibility from 2 to the square root of n
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False

    # If no divisors were found, n is prime
    return True

n = 11
print(is_prime(n))

````

C#

````
using System;

class GfG {
    // Function to check whether a number is prime or not
    static bool IsPrime(int n) {

        // Numbers less than or equal to 1 are not prime
        if (n <= 1)
            return false;

        // Check divisibility from 2 to the square root of n
        for (int i = 2; i <= Math.Sqrt(n); i++)
            if (n % i == 0)
                return false;

        // If no divisors were found, n is prime
        return true;
    }

    static void Main(string[] args) {
        int n = 11;
        Console.WriteLine(IsPrime(n));
    }
}

````

Javascript

````
// Function to check whether a number is prime or not
function isPrime(n) {

    // Numbers less than or equal to 1 are not prime
    if (n <= 1)
        return false;

    // Check divisibility from 2 to the square root of n
    for (let i = 2; i <= Math.sqrt(n); i++)
        if (n % i === 0)
            return false;

    // If no divisors were found, n is prime
    return true;
}

let n = 11;
console.log(isPrime(n));

````




**Output**
```
1
```

****Time Complexity:****
O(sqrt(n))



****Auxiliary Space:****
O(1)


### [Expected Approach – 2] Optimized Trial Division Method – O(√n) time and O(1) space

> We know that any integer number can be written in the form of
>
> ****6k+i,****
> where
>
> ****k****
> is a nonnegative integer (like 0, 1, 2, 3,…) and
>
> ****i****
> is a number between 0 and 5 (so i can be 0, 1, 2, 3, 4, or 5). If we look closely, we’ll notice that when
>
> ****i****
> is 0, 2, 3, or 4, the numbers
>
> ****6k, 6k+2, 6k+3,****
> and
>
> ****6k+4****
> are all divisible by either 2 or 3. But prime numbers greater than
>
> ****3****
> can’t be divisible by
>
> ****2****
> or
>
> ****3****
> . Therefore, the only forms left that a prime number can have are
>
> ****6k+1****
> or
>
> ****6k+5****
> (since these forms are not divisible by 2 or 3).
>
>
> Instead of checking every number up to the √n to see if it divides
>
> ****n****
> , we only check numbers of the form
>
> ****6k+1****
> and
>
> ****6k+5.****
> This reduces the number of checks needed.


Step-by-step approach:


* Check if

  ****n == 1****
  or

  ****n == 0****
  then return

  ****false****
  .
* Check if

  ****n****
  is

  ****2****
  or

  ****3****
  and return

  ****true****
  .
* Check if

  ****n****
  is divisible by

  ****2****
  or

  ****3****
  and return

  ****false****
  .
* Loop from

  ****5****
  to

  ****√n****
  ​, incrementing by

  ****6****
  .
  + Checks if

    ****n****
    is divisible by

    ****i****
    (which corresponds to

    ****6k+1****
    ) or by

    ****i+2****
    (which corresponds to

    ****6k+5****
    ).
* If no divisors are found, return

  ****true****
  .


Below is the implementation of the above approach:


C++

````
#include <iostream>
#include <cmath>
using namespace std;

// Function to check whether a number is prime or not
bool isPrime(int n) {
    // Check if n is 1 or 0
    if (n <= 1)
        return false;

    // Check if n is 2 or 3
    if (n == 2 || n == 3)
        return true;

    // Check whether n is divisible by 2 or 3
    if (n % 2 == 0 || n % 3 == 0)
        return false;

    // Check from 5 to square root of n
    // Iterate i by (i+6)
    for (int i = 5; i <= sqrt(n); i = i + 6)
        if (n % i == 0 || n % (i + 2) == 0)
            return false;

    return true;
}

int main() {
    int n = 11;
    cout << isPrime(n);
    return 0;
}

````

C

````
#include <stdio.h>
#include <stdbool.h>
#include <math.h>

// Function to check whether a number is prime or not
bool isPrime(int n) {
    // Check if n is 1 or 0
    if (n <= 1)
        return false;

    // Check if n is 2 or 3
    if (n == 2 || n == 3)
        return true;

    // Check whether n is divisible by 2 or 3
    if (n % 2 == 0 || n % 3 == 0)
        return false;

    // Check from 5 to square root of n
    // Iterate i by (i+6)
    for (int i = 5; i <= sqrt(n); i = i + 6)
        if (n % i == 0 || n % (i + 2) == 0)
            return false;

    return true;
}

int main() {
    int n = 11;
    printf("%d", isPrime(n));
    return 0;
}

````

Java

````
class GfG {

    // Function to check whether a number is prime or not
    static boolean isPrime(int n) {
        // Check if n is 1 or 0
        if (n <= 1)
            return false;

        // Check if n is 2 or 3
        if (n == 2 || n == 3)
            return true;

        // Check whether n is divisible by 2 or 3
        if (n % 2 == 0 || n % 3 == 0)
            return false;

        // Check from 5 to square root of n
        // Iterate i by (i+6)
        for (int i = 5; i <= Math.sqrt(n); i = i + 6)
            if (n % i == 0 || n % (i + 2) == 0)
                return false;

        return true;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(isPrime(n));
    }
}

````

Python

````
import math

# Function to check whether a number is prime or not
def is_prime(n):
    # Check if n is 1 or 0
    if n <= 1:
        return False

    # Check if n is 2 or 3
    if n == 2 or n == 3:
        return True

    # Check whether n is divisible by 2 or 3
    if n % 2 == 0 or n % 3 == 0:
        return False

    # Check from 5 to square root of n
    # Iterate i by (i+6)
    i = 5
    while i <= math.sqrt(n):
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6

    return True

n = 11
print(is_prime(n))

````

C#

````
using System;

class Program {
    // Function to check whether a number is prime or not
    static bool IsPrime(int n) {
        // Check if n is 1 or 0
        if (n <= 1)
            return false;

        // Check if n is 2 or 3
        if (n == 2 || n == 3)
            return true;

        // Check whether n is divisible by 2 or 3
        if (n % 2 == 0 || n % 3 == 0)
            return false;

        // Check from 5 to square root of n
        // Iterate i by (i+6)
        for (int i = 5; i <= Math.Sqrt(n); i += 6)
            if (n % i == 0 || n % (i + 2) == 0)
                return false;

        return true;
    }

    static void Main(string[] args) {
        int n = 11;
        Console.WriteLine(IsPrime(n));
    }
}

````

Javascript

````
// Function to check whether a number is prime or not
function isPrime(n) {
    // Check if n is 1 or 0
    if (n <= 1)
        return false;

    // Check if n is 2 or 3
    if (n === 2 || n === 3)
        return true;

    // Check whether n is divisible by 2 or 3
    if (n % 2 === 0 || n % 3 === 0)
        return false;

    // Check from 5 to square root of n
    // Iterate i by (i+6)
    for (let i = 5; i <= Math.sqrt(n); i += 6)
        if (n % i === 0 || n % (i + 2) === 0)
            return false;

    return true;
}

let n = 11;
console.log(isPrime(n));

````




**Output**
```
1
```

****Time Complexity:****
O(sqrt(n))



****Auxiliary Space:****
O(1)


****Primality Testing Methods****
---------------------------------

* [Primality Test | Set 1 (Introduction and School Method)](https://www.geeksforgeeks.org/primality-test-set-1-introduction-and-school-method/)
* [Primality Test | Set 2 (Fermat Method)](https://www.geeksforgeeks.org/primality-test-set-2-fermet-method/)
* [Primality Test | Set 3 (Miller–Rabin)](https://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/)
* [Primality Test | Set 4 (Solovay-Strassen)](https://www.geeksforgeeks.org/primality-test-set-4-solovay-strassen/)
* [Lucas Primality Test](https://www.geeksforgeeks.org/lucas-primality-test/)

Sieve Algorithms for Prime Number Generation
--------------------------------------------

* [Sieve of Eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)
* [Sieve of Eratosthenes in O(n) time complexity](https://www.geeksforgeeks.org/sieve-eratosthenes-0n-time-complexity/)
* [Segmented Sieve](https://www.geeksforgeeks.org/segmented-sieve/)
* [Sieve of Sundaram](https://www.geeksforgeeks.org/sieve-sundaram-print-primes-smaller-n/)
* [Bitwise Sieve](https://www.geeksforgeeks.org/bitwise-sieve/)


For more related article on Sieve algorithms , please refer to

[Recent Articles on Sieve](https://www.geeksforgeeks.org/tag/sieve/)


****Prime Number Algorithms and Related Problems****
----------------------------------------------------

* [Find two distinct prime numbers with](https://www.geeksforgeeks.org/find-two-distinct-prime-numbers-with-given-product/)
  a

  [given product](https://www.geeksforgeeks.org/find-two-distinct-prime-numbers-with-given-product/)
* [Print all prime numbers less than or equal to N](https://www.geeksforgeeks.org/print-all-prime-numbers-less-than-or-equal-to-n/)
* [Recursive program for prime number](https://www.geeksforgeeks.org/recursive-program-prime-number/)
* [Find two prime numbers with](https://www.geeksforgeeks.org/find-two-prime-numbers-with-given-sum/)
  a

  [given sum](https://www.geeksforgeeks.org/find-two-prime-numbers-with-given-sum/)
* [Find the highest occurring digit in prime numbers in a range](https://www.geeksforgeeks.org/find-highest-occurring-digit-prime-numbers-range/)
* [Prime Factorization using Sieve O(log n) for multiple queries](https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/)
* [Program to print all prime factors of a given number](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)
* [Least prime factor of numbers till n](https://www.geeksforgeeks.org/least-prime-factor-of-numbers-till-n/)
* [Prime factors of LCM of array elements](https://www.geeksforgeeks.org/prime-factors-lcm-array-elements/)
* [Program for Goldbach’s Conjecture](https://www.geeksforgeeks.org/program-for-goldbachs-conjecture-two-primes-with-given-sum/)
* [Prime numbers and Fibonacci](https://www.geeksforgeeks.org/prime-numbers-fibonacci/)
* [Composite Number](https://www.geeksforgeeks.org/composite-number/)


For more related problems on prime number, please refer to


[Recent Articles on Prime Numbers](https://www.geeksforgeeks.org/tag/prime-number/)

  ', '', 'Check for Prime Number', 11, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('e463ed6b-9b9c-4b7f-aaa9-d9607492b53e', e'Given a number

****n****
, find the sum of its digits.


****Examples :****

> ****Input:****
> n = 687
>
>
>
> ****Output:****
> 21
>
>
>
> ****Explanation:****
> **The sum of its digits are: 6 + 8 + 7 = 21**
>
> ****Input:****
> n = 12
>
>
>
> ****Output:****
> 3
>
>
>
> ****Explanation:****
> **The sum of its digits are: 1 + 2 = 3**

Table of Content

* [[Expected Approach] Sum of the digits of a given number using recursion](#expected-approach-sum-of-the-digits-of-a-given-number-using-recursion)
* [[Alternate Approach] Sum of the digits of a given number using tail recursion](#alternate-approach-sum-of-the-digits-of-a-given-number-using-tail-recursion)
* [[Alternate Approach] Converting Number to String](#sum-of-the-digits-of-a-given-number-with-input-as-string)
### ****[Expected Approach] Sum of the digits using recursion****

> **The idea is to count the digits by removing the digits from the input number starting from**
> ****right(least significant digit)****
> **to**
> ****left(most significant digit)****
> **till the number is reduced to 0 because the rightmost digit can be removed simply by performing**
> ****integer division by 10****
> **. For eg: n = 1567, then 1567 / 10 = 156.7 = 156(Integer Division).**

C++

````
#include <iostream>
using namespace std;

int sumDigits(int no) {
    if (no == 0) {
        return 0;
    }

    return (no % 10) + sumDigits(no / 10);
}

int main(void) {
    cout << sumDigits(687);
    return 0;
}

````

C

````
#include <stdio.h>

int sumDigits(int no) {
    if (no == 0) {
        return 0;
    }

    return (no % 10) + sumDigits(no / 10);
}

int main() {
    printf("%d", sumDigits(687));
    return 0;
}

````

Java

````
import java.io.*;

class GfG {
    static int sumDigits(int no) {
        if (no == 0) {
            return 0;
        }

        return (no % 10) + sumDigits(no / 10);
    }

    public static void main(String[] args) {
        System.out.println(sumDigits(687));
    }
}

````

Python

````
def sumDigits(no):

    return 0 if no == 0 else int(no % 10) + sumDigits(int(no/10))

if __name__ == "__main__":

    print(sumDigits(687))

````

C#

````
using System;

 class GfG {

    static int sumDigits(int n) {
        return n == 0 ? 0 : n % 10 + sumDigits(n / 10);
    }

  static void  Main() {
        Console.Write(sumDigits(687));
    }
}

````

JavaScript

````

  function sumDigits(no) {
       if(no == 0){
         return 0 ;
       }

      return (no % 10) + sumDigits(parseInt(no/10)) ;
  }

// Driver code
      console.log(sumDigits(687));


````




**Output**
```
21
```

****Time Complexity:****
O(log n)



****Auxiliary Space:****
O(log n)


### ****[Alternate Approach] Using tail recursion****

> This approach ensures that the recursive call is the last operation, allowing for better memory efficiency and preventing stack overflow.

C++

````
// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;

int sumOfDigit(int n, int val) {
    if (n < 10) {
        val = val + n;
        return val;
    }
    return sumOfDigit(n / 10, (n % 10) + val);
}

int main() {
    int num = 12345;

    int result = sumOfDigit(num, 0);
    cout <<  result;
    return 0;
}

````

C

````
// C program for the above approach
#include <stdio.h>

int sumOfDigit(int n, int val)
{
    if (n < 10) {
        val = val + n;
        return val;
    }
    return sumOfDigit(n / 10, (n % 10) + val);
}

int main() {
    int num = 12345;
    int result = sumOfDigit(num, 0);
    printf("%d", result);
    return 0;
}

````

Java

````
// Java program for the above approach
import java.io.*;
import java.lang.*;
import java.util.*;

class GfG {

    static int sumOfDigit(int n, int val)  {
        if (n < 10) {
            val = val + n;
            return val;
        }
        return sumOfDigit(n / 10, (n % 10) + val);
    }

    public static void main(String args[]) {
        int num = 12345;
        int result = sumOfDigit(num, 0);
        System.out.println( result);
    }
}

````

Python

````
# Python3 program for the above approach

def sumOfDigit(n, val):

    if (n < 10):
        val = val + n
        return val

    return sumOfDigit(n // 10, (n % 10) + val)


if __name__ == "__main__":
    num = 12345

    result = sumOfDigit(num, 0)

    print(result)

````

C#

````
// C# program for the above approach
using System;

class GfG {

    static int sumOfDigit(int n, int val) {
        if (n < 10) {
            val = val + n;
            return val;
        }
        return sumOfDigit(n / 10, (n % 10) + val);
    }

    public static void Main() {
        int num = 12345;

        int result = sumOfDigit(num, 0);
        Console.Write( result);
    }
}

````

JavaScript

````
// Javascript program for the above approach

function sumOfDigit(n, val)
{
    if (n < 10)
    {
        val = val + n;
        return val;
    }
    return sumOfDigit(parseInt(n / 10),
    (n % 10) + val);
}

// Driver code
    let num = 12345;
    let result = sumOfDigit(num, 0);

    console.log( result);

````




**Output**
```
15
```

****Time Complexity:****
O(log n)



****Auxiliary Space:****
O(log n)


### ****[Alternate Approach]**** Converting Number to String

> When the number of digits of that number exceeds 10
>
> 19
> , we can’t take that number as an integer since the range of long long int doesn’t satisfy the given number. So take input as a string, run a loop from start to the length of the string and increase the sum with that character(in this case it is numeric)

C++14

````
// C++ implementation of the above approach
#include <bits/stdc++.h>
using namespace std;

int getSum(string s) {
    int sum = 0;

    // Traversing through the string
    for (int i = 0; i < s.length(); i++) {
        // Since ascii value of  numbers starts
        // from 48 so we subtract it from sum
        sum = sum + s[i] - 48;
    }
    return sum;
}

int main() {
    string s = "123456789123456789123422";

    cout << getSum(s);
    return 0;
}

````

Java

````
// Java implementation of the above approach
import java.io.*;
class GfG {

    static int getSum(String s) {
        int sum = 0;

        for (int i = 0; i < s.length(); i++) {

            // Since ascii value of numbers starts
            //  from 48 so we subtract it from sum
            sum = sum + s.charAt(i) - 48;
        }
        return sum;
    }

    public static void main(String[] args)  {
        String s = "123456789123456789123422";

        System.out.print(getSum(s));
    }
}

````

Python

````
# Python3 implementation of the above approach
def getSum(n):
    sum = 0

    # Traversing through string
    for i in n:

        # Converting char to int
        sum = sum + int(i)

    return sum

if __name__ == "__main__":
    n = "123456789123456789123422"

    print(getSum(n))

````

C#

````
// C# implementation of the above approach
using System;
class GfG {
    static int getSum(String s) {
        int sum = 0;

        for (int i = 0; i < s.Length; i++) {

            // Since ascii value of numbers starts
            //  from 48 so we subtract it from sum
            sum = sum + s[i] - 48;
        }
        return sum;
    }

    static public void Main()  {
        String st = "123456789123456789123422";
        Console.Write(getSum(st));
    }
}

````

JavaScript

````
// Javascript implementation of the above approach

function getSum(s)
{
    let sum = 0;

    // Traversing through the string
    for (let i = 0; i < s.length; i++)
    {

        // Since ascii value of  numbers starts from
        //48 so we subtract it from sum
        sum = sum + parseInt(s[i]);
    }
    return sum;
}

// Driver Code
let st = "123456789123456789123422";
console.log(getSum(st));

````




**Output**
```
104
```

****Time Complexity:****
O(n)



****Auxiliary Space:****
O(1)

', '', 'Program for Sum of the digits of a given number', 12, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('ec26f50a-f134-4978-b817-3084496c9feb', e'Table of Content

* [Applications of Array Data Structure:](#applications-of-array-data-structure)
* [Advantages of Array Data Structure:](#advantages-of-array-data-structure)
* [Disadvantages of Array Data Structure:](#disadvantages-of-array-data-structure)
### ****Applications of Array Data Structure:****

Arrays mainly have advantages like random access and cache friendliness
over other data structures that make them useful.

Below are some applications of arrays.

* ****Storing and accessing data****: Arrays store elements in a specific order and allow constant-time
  O(1) access to any element.
* ****Searching****: If data in array is sorted, we can search an item in O(log n) time.
  We can also find floor(), ceiling(), kth smallest, kth largest, etc
  efficiently.
* ****Matrices****: Two-dimensional arrays are used for matrices in computations like
  graph algorithms and image processing.
* ****Implementing other data structures:****
  Arrays are used as the underlying data structure for implementing
  stacks and queues.
* ****Dynamic programming****: Dynamic programming algorithms often use arrays to store
  intermediate results of subproblems in order to solve a larger
  problem.
* ****Data Buffers:****
  Arrays serve as data buffers and queues, temporarily storing incoming
  data like network packets, file streams, and database results before
  processing.

### ****Advantages of Array Data Structure:****

* ****Efficient and Fast Access:****
  Arrays allow direct and efficient access to any element in the
  collection with constant access time, as the data is stored in
  contiguous memory locations.
* ****Memory Efficiency:****
  Arrays store elements in contiguous memory, allowing efficient
  allocation in a single block and reducing memory fragmentation.
* ****Versatility:****
  Arrays can be used to store a wide range of data types, including
  integers, floating-point numbers, characters, and even complex data
  structures such as objects and pointers.
* ****Compatibility with hardware:**** The array data structure is compatible with most hardware
  architectures, making it a versatile tool for programming in a wide
  range of environments.

### ****Disadvantages of Array Data Structure:****

* ****Fixed Size:****
  Arrays have a fixed size set at creation. Expanding an array requires
  creating a new one and copying elements, which is time-consuming and
  memory-intensive.
* ****Memory Allocation Issues:****
  Allocating large arrays can cause memory exhaustion, leading to
  crashes, especially on systems with limited resources.
* ****Insertion and Deletion Challenges:****
  Adding or removing elements requires shifting subsequent elements,
  making these operations inefficient.
* ****Limited Data Type Support:****
  Arrays support only elements of the same type, limiting their use with
  complex data types.
* ****Lack of Flexibility:****
  Fixed size and limited type support make arrays less adaptable than
  structures like linked lists or trees.', e'Array is a linear data structure that is a collection of data elements of same
types. Arrays are stored in contiguous memory locations. It is a static
data structure with a fixed size.', 'Applications, Advantages and Disadvantages of Array', 2, '73c532f9-4d55-4737-ae19-3006e02864cc', 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('96fc2a66-d810-48cb-9c86-1f28415e1e5b', e'
Given the radius of a circle, find the area of that circle.


![Area-of-circle](https://media.geeksforgeeks.org/wp-content/cdn-uploads/Area-of-circle-300x283.png)
> The area of a circle can simply be evaluated using the following formula.
>
>
> [Tex]Area = \\pi r^2[/Tex]
>
>
> where r is radius of circle and it maybe in float because value of pie is 3.14

****Approach****
: Using the given radius, find the area using the above formula: (pi \\* r \\* r) and print the result in float.





C++

````
// C++ program to find area
// of circle
#include <iostream>
const double pi = 3.14159265358979323846;
using namespace std;

// function to calculate the area of circle
float findArea(float r)
{
    return (pi * r * r);
}
// driver code
int main()
{
    float r, Area;
    r = 5;

    // function calling
    Area = findArea(r);
    // displaying the area
    cout << "Area of Circle is :" << Area;
    return 0;
}

````

C

````
// C program to find area
// of circle
#include <stdio.h>
#include <math.h>
#define PI 3.142

double findArea(int r)
{
   return PI * pow(r, 2);
}

int main()
{
    printf("Area is %f", findArea(5));
    return 0;
}

````

Java

````
// Java program to find area
// of circle

class Test
{
    static final double PI = Math.PI;

    static double findArea(int r)
    {
       return PI * Math.pow(r, 2);
    }

    // Driver method
    public static void main(String[] args)
    {
        System.out.println("Area is " +  findArea(5));
    }
}

````

Python

````
# Python3 program to find Area of a circle

def findArea(r):
    PI = 3.142
    return PI * (r*r);

# Driver method
print("Area is %.6f" % findArea(5));

# This code is contributed by Chinmoy Lenka

````

C#

````
// C# program to find area of circle
using System;

class GFG
{
    static double PI = Math.PI;

    static double findArea(int r)
    {
    return PI * Math.Pow(r, 2);
    }

    // Driver method
    static void Main()
    {
        Console.Write("Area is " + findArea(5));
    }
}

// This code is contributed by Sam007.

````

JavaScript

````
<script>

// Javascript program to find area
// of circle

let pi = 3.14159265358979323846;

// function to calculate the area of circle
function findArea(r)
{
    return (pi * r * r);
}

// Driver code
    let r, Area;
    r = 5;

    // function calling
    Area = findArea(r);

    // displaying the area
    document.write("Area of Circle is :" + Area);

// This code is contributed by Mayank Tyagi

</script>

````

PHP

````
<?php
// PHP program to find area
// of circle

function findArea( $r)
{
    $PI =3.142;
    return $PI * pow($r, 2);
}

// Driver Code
echo("Area is ");
echo(findArea(5));
return 0;

// This code is contributed by vt_m.
?>

````




**Output**
```
Area of Circle is :78.5398
```

****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1), since no extra space has been taken.
', '', 'Program to find area of a circle', 13, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('1b6d1c4b-b27f-48f6-a074-6891bfbd3ab6', e'Given Principal

****p****
, Rate

****r****
and Time

****t,****
the task is to calculate Simple Interest.


****Examples :****

> ****Input****
> : p = 10000, r = 5, t = 5
>
>
>
> ****Output****
> :2500
>
>
>
> ****Explanation****
> : We need to find simple interest on Rs. 10,000 at the rate of 5% for 5 units of time.
>
>
> ****Input****
> : p = 3000, r = 7, t = 1
>
>
>
> ****Output****
> :210


The basic idea is to calculate by applying the formula

****SI = (p x t x r)/100****

C++

````
// CPP program to find simple interest for
// given principal amount, time and rate of interest
#include<iostream>
using namespace std;

float simpleInterest(float p, float t, float r){
    /* Calculate simple interest  */
    float ans = (p * t * r) / 100;
    return ans;
}

int main() {

    float p = 1, r = 1, t = 1;
    cout <<simpleInterest(p,r,t);

    return 0;
}

````

C

````
#include <stdio.h>

float simpleInterest(float p, float t, float r) {
    /* Calculate simple interest  */
    float ans = (p * t * r) / 100;
    return ans;
}

int main() {
    float p = 1, r = 1, t = 1;
    printf("%f", simpleInterest(p, r, t));
    return 0;
}

````

Java

````
class GfG {
    static float simpleInterest(float p, float t, float r) {
        /* Calculate simple interest  */
        return (p * t * r) / 100;
    }

    public static void main(String[] args) {
        float p = 1, r = 1, t = 1;
        System.out.println(simpleInterest(p, r, t));
    }
}

````

Python

````
def simpleInterest(p, t, r):
    /* Calculate simple interest  */
    return (p * t * r) / 100

if __name__ == "__main__":
  p = 1
  r = 1
  t = 1
  print(simpleInterest(p, r, t))

````

C#

````
using System;

class GfG {
    public static float SimpleInterest(float p, float t, float r) {
        /* Calculate simple interest  */
        return (p * t * r) / 100;
    }

    static void Main() {
        float p = 1, r = 1, t = 1;
        Console.WriteLine(SimpleInterest(p, r, t));
    }
}

````

JavaScript

````
function simpleInterest(p, t, r) {
    /* Calculate simple interest  */
    return (p * t * r) / 100;
}

//driver code
let p = 1, r = 1, t = 1;
console.log(simpleInterest(p, r, t));

````




**Output**
```
0.01
```

****Time complexity****
: O(1)



****Auxiliary Space****
: O(1)
', '', 'Program to find simple interest', 14, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('1c9888f0-5d92-4cf6-b41a-deff87b117b1', e'
Table of Content

* [Operations on Circular Queue](#operations-on-circular-queue)
* [Implement Circular Queue using Array](#implement-circular-queue-using-array)
* [Complexity Analysis of Circular Queue Operations](#complexity-analysis-of-circular-queue-operations)
### Operations on Circular Queue

* ****getFront:****
  Get the front item from the queue.
* ****getRear:****
  Get the last item from the queue.
* ****enqueue(value):****
  To

  ****insert****
  an element into the circular queue. In a circular queue, the new element is always inserted at the rear position.
* ****dequeue()****
  : To

  ****delete****
  an element from the circular queue. In a circular queue, the element is always deleted from the front position.

### Implement Circular Queue using Array

1. Initialize an

   ****array****
   of

   ****size n****
   , where

   ****n is the maximum number of element****
   s that the queue can hold.
2. Initialize

   ****three variables (size, capacity, and front.)****
3. ****Enqueue:****
   To enqueue an

   ****element x****
   into the queue, do the following:
   1. Check if

      ****size == capacity****
      (queue is full), display

      ****“Queue is full”.****
   2. If not full: calculate

      ****rear = (front + size) % capacity****
      and

      ****Insert****
      value at the rear index.

      ****Increment****
      size by 1.
4. ****Dequeue:****
   To dequeue an element from the queue, do the following:
   1. Check if

      ****size == 0 (****
      queue is empty), display

      ****“Queue is empty”.****
   2. If not empty:

      ****retrieve****
      the element at the

      ****front index****
      and

      ****move front = (front + 1) % capacity****
      . Also,

      ****decrement****
      size by 1 and

      ****return the removed element.****

****Illustration of Circular Queue****
:









****Below is the implementation of above approach:****

C++

````
// C++ program for insertion and
// deletion in Circular Queue
#include <iostream>
using namespace std;

class MyQueue {
private:
    int *arr;
    int front, size;
    int capacity;

public:

    // Constructor to initialize the queue
    MyQueue(int c) {
        arr = new int[c];
        capacity = c;
        size = 0;
        front = 0;
    }

    // Get the front element
    int getFront() {

        // Queue is empty
        if (size == 0)
            return -1;
        return arr[front];
    }

    // Get the rear element
    int getRear() {

        // Queue is empty
        if (size == 0)
            return -1;
        int rear = (front + size - 1) % capacity;
        return arr[rear];
    }

    // Insert an element at the rear
    void enqueue(int x) {

        // Queue is full
        if (size == capacity)
            return;
        int rear = (front + size) % capacity;
        arr[rear] = x;
        size++;
    }

    // Remove an element from the front
    int dequeue() {

        // Queue is empty
        if (size == 0)
            return -1;
        int res = arr[front];
        front = (front + 1) % capacity;
        size--;
        return res;
    }
};

int main() {
    MyQueue q(4);
    q.enqueue(10);
    cout << q.getFront() << " " << q.getRear() << endl;
    q.enqueue(20);
    cout << q.getFront() << " " << q.getRear() << endl;
    q.enqueue(30);
    cout << q.getFront() << " " << q.getRear() << endl;
    q.enqueue(40);
    cout << q.getFront() << " " << q.getRear() << endl;
    q.dequeue();
    cout << q.getFront() << " " << q.getRear() << endl;
    q.dequeue();
    cout << q.getFront() << " " << q.getRear() << endl;
    q.enqueue(50);
    cout << q.getFront() << " " << q.getRear() << endl;
    return 0;
}

````

Java

````
// Java program for insertion and
// deletion in Circular Queue
class MyQueue {
    private int[] arr;
    private int front;
    private int size;
    private int capacity;

    // Constructor to initialize the queue
    public MyQueue(int c) {
        arr = new int[c];
        capacity = c;
        size = 0;
        front = 0;
    }

    // Get the front element
    public int getFront() {

        // Queue is empty
        if (size == 0)
            return -1;
        return arr[front];
    }

    // Get the rear element
    public int getRear() {

        // Queue is empty
        if (size == 0)
            return -1;
        int rear = (front + size - 1) % capacity;
        return arr[rear];
    }

    // Insert an element at the rear
    public void enqueue(int x) {

        // Queue is full
        if (size == capacity)
            return;
        int rear = (front + size) % capacity;
        arr[rear] = x;
        size++;
    }

    // Remove an element from the front
    public int dequeue() {

        // Queue is empty
        if (size == 0)
            return -1;
        int res = arr[front];
        front = (front + 1) % capacity;
        size--;
        return res;
    }
}

class GfG {

    public static void main(String[] args) {
        MyQueue q = new MyQueue(4);
        q.enqueue(10);
        System.out.println(q.getFront() + " " + q.getRear());
        q.enqueue(20);
        System.out.println(q.getFront() + " " + q.getRear());
        q.enqueue(30);
        System.out.println(q.getFront() + " " + q.getRear());
        q.enqueue(40);
        System.out.println(q.getFront() + " " + q.getRear());
        q.dequeue();
        System.out.println(q.getFront() + " " + q.getRear());
        q.dequeue();
        System.out.println(q.getFront() + " " + q.getRear());
        q.enqueue(50);
        System.out.println(q.getFront() + " " + q.getRear());
    }
}

````

Python

````
# python3 program for insertion and
# deletion in Circular Queue
class MyQueue:
    def __init__(self, c):
        self.l = [None] * c
        self.cap = c
        self.size = 0
        self.front = 0

    def getFront(self):

        # Check if queue is empty
        if self.size == 0:
            return None
        return self.l[self.front]

    def getRear(self):

        # Check if queue is empty
        if self.size == 0:
            return None

        # Calculate rear index
        rear = (self.front + self.size - 1) % self.cap
        return self.l[rear]

    def enqueue(self, x):

        # Check if queue is full
        if self.size == self.cap:
            return

        # Calculate rear index
        rear = (self.front + self.size) % self.cap
        self.l[rear] = x
        self.size += 1

    def dequeue(self):

        # Check if queue is empty
        if self.size == 0:
            return None
        res = self.l[self.front]

        # Move front index circularly
        self.front = (self.front + 1) % self.cap
        self.size -= 1
        return res

q = MyQueue(4)
q.enqueue(10)
print(q.getFront(), q.getRear())
q.enqueue(20)
print(q.getFront(), q.getRear())
q.enqueue(30)
print(q.getFront(), q.getRear())
q.enqueue(40)
print(q.getFront(), q.getRear())
q.dequeue()
print(q.getFront(), q.getRear())
q.dequeue()
print(q.getFront(), q.getRear())
q.enqueue(50)
print(q.getFront(), q.getRear())

````

C#

````
// C# program for insertion and
// deletion in Circular Queue
using System;

class MyQueue {
    private int[] arr;
    private int front;
    private int size;
    private int capacity;

    // Constructor to initialize the queue
    public MyQueue(int c) {
        arr = new int[c];
        capacity = c;
        size = 0;
        front = 0;
    }

    // Get the front element
    public int getFront() {

        // Queue is empty
        if (size == 0)
          return -1;
        return arr[front];
    }

    // Get the rear element
    public int getRear() {

        // Queue is empty
        if (size == 0)
          return -1;
        int rear = (front + size - 1) % capacity;
        return arr[rear];
    }

    // Insert an element at the rear
    public void enqueue(int x) {

        // Queue is full
        if (size == capacity) return;
        int rear = (front + size) % capacity;
        arr[rear] = x;
        size++;
    }

    // Remove an element from the front
    public int dequeue() {

        // Queue is empty
        if (size == 0) return -1;
        int res = arr[front];
        front = (front + 1) % capacity;
        size--;
        return res;
    }
}
class GfG {

        static void Main(string[] args) {
        MyQueue q = new MyQueue(4);
        q.enqueue(10);
        Console.WriteLine(q.getFront() + " " + q.getRear());
        q.enqueue(20);
        Console.WriteLine(q.getFront() + " " + q.getRear());
        q.enqueue(30);
        Console.WriteLine(q.getFront() + " " + q.getRear());
        q.enqueue(40);
        Console.WriteLine(q.getFront() + " " + q.getRear());
        q.dequeue();
        Console.WriteLine(q.getFront() + " " + q.getRear());
        q.dequeue();
        Console.WriteLine(q.getFront() + " " + q.getRear());
        q.enqueue(50);
        Console.WriteLine(q.getFront() + " " + q.getRear());
    }
}

````

JavaScript

````
// JS program for insertion and
// deletion in Circular Queue
class MyQueue {
    constructor(c) {
        this.arr = new Array(c).fill(null);
        this.capacity = c;
        this.size = 0;
        this.front = 0;
    }

    // Get the front element
    getFront() {

        // Queue is empty
        if (this.size === 0) return null;
        return this.arr[this.front];
    }

    // Get the rear element
    getRear() {

        // Queue is empty
        if (this.size === 0) return null;
        let rear = (this.front + this.size - 1) % this.capacity;
        return this.arr[rear];
    }

    // Insert an element at the rear
    enqueue(x) {

        // Queue is full
        if (this.size === this.capacity) return;
        let rear = (this.front + this.size) % this.capacity;
        this.arr[rear] = x;
        this.size++;
    }

    // Remove an element from the front
    dequeue() {

        // Queue is empty
        if (this.size === 0) return null;
        let res = this.arr[this.front];
        this.front = (this.front + 1) % this.capacity;
        this.size--;
        return res;
    }
}

const q = new MyQueue(4);
q.enqueue(10);
console.log(q.getFront(), q.getRear());
q.enqueue(20);
console.log(q.getFront(), q.getRear());
q.enqueue(30);
console.log(q.getFront(), q.getRear());
q.enqueue(40);
console.log(q.getFront(), q.getRear());
q.dequeue();
console.log(q.getFront(), q.getRear());
q.dequeue();
console.log(q.getFront(), q.getRear());
q.enqueue(50);
console.log(q.getFront(), q.getRear());

````




**Output**
```
10 10
10 20
10 30
10 40
20 40
30 40
30 50

```
### Complexity Analysis of Circular Queue Operations

****Time Complexity:****

****Auxiliary Space:****
O(size), where

****size****
is the number of elements in the circular queue.
', e'A Circular Queue is another way of implementing a normal queue
where the last element of the queue is connected
to the first element of the queue forming a circle.', 'Introduction to Circular Queue', 9, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('39944df7-8db0-4d3d-a12d-e09eebfacaaa', e'****Stack Operations:****
-------------------------

* [****push()****](https://www.geeksforgeeks.org/stack-push-and-pop-in-c-stl/)****:****
  Insert a new element into the stack i.e just insert a new element at
  the beginning of the linked list.
* [****pop()****](https://www.geeksforgeeks.org/stack-push-and-pop-in-c-stl/)****:****
  Return the top element of the Stack i.e simply delete the first
  element from the linked list.
* [****peek()****](https://www.geeksforgeeks.org/stack-peek-method-in-java/)****:**** Return the top element.
* ****display():**** Print all elements in Stack.

Push Operation:
---------------

> * Initialise a node
> * Update the value of that node by data i.e. ****node->data = data****
> * Now link this node to the top of the linked list
> * And update top pointer to the current node

Pop Operation:
--------------

> * First Check whether there is any node present in the linked list or
>   not, if not then return
> * Otherwise make pointer let say ****temp**** to the top node and move forward the top node by 1 step
> * Now free this temp node

Peek Operation:
---------------

> * Check if there is any node present or not, if not then
>   return.
> * Otherwise return the value of top node of the linked list

Display Operation:
------------------

> * Take a ****temp**** node and initialize it with top pointer
> * Now start traversing temp till it encounters NULL
> * Simultaneously print the value of the temp node



Below is the implementation of the above operations

C++
````
// C++ program to implement a stack using singly linked list
#include <bits/stdc++.h>
using namespace std;

// Class representing a node in the linked list
class Node {
public:
    int data;
    Node* next;
    Node(int new_data) {
        this->data = new_data;
        this->next = nullptr;
    }
};

// Class to implement stack using a singly linked list
class Stack {

    // head of the linked list
    Node* head;

public:
    // Constructor to initialize the stack
    Stack() { this->head = nullptr; }

    // Function to check if the stack is empty
    bool isEmpty() {

        // If head is nullptr, the stack is empty
        return head == nullptr;
    }

    // Function to push an element onto the stack
    void push(int new_data) {

        // Create a new node with given data
        Node* new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (!new_node) {
            cout << "\\nStack Overflow";
        }

        // Link the new node to the current top node
        new_node->next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    void pop() {

        // Check for stack underflow
        if (this->isEmpty()) {
            cout << "\\nStack Underflow" << endl;
        }
        else {
            // Assign the current top to a temporary
            // variable
            Node* temp = head;

            // Update the top to the next node
            head = head->next;

            // Deallocate the memory of the old top node
            delete temp;
        }
    }

    // Function to return the top element of the stack
    int peek() {

        // If stack is not empty, return the top element
        if (!isEmpty())
            return head->data;
        else {
            cout << "\\nStack is empty";
            return INT_MIN;
        }
    }
};

// Driver program to test the stack implementation
int main() {
    // Creating a stack
    Stack st;

    // Push elements onto the stack
    st.push(11);
    st.push(22);
    st.push(33);
    st.push(44);

    // Print top element of the stack
    cout << "Top element is " << st.peek() << endl;

    // removing two elemements from the top
      cout << "Removing two elements..." << endl;
    st.pop();
    st.pop();

    // Print top element of the stack
    cout << "Top element is " << st.peek() << endl;

    return 0;
}

````

C
````
// C program to implement a stack using singly linked list
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

// Struct representing a node in the linked list
typedef struct Node {
    int data;
    struct Node* next;
} Node;
Node* createNode(int new_data) {
    Node* new_node = (Node*)malloc(sizeof(Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Struct to implement stack using a singly linked list
typedef struct Stack {
    Node* head;
} Stack;

// Constructor to initialize the stack
void initializeStack(Stack* stack) { stack->head = NULL; }

// Function to check if the stack is empty
int isEmpty(Stack* stack) {

    // If head is NULL, the stack is empty
    return stack->head == NULL;
}

// Function to push an element onto the stack
void push(Stack* stack, int new_data) {

    // Create a new node with given data
    Node* new_node = createNode(new_data);

    // Check if memory allocation for the new node failed
    if (!new_node) {
        printf("\\nStack Overflow");
        return;
    }

    // Link the new node to the current top node
    new_node->next = stack->head;

    // Update the top to the new node
    stack->head = new_node;
}

// Function to remove the top element from the stack
void pop(Stack* stack) {

    // Check for stack underflow
    if (isEmpty(stack)) {
        printf("\\nStack Underflow\\n");
        return;
    }
    else {

        // Assign the current top to a temporary variable
        Node* temp = stack->head;

        // Update the top to the next node
        stack->head = stack->head->next;

        // Deallocate the memory of the old top node
        free(temp);
    }
}

// Function to return the top element of the stack
int peek(Stack* stack) {

    // If stack is not empty, return the top element
    if (!isEmpty(stack))
        return stack->head->data;
    else {
        printf("\\nStack is empty");
        return INT_MIN;
    }
}

// Driver program to test the stack implementation
int main() {

    // Creating a stack
    Stack stack;
    initializeStack(&stack);

    // Push elements onto the stack
    push(&stack, 11);
    push(&stack, 22);
    push(&stack, 33);
    push(&stack, 44);

    // Print top element of the stack
    printf("Top element is %d\\n", peek(&stack));


      // removing two elemements from the top
      printf("Removing two elements...\\n");
    pop(&stack);
    pop(&stack);

    // Print top element of the stack
    printf("Top element is %d\\n", peek(&stack));

    return 0;
}

````

Java
````
// Java program to implement a stack using singly linked
// list

// Class representing a node in the linked list
class Node {
    int data;
    Node next;
    Node(int new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // Head of the linked list
    Node head;

    // Constructor to initialize the stack
    Stack() { this.head = null; }

    // Function to check if the stack is empty
    boolean isEmpty() {

        // If head is null, the stack is empty
        return head == null;
    }

    // Function to push an element onto the stack
    void push(int new_data) {

        // Create a new node with given data
        Node new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (new_node == null) {
            System.out.println("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    void pop() {

        // Check for stack underflow
        if (isEmpty()) {
            System.out.println("\\nStack Underflow");
            return;
        }
        else {

            // Assign the current top to a temporary
            // variable
            Node temp = head;

            // Update the top to the next node
            head = head.next;

            // Deallocate the memory of the old top node
            temp = null;
        }
    }

    // Function to return the top element of the stack
    int peek() {

        // If stack is not empty, return the top element
        if (!isEmpty())
            return head.data;
        else {
            System.out.println("\\nStack is empty");
            return Integer.MIN_VALUE;
        }
    }
}

// Driver code
public class Main {
    public static void main(String[] args)
    {
        // Creating a stack
        Stack st = new Stack();

        // Push elements onto the stack
        st.push(11);
        st.push(22);
        st.push(33);
        st.push(44);

        // Print top element of the stack
        System.out.println("Top element is " + st.peek());

        // removing two elemements from the top
          System.out.println("Removing two elements...");
        st.pop();
        st.pop();

        // Print top element of the stack
        System.out.println("Top element is " + st.peek());
    }
}

````

Python
````
# Java program to implement a stack using singly linked
# list

# Class representing a node in the linked list
class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Class to implement stack using a singly linked list
class Stack:
    def __init__(self):

        # head of the linked list
        self.head = None

    # Function to check if the stack is empty
    def is_empty(self):

        # If head is None, the stack is empty
        return self.head is None

    # Function to push an element onto the stack
    def push(self, new_data):

        # Create a new node with given data
        new_node = Node(new_data)

        # Check if memory allocation for the new node failed
        if not new_node:
            print("\\nStack Overflow")
            return

        # Link the new node to the current top node
        new_node.next = self.head

        # Update the top to the new node
        self.head = new_node

    # Function to remove the top element from the stack
    def pop(self):

        # Check for stack underflow
        if self.is_empty():
            print("\\nStack Underflow")
        else:

            # Assign the current top to a temporary variable
            temp = self.head

            # Update the top to the next node
            self.head = self.head.next

            # Deallocate the memory of the old top node
            del temp

    # Function to return the top element of the stack
    def peek(self):

        # If stack is not empty, return the top element
        if not self.is_empty():
            return self.head.data
        else:
            print("\\nStack is empty")
            return float(\'-inf\')


# Creating a stack
st = Stack()

# Push elements onto the stack
st.push(11)
st.push(22)
st.push(33)
st.push(44)

# Print top element of the stack
print("Top element is", st.peek())

# removing two elemements from the top
print("Removing two elements...");
st.pop()
st.pop()

# Print top element of the stack
print("Top element is", st.peek())

````

C#
````
// C# program to implement a stack using singly linked list
using System;

// Class representing a node in the linked list
class Node {
    public int data;
    public Node next;
    public Node(int new_data)
    {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // head of the linked list
    private Node head;

    // Constructor to initialize the stack
    public Stack() { this.head = null; }

    // Function to check if the stack is empty
    public bool isEmpty()
    {

        // If head is null, the stack is empty
        return head == null;
    }

    // Function to push an element onto the stack
    public void push(int new_data)
    {

        // Create a new node with given data
        Node new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (new_node == null) {
            Console.WriteLine("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    public void pop()
    {

        // Check for stack underflow
        if (this.isEmpty()) {
            Console.WriteLine("\\nStack Underflow");
        }
        else {

            // Update the top to the next node
            head = head.next;
            /* No need to manually free the memory of the
             * old head in C# */
        }
    }

    // Function to return the top element of the stack
    public int peek()
    {

        // If stack is not empty, return the top element
        if (!isEmpty())
            return head.data;
        else {
            Console.WriteLine("\\nStack is empty");
            return int.MinValue;
        }
    }
}

// Driver program to test the stack implementation
class GfG {
    static void Main(string[] args)
    {

        // Creating a stack
        Stack st = new Stack();

        // Push elements onto the stack
        st.push(11);
        st.push(22);
        st.push(33);
        st.push(44);

        // Print top element of the stack
        Console.WriteLine("Top element is " + st.peek());

        // removing two elemements from the top
          Console.WriteLine("Removing two elements...");
        st.pop();
        st.pop();

        // Print top element of the stack
        Console.WriteLine("Top element is " + st.peek());
    }
}

````

JavaScript
````
// Javascript program to implement a stack using singly
// linked list

// Class representing a node in the linked list
class Node {
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // Constructor to initialize the stack
    constructor() { this.head = null; }

    // Function to check if the stack is empty
    isEmpty() {

        // If head is null, the stack is empty
        return this.head === null;
    }

    // Function to push an element onto the stack
    push(new_data) {

        // Create a new node with given data
        const new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (!new_node) {
            console.log("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = this.head;

        // Update the top to the new node
        this.head = new_node;
    }

    // Function to remove the top element from the stack
    pop() {

        // Check for stack underflow
        if (this.isEmpty()) {
            console.log("\\nStack Underflow");
        }
        else {

            // Assign the current top to a temporary
            // variable
            let temp = this.head;

            // Update the top to the next node
            this.head = this.head.next;

            // Deallocate the memory of the old top node
            temp = null;
        }
    }

    // Function to return the top element of the stack
    peek() {

        // If stack is not empty, return the top element
        if (!this.isEmpty())
            return this.head.data;
        else {
            console.log("\\nStack is empty");
            return Number.MIN_VALUE;
        }
    }
}

// Driver program to test the stack implementation
const st = new Stack();

// Push elements onto the stack
st.push(11);
st.push(22);
st.push(33);
st.push(44);

// Print top element of the stack
console.log("Top element is " + st.peek());

// removing two elemements from the top
console.log("Removing two elements...");
st.pop();
st.pop();

// Print top element of the stack
console.log("Top element is " + st.peek());

````


**Output**
```

Top element is 44
Top element is 22

```

****Time Complexity:****
O(1), for all push(), pop(), and peek(), as we are not performing any
kind of traversal over the list. We perform all the operations through
the current pointer only.
****Auxiliary Space:**** O(N), where N is the size of the stack


In this implementation, we define a Node class that represents a node
in the linked list, and a Stack class that uses this node class to
implement the stack. The head attribute of the Stack class points to the
top of the stack (i.e., the first node in the linked list).

To push an item onto the stack, we create a new node with the given
item and set its next pointer to the current head of the stack. We then
set the head of the stack to the new node, effectively making it the new
top of the stack.

To pop an item from the stack, we simply remove the first node from the
linked list by setting the head of the stack to the next node in the
list (i.e., the node pointed to by the next pointer of the current
head). We return the data stored in the original head node, which is the
item that was removed from the top of the stack.

### Benefits of implementing a stack using a singly linked list include:

****Dynamic memory allocation****: The size of the stack can be increased or decreased dynamically by
adding or removing nodes from the linked list, without the need to
allocate a fixed amount of memory for the stack upfront.

****Efficient memory usage:**** Since nodes in a singly linked list only have a next pointer and not a
prev pointer, they use less memory than nodes in a doubly linked
list.

****Easy implementation****: Implementing a stack using a singly linked list is straightforward
and can be done using just a few lines of code.

****Versatile****: Singly linked lists can be used to implement other data structures
such as queues, linked lists, and trees.

In summary, implementing a stack using a singly linked list is a simple
and efficient way to create a dynamic stack data structure in
Python.

### Real time examples of stack:

Stacks are used in various real-world scenarios where a last-in,
first-out (LIFO) data structure is required. Here are some examples of
real-time applications of stacks:

****Function call stack****: When a function is called in a program, the return address and all
the function parameters are pushed onto the function call stack. The
stack allows the function to execute and return to the caller function
in the reverse order in which they were called.

****Undo/Redo operations:****
In many applications, such as text editors, image editors, or web
browsers, the undo and redo functionalities are implemented using a
stack. Every time an action is performed, it is pushed onto the stack.
When the user wants to undo the last action, the top element of the
stack is popped and the action is reversed.

****Browser history:**** Web browsers use stacks to keep track of the pages visited by the user.
Every time a new page is visited, its URL is pushed onto the stack. When
the user clicks the “Back” button, the last visited URL is popped from
the stack and the user is directed to the previous page.

****Expression evaluation****: Stacks are used in compilers and interpreters to evaluate
expressions. When an expression is parsed, it is converted into postfix
notation and pushed onto a stack. The postfix expression is then
evaluated using the stack.

****Call stack in recursion:****
When a recursive function is called, its call is pushed onto the stack.
The function executes and calls itself, and each subsequent call is
pushed onto the stack. When the recursion ends, the stack is popped, and
the program returns to the previous function call.

In summary, stacks are widely used in many applications where LIFO
functionality is required, such as function calls, undo/redo operations,
browser history, expression evaluation, and recursive function
calls.
', 'To implement a stack using the singly linked list concept, all the singly linked list operations should be performed based on Stack operations LIFO(last in first out) and with the help of that knowledge, we are going to implement a stack using a singly linked list.', 'Implement a stack using singly linked list', 10, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('82a0d245-a665-4ec2-a2fe-145f7e841ef1', e'
You are given a

****cubic dice****
with

****6****
faces. All the individual faces have a number printed on them. The numbers are in the range of

****1 to 6****
, like any ordinary dice. You will be provided with a face of this cube, your task is to guess the number on the opposite face of the cube.


****Examples:****

> ****Input:****
> n = 2
>
>
>
> ****Output:****
> 5
>
>
>
> ****Explanation:****
> For dice facing number 5 opposite face will have the number 2.
>
>
> ****Input:****
> 6 = 6
>
>
>
> ****Output:****
> 1

Table of Content

* [[Naive Approach] Using if-else – O(1) Time and O(1) Space](#naive-approach-using-ifelse-o1-time-and-o1-space)
* [[Expected Approach] Using Sum of two sides – O(1) Time and O(1) Space](#expected-approach-using-sum-of-two-sides-o1-time-and-o1-space)
### ****[Naive Approach] Using if-else – O(1) Time and O(1) Space****

> In a normal 6-faced dice, 1 is opposite to 6, 2 is opposite to 5, and 3 is opposite to 4. Hence a normal if-else-if block can be placed

C++

````
// C++ program for the above approach
#include<bits/stdc++.h>
using namespace std;

int oppositeFaceOfDice(int n) {

  if(n==1){
    cout<<6;
  }else if(n==2){
    cout<<5;
  }else if(n==3){
    cout<<4;
  }else if(n==4){
    cout<<3;
  }else if(n==5){
    cout<<2;
  }else{
    cout<<1;
  }
}

int main() {

    int n = 2;
    oppositeFaceOfDice(n);

    return 0;
}

````

Java

````
// Java program to find opposite face of dice
class Dice {
    static int oppositeFaceOfDice(int n) {
        if (n == 1) {
            System.out.println(6);
        } else if (n == 2) {
            System.out.println(5);
        } else if (n == 3) {
            System.out.println(4);
        } else if (n == 4) {
            System.out.println(3);
        } else if (n == 5) {
            System.out.println(2);
        } else {
            System.out.println(1);
        }
        return 0;
    }

    public static void main(String[] args) {
        int n = 2;
        oppositeFaceOfDice(n);
    }
}

````

Python

````
# Python program to find opposite face of dice
def opposite_face_of_dice(n):
    if n == 1:
        print(6)
    elif n == 2:
        print(5)
    elif n == 3:
        print(4)
    elif n == 4:
        print(3)
    elif n == 5:
        print(2)
    else:
        print(1)

if __name__ == "__main__":
  n = 2
  opposite_face_of_dice(n)

````

C#

````
// C# program to find opposite face of dice
using System;

class Program {
    static void OppositeFaceOfDice(int n) {
        if (n == 1) {
            Console.WriteLine(6);
        } else if (n == 2) {
            Console.WriteLine(5);
        } else if (n == 3) {
            Console.WriteLine(4);
        } else if (n == 4) {
            Console.WriteLine(3);
        } else if (n == 5) {
            Console.WriteLine(2);
        } else {
            Console.WriteLine(1);
        }
    }

    static void Main() {
        int n = 2;
        OppositeFaceOfDice(n);
    }
}

````

JavaScript

````
// JavaScript program to find opposite face of dice
function oppositeFaceOfDice(n) {
    if (n === 1) {
        console.log(6);
    } else if (n === 2) {
        console.log(5);
    } else if (n === 3) {
        console.log(4);
    } else if (n === 4) {
        console.log(3);
    } else if (n === 5) {
        console.log(2);
    } else {
        console.log(1);
    }
}

//driver code
let n = 2;
oppositeFaceOfDice(n);

````




**Output**
```
5
```
### [Expected Approach] Using Sum of two sides – O(1) Time and O(1) Space

> The idea is based on the observation that the sum of two opposite sides of a cubical dice is equal to
>
> ****7****
> . So, just subtract the given
>
> ****n****
> from
>
> ****7****
> and print the answer.

C++

````
// C++ program for the above approach
#include<bits/stdc++.h>
using namespace std;

int oppositeFaceOfDice(int n) {

    // Stores number on opposite face
    // of dice
    int ans = 7 - n;
    cout << ans;
}

int main() {

    int n = 2;
    oppositeFaceOfDice(n);

    return 0;
}

````

Java

````
// Java program for the above approach
import java.io.*;

class GfG {

    static void oppositeFaceOfDice(int n)  {

        // Stores number on opposite face
        // of dice
        int ans = 7 - n;
        System.out.println(ans);
    }

    public static void main(String[] args) {

        int n = 2;
        oppositeFaceOfDice(n);
    }
}

````

Python

````
# Python3 program for the above approach
def oppositeFaceOfDice(n):

    # Stores number on opposite face
    # of dice
    ans = 7 - n
    print(ans)

if __name__ == "__main__":
  n = 2
  oppositeFaceOfDice(n)

````

C#

````
// C# program for the above approach
using System;
using System.Collections.Generic;

class GfG{

static void oppositeFaceOfDice(int n) {

    // Stores number on opposite face
    // of dice
    int ans = 7 - n;
    Console.Write(ans);
}

public static void Main() {

    int n = 2;
    oppositeFaceOfDice(n);
}
}

````

JavaScript

````
// JavaScript program for the above approach

function oppositeFaceOfDice(n) {
  // Stores number on opposite face
  // of dice
  let ans = 7 - n;
  console.log(ans);
}

// Driver Code
let n = 2;
oppositeFaceOfDice(n);

````




**Output**
```
5
```

*****Time Complexity:*****
**O(1)**


*****Auxiliary Space:*****
**O(1)**
', '', 'The Logic Building Problems', 15, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('ddd30ce5-7b19-476e-ab39-8ea4f71a40f6', e'
Given two integers

****n****
and

****m (m != 0)****
. Find the number closest to

****n****
and divisible by

****m****
. If there is more than one such number, then output the one having maximum absolute value.


****Examples:****


> Input: n = 13, m = 4
>
>
>
> Output: 12
>
>
>
> Explanation: 12 is the closest to 13, divisible by 4.
>
>
> Input: n = -15, m = 6
>
>
>
> Output: -18
>
>
>
> Explanation: Both -12 and -18 are closest to -15, but-18 has the maximum absolute value.

Table of Content

* [[Naive Approach] – O(m) Time and O(1) Space](#naive-approach-om-time-and-o1-space)
* [[Expected Approach] By finding Quotient – O(1) Time and O(1) Space](#expected-approach-by-finding-quotient-o1-time-and-o1-space)
### [Naive Approach] – O(m) Time and O(1) Space

> The basic idea is to start checking from n – m to n + m one by one and tack the closest number.

C++

````
// C++ implementation to find the number closest to n
// and divisible by m
#include <bits/stdc++.h>
using namespace std;

int closestNumber(int n, int m) {
    // find the quotient
   int closest = 0;
    int minDifference = INT_MAX;

    // Check numbers around n
    for (int i = n - abs(m); i <= n + abs(m); ++i) {
        if (i % m == 0) {
            int difference = abs(n - i);

            if (difference < minDifference ||
               (difference == minDifference && abs(i) > abs(closest))) {
                closest = i;
                minDifference = difference;
            }
        }
    }
    return closest;
}

int main() {
    int n = 13, m = 4;
    cout << closestNumber(n, m) << endl;

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int closestNumber(int n, int m) {
    // find the quotient
    int closest = 0;
    int minDifference = INT_MAX;

    // Check numbers around n
    for (int i = n - abs(m); i <= n + abs(m); ++i) {
        if (i % m == 0) {
            int difference = abs(n - i);

            if (difference < minDifference ||
               (difference == minDifference && abs(i) > abs(closest))) {
                closest = i;
                minDifference = difference;
            }
        }
    }
    return closest;
}

int main() {
    int n = 13, m = 4;
    printf("%d\\n", closestNumber(n, m));

    return 0;
}

````

Java

````
// Java implementation to find the number closest to n
// and divisible by m
class Main {
    static int closestNumber(int n, int m) {
        // find the quotient
        int closest = 0;
        int minDifference = Integer.MAX_VALUE;

        // Check numbers around n
        for (int i = n - Math.abs(m); i <= n + Math.abs(m); ++i) {
            if (i % m == 0) {
                int difference = Math.abs(n - i);

                if (difference < minDifference ||
                   (difference == minDifference && Math.abs(i) > Math.abs(closest))) {
                    closest = i;
                    minDifference = difference;
                }
            }
        }
        return closest;
    }

    public static void main(String[] args) {
        int n = 13, m = 4;
        System.out.println(closestNumber(n, m));
    }
}

````

Python

````
# Python implementation to find the number closest to n
# and divisible by m
def closest_number(n, m):
    # find the quotient
    closest = 0
    min_difference = float(\'inf\')

    # Check numbers around n
    for i in range(n - abs(m), n + abs(m) + 1):
        if i % m == 0:
            difference = abs(n - i)

            if difference < min_difference or \\
                        (difference == min_difference and abs(i) > abs(closest)):
                closest = i
                min_difference = difference
    return closest


if __name__ == "__main__":
  n = 13
  m = 4
  print(closest_number(n, m))

````

C#

````
// C# implementation to find the number closest to n
// and divisible by m
using System;

class GfG {
    static int ClosestNumber(int n, int m) {

        // find the quotient
        int closest = 0;
        int minDifference = int.MaxValue;

        // Check numbers around n
        for (int i = n - Math.Abs(m); i <= n + Math.Abs(m); ++i) {
            if (i % m == 0) {
                int difference = Math.Abs(n - i);

                if (difference < minDifference ||
                   (difference == minDifference && Math.Abs(i) > Math.Abs(closest))) {
                    closest = i;
                    minDifference = difference;
                }
            }
        }
        return closest;
    }

    static void Main() {
        int n = 13, m = 4;
        Console.WriteLine(ClosestNumber(n, m));
    }
}

````

JavaScript

````
// JavaScript implementation to find the number closest to n
// and divisible by m
function closestNumber(n, m) {

    // find the quotient
    let closest = 0;
    let minDifference = Infinity;

    // Check numbers around n
    for (let i = n - Math.abs(m); i <= n + Math.abs(m); i++) {
        if (i % m === 0) {
            let difference = Math.abs(n - i);

            if (difference < minDifference ||
               (difference === minDifference && Math.abs(i) > Math.abs(closest))) {
                closest = i;
                minDifference = difference;
            }
        }
    }
    return closest;
}

//driver code
let n = 13, m = 4;
console.log(closestNumber(n, m));

````




**Output**
```
12

```
### [Expected Approach] By finding Quotient – O(1) Time and O(1) Space

> We find the value of n/m. Then we find closest of two possibilities. One is q \\* m other is (m \\* (q + 1)) or (m \\* (q – 1)) depending on whether one of the given two numbers is negative or not.

C++

````
// C++ implementation to find the number closest to n
// and divisible by m
#include <bits/stdc++.h>
using namespace std;

int closestNumber(int n, int m) {
    // find the quotient
    int q = n / m;

    // 1st possible closest number
    int n1 = m * q;

    // 2nd possible closest number
    int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));

    // if true, then n1 is the required closest number
    if (abs(n - n1) < abs(n - n2))
        return n1;

    // else n2 is the required closest number
    return n2;
}

int main() {
    int n = 13, m = 4;
    cout << closestNumber(n, m) << endl;

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

int closestNumber(int n, int m) {
    // find the quotient
    int q = n / m;

    // 1st possible closest number
    int n1 = m * q;

    // 2nd possible closest number
    int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));

    // if true, then n1 is the required closest number
    if (abs(n - n1) < abs(n - n2))
        return n1;

    // else n2 is the required closest number
    return n2;
}

int main() {
    int n = 13, m = 4;
    printf("%d\\n", closestNumber(n, m));

    return 0;
}

````

Java

````
// Java implementation to find the number closest to n
// and divisible by m
class GfG {

    static int closestNumber(int n, int m)  {
        // find the quotient
        int q = n / m;

        // 1st possible closest number
        int n1 = m * q;

        // 2nd possible closest number
        int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));

        // if true, then n1 is the required closest number
        if (Math.abs(n - n1) < Math.abs(n - n2))
            return n1;

        // else n2 is the required closest number
        return n2;
    }

    public static void main(String args[]) {
        int n = 13, m = 4;
        System.out.println(closestNumber(n, m));

    }
}

````

Python

````
# Python 3 implementation to find
# the number closest to n

def closestNumber(n, m) :
    # Find the quotient
    q = int(n / m)

    # 1st possible closest number
    n1 = m * q

    # 2nd possible closest number
    if((n * m) > 0) :
        n2 = (m * (q + 1))
    else :
        n2 = (m * (q - 1))

    # if true, then n1 is the required closest number
    if (abs(n - n1) < abs(n - n2)) :
        return n1

    # else n2 is the required closest number
    return n2


if __name__ == "__main__":
  n = 13; m = 4
  print(closestNumber(n, m))

````

C#

````
// C# implementation to find the
// number closest to n and divisible by m
using System;

class GfG {

    static int closestNumber(int n, int m) {
        // find the quotient
        int q = n / m;

        // 1st possible closest number
        int n1 = m * q;

        // 2nd possible closest number
        int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));

        // if true, then n1 is the required closest number
        if (Math.Abs(n - n1) < Math.Abs(n - n2))
            return n1;

        // else n2 is the required closest number
        return n2;
    }

    public static void Main()  {
        int n = 13, m = 4;
        Console.WriteLine(closestNumber(n, m));

    }
}

````

JavaScript

````
// Javascript implementation to find
// the number closest to n and
// divisible by m

function closestNumber(n, m) {

    // find the quotient
    let q = parseInt(n / m);

    // 1st possible closest number
    let n1 = m * q;

    // 2nd possible closest number
    let n2 = (n * m) > 0 ?
        (m * (q + 1)) : (m * (q - 1));

    // if true, then n1 is the
    // required closest number
    if (Math.abs(n - n1) < Math.abs(n - n2))
        return n1;

    // else n2 is the required
    // closest number
    return n2;
}

// Driver Code
let n = 13;
let m = 4;
console.log(closestNumber(n, m));

````




**Output**
```
12

```

****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1)


', '', 'Find the number closest to n and divisible by m', 16, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('7e9a63b3-707f-46f9-a983-79eab80f9bce', e'

Given two variables, x, and y, swap two variables without using a third variable.


![](https://www.geeksforgeeks.org/wp-content/uploads/CommonArticleDesign16.png)



****Method 1 (Using Addition and subtraction)****


The idea is to get a sum in one of the two given

[numbers](https://www.geeksforgeeks.org/numbers/)
. The numbers can then be swapped using the sum and subtraction from the sum.


C++

````
// C++ Program to swap two numbers  without
// using temporary variable
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int x = 10, y = 5;

    // Code to swap \'x\' and \'y\'
    x = x + y; // x now becomes 15
    y = x - y; // y becomes 10
    x = x - y; // x becomes 5
    cout << "After Swapping: x =" << x << ", y=" << y;
}

// This code is contributed by mohit kumar.

````

C

````
#include <stdio.h>
int main()
{
    int x = 10, y = 5;

    // Code to swap \'x\' and \'y\'
    x = x + y; // x now becomes 15
    y = x - y; // y becomes 10
    x = x - y; // x becomes 5

    printf("After Swapping: x = %d, y = %d", x, y);

    return 0;
}

````

Java

````
// Java Program to swap two numbers  without
// using temporary variable
import java.io.*;

class Geeks {

    public static void main(String a[])
    {
        int x = 10;
        int y = 5;
        x = x + y;
        y = x - y;
        x = x - y;
        System.out.println("After swapping:"
                           + " x = " + x + ", y = " + y);
    }
}

// This code is contributed by Mayank Tyagi

````

Python

````
x = 10
y = 5

# Code to swap \'x\' and \'y\'

# x now becomes 15
x = x + y

# y becomes 10
y = x - y

# x becomes 5
x = x - y
print("After Swapping: x =", x, " y =", y)

# This code is contributed
# by Sumit Sudhakar

````

C#

````
// Program to swap two numbers  without
// using temporary variable
using System;

class GFG {
    public static void Main()
    {
        int x = 10;
        int y = 5;

        x = x + y;
        y = x - y;
        x = x - y;
        Console.WriteLine("After swapping: x = " + x
                          + ", y = " + y);
    }
}

// This code is contributed by Sam007

````

JavaScript

````
<script>

// Javascript program to swap two
// numbers without using temporary
// variable

let x = 10, y = 5;

// Code to swap \'x\' and \'y\'

// x now becomes 15
x = x + y;

// y becomes 10
y = x - y;

// x becomes 5
x = x - y;

document.write("After Swapping: x =" + x + ", y=" + y);

// This code is contributed by mukesh07

</script>

````

PHP

````
<?php
// PHP Program to swap two
// numbers without using
// temporary variable
$x = 10; $y = 5;

// Code to swap \'x\' and \'y\'
$x = $x + $y; // x now becomes 15
$y = $x - $y; // y becomes 10
$x = $x - $y; // x becomes 5

echo "After Swapping: x = ",
       $x, ", ", "y = ", $y;

// This code is contributed by m_kit
?>

````




**Output**
```
After Swapping: x =5, y=10

```

****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Method 2: (Using Multiplication and division)****


Multiplication and division can also be used for swapping.




C++

````
// C++ Program to swap two numbers without using temporary
// variable
#include <bits/stdc++.h>
using namespace std;

int main()
{ // NOTE - for this code to work in a generalised sense, y
  // !- 0 to prevent zero division
    int x = 10, y = 5;

    if (y == 0) {
        y = x;
        x = 0;
    }
    else if (x == 0) {
        x = y;
        y = 0;
    }
    // Code to swap \'x\' and \'y\'
    else {
        x = x * y; // x now becomes 50
        y = x / y; // y becomes 10
        x = x / y; // x becomes 5
    }
    cout << "After Swapping: x =" << x << ", y=" << y;
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

C

````
// C Program to swap two numbers without using temporary
// variable
#include <stdio.h>
int main()
{
    int x = 10, y = 5;

    if (y == 0) {
        y = x;
        x = 0;
    }
    else if (x == 0) {
        x = y;
        y = 0;
    }
    // Code to swap \'x\' and \'y\'
    else {
        x = x * y; // x now becomes 50
        y = x / y; // y becomes 10
        x = x / y; // x becomes 5
    }

    printf("After Swapping: x = %d, y = %d", x, y);

    return 0;
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

Java

````
// Java Program to swap two numbers without using temporary
// variable
import java.io.*;

class GFG {
    public static void main(String[] args)
    {
        int x = 10;
        int y = 5;

        if (y == 0) {
            y = x;
            x = 0;
        }
        else if (x == 0) {
            x = y;
            y = 0;
        }
        // Code to swap \'x\' and \'y\'
        else {
            x = x * y; // x now becomes 50
            y = x / y; // y becomes 10
            x = x / y; // x becomes 5
        }

        System.out.println("After swapping:"
                           + " x = " + x + ", y = " + y);
    }
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

Python

````
# Python3 program to
# swap two numbers
# without using
# temporary variable
x = 10
y = 5

# code to swap
# \'x\' and \'y\'

if y == 0:
    y = x
    x = 0
elif x == 0:
    x = y
    y = 0
else:
    x = x * y
    y = x // y
    x = x // y


print("After Swapping: x =",
      x, " y =", y)

# This code is contributed
# by @ajit

````

C#

````
// C# Program to swap two
// numbers without using
// temporary variable
using System;

class GFG {
    static public void Main()
    {
        int x = 10;
        int y = 5;

        if (y == 0) {
            y = x;
            x = 0;
        }
        else if (x == 0) {
            x = y;
            y = 0;
        }
        // Code to swap \'x\' and \'y\'
        else {
            x = x * y; // x now becomes 50
            y = x / y; // y becomes 10
            x = x / y; // x becomes 5
        }

        Console.WriteLine("After swapping:"
                          + " x = " + x + ", y = " + y);
    }
}

// This code is contributed by ajit.

````

JavaScript

````
<script>

// Javascript program to swap two numbers
// without using temporary variable
var x = 10;
var y = 5;

// Code to swap \'x\' and \'y\'
if (y == 0)
{ y = x; x = 0; }
else if (x == 0) { x = y; y = 0; }
    // Code to swap \'x\' and \'y\'
  else
  {x = x * y; // x now becomes 50
    y = x / y; // y becomes 10
    x = x / y; // x becomes 5
    }

document.write("After swapping:" + " x = " +
               x + ", y = " + y);

// This code is contributed by shikhasingrajput

</script>

````




**Output**
```
After Swapping: x =5, y=10

```

****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Method 3: (Using Bitwise XOR)****



The bitwise XOR operator can be used to swap two variables. The XOR of two numbers x and y returns a number that has all the bits as 1 wherever bits of x and y differ. For example, XOR of 10 (In Binary 1010) and 5 (In Binary 0101) is 1111, and XOR of 7 (0111) and 5 (0101) is (0010).


C++

````
// C++ code to swap using XOR
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int x = 10, y = 5;
    // Code to swap \'x\' (1010) and \'y\' (0101)
    x = x ^ y; // x now becomes 15 (1111)
    y = x ^ y; // y becomes 10 (1010)
    x = x ^ y; // x becomes 5 (0101)
    cout << "After Swapping: x =" << x << ", y=" << y;
    return 0;
}

// This code is contributed by mohit kumar.

````

C

````
// C code to swap using XOR
#include <stdio.h>
int main()
{
    int x = 10, y = 5;

    // Code to swap \'x\' (1010) and \'y\' (0101)
    x = x ^ y; // x now becomes 15 (1111)
    y = x ^ y; // y becomes 10 (1010)
    x = x ^ y; // x becomes 5 (0101)

    printf("After Swapping: x = %d, y = %d", x, y);

    return 0;
}

````

Java

````
// Java code to swap using XOR
import java.io.*;

public class GFG {

    public static void main(String a[])
    {
        int x = 10;
        int y = 5;

        // Code to swap \'x\' (1010) and \'y\' (0101)
        x = x ^ y; // x now becomes 15 (1111)
        y = x ^ y; // y becomes 10 (1010)
        x = x ^ y; // x becomes 5 (0101)

        System.out.println("After swap: x = "
                           + x + ", y = " + y);
    }
}

// This code is contributed by Mayank Tyagi

````

Python

````
# Python3 code to swap using XOR

x = 10
y = 5

# Code to swap \'x\' and \'y\'
x = x ^ y; # x now becomes 15 (1111)
y = x ^ y; # y becomes 10 (1010)
x = x ^ y; # x becomes 5 (0101)

print ("After Swapping: x = ", x, " y =", y)

# This code is contributed by
# Sumit Sudhakar

````

C#

````
// C# program to swap using XOR
using System;

class GFG {
    public static void Main()
    {
        int x = 10;
        int y = 5;

        // Code to swap \'x\' (1010)
        // and \'y\' (0101)

        // x now becomes 15 (1111)
        x = x ^ y;

        // y becomes 10 (1010)
        y = x ^ y;

        // x becomes 5 (0101)
        x = x ^ y;

        Console.WriteLine("After swap: x = " + x + ", y = " + y);
    }
}

// This code is contributed by ajit

````

JavaScript

````
<script>

// Javascript code to swap using XOR

let x = 10, y = 5;

// Code to swap \'x\' (1010) and \'y\' (0101)
x = x ^ y; // x now becomes 15 (1111)
y = x ^ y; // y becomes 10 (1010)
x = x ^ y; // x becomes 5 (0101)

document.write("After Swapping: x =" +
               x + ", y=" + y);

// This code is contributed by Mayank Tyagi

</script>

````

PHP

````
<?php

// Driver Code
$x = 10;
$y = 5;

// Code to swap \'x\' (1010)
// and \'y\' (0101)

// x now becomes 15 (1111)
$x = $x ^ $y;

// y becomes 10 (1010)
$y = $x ^ $y;

// x becomes 5 (0101)
$x = $x ^ $y;

echo "After Swapping: x = ", $x,
                ", ", "y = ", $y;

// This code is contributed by aj_36
?>

````




**Output**
```
After Swapping: x =5, y=10

```

****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Problems with the above methods****



****1)****
The multiplication and division-based approach doesn’t work if one of the numbers is 0 as the product becomes 0 irrespective of the other number.



****2)****
Both Arithmetic solution may cause an arithmetic overflow. If x and y are too large, addition and multiplication may go out of the integer range.



****3)****
When we use pointers to variable and make a function swap, all the above methods fail when both pointers point to the same variable. Let’s take a look at what will happen in this case if both are pointing to the same variable.


// Bitwise XOR based method



x = x ^ x; // x becomes 0



x = x ^ x; // x remains 0



x = x ^ x; // x remains 0



// Arithmetic based method



x = x + x; // x becomes 2x



x = x – x; // x becomes 0



x = x – x; // x remains 0


Let us see the following program.



C++

````
#include <bits/stdc++.h>
using namespace std;
void swap(int* xp, int* yp)
{
    *xp = *xp ^ *yp;
    *yp = *xp ^ *yp;
    *xp = *xp ^ *yp;
}

// Driver code
int main()
{
    int x = 10;
    swap(&x, &x);
    cout << "After swap(&x, &x): x = " << x;
    return 0;
}

// This code is contributed by rathbhupendra

````

C

````
#include <stdio.h>
void swap(int* xp, int* yp)
{
    *xp = *xp ^ *yp;
    *yp = *xp ^ *yp;
    *xp = *xp ^ *yp;
}

int main()
{
    int x = 10;
    swap(&x, &x);
    printf("After swap(&x, &x): x = %d", x);
    return 0;
}

````

Java

````
class GFG {
    static void swap(int[] xp, int[] yp)
    {
        xp[0] = xp[0] ^ yp[0];
        yp[0] = xp[0] ^ yp[0];
        xp[0] = xp[0] ^ yp[0];
    }

    // Driver code
    public static void main(String[] args)
    {
        int[] x = { 10 };
        swap(x, x);
        System.out.println("After swap(&x, &x): x = " + x[0]);
    }
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

Python

````
def swap(xp, yp):

    xp[0] = xp[0] ^ yp[0]
    yp[0] = xp[0] ^ yp[0]
    xp[0] = xp[0] ^ yp[0]


# Driver code
x = [10]
swap(x, x)
print("After swap(&x, &x): x = ", x[0])

# This code is contributed by SHUBHAMSINGH10

````

C#

````
// C# program to implement
// the above approach
using System;
class GFG {

    static void swap(int[] xp, int[] yp)
    {
        xp[0] = xp[0] ^ yp[0];
        yp[0] = xp[0] ^ yp[0];
        xp[0] = xp[0] ^ yp[0];
    }

    // Driver code
    static void Main()
    {
        int[] x = { 10 };
        swap(x, x);
        Console.WriteLine("After swap(&x,"
                          + "&x): x = " + x[0]);
    }
}

// This code is contributed by divyeshrabadiya07

````

JavaScript

````
<script>

    function swap(xp,yp)
    {
        xp[0] = xp[0] ^ yp[0];
        yp[0] = xp[0] ^ yp[0];
        xp[0] = xp[0] ^ yp[0];
    }

    // Driver code

    let x=[10];
    swap(x, x);
    document.write("After swap(&x, &x): x = "
                           + x[0]);


    // This code is contributed by unknown2108

</script>

````

PHP

````
<?php
function swap(&$xp, &$yp)
{
    $xp = $xp ^ $yp;
    $yp = $xp ^ $yp;
    $xp = $xp ^ $yp;
}

// Driver Code
$x = 10;
swap($x, $x);
print("After swap(&x, &x): x = " . $x);

// This code is contributed
// by chandan_jnu
?>

````




**Output**
```
After swap(&x, &x): x = 0

```

****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


Swapping a variable with itself may be needed in many standard algorithms. The above problem can be avoided by putting a condition before swapping.


C++

````
#include <bits/stdc++.h>
using namespace std;
void swap(int* xp, int* yp)
{

    // Check if the two addresses are same
    if (xp == yp)
        return;
    *xp = *xp + *yp;
    *yp = *xp - *yp;
    *xp = *xp - *yp;
}

// Driver Code
int main()
{
    int x = 10;
    swap(&x, &x);
    cout << "After swap(&x, &x): x = " << x;
    return 0;
}

// This code is contributed by rathbhupendra

````

C

````
#include <stdio.h>
void swap(int* xp, int* yp)
{
    if (xp == yp) // Check if the two addresses are same
        return;
    *xp = *xp + *yp;
    *yp = *xp - *yp;
    *xp = *xp - *yp;
}
int main()
{
    int x = 10;
    swap(&x, &x);
    printf("After swap(&x, &x): x = %d", x);
    return 0;
}

````

Java

````
// Java program of above approach
class GFG {

    static void swap(int xp, int yp)
    {
        if (xp == yp) // Check if the two addresses are same
            return;
        xp = xp + yp;
        yp = xp - yp;
        xp = xp - yp;
    }

    // Driver code
    public static void main(String[] args)
    {
        int x = 10;
        swap(x, x);
        System.out.println("After swap(&x, &x): x = " + x);
    }
}

// This code is Contributed by Code_Mech.

````

Python

````
# Python3 program of above approach
def swap(xp, yp):

    # Check if the two addresses are same
    if (xp[0] == yp[0]):
        return
    xp[0] = xp[0] + yp[0]
    yp[0] = xp[0] - yp[0]
    xp[0] = xp[0] - yp[0]


# Driver Code
x = [10]
swap(x, x)
print("After swap(&x, &x): x = ", x[0])

# This code is contributed by SHUBHAMSINGH10

````

C#

````
// C# program of above approach
using System;
class GFG {

    static void swap(int xp, int yp)
    {
        if (xp == yp) // Check if the two addresses are same
            return;
        xp = xp + yp;
        yp = xp - yp;
        xp = xp - yp;
    }

    // Driver code
    public static void Main()
    {
        int x = 10;
        swap(x, x);
        Console.WriteLine("After swap(&x, &x): x = " + x);
    }
}

// This code is Contributed by Code_Mech.

````

JavaScript

````
<script>
   function swap(xp, yp)
{

    // Check if the two addresses are same
    if (xp == yp)
        return;
    xp[0] = xp[0] + yp[0];
    yp[0] = xp[0] - yp[0];
    xp[0]= xp[0] - yp[0];
}

// Driver Code
     x = 10;
    swap(x, x);
    document.write("After swap(&x , &x) : x = " + x);
//This code is contributed by simranarora5sos
</script>

````

PHP

````
<?php
function swap($xp, $yp)
{
    // Check if the two addresses
    // are same
    if ($xp == $yp)
        return;
    $xp = $xp + $yp;
    $yp = $xp - $yp;
    $xp = $xp - $yp;
}

// Driver Code
$x = 10;
swap($x, $x);
echo("After swap(&x, &x): x = " . $x);
return 0;

// This code is contributed
// by Code_Mech.

````




**Output**
```
After swap(&x, &x): x = 10

```

****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Method 4 (A mixture of bitwise operators and arithmetic operators)****



The idea is the same as discussed in

****Method 1****
but uses Bitwise addition and subtraction for swapping.


Below is the implementation of the above approach.


C++

````
// C++ program to swap two numbers
#include <bits/stdc++.h>
using namespace std;

// Function to swap the numbers.
void swap(int& a, int& b)
{
    // same as a = a + b
    a = (a & b) + (a | b);
    // same as b = a - b
    b = a + (~b) + 1;
    // same as a = a - b
    a = a + (~b) + 1;
}

// Driver Code
int main()
{
    int a = 5, b = 10;
    // Function Call
    swap(a, b);
    cout << "After swapping: a = " << a << ", b = " << b;
    return 0;
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

C

````
// C program to swap two numbers
#include <stdio.h>

// Function to swap the numbers.
void swap(int a, int b)
{
    // same as a = a + b
    a = (a & b) + (a | b);
    // same as b = a - b
    b = a + (~b) + 1;
    // same as a = a - b
    a = a + (~b) + 1;
      printf("After swapping: a = %d , b = %d ",a,b);
}

// Driver Code
int main()
{
    int a = 5, b = 10;
    // Function Call
    swap(a, b);
    return 0;
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

Java

````
// Java program to swap two numbers
import java.io.*;

class GFG {
    public static void swap(int a, int b)
    {
        // same as a = a + b
        a = (a & b) + (a | b);
        // same as b = a - b
        b = a + (~b) + 1;
        // same as a = a - b
        a = a + (~b) + 1;
        System.out.print("After swapping: a = " + a + ", b = " + b);
    }
    public static void main(String[] args)
    {
        int a = 5, b = 10;
        // Function Call
        swap(a, b);
    }
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

Python

````
# Python3 program to swap two numbers

# Function to swap the numbers


def swap(a, b):

    # Same as a = a + b
    a = (a & b) + (a | b)

    # Same as b = a - b
    b = a + (~b) + 1

    # Same as a = a - b
    a = a + (~b) + 1

    print("After Swapping: a = ", a, ", b = ", b)


# Driver code
a = 5
b = 10

# Function call
swap(a, b)

# This code is contributed by bunnyram19

````

C#

````
// C# program to swap two numbers
using System;
class GFG {

    static void swap(int a, int b)
    {
        // same as a = a + b
        a = (a & b) + (a | b);

        // same as b = a - b
        b = a + (~b) + 1;

        // same as a = a - b
        a = a + (~b) + 1;

        Console.Write("After swapping: a = " + a
                      + ", b = " + b);
    }

    static void Main()
    {
        int a = 5, b = 10;

        // Function Call
        swap(a, b);
    }
}

// This code is contributed by divyesh072019

````

JavaScript

````
<script>
    // Javascript program to swap two numbers

    function swap(a, b)
    {
        // same as a = a + b
        a = (a & b) + (a | b);

        // same as b = a - b
        b = a + (~b) + 1;

        // same as a = a - b
        a = a + (~b) + 1;

        document.write("After swapping: a = " + a + ", b = " + b);
    }

    let a = 5, b = 10;

    // Function Call
    swap(a, b);

    // This code is contributed by suresh07.
</script>

````

PHP

````
<?php


// Driver Code
$a = 5;
$b = 10;

echo("Before swap(a and b) " . $a . "and". $b."<br>");
// same as a = a + b
    $a = ($a & $b) + ($a | $b);

    // same as b = a - b
    $b = $a + (~$b) + 1;

    // same as a = a - b
    $a = $a + (~$b) + 1;

echo("After swap(a and b) " . $a. "and". $b);
return 0;

?>

````




**Output**
```
After swapping: a = 10, b = 5

```

****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1), since no extra space has been taken.


****Method 5 (One Line Expression)****


We can write only one line to swap two numbers.


* x = x ^ y ^ (y = x);
* x = x + y – (y = x);
* x = (x \\* y) / (y = x);
* x , y = y, x (In Python)

C++

````
#include <iostream>
using namespace std;

int main(){
    int x = 10, y = 5;
    x = (x * y) / (y = x);
    cout << x << " " << y;
    return 0;
}

// This code is contributed by isha307

````

C

````
#include <stdio.h>

int main() {
    int x = 10, y = 5;
    x = (x * y) / (y = x);
    printf("After Swapping: x = %d, y = %d", x, y);
    return 0;
}

// This code is contributed by isha307

````

Java

````
/*package whatever //do not write package name here */
import java.io.*;

class GFG {
    public static void main(String[] args)
    {
        int x = 10;
        int y = 5;
        x = (x * y) / (y = x);
        System.out.println("After swapping:"
                           + " x = " + x + ", y = " + y);
    }
}

// This code is contributed by isha307

````

Python

````
# Python3 program to swap two numbers

# Function to swap the numbers
def swap(x, y):
  x , y = y, x
  print("After Swapping: x = ", x, ", y = ", y)

# Driver code
x = 10
y = 5

# Function call
swap(x, y)

# This code is contributed by kothavvsaakash

````

C#

````
// C# program to swap two numbers

using System;

public class GFG
{
    static public void Main ()
    {
        int x = 10;
        int y = 5;
        x = (x * y) / (y = x);
        Console.Write("After swapping:"  + " x = " + x + ", y = " + y);
    }
}

// This code is contributed by kothavvsaakash

````

JavaScript

````
<script>

// Javascript program to swap two
// numbers without using temporary
// variable

let x = 10, y = 5;

// Code to swap \'x\' and \'y\'
x = (x * y)/(x = y);

document.write("After Swapping: x =" + x + ", y=" + y);

// This code is contributed by Abhijeet Kumar(abhijeet19403)

</script>

````




**Output**
```
5 10

```

****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1)
', '', 'How to swap two numbers without using a temporary variable?', 17, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('52069685-2d95-4f5f-9678-294844ede87b', e'
Given a number n, find the sum of the first natural numbers.


****Examples :****


> ****Input:****
> n = 3
>
>
>
> ****Output:****
> 6
>
>
>
> ****Explanation****
> : Note that 1 + 2 + 3 = 6
>
>
>
>
>
> ****Input****
> : 5
>
>
>
> ****Output****
> : 15
>
>
>
> ****Explanation****
> : Note that 1 + 2 + 3 + 4 + 5 = 15

### Naive Solution – O(n) Time and O(1) Space


Calculate the sum of all integers from 1 to

`n`
by iterating through a loop.


C++

````
// CPP program to find sum of first
// n natural numbers.
#include <iostream>
using namespace std;

int findSum(int n)
{
    int sum = 0;
    for (int x = 1; x <= n; x++)
        sum = sum + x;
    return sum;
}

// Driver code
int main()
{
    int n = 5;
    cout << findSum(n);
    return 0;
}

````

C

````
// C program to find sum of first
// n natural numbers.
#include <stdio.h>

int findSum(int n)
{
    int sum = 0;
    for (int x = 1; x <= n; x++)
        sum = sum + x;
    return sum;
}

// Driver code
int main()
{
    int n = 5;
    printf("%d", findSum(n));
    return 0;
}

````

Java

````
// JAVA program to find sum of first
// n natural numbers.
import java.io.*;

class GfG{
    static int findSum(int n)
    {
        int sum = 0;
        for (int x = 1; x <= n; x++)
            sum = sum + x;
        return sum;
    }

    // Driver code
    public static void main(String args[])
    {
        int n = 5;
        System.out.println(findSum(n));
    }
}

// This code is contributed by Nikita Tiwari.

````

Python

````
# PYTHON program to find sum of first
# n natural numbers.

def findSum(n):
    sum = 0
    x = 1
    while x <= n:
        sum = sum + x
        x = x + 1
    return sum


# Driver code
n = 5
print findSum(n)

````

C#

````
// C# program to find sum of first
// n natural numbers.
using System;

class GfG{

    static int findSum(int n)
    {
        int sum = 0;
        for (int x = 1; x <= n; x++)
            sum = sum + x;
        return sum;
    }

    // Driver code
    public static void Main()
    {
        int n = 5;
        Console.Write(findSum(n));
    }
}

````

JavaScript

````
// Javascript program to find sum of first n natural numbers.

function findSum(n)
{
   let sum = 0;
   for (let x = 1; x <= n; x++)
     sum = sum + x;
   return sum;
}

let n = 5;
console.log(findSum(n));

````

PHP

````
<?php
// PHP program to find sum of first
// n natural numbers.

function findSum($n)
{
$sum = 0;
for ($x = 1; $x <= $n; $x++)
    $sum = $sum + $x;
return $sum;
}

// Driver code
$n = 5;
echo findSum($n);

?>

````




**Output**
```
15
```
### Expected Approach – O(1) Time and O(1) Space


An

****efficient solution****
is to use the below formula.


> ****Sum of first n natural numbers = (n \\* (n+1)) / 2****
>
>
> For example: n = 5
>
>
>
> Sum = (5 \\* (5 + 1)) / 2 = (5 \\* 6) / 2 = 30 / 2 = 15

****How does this work?****

> ****We can prove this formula using induction.****
>
>
>
>
> It is true for n = 1 and n = 2
>
>
>
> For n = 1, sum = 1 \\* (1 + 1)/2 = 1
>
>
>
> For n = 2, sum = 2 \\* (2 + 1)/2 = 3
>
>
>
>
>
> Let it be true for k = n-1.
>
>
>
>
>
> Sum of k numbers = (k \\* (k+1))/2
>
>
>
> Putting k = n-1, we get
>
>
>
> Sum of k numbers = ((n-1) \\* (n-1+1))/2
>
>
>
> = (n – 1) \\* n / 2
>
>
>
>
>
> If we add n, we get,
>
>
>
> Sum of n numbers = n + (n – 1) \\* n / 2
>
>
>
> = (2n + n
>
> 2
> – n)/2
>
>
>
> = n \\* (n + 1)/2

C++

````
// Efficient CPP program to find sum of first
// n natural numbers.
#include<iostream>
using namespace std;

int findSum(int n)
{
   return n * (n + 1) / 2;
}

// Driver code
int main()
{
  int n = 5;
  cout << findSum(n);
  return 0;
}

````

C

````
// Efficient C program to find
// sum of first n natural numbers.
#include<stdio.h>

int findSum(int n)
{
   return n * (n + 1) / 2;
}

// Driver code
int main()
{
  int n = 5;
  printf("%d", findSum(n));
  return 0;
}

````

Java

````
// Efficient JAVA program to find sum
// of first n natural numbers.
import java.io.*;

class GfG{

    static int findSum(int n)
    {
        return n * (n + 1) / 2;
    }

    // Driver code
    public static void main(String args[])
    {
        int n = 5;
        System.out.println(findSum(n));
    }
}

````

Python

````
# Efficient CPP program to find sum
# of first n natural numbers.

def findSum(n) :
    return n * (n + 1) / 2

# Driver code
n = 5
print findSum(n)

````

C#

````
// Efficient C# program to find sum
// of first n natural numbers.
using System;

class GFG{

    static int findSum(int n)
    {
        return n * (n + 1) / 2;
    }

    // Driver code
    public static void Main()
    {
        int n = 5;
        Console.Write(findSum(n));
    }
}

````

JavaScript

````
// javascript Program to find the average
// of sum of first n natural numbers

function findSum(n)
{
    return n * (n + 1) / 2;
}
var n = 5;
console.log(findSum(n));

````

php

````
<?php
// Efficient PHP program to find sum
// of first n natural numbers.

function findSum($n)
{
    return ($n * ($n + 1) / 2);
}

// Driver code
$n = 5;
echo findSum($n);

?>

````




**Output**
```
15
```

****Note:****
The above program causes

****overflow,****
even if the

****result****
is not beyond the

****integer limit****
. We can avoid overflow up to some extent by

****dividing first****
.


C++

````
// n natural numbers that avoids overflow if
// result is going to be within limits.
#include<iostream>
using namespace std;

int findSum(int n)
{
   if (n % 2 == 0)

      // Here multiplying by 1LL help to
      // perform calculations in long long,
      // so that answer should not be overflowed
      return (n / 2) * 1LL * (n + 1);

   // If n is odd, (n+1) must be even
   else

      // Here multiplying by 1LL help to
      // perform calculations in long long,
      // so that answer should not be overflowed
      return  ((n + 1) / 2) * 1LL * n;
}

// Driver code
int main()
{
  int n = 5;
  cout << findSum(n);
  return 0;
}

````

C

````
// Efficient C program to find
// sum of first n natural numbers
// that avoids overflow if result
// is going to be within limits.
#include<stdio.h>

int findSum(int n)
{
   if (n % 2 == 0)

      // Here multiplying by 1LL help to
      // perform calculations in long long,
      // so that answer should not be overflowed
      return (n / 2) * 1LL * (n + 1);

   // If n is odd, (n+1) must be even
   else

      // Here multiplying by 1LL help to
      // perform calculations in long long,
      // so that answer should not be overflowed
      return  ((n + 1) / 2) * 1LL * n;
}

// Driver code
int main()
{
  int n = 5;
  printf("%d", findSum(n));
  return 0;
}

````

Java

````
// n natural numbers that avoids overflow if
// result is going to be within limits.
import java.io.*;

class GfG{

    // Returns sum of first n natural
    // numbers
    static int findSum(int n)
    {
        if (n % 2 == 0)
            return (n / 2) * (n + 1);

        // If n is odd, (n+1) must be even
        else
            return ((n + 1) / 2) * n;
    }

    // Driver code
    public static void main(String args[])
    {
        int n = 5;
        System.out.println(findSum(n));
    }
}

````

Python

````
# Efficient Python program to find the sum
# of first n natural numbers that avoid
# overflow if the result is going to be
# within limits.

# Returns sum of first n natural
# numbers
def findSum(n):
    if (n % 2 == 0):
        return (n / 2) * (n + 1)

   # If n is odd, (n+1) must be even
    else:
        return ((n + 1) / 2) * n


# Driver code
n = 5
print findSum(n)

````

C#

````
// Efficient C# program to find the sum of first
// n natural numbers that avoid overflow if
// result is going to be within limits.
using System;

class GfG{

    static int findSum(int n)
    {
        if (n % 2 == 0)
            return (n / 2) * (n + 1);

        // If n is odd, (n+1) must be even
        else
            return ((n + 1) / 2) * n;
    }

    // Driver code
    public static void Main()
    {
        int n = 5;
        Console.Write(findSum(n));
    }
}

````

JavaScript

````
//efficient approach using  javascript to find the average
// of sum of first n natural numbers

// Return the average of sum
// of first n even numbers
function findSum(n)
{
    if (n % 2 == 0)
        return (n / 2) * (n + 1)

// If n is odd, (n+1) must be even
    else
    return ((n + 1) / 2) * n

}
var n = 5;
console.log(findSum(n));

````

PHP

````
<?php
// Efficient php program to find sum of first
// n natural numbers that avoids overflow if
// result is going to be within limits.

function findSum($n)
{
    if ($n % 2 == 0)
        return ($n / 2) *
               ($n + 1);

    // If n is odd, (n+1) must be even
    else
        return (($n + 1) / 2) * $n;
}

// Driver code
$n = 5;
echo findSum($n);
?>

````




**Output**
```
15
```
', '', 'Program to find sum of first n natural numbers', 18, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('0aeea379-45ac-4886-bc6e-ebee7abcae78', e'****Learn Basics of Singly Linked List:****
-------------------------------------------

1. [Basic Terminologies in Linked List](https://www.geeksforgeeks.org/what-is-linked-list/)
2. [Singly Linked List Tutorial](https://www.geeksforgeeks.org/singly-linked-list-tutorial/)
3. [Linked List vs Array](https://www.geeksforgeeks.org/linked-list-vs-array/)

****Basic Operations of Singly Linked List:****
-----------------------------------------------

1. [Linked List Insertion](https://www.geeksforgeeks.org/linked-list-set-2-inserting-a-node/)
2. [Search an element in a Linked List (Iterative and Recursive)](https://www.geeksforgeeks.org/search-an-element-in-a-linked-list-iterative-and-recursive/)
3. [Find Length of a Linked List (Iterative and Recursive)](https://www.geeksforgeeks.org/find-length-of-a-linked-list-iterative-and-recursive/)
4. [Reverse a linked list](https://www.geeksforgeeks.org/write-a-function-to-reverse-the-nodes-of-a-linked-list/)
5. [Linked List Deletion (Deleting a given key)](https://www.geeksforgeeks.org/linked-list-set-3-deleting-node/)
6. [Linked List Deletion (Deleting a key at given position)](https://www.geeksforgeeks.org/delete-a-linked-list-node-at-a-given-position/)
7. [Write a function to delete a Linked List](https://www.geeksforgeeks.org/write-a-function-to-delete-a-linked-list/)

****Easy Problems on Singly Linked List:****
--------------------------------------------

* [Identical Linked Lists](https://www.geeksforgeeks.org/identical-linked-lists/)
* [Print the middle of a given linked list](https://www.geeksforgeeks.org/write-a-c-function-to-print-the-middle-of-the-linked-list/)
* [Write a function to get Nth node in a Linked List](https://www.geeksforgeeks.org/write-a-function-to-get-nth-node-in-a-linked-list/)
* [Nth node from the end of a Linked List](https://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/)
* [Move last element to front of a given Linked List](https://www.geeksforgeeks.org/move-last-element-to-front-of-a-given-linked-list/)
* [Make middle node head in a linked list](https://www.geeksforgeeks.org/make-middle-node-head-linked-list/)
* [Delete alternate nodes of a Linked List](https://www.geeksforgeeks.org/delete-alternate-nodes-of-a-linked-list/)
* [Add 1 to a number represented as linked list](https://www.geeksforgeeks.org/add-1-number-represented-linked-list/)
* [Add two numbers represented by linked lists](https://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-list/)
* [Subtract Two Numbers represented as Linked Lists](https://www.geeksforgeeks.org/subtract-two-numbers-represented-as-linked-lists/)
* [Find the sum of last n nodes of the given Linked List](https://www.geeksforgeeks.org/find-sum-last-n-nodes-given-linked-list/)
* [Pairwise swap elements of a given linked list](https://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list/)
* [Remove every k-th node of the linked list](https://www.geeksforgeeks.org/remove-every-k-th-node-linked-list/)
* [Remove duplicates from a sorted linked list](https://www.geeksforgeeks.org/remove-duplicates-from-a-sorted-linked-list/)

****Intermediate Problems on Singly Linked List:****
----------------------------------------------------

* [Detect loop in a linked list](https://www.geeksforgeeks.org/write-a-c-function-to-detect-loop-in-a-linked-list/)
* [Find length of loop in linked list](https://www.geeksforgeeks.org/find-length-of-loop-in-linked-list/)
* [Function to check if a singly linked list is palindrome](https://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/)
* [Remove duplicates from an unsorted linked list](https://www.geeksforgeeks.org/remove-duplicates-from-an-unsorted-linked-list/)
* [Remove all occurrences of duplicates from a sorted Linked List](https://www.geeksforgeeks.org/remove-occurrences-duplicates-sorted-linked-list/)
* [Swap nodes in a linked list without swapping data](https://www.geeksforgeeks.org/swap-nodes-in-a-linked-list-without-swapping-data/)
* [Intersection point of two Linked Lists.](https://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/)
* [Iteratively Reverse a linked list using only 2 pointers (An Interesting Method)](https://www.geeksforgeeks.org/iteratively-reverse-a-linked-list-using-only-2-pointers/)
* [Segregate even and odd nodes in a Linked List](https://www.geeksforgeeks.org/segregate-even-and-odd-elements-in-a-linked-list/)
* [Alternate Odd and Even Nodes in a Singly Linked List](https://www.geeksforgeeks.org/alternate-odd-even-nodes-singly-linked-list/)
* [Rearrange a Linked List in Zig-Zag fashion](https://www.geeksforgeeks.org/linked-list-in-zig-zag-fashion/)
* [Adding two polynomials using Linked List](https://www.geeksforgeeks.org/adding-two-polynomials-using-linked-list/)
* [Union and Intersection of two Linked Lists](https://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/)
* [Sort linked list which is already sorted on absolute values](https://www.geeksforgeeks.org/sort-linked-list-already-sorted-absolute-values/)

****Hard Problems on Singly Linked List:****
--------------------------------------------

* [Reverse a Linked List in groups of given size](https://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/)
* [Flattening a Linked List](https://www.geeksforgeeks.org/flattening-a-linked-list/)
* [Reverse alternate K nodes in a Singly Linked List](https://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/)
* [Alternating split of a given Singly Linked List](https://www.geeksforgeeks.org/alternating-split-of-a-given-singly-linked-list/)
* [Delete nodes which have a greater value on right side](https://www.geeksforgeeks.org/delete-nodes-which-have-a-greater-value-on-right-side/)
* [Given a linked list of line segments, remove middle points](https://www.geeksforgeeks.org/given-linked-list-line-segments-remove-middle-points/)
* [Clone a linked list with next and random pointer](https://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/)
* [Rearrange a given linked list in-place.](https://www.geeksforgeeks.org/rearrange-a-given-linked-list-in-place/)
* [Select a Random Node from a Singly Linked List](https://www.geeksforgeeks.org/select-a-random-node-from-a-singly-linked-list/)
* [In-place Merge two linked lists without changing links of first list](https://www.geeksforgeeks.org/in-place-merge-two-linked-list-without-changing-links-of-first-list/)
* [Length of longest palindrome list in a linked list using O(1) extra space](https://www.geeksforgeeks.org/length-longest-palindrome-list-linked-list-using-o1-extra-space/)
* [Rotate Linked List block wise](https://www.geeksforgeeks.org/rotate-linked-list-block-wise/)
* [Count rotations in sorted and rotated linked list](https://www.geeksforgeeks.org/count-rotations-sorted-rotated-linked-list/)

****Quick Links:****
--------------------

* [\'Practice Problems\' on Linked List](https://www.geeksforgeeks.org/explore?page=2&category=Linked%20List&sortBy=difficulty&itm_source=geeksforgeeks&itm_medium=main_header&itm_campaign=practice_header)
    * [\'Videos\' on Linked List](https://www.youtube.com/playlist?list=PLqM7alHXFySH41ZxzrPNj2pAYPOI8ITe7)
* [\'Quizzes\' on Linked List](https://www.geeksforgeeks.org/data-structure-gq/linked-list-gq/)
', 'Singly linked list is a linear data structure in which the elements are not stored in contiguous memory locations and each element is connected only to its next element using a pointer.', 'Singly Linked List Problems', 3, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('ae34492a-cfab-417f-952f-ddb4957195e8', e'Given a number

****n****
, we need to print its table.


****Examples :****


> ****Input****
> : 5
>
>
>
> ****Output****
> :
>
>
>
> 5 \\* 1 = 5
>
>
>
> 5 \\* 2 = 10
>
>
>
> 5 \\* 3 = 15
>
>
>
> 5 \\* 4 = 20
>
>
>
> 5 \\* 5 = 25
>
>
>
> 5 \\* 6 = 30
>
>
>
> 5 \\* 7 = 35
>
>
>
> 5 \\* 8 = 40
>
>
>
> 5 \\* 9 = 45
>
>
>
> 5 \\* 10 = 50

Table of Content

* [Iterative Approach – O(1) Time and O(1) Space](#using-a-loop-o1-time-and-o1-space)
* [Recursive Approach – O(1) Time and O(1) Space](#using-recursion-o1-space-and-o1-time)
### Iterative Approach – O(1) Time and O(1) Space

C++

````
// CPP program to print table of a number
#include <iostream>
using namespace std;

void printTable(int n) {
  for (int i = 1; i <= 10; ++i)
        cout << n << " * " << i << " = "
             << n * i << endl;
}

int main() {
    int n = 5;  // Change here to change output
    printTable(n);
    return 0;
}

````

Java

````
// Java program to print table of a number
import java.io.*;

class GfG {

    public static void printTable(int n)  {

        for (int i = 1; i <= 10; ++i)
            System.out.println(n + " * " + i +
                               " = " + n * i);
    }

    public static void main(String arg[]){
        int n = 5;
        printTable(n);
    }
}

````

Python

````
# Python Program to print table of a number

def printTable(n):

    for i in range (1, 11):

        # multiples from 1 to 10
        print "%d * %d = %d" % (n, i, n * i)


if __name__ == "__main__":
  n = 5
  printTable(n)

````

C#

````
// C# program to print table of a number
using System;

class GfG {
    public static void printTable(int n) {

        for (int i = 1; i <= 10; ++i)
            Console.Write(n + " * " + i +
                              " = " + n *
                               i + "\\n");
    }

    public static void Main()   {
      int n = 5;
      printTable(n);

    }
}

````

JavaScript

````
// Javascript program to print
// table of a number

function printTable(n) {
for (let i = 1; i <= 10; ++i)
    console.log( n + " * " +i +
            " = " + n *
                i);
}

// Driver Code
let n = 5;
printTable(n);

````

****Output :****


```
5 * 1 = 5
5 * 2 = 10
5 * 3 = 15
5 * 4 = 20
5 * 5 = 25
5 * 6 = 30
5 * 7 = 35
5 * 8 = 40
5 * 9 = 45
5 * 10 = 50
```
### ****Recursive Approach – O(1) Time and O(1) Space****

C++

````
#include <iostream>
using namespace std;

// printTable() prints table of number and takes
//1 required value that is number of whose teble to be printed
//and an optional input i whose default value is 1

void printTable(int n, int i = 1) {
    if (i == 11)// base case
        return;
    cout << n << " * " << i << " = " << n * i << endl;
    i++;//increment i
    printTable(n,i);
}

int main() {
    int n = 5;
    printTable(n);
}

````

Java

````
import java.util.*;

class GfG {

    // printTable() prints table of number and takes
    // 1 required value that is number of whose teble to be
    // printed and an optional input i whose default value is 1
    static void printTable(int n, Integer... val)  {
          int i = 1;
        if (val.length != 0)
            i = val[0];
        if (i == 11) // base case
            return;
        System.out.println(n + " * " + i + " = " + n * i);
        i++; // increment i
        printTable(n, i);
    }

    public static void main(String[] args) {
        int n = 5;
        printTable(n);
    }
}


````

Python

````
# printTable() prints table of number and takes
# 1 required value that is number of whose teble to be printed
# and an optional input i whose default value is 1
def printTable(n, i=1):

    if (i == 11):  # base case
        return
    print(n, "*", i, "=", n * i)
    i += 1  # increment i
    printTable(n, i)

if __name__ == "__main__":
  n = 5
  printTable(n)

````

C#

````
using System;
using System.Collections.Generic;

class GfG {

  // print_table() prints table of number and takes
  // 1 required value that is number of whose teble to be
  // printed and an optional input i whose default value is 1
  static void printTable(int n, int i = 1) {
    if (i == 11) // base case
      return;
    Console.WriteLine(n + " * " + i + " = " + n * i);
    i++; // increment i
    printTable(n, i);
  }

  public static void Main(string[] args) {
    int n = 5;
    printTable(n);
  }
}

````

JavaScript

````
// printTable() prints table of number and takes
//1 required value that is number of whose teble to be printed
//and an optional input i whose default value is 1

function printTable(n, i = 1) {
    if (i == 11)// base case
        return;
    console.log(n + " * " + i + " = " + n * i);
    i++;//increment i
    printTable(n,i);
}

// Driver Code
let n = 5;
printTable(n);

````




**Output**
```
5 * 1 = 5
5 * 2 = 10
5 * 3 = 15
5 * 4 = 20
5 * 5 = 25
5 * 6 = 30
5 * 7 = 35
5 * 8 = 40
5 * 9 = 45
5 * 10 = 50
```

****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1), since the recursion stack will only go up to 10.

', '', 'Program to print multiplication table of a number', 19, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('2bbe24be-6a3c-49ad-bb76-363d65e58895', e'Given a number

****n****
, check whether it is even or odd. Return

****true****
for even and

****false****
for odd.


****Examples:****


> ****Input****
> : 2
>
>
>
> ****Output****
> : true
>
>
> ****Input****
> : 5
>
>
>
> ****Output****
> : false

Table of Content

* [By Finding the Remainder – O(1) Time and O(1) Space](#by-finding-the-reminder-o1-time-and-o1-space)
* [Using Bitwise AND Operator – O(1) Time and O(1) Space](#using-bitwaise-operators-o1-time-and-o1-space)
* [Using Bitwise Shift Operators – O(1) Time and O(1) Space](#using-bitwaise-shift-operators-o1-time-and-o1-space)
### By Finding the Remainder – O(1) Time and O(1) Space


We can check the remainder when divided by 2. If the remainder is 0, the number is even; otherwise, it is odd


C++

````
// A simple C++ program to check for even or odd
#include <iostream>
using namespace std;

bool isEven(int n) {
  return (n % 2 == 0);
}

int main() {
    int n = 101;
    if(isEven(n))
         cout << "true";
      else
        cout << "false";

    return 0;
}

````

Java

````
// Java program  to check for even or odd
class GfG {

    public static boolean isEven(int n)  {
        return (n % 2 == 0);
    }

    public static void main(String[] args) {
        int n = 101;
        if (isEven(n) == true)
            System.out.print("true");
        else
            System.out.print("false");
    }
}

````

Python

````
# A simple Python3 code check for even or odd

def isEven(n):
    return (n % 2 == 0)


if __name__ == "__main__":
  n = 101
  if is_even(n):
      print("true")
  else:
      print("false")

````

C#

````
// C# program toif __name__ == "__main__":
using System;
class GfG {
    public static bool isEven(int n) {
        return (n % 2 == 0);
    }

    public static void Main() {
        int n = 101;
        if (isEven(n) == true)
            Console.WriteLine("true");
        else
            Console.WriteLine("false");
    }
}

````

JavaScript

````
// A simple Javascript program to
// check for even or odd

function isEven(n) {
    return (n % 2 == 0);
}

// Driver code

    let n = 101;
    if (isEven(n)) {
        console.log("true");
    } else {
        console.log("false");
    }

````




**Output**
```
false
```
### Using Bitwise AND Operator – O(1) Time and O(1) Space

> The last bit of all odd numbers is always 1, while for even numbers it’s 0. So, when performing bitwise AND operation with 1, odd numbers give 1, and even numbers give 0.
>
>
> Ex: 5 (101) -> 101
>
>
>
> & 001
>
>
>
> —-
>
>
>
> 001 , so this we can say it is an odd number.

C++

````
// A simple C++ program to check for even or odd
#include <iostream>
using namespace std;

bool isEven(int n) {
        if ((n & 1) == 0)
            return true;
        else
            return false;
}

int main() {
    int n = 101;
     if (isEven(n) == true)
        cout<<"true";
       else
        cout<<"false";

    return 0;
}

````

C

````
#include <math.h>
#include <stdio.h>

bool isEven(int n) {
         if ((n & 1) == 0)
            return true;
        else
            return false;
}

int main() {
    int n = 101;
    if (isEven) {
        printf("true");
    }
    else {
        printf("false");
    }
    return 0;
}

````

Java

````
// Java program to
// check for even or odd
class GfG {
    public static boolean isEven(int n){
        if ((n & 1) == 0)
            return true;
        else
            return false;
    }

    public static void main(String[] args) {
        int n = 101;
        if (isEven(n) == true)
            System.out.print("true");
        else
            System.out.print("false");
    }
}

````

Python

````
# A Python3 code program
# to check for even or odd
def isEven(n):

    # n&1 is 1, then odd, else even
    if (n & 1) == 0:
        return True
    else:
        return False

if __name__ == "__main__":
  n = 101
  if isEven(n):
      print("true")
  else:
      print("false")

````

C#

````
// C# program  to check for even or odd
using System;

class GfG {
    public static bool isEven(int n)   {
        if ((n & 1) == 0)
            return true;
        else
            return false;
    }

    public static void Main() {
        int n = 101;
        if (isEven(n) == true)
            Console.WriteLine("true");
        else
            Console.WriteLine("false");
    }
}

````

JavaScript

````
// A simple JavaScript program to
// check for even or odd

function isEven(n) {

 // n & 1 is 1, then odd, else even
 if ((n & 1) === 0) {
        return true;
    } else {
        return false;
    }
}

// Driver code
let n = 101;
if (isEven(n)) {
    console.log("true");
} else {
    console.log("false");
}

````




**Output**
```
false
```

****Time Complexity: O(1)****


****Auxiliary Space: O(1)****

### Using Bitwise Shift Operators – O(1) Time and O(1) Space

![](https://media.geeksforgeeks.org/wp-content/uploads/20221201114030/Group1.png)
C++

````
#include <bits/stdc++.h>
using namespace std;

bool isEven(int n) {
  if (n == (n >> 1) << 1) {
        return true;
    }
    else {
        return false;
    }
}

int main() {

  int n = 4;
  if (isEven(n) == true)
        cout<<"true";
   else
        cout<<"false";

    return 0;
}

````

Java

````
// Java program to
// check for even or odd
class GfG {
    public static boolean isEven(int n){
       if (n == (n >> 1) << 1)
            return true;
        else
            return false;
    }

    public static void main(String[] args) {
        int n = 4;
        if (isEven(n) == true)
            System.out.print("true");
        else
            System.out.print("false");
    }
}

````

Python

````
# A Python3 code program
# to check for even or odd
def isEven(n):

    if n == (n >> 1) << 1:
        return True
    else:
        return False

if __name__ == "__main__":
  n = 4
  if isEven(n):
      print("true")
  else:
      print("false")

````

C#

````
// C# program  to check for even or odd
using System;

class GfG {
    public static bool isEven(int n)   {
        if (n == (n >> 1) << 1)
            return true;
        else
            return false;
    }

    public static void Main() {
        int n = 4;
        if (isEven(n) == true)
            Console.WriteLine("true");
        else
            Console.WriteLine("false");
    }
}

````

JavaScript

````
// A simple JavaScript program to
// check for even or odd

function isEven(n) {

    if (n == (n >> 1) << 1)
       return true;
    else
       return false;
}

// Driver code
let n = 4;
if (isEven(n)) {
    console.log("true");
} else {
    console.log("false");
}

````




**Output**
```
true
```
', '', 'Check whether a given number is even or odd', 20, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('192cb6e4-14cd-4265-9d7d-7cbf5bc0817f', e'****Properties of Priority Queue****
------------------------------------

*****So, a priority Queue is an extension of the*****
[*****queue*****](https://www.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/)
*****with the following properties.*****

* Every item has a priority associated with it.
* An element with high priority is dequeued before an element with low priority.
* If two elements have the same priority, they are served according to their order in the queue.


In the below priority queue, an element with a maximum ASCII value will have the highest priority. The elements with higher priority are served first.


![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/Priority-Queue-min-1024x512.png)

****How is Priority assigned to the elements in a Priority Queue?****
---------------------------------------------------------------------


In a priority queue, generally, the value of an element is considered for assigning the priority.


For example, the element with the highest value is assigned the highest priority and the element with the lowest value is assigned the lowest priority. The reverse case can also be used i.e., the element with the lowest value can be assigned the highest priority. Also, the priority can be assigned according to our needs.


****Operations of a Priority Queue:****
---------------------------------------


A typical priority queue supports the following operations:


### ****1) Insertion in a Priority Queue****


When a new element is inserted in a priority queue, it moves to the empty slot from top to bottom and left to right. However, if the element is not in the correct place then it will be compared with the parent node. If the element is not in the correct order, the elements are swapped. The swapping process continues until all the elements are placed in the correct position.


### ****2) Deletion in a Priority Queue****


As you know that in a max heap, the maximum element is the root node. And it will remove the element which has maximum priority first. Thus, you remove the root node from the queue. This removal creates an empty slot, which will be further filled with new insertion. Then, it compares the newly inserted element with all the elements inside the queue to maintain the heap invariant.


### ****3) Peek in a Priority Queue****


This operation helps to return the maximum element from Max Heap or the minimum element from Min Heap without deleting the node from the priority queue.


Types of Priority Queue:
------------------------

### ****1) Ascending Order Priority Queue****


As the name suggests, in ascending order priority queue, the element with a lower priority value is given a higher priority in the priority list. For example, if we have the following elements in a priority queue arranged in ascending order like 4,6,8,9,10. Here, 4 is the smallest number, therefore, it will get the highest priority in a priority queue and so when we dequeue from this type of priority queue, 4 will remove from the queue and dequeue returns 4.


### ****2) Descending order Priority Queue****


The root node is the maximum element in a max heap, as you may know. It will also remove the element with the highest priority first. As a result, the root node is removed from the queue. This deletion leaves an empty space, which will be filled with fresh insertions in the future. The heap invariant is then maintained by comparing the newly inserted element to all other entries in the queue.


![Types of Priority Queues](https://media.geeksforgeeks.org/wp-content/uploads/20220623153252/priorityqueue.jpg)

Types of Priority Queues

****Difference between Priority Queue and Normal Queue?****
-----------------------------------------------------------


There is no priority attached to elements in a queue, the rule of first-in-first-out(FIFO) is implemented whereas, in a priority queue, the elements have a priority. The elements with higher priority are served first.


****How to Implement Priority Queue?****
----------------------------------------


Priority queue can be implemented using the following data structures:


* Arrays
* Linked list
* Heap data structure
* Binary search tree

****Let’s discuss all these in detail.****

### ****1) Implement Priority Queue Using Array:****


A simple implementation is to use an array of the following structure.


> struct item {
>
>
>
> int item;
>
>
>
> int priority;
>
>
>
> }

* ****enqueue():****
  This function is used to insert new data into the queue.
* ****dequeue():****
  This function removes the element with the highest priority from the queue.
* ****peek()/top():****
  This function is used to get the highest priority element in the queue without removing it from the queue.

C++

````
// C++ program to implement Priority Queue
// using Arrays
#include <bits/stdc++.h>
using namespace std;

// Structure for the elements in the
// priority queue
struct item {
    int value;
    int priority;
};

// Store the element of a priority queue
item pr[100000];

// Pointer to the last index
int size = -1;

// Function to insert a new element
// into priority queue
void enqueue(int value, int priority)
{
    // Increase the size
    size++;

    // Insert the element
    pr[size].value = value;
    pr[size].priority = priority;
}

// Function to check the top element
int peek()
{
    int highestPriority = INT_MIN;
    int ind = -1;

    // Check for the element with
    // highest priority
    for (int i = 0; i <= size; i++) {

        // If priority is same choose
        // the element with the
        // highest value
        if (highestPriority == pr[i].priority && ind > -1
            && pr[ind].value < pr[i].value) {
            highestPriority = pr[i].priority;
            ind = i;
        }
        else if (highestPriority < pr[i].priority) {
            highestPriority = pr[i].priority;
            ind = i;
        }
    }

    // Return position of the element
    return ind;
}

// Function to remove the element with
// the highest priority
void dequeue()
{
    // Find the position of the element
    // with highest priority
    int ind = peek();

    // Shift the element one index before
    // from the position of the element
    // with highest priority is found
    for (int i = ind; i < size; i++) {
        pr[i] = pr[i + 1];
    }

    // Decrease the size of the
    // priority queue by one
    size--;
}

// Driver Code
int main()
{
    // Function Call to insert elements
    // as per the priority
    enqueue(10, 2);
    enqueue(14, 4);
    enqueue(16, 4);
    enqueue(12, 3);

    // Stores the top element
    // at the moment
    int ind = peek();

    cout << pr[ind].value << endl;

    // Dequeue the top element
    dequeue();

    // Check the top element
    ind = peek();
    cout << pr[ind].value << endl;

    // Dequeue the top element
    dequeue();

    // Check the top element
    ind = peek();
    cout << pr[ind].value << endl;

    return 0;
}

````

Java

````
// Java program to implement Priority Queue
// using Arrays
import java.util.*;

// Structure for the elements in the
// priority queue
class item {
  public int value;
  public int priority;
};

class GFG {

  // Store the element of a priority queue
  static item[] pr = new item[100000];

  // Pointer to the last index
  static int size = -1;
  // Function to insert a new element
  // into priority queue
  static void enqueue(int value, int priority)
  {
    // Increase the size
    size++;

    // Insert the element
    pr[size] = new item();
    pr[size].value = value;
    pr[size].priority = priority;
  }

  // Function to check the top element
  static int peek()
  {
    int highestPriority = Integer.MIN_VALUE;
    int ind = -1;

    // Check for the element with
    // highest priority
    for (int i = 0; i <= size; i++) {

      // If priority is same choose
      // the element with the
      // highest value
      if (highestPriority == pr[i].priority
          && ind > -1
          && pr[ind].value < pr[i].value) {
        highestPriority = pr[i].priority;
        ind = i;
      }
      else if (highestPriority < pr[i].priority) {
        highestPriority = pr[i].priority;
        ind = i;
      }
    }

    // Return position of the element
    return ind;
  }

  // Function to remove the element with
  // the highest priority
  static void dequeue()
  {
    // Find the position of the element
    // with highest priority
    int ind = peek();

    // Shift the element one index before
    // from the position of the element
    // with highest priority is found
    for (int i = ind; i < size; i++) {
      pr[i] = pr[i + 1];
    }

    // Decrease the size of the
    // priority queue by one
    size--;
  }

  public static void main(String[] args)
  {
    // Function Call to insert elements
    // as per the priority
    enqueue(10, 2);
    enqueue(14, 4);
    enqueue(16, 4);
    enqueue(12, 3);

    // Stores the top element
    // at the moment
    int ind = peek();

    System.out.println(pr[ind].value);

    // Dequeue the top element
    dequeue();

    // Check the top element
    ind = peek();
    System.out.println(pr[ind].value);

    // Dequeue the top element
    dequeue();

    // Check the top element
    ind = peek();
    System.out.println(pr[ind].value);
  }
}

// this code is contributed by phasing17

````

Python

````
import sys

# Structure for the elements in the
# priority queue
class item :
    value = 0
    priority = 0
class GFG :

    # Store the element of a priority queue
    pr = [None] * (100000)

    # Pointer to the last index
    size = -1

    # Function to insert a new element
    # into priority queue
    @staticmethod
    def enqueue( value,  priority) :

        # Increase the size
        GFG.size += 1

        # Insert the element
        GFG.pr[GFG.size] = item()
        GFG.pr[GFG.size].value = value
        GFG.pr[GFG.size].priority = priority

    # Function to check the top element
    @staticmethod
    def  peek() :
        highestPriority = -sys.maxsize
        ind = -1

        # Check for the element with
        # highest priority
        i = 0
        while (i <= GFG.size) :

            # If priority is same choose
            # the element with the
            # highest value
            if (highestPriority == GFG.pr[i].priority and ind > -1 and GFG.pr[ind].value < GFG.pr[i].value) :
                highestPriority = GFG.pr[i].priority
                ind = i
            elif(highestPriority < GFG.pr[i].priority) :
                highestPriority = GFG.pr[i].priority
                ind = i
            i += 1

        # Return position of the element
        return ind

    # Function to remove the element with
    # the highest priority
    @staticmethod
    def dequeue() :

        # Find the position of the element
        # with highest priority
        ind = GFG.peek()

        # Shift the element one index before
        # from the position of the element
        # with highest priority is found
        i = ind
        while (i < GFG.size) :
            GFG.pr[i] = GFG.pr[i + 1]
            i += 1

        # Decrease the size of the
        # priority queue by one
        GFG.size -= 1
    @staticmethod
    def main( args) :

        # Function Call to insert elements
        # as per the priority
        GFG.enqueue(10, 2)
        GFG.enqueue(14, 4)
        GFG.enqueue(16, 4)
        GFG.enqueue(12, 3)

        # Stores the top element
        # at the moment
        ind = GFG.peek()
        print(GFG.pr[ind].value)

        # Dequeue the top element
        GFG.dequeue()

        # Check the top element
        ind = GFG.peek()
        print(GFG.pr[ind].value)

        # Dequeue the top element
        GFG.dequeue()

        # Check the top element
        ind = GFG.peek()
        print(GFG.pr[ind].value)

if __name__=="__main__":
    GFG.main([])

    # This code is contributed by aadityaburujwale.

````

C#

````
// C# program to implement Priority Queue
// using Arrays

using System;

// Structure for the elements in the
// priority queue
public class item {
    public int value;
    public int priority;
};


public class GFG
{

    // Store the element of a priority queue
    static item[] pr = new item[100000];

    // Pointer to the last index
    static int size = -1;
    // Function to insert a new element
    // into priority queue
    static void enqueue(int value, int priority)
    {
        // Increase the size
        size++;

        // Insert the element
        pr[size] = new item();
        pr[size].value = value;
        pr[size].priority = priority;
    }

    // Function to check the top element
    static int peek()
    {
        int highestPriority =  int.MinValue;
        int ind = -1;

        // Check for the element with
        // highest priority
        for (int i = 0; i <= size; i++) {

            // If priority is same choose
            // the element with the
            // highest value
            if (highestPriority == pr[i].priority && ind > -1
                && pr[ind].value < pr[i].value) {
                highestPriority = pr[i].priority;
                ind = i;
            }
            else if (highestPriority < pr[i].priority) {
                highestPriority = pr[i].priority;
                ind = i;
            }
        }

        // Return position of the element
        return ind;
    }

    // Function to remove the element with
    // the highest priority
    static void dequeue()
    {
        // Find the position of the element
        // with highest priority
        int ind = peek();

        // Shift the element one index before
        // from the position of the element
        // with highest priority is found
        for (int i = ind; i < size; i++) {
            pr[i] = pr[i + 1];
        }

        // Decrease the size of the
        // priority queue by one
        size--;
    }

    public static void Main(string[] args)
    {
         // Function Call to insert elements
        // as per the priority
        enqueue(10, 2);
        enqueue(14, 4);
        enqueue(16, 4);
        enqueue(12, 3);

        // Stores the top element
        // at the moment
        int ind = peek();

        Console.WriteLine(pr[ind].value);

        // Dequeue the top element
        dequeue();

        // Check the top element
        ind = peek();
        Console.WriteLine(pr[ind].value);

        // Dequeue the top element
        dequeue();

        // Check the top element
        ind = peek();
        Console.WriteLine(pr[ind].value);
    }
}

//this code is contributed by phasing17

````

JavaScript

````
// JavaScript program to implement Priority Queue
// using Arrays

// Structure for the elements in the
// priority queue
class item {
    constructor()
    {
        this.value;
        this.priority;
    }
};

// Store the element of a priority queue
let pr = [];
for (var i = 0; i < 100000; i++)
    pr.push(new item());

// Pointer to the last index
let size = -1;

// Function to insert a new element
// into priority queue
function enqueue(value, priority)
{
    // Increase the size
    size++;

    // Insert the element
    pr[size] = new item();
    pr[size].value = value;
    pr[size].priority = priority;
}

// Function to check the top element
function peek()
{
    let highestPriority = Number.MIN_SAFE_INTEGER;
    let ind = -1;

    // Check for the element with
    // highest priority
    for (var i = 0; i <= size; i++) {

        // If priority is same choose
        // the element with the
        // highest value
        if (highestPriority == pr[i].priority && ind > -1
            && pr[ind].value < pr[i].value) {
            highestPriority = pr[i].priority;
            ind = i;
        }
        else if (highestPriority < pr[i].priority) {
            highestPriority = pr[i].priority;
            ind = i;
        }
    }

    // Return position of the element
    return ind;
}

// Function to remove the element with
// the highest priority
function dequeue()
{
    // Find the position of the element
    // with highest priority
    let ind = peek();

    // Shift the element one index before
    // from the position of the element
    // with highest priority is found
    for (var i = ind; i < size; i++) {
        pr[i] = pr[i + 1];
    }

    // Decrease the size of the
    // priority queue by one
    size--;
}

// Function Call to insert elements
// as per the priority
enqueue(10, 2);
enqueue(14, 4);
enqueue(16, 4);
enqueue(12, 3);

// Stores the top element
// at the moment
let ind = peek();

console.log(pr[ind].value);

// Dequeue the top element
dequeue();

// Check the top element
ind = peek();
console.log(pr[ind].value);

// Dequeue the top element
dequeue();

// Check the top element
ind = peek();
console.log(pr[ind].value);

// this code is contributed by phasing17

````




**Output**
```
16
14
12
```
> ****Note:****
> Read
>
> [****this article****](https://www.geeksforgeeks.org/priority-queue-using-array-in-c/)
>
> for more details.

### ****2) Implement Priority Queue Using Linked List:****


In a LinkedList implementation, the entries are sorted in descending order based on their priority. The highest priority element is always added to the front of the priority queue, which is formed using linked lists. The functions like

****push()****
,

****pop()****
, and

****peek()****
are used to implement a priority queue using a linked list and are explained as follows:


* ****push():****
  This function is used to insert new data into the queue.
* ****pop():****
  This function removes the element with the highest priority from the queue.
* ****peek() / top():****
  This function is used to get the highest priority element in the queue without removing it from the queue.

C++

````
// C++ code to implement Priority Queue
// using Linked List
#include <bits/stdc++.h>
using namespace std;

// Node
typedef struct node {
    int data;

    // Lower values indicate
    // higher priority
    int priority;

    struct node* next;

} Node;

// Function to create a new node
Node* newNode(int d, int p)
{
    Node* temp = (Node*)malloc(sizeof(Node));
    temp->data = d;
    temp->priority = p;
    temp->next = NULL;

    return temp;
}

// Return the value at head
int peek(Node** head) { return (*head)->data; }

// Removes the element with the
// highest priority form the list
void pop(Node** head)
{
    Node* temp = *head;
    (*head) = (*head)->next;
    free(temp);
}

// Function to push according to priority
void push(Node** head, int d, int p)
{
    Node* start = (*head);

    // Create new Node
    Node* temp = newNode(d, p);

    // Special Case: The head of list has
    // lesser priority than new node
    if ((*head)->priority < p) {

        // Insert New Node before head
        temp->next = *head;
        (*head) = temp;
    }
    else {

        // Traverse the list and find a
        // position to insert new node
        while (start->next != NULL
               && start->next->priority > p) {
            start = start->next;
        }

        // Either at the ends of the list
        // or at required position
        temp->next = start->next;
        start->next = temp;
    }
}

// Function to check is list is empty
int isEmpty(Node** head) { return (*head) == NULL; }

// Driver code
int main()
{

    // Create a Priority Queue
    // 7->4->5->6
    Node* pq = newNode(4, 1);
    push(&pq, 5, 2);
    push(&pq, 6, 3);
    push(&pq, 7, 0);

    while (!isEmpty(&pq)) {
        cout << " " << peek(&pq);
        pop(&pq);
    }
    return 0;
}

````

Java

````
// Java code to implement Priority Queue
// using Linked List
import java.util.* ;

class Solution
{

// Node
static class Node {
    int data;

    // Lower values indicate higher priority
    int priority;
    Node next;

}

static Node node = new Node();

// Function to Create A New Node
static Node newNode(int d, int p)
{
    Node temp = new Node();
    temp.data = d;
    temp.priority = p;
    temp.next = null;

    return temp;
}

// Return the value at head
static int peek(Node head)
{
    return (head).data;
}

// Removes the element with the
// highest priority from the list
static Node pop(Node head)
{
    Node temp = head;
    (head) = (head).next;
    return head;
}

// Function to push according to priority
static Node push(Node head, int d, int p)
{
    Node start = (head);

    // Create new Node
    Node temp = newNode(d, p);

    // Special Case: The head of list has lesser
    // priority than new node. So insert new
    // node before head node and change head node.
    if ((head).priority < p) {

        // Insert New Node before head
        temp.next = head;
        (head) = temp;
    }
    else {

        // Traverse the list and find a
        // position to insert new node
        while (start.next != null &&
            start.next.priority > p) {
            start = start.next;
        }

        // Either at the ends of the list
        // or at required position
        temp.next = start.next;
        start.next = temp;
    }
    return head;
}

// Function to check is list is empty
static int isEmpty(Node head)
{
    return ((head) == null)?1:0;
}

// Driver code
public static void main(String args[])
{
    // Create a Priority Queue
    // 7.4.5.6
    Node pq = newNode(4, 1);
    pq =push(pq, 5, 2);
    pq =push(pq, 6, 3);
    pq =push(pq, 7, 0);

    while (isEmpty(pq)==0) {
        System.out.printf("%d ", peek(pq));
        pq=pop(pq);
    }

}
}

// This code is contributed by ishankhandelwals.

````

Python

````
# Python3 code to implement Priority Queue
# using Singly Linked List

# Class to create new node which includes
# Node Data, and Node Priority
class PriorityQueueNode:

    def _init_(self, value, pr):

        self.data = value
        self.priority = pr
        self.next = None

# Implementation of Priority Queue


class PriorityQueue:

    def _init_(self):

        self.front = None

    # Method to check Priority Queue is Empty
    # or not if Empty then it will return True
    # Otherwise False
    def isEmpty(self):

        return True if self.front == None else False

    # Method to add items in Priority Queue
    # According to their priority value
    def push(self, value, priority):

        # Condition check for checking Priority
        # Queue is empty or not
        if self.isEmpty() == True:

            # Creating a new node and assigning
            # it to class variable
            self.front = PriorityQueueNode(value,
                                           priority)

            # Returning 1 for successful execution
            return 1

        else:

            # Special condition check to see that
            # first node priority value
            if self.front.priority < priority:

                # Creating a new node
                newNode = PriorityQueueNode(value,
                                            priority)

                # Updating the new node next value
                newNode.next = self.front

                # Assigning it to self.front
                self.front = newNode

                # Returning 1 for successful execution
                return 1

            else:

                # Traversing through Queue until it
                # finds the next smaller priority node
                temp = self.front

                while temp.next:

                    # If same priority node found then current
                    # node will come after previous node
                    if priority >= temp.next.priority:
                        break

                    temp = temp.next

                newNode = PriorityQueueNode(value,
                                            priority)
                newNode.next = temp.next
                temp.next = newNode

                # Returning 1 for successful execution
                return 1

    # Method to remove high priority item
    # from the Priority Queue
    def pop(self):

        # Condition check for checking
        # Priority Queue is empty or not
        if self.isEmpty() == True:
            return

        else:

            # Removing high priority node from
            # Priority Queue, and updating front
            # with next node
            self.front = self.front.next
            return 1

    # Method to return high priority node
    # value Not removing it
    def peek(self):

        # Condition check for checking Priority
        # Queue is empty or not
        if self.isEmpty() == True:
            return
        else:
            return self.front.data

    # Method to Traverse through Priority
    # Queue
    def traverse(self):

        # Condition check for checking Priority
        # Queue is empty or not
        if self.isEmpty() == True:
            return "Queue is Empty!"
        else:
            temp = self.front
            while temp:
                print(temp.data, end=" ")
                temp = temp.next


# Driver code
if _name_ == "_main_":

    # Creating an instance of Priority
    # Queue, and adding values
    # 7 -> 4 -> 5 -> 6
    pq = PriorityQueue()
    pq.push(4, 1)
    pq.push(5, 2)
    pq.push(6, 3)
    pq.push(7, 0)

    # Traversing through Priority Queue
    pq.traverse()

    # Removing highest Priority item
    # for priority queue
    pq.pop()

````

C#

````
// C# code to implement Priority Queue
// using Linked List
using System;

class GFG
{
  // Node
  public class Node
  {
    public int data;

    // Lower values indicate
    // higher priority
    public int priority;

    public Node next;
  }

  public static Node node = new Node();

  // Function to Create A New Node
  public static Node newNode(int d, int p)
  {
    Node temp = new Node();
    temp.data = d;
    temp.priority = p;
    temp.next = null;

    return temp;
  }

  // Return the value at head
  public static int peek(Node head)
  {
    return (head).data;
  }

  // Removes the element with the
  // highest priority from the list
  public static Node pop(Node head)
  {
    Node temp = head;
    (head) = (head).next;
    return head;
  }

  // Function to push according to priority
  public static Node push(Node head,
                          int d, int p)
  {
    Node start = (head);

    // Create new Node
    Node temp = newNode(d, p);

    // Special Case: The head of list
    // has lesser priority than new node.
    // So insert new node before head node
    // and change head node.
    if ((head).priority < p)
    {

      // Insert New Node before head
      temp.next = head;
      (head) = temp;
    }
    else
    {

      // Traverse the list and find a
      // position to insert new node
      while (start.next != null &&
             start.next.priority > p)
      {
        start = start.next;
      }

      // Either at the ends of the list
      // or at required position
      temp.next = start.next;
      start.next = temp;
    }
    return head;
  }

  // Function to check is list is empty
  public static int isEmpty(Node head)
  {
    return ((head) == null) ? 1 : 0;
  }

  // Driver code
  public static void Main(string[] args)
  {
    // Create a Priority Queue
    // 7.4.5.6
    Node pq = newNode(4, 1);
    pq = push(pq, 5, 2);
    pq = push(pq, 6, 3);
    pq = push(pq, 7, 0);

    while (isEmpty(pq) == 0)
    {
      Console.Write("{0:D} ", peek(pq));
      pq = pop(pq);
    }
  }
}

// This code is contributed by ishankhandelwals.

````

JavaScript

````
// JavaScript code to implement Priority Queue
// using Linked List
// Node
class Node {

    // Lower values indicate
    // higher priority
    constructor() {
        this.data = 0;
        this.priority = 0;
        this.next = null;
    }
}

var node = new Node();

// Function to Create A New Node
function newNode(d, p) {
    var temp = new Node();
    temp.data = d;
    temp.priority = p;
    temp.next = null;

    return temp;
}

// Return the value at head
function peek(head) {
    return head.data;
}

// Removes the element with the
// highest priority from the list
function pop(head) {
    var temp = head;
    head = head.next;
    return head;
}

// Function to push according to priority
function push(head, d, p) {
    var start = head;

    // Create new Node
    var temp = newNode(d, p);

    // Special Case: The head of list
    // has lesser priority than new node.
    // So insert new node before head node
    // and change head node.
    if (head.priority < p) {

        // Insert New Node before head
        temp.next = head;
        head = temp;
    }
    else {

        // Traverse the list and find a
        // position to insert new node
        while (start.next != null && start.next.priority > p) {
            start = start.next;
        }

        // Either at the ends of the list
        // or at required position
        temp.next = start.next;
        start.next = temp;
    }
    return head;
}

// Function to check is list is empty
function isEmpty(head) {
    return head == null ? 1 : 0;
}

// Driver code
// Create a Priority Queue
// 7.4.5.6
var pq = newNode(4, 1);
pq = push(pq, 5, 2);
pq = push(pq, 6, 3);
pq = push(pq, 7, 0);

while (isEmpty(pq) == 0) {
    console.log(peek(pq)," ");
    pq = pop(pq);
}

// This code is contributed by ishankhandelwals.

````




**Output**
```
 6 5 4 7
```


Refer to

[this article](https://www.geeksforgeeks.org/priority-queue-using-linked-list/)
for more details.


> ****Note:****
> We can also use Linked List, time complexity of all operations with linked list remains same as array. The advantage with linked list is
>
>
> deleteHighestPriority()
>
>
> can be more efficient as we don’t have to move items.

### ****3) Implement Priority Queue Using Heaps:****


Binary Heap is generally preferred for priority queue implementation because heaps provide better performance compared to arrays or LinkedList. Considering the properties of a heap, The entry with the largest key is on the top and can be removed immediately. It will, however, take time O(log n) to restore the heap property for the remaining keys. However if another entry is to be inserted immediately, then some of this time may be combined with the O(log n) time needed to insert the new entry. Thus the representation of a priority queue as a heap proves advantageous for large n, since it is represented efficiently in contiguous storage and is guaranteed to require only logarithmic time for both insertions and deletions. Operations on Binary Heap are as follows:


* ****insert(p):****
  Inserts a new element with priority p.
* ****extractMax():****
  Extracts an element with maximum priority.
* ****remove(i):****
  Removes an element pointed by an iterator i.
* ****getMax():****
  Returns an element with maximum priority.
* ****changePriority(i, p):****
  Changes the priority of an element pointed by

  ****i to p****
  .

> Refer to
>
> [this article](https://www.geeksforgeeks.org/priority-queue-using-binary-heap/)
> for code implementation.

### ****4) Implement Priority Queue Using Binary Search Tree:****


A Self-Balancing Binary Search Tree like AVL Tree, Red-Black Tree, etc. can also be used to implement a priority queue. Operations like peek(), insert() and delete() can be performed using BST.


****Applications of Priority Queue:****
---------------------------------------

* CPU Scheduling
* Graph algorithms like

  [Dijkstra’s shortest path algorithm](https://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/)
  ,

  [Prim’s Minimum Spanning Tree](https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/)
  , etc.
* All

  [queue applications](https://www.geeksforgeeks.org/applications-of-queue-data-structure/)
  where priority is involved.
* Data compression in Huffman code
* Event-driven simulation such as customers waiting in a queue.
* Finding Kth largest/smallest element.

****Advantages of Priority Queue:****
-------------------------------------

* It helps to access the elements in a faster way. This is because elements in a priority queue are ordered by priority, one can easily retrieve the highest priority element without having to search through the entire queue.
* The ordering of elements in a Priority Queue is done dynamically. Elements in a priority queue can have their priority values updated, which allows the queue to dynamically reorder itself as priorities change.
* Efficient algorithms can be implemented. Priority queues are used in many algorithms to improve their efficiency, such as Dijkstra’s algorithm for finding the shortest path in a graph and the A\\* search algorithm for pathfinding.
* Included in real-time systems. This is because priority queues allow you to quickly retrieve the highest priority element, they are often used in real-time systems where time is of the essence.

****Disadvantages of Priority Queue:****
----------------------------------------

* High complexity. Priority queues are more complex than simple data structures like arrays and linked lists, and may be more difficult to implement and maintain.
* High consumption of memory. Storing the priority value for each element in a priority queue can take up additional memory, which may be a concern in systems with limited resources.
* It is not always the most efficient data structure. In some cases, other data structures like heaps or binary search trees may be more efficient for certain operations, such as finding the minimum or maximum element in the queue.
* At times it is less predictable:. This is because the order of elements in a priority queue is determined by their priority values, the order in which elements are retrieved may be less predictable than with other data structures like stacks or queues, which follow a first-in, first-out (FIFO) or last-in, first-out (LIFO) order.
', 'A priority queue is a type of queue that arranges elements based on their priority values. Elements with higher priority values are typically retrieved or removed before elements with lower priority values. Each element has a priority value associated with it. When we add an item, it is inserted in a position based on its priority value.', 'What is Priority Queue | Introduction to Priority Queue', 10, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('7106768d-cb8a-49a3-b944-1aa4e1266f10', e'Need of Recursive Function:
---------------------------


A recursive function is a function that solves a problem by solving smaller instances of the same problem. This technique is often used in programming to solve problems that can be broken down into simpler, similar subproblems.


### 1. ****Solving complex tasks:****


Recursive functions break complex problems into smaller instances of the same problem, resulting in compact and readable code.


### 2. Divide and Conquer:


Recursive functions are suitable for divide-and-conquer algorithms such as merge sort and quicksort, breaking problems into smaller subproblems, solving them recursively, and merging the solution with the original problem.


### 3. ****Backtracking**** :


Recursive backtracking is ideal for exploring and solving problems like N-Queens and Sudoku.



### 4. Dynamic ****programming:****


Recursive functions efficiently solve dynamic programming problems by solving subproblems and combining their solution into a complete solution.


### 5. Tree and ****graph structures:****


Recursive functions are great for working with tree and graph structures, simplifying traversal and pattern recognition tasks

****.****

How to write a Recursive Function:
----------------------------------

### Components of a recursive function:

****Base case:****
Every recursive function must have a base case. The base case is the simplest scenario that does not require further recursion. This is a termination condition that prevents the function from calling itself indefinitely. Without a proper base case, a recursive function can lead to infinite recursion.


****Recursive case:****
In the recursive case, the function calls itself with the modified arguments. This is the essence of recursion – solving a larger problem by breaking it down into smaller instances of the same problem. The recursive case should move closer to the base case with each iteration.


Let’s consider the example of

[factorial of number](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/)
:


In this example, the base case is when

****n****
is

****0****
, and the function returns

****1****
. The recursive case multiplies

****n****
with the result of the function called with parameter

****n – 1****
. The process continues until the base case is reached.


It’s essential to ensure that the recursive function has a correct base case and that the recursive calls lead to the base case, otherwise, the procedure might run indefinitely, leading to a stack overflow (exceeding the available memory allocated for function calls).


Below is the implementation of factorial of a number:


C++

````
#include <iostream>
using namespace std;

// Recursive Function to calculate Factorial of a number
int factorial(int n)
{
    // Base case
    if (n == 0) {
        return 1;
    }

    // Recursive case
    return n * factorial(n - 1);
}

// Driver Code

int main()
{
    int n = 4;

    cout << "Factorial of " << n
         << " is:" << factorial(n);
    return 0;
}

````

Java

````
import java.util.Scanner;

public class Factorial {
    // Recursive Function to calculate the factorial of a number
    static int factorial(int n) {
        // Base case: If n is 0, the factorial is 1.
        if (n == 0) {
            return 1;
        }

        // Recursive case: Calculate the factorial by multiplying n with the factorial of (n - 1).
        return n * factorial(n - 1);
    }

    public static void main(String[] args) {
        int n = 4;

        // Calculate and print the factorial of n.
        int result = factorial(n);
        System.out.println("Factorial of " + n + " is: " + result);
    }
}

````

Python

````
# Recursive Function to calculate Factorial of a number
def factorial(n):
    # Base case
    if n == 0:
        return 1

    # Recursive case
    return n * factorial(n - 1)

# Driver Code
if __name__ == "__main__":
    n = 4

    print("Factorial of", n, "is:", factorial(n))

````

C#

````
using System;

class Program
{
    // Recursive Function to calculate Factorial of a number
    static int Factorial(int n)
    {
        // Base case
        if (n == 0)
        {
            return 1;
        }

        // Recursive case
        return n * Factorial(n - 1);
    }

    // Driver Code
    static void Main()
    {
        int n = 4;

        Console.WriteLine("Factorial of " + n + " is: " + Factorial(n));
    }
}

````

JavaScript

````
// Function to calculate the factorial of a number using recursion
function factorial(n) {
    // Base case: If n is 0, the factorial is 1.
    if (n === 0) {
        return 1;
    }

    // Recursive case: Calculate the factorial by multiplying n with the factorial of (n - 1).
    return n * factorial(n - 1);
}

// Main function
function main() {
    // Given number
    let n = 4;

    // Calculate the factorial of n.
    let result = factorial(n);

    // Print the result
    console.log("Factorial of " + n + " is: " + result);
}

// Call the main function
main();

````




**Output**
```
Factorial of 4 is:24
```

****Time Complexity:****
O(n)



****Auxiliary Space:****
O(n)

', 'In other words, a recursive function is a function that solves a problem by solving smaller instances of the same problem. This technique is commonly used in programming to solve problems that can be broken down into simpler, similar subproblems.', 'Recursive Functions', 11, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('6477db8f-1fdf-4441-80b4-09122d290265', e'
[Factorial](https://www.geeksforgeeks.org/factorial/)
of a number

****n****
is defined as the product of all the

****positive****
numbers less than n. In other words, Factorial of a number

****n****
can be calculated as:

****n × (n – 1) × (n – 2) × … × 1.****
Factorial of a number n is denoted as

****n!****
. It is widely used in Combinatorics and Algebra to find the number of ways to arrange or select items.


****Examples:****

> ****0!****
> = 1
>
>
> ****1!****
> = 1
>
>
> ****3!****
> = 3 x 2 x 1 = 6


Here is a list of problems based on Factorial.


* [Factorial of a Number](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/)
* [Check Factorial](https://www.geeksforgeeks.org/check-if-a-given-number-is-factorial-of-any-number/)
* [Factorial of Large number](https://www.geeksforgeeks.org/factorial-large-number/)
* [Count trailing zeroes](https://www.geeksforgeeks.org/count-trailing-zeroes-factorial-number/)
* [Sum of Digits](https://www.geeksforgeeks.org/find-sum-digits-factorial-number/)
* [Double Factorial](https://www.geeksforgeeks.org/double-factorial/)
* [Last Non-Zero digit](https://www.geeksforgeeks.org/last-non-zero-digit-factorial/)
* [Check Strong Number](https://www.geeksforgeeks.org/program-to-check-strong-number/)
* [Factorial without Multiplication](https://www.geeksforgeeks.org/factorial-of-a-number-without-using-multiplication/)
* [Length of factorial](https://www.geeksforgeeks.org/find-the-length-of-factorial-of-a-number-in-any-given-base/)
* [Sum of Factorials till N (1! + 2! + 3! + … + N!)](https://www.geeksforgeeks.org/find-sum-of-factorials-till-n-factorial-1-2-3-n/)
* [Smallest number at least n trailing zeroes](https://www.geeksforgeeks.org/smallest-number-least-n-trailing-zeroes-factorial/)
* [Factorial of an Array](https://www.geeksforgeeks.org/factorial-of-an-array-of-integers/)
* [K-th Prime Factor](https://www.geeksforgeeks.org/k-th-prime-factor-given-number/)
* [nCr](https://www.geeksforgeeks.org/program-calculate-value-ncr/)
* [Ways to go from one point to another](https://www.geeksforgeeks.org/number-of-ways-to-go-from-one-point-to-another-in-a-grid/)
* [Check Krishnamurthy Number](https://www.geeksforgeeks.org/check-if-a-number-is-a-krishnamurthy-number-or-not-2/)
* [nCr using Fermat Little Theorem](https://www.geeksforgeeks.org/compute-ncrp-using-fermat-little-theorem/)
* [Ways to arrange K different objects](https://www.geeksforgeeks.org/number-of-ways-to-arrange-k-different-objects-taking-n-objects-at-a-time/)

> Recommended Links
>
>
> * [Factorial Formula](https://www.geeksforgeeks.org/factorial-formula/)
> * [Interesting Facts about Factorial](https://www.geeksforgeeks.org/interesting-facts-about-factorial/)
', '', 'Factorial Coding Problems', 21, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('e87fc291-5b1a-497b-ad5b-54a15743ed1f', e'
[Prime Numbers](https://www.geeksforgeeks.org/prime-numbers/)
are natural numbers greater than 1 and can be divided by itself and 1 only. For instance, numbers 2, 3, 5, 7, and 11 are the prime numbers since they can only be divided by 1 and themselves, there is no other number that can fully divide them Since it is manually very difficult to check if a number is prime (no direct formula) and find prime factors, problems related to prime become really interesting coding problems.


Here is a list of example problems based on prime.


* [Check for Prime Number](https://www.geeksforgeeks.org/check-for-prime-number/)
* [All Prime Factors](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)
* [Largest Prime Factor](https://www.geeksforgeeks.org/find-largest-prime-factor-number/)
* [Check for Co-Prime](https://www.geeksforgeeks.org/count-number-of-primes-in-an-array/)
* [Primes in an Array](https://www.geeksforgeeks.org/find-two-prime-numbers-with-given-sum/)
* [Primes with Given Sum](https://www.geeksforgeeks.org/pair-of-prime-numbers-with-a-given-sum-and-minimum-absolute-difference/)
* [Pair of Primes with Given Sum and Min Diff](https://www.geeksforgeeks.org/pair-of-prime-numbers-with-a-given-sum-and-minimum-absolute-difference/)
* [Prime Number Gap](https://www.geeksforgeeks.org/minimum-difference-between-any-two-primes-from-the-given-range/)
* [Find the next prime](https://www.geeksforgeeks.org/program-to-find-the-next-prime-number/)
* [Check for Strong Prime](https://www.geeksforgeeks.org/check-if-n-is-strong-prime/)
* [Closest Prime](https://www.geeksforgeeks.org/count-of-n-digit-numbers-which-contains-all-single-digit-primes/)
* [N Digit Numbers with Prime Digits](https://www.geeksforgeeks.org/count-of-n-digit-numbers-which-contains-all-single-digit-primes/)
* [Sieve of Eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)
* [Nth Prime Number](https://www.geeksforgeeks.org/program-to-find-the-nth-prime-number/)
* [Program to print prime numbers from 1 to N.](https://www.geeksforgeeks.org/program-to-print-first-n-prime-numbers/)
* [Segmented Sieve](https://www.geeksforgeeks.org/segmented-sieve/)', '', 'Prime Number Coding Problems', 22, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('28f5205e-a507-4ef7-aaf7-73b013044326', e'
### ****Mathematical Concepts:****

* [Numbers](https://www.geeksforgeeks.org/numbers-aptitude-questions-and-answers/)
* [Prime Numbers](https://www.geeksforgeeks.org/prime-numbers/)
* [Arithmetic Progression](https://www.geeksforgeeks.org/what-is-arithmetic-progression/)
* [Geometric Progression](https://www.geeksforgeeks.org/what-is-geometric-progression/)
* [GCD](https://www.geeksforgeeks.org/greatest-common-divisor-gcd/)
  and

  [LCM](https://www.geeksforgeeks.org/lcm-least-common-multiple/)
* [Factorial](https://www.geeksforgeeks.org/factorial/)
* [Permutation](https://www.geeksforgeeks.org/permutation/)
  and

  [Combination](https://www.geeksforgeeks.org/combinations/)
* [Catalan Number](https://www.geeksforgeeks.org/catalan-numbers/)
* [Modular Arithmetic](https://www.geeksforgeeks.org/modular-arithmetic/)

### ****Basic Problems****

* [Sum of Naturals](https://www.geeksforgeeks.org/program-find-sum-first-n-natural-numbers/)
* [Sum of Squares of Naturals](https://www.geeksforgeeks.org/sum-of-squares-of-first-n-natural-numbers/)
* [Nth Term of AP](https://www.geeksforgeeks.org/program-n-th-term-arithmetic-progression-series/)
* [Nth Term of GP](https://www.geeksforgeeks.org/find-nth-term-geometric-progression-series/)
* [Nth Triangular Number](https://www.geeksforgeeks.org/triangular-numbers/)
* [Sum of Sums of Natural Numbers](https://www.geeksforgeeks.org/sum-of-first-n-natural-numbers/)
* [Count Digits](https://www.geeksforgeeks.org/program-count-digits-integer-3-different-methods/)
* [Sum of Digits](https://www.geeksforgeeks.org/program-for-sum-of-the-digits-of-a-given-number/)
* [Reverse Digits](https://www.geeksforgeeks.org/write-a-program-to-reverse-digits-of-a-number/)
* [K-th Digit in a^b](https://www.geeksforgeeks.org/k-th-digit-raised-power-b/)
* [Palindrome Number](https://www.geeksforgeeks.org/check-if-a-number-is-palindrome/)
* [GCD of Two Numbers](https://www.geeksforgeeks.org/program-to-find-lcm-of-two-numbers/)
* [LCM of Two Numbers](https://www.geeksforgeeks.org/program-to-find-lcm-of-two-numbers/)
* [Add two fractions](https://www.geeksforgeeks.org/program-to-add-two-fractions/)
* [Check for Co-Prime](https://www.geeksforgeeks.org/check-two-numbers-co-prime-not/)
* [Factorial of a Number](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/)
* [GCD of more than 2](https://www.geeksforgeeks.org/gcd-two-array-numbers/)
* [LCM of more than 2](https://www.geeksforgeeks.org/lcm-of-given-array-elements/)
* [Padovan Sequence](https://www.geeksforgeeks.org/padovan-sequence/)

### ****Easy Problems****

* [Pair Cube Count](https://www.geeksforgeeks.org/count-pairs-a-b-whose-sum-of-cubes-is-n-a3-b3-n/)
* [Sum of 2, 22, 222, ………](https://www.geeksforgeeks.org/sum-sequence-2-22-222/)
* [Sum of 1^2 + 3^2 + 5^2 + . . . + (2\\*n – 1)^2](https://www.geeksforgeeks.org/sum-series-12-32-52-2n-12/)
* [Sum of 0.6, 0.06, 0.006, 0.0006, …to n terms](https://www.geeksforgeeks.org/sum-series-0-6-0-06-0-006-0-0006-n-terms/)
* [n-th term of 2, 12, 36, 80, 150….](https://www.geeksforgeeks.org/n-th-term-series-2-12-36-80-150/)
* [Digit Root](https://www.geeksforgeeks.org/digital-rootrepeated-digital-sum-given-integer/)
* [Fibonacci Numbers](https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/)
* [Lucas Number](https://www.geeksforgeeks.org/lucas-numbers/)
* [Check for Power](https://www.geeksforgeeks.org/check-if-a-number-is-power-of-another-number/)
* [Three Divisors](https://www.geeksforgeeks.org/numbers-exactly-3-divisors/)
* [Square Root](https://www.geeksforgeeks.org/square-root-of-an-integer/)
* [Binomial Coefficient](https://www.geeksforgeeks.org/binomial-coefficient-dp-9/)
* [Pascal Triangle](https://www.geeksforgeeks.org/pascal-triangle/)
* [nth Row of the Pascal Triangle](https://www.geeksforgeeks.org/find-the-nth-row-in-pascals-triangle/)
* [Armstrong Numbers](https://www.geeksforgeeks.org/program-for-armstrong-numbers/)
* [Determinant of a Matrix](https://www.geeksforgeeks.org/determinant-of-a-matrix/)
* [Modular Exponentiation](https://www.geeksforgeeks.org/modular-exponentiation-power-in-modular-arithmetic/)
* [Check for Perfect Squares](https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/)
* [Divisibility by 3](https://www.geeksforgeeks.org/check-large-number-divisible-3-not/)
* [Divisibility by 4](https://www.geeksforgeeks.org/check-large-number-divisible-4-not/)
* [Divisibility by 7](https://www.geeksforgeeks.org/divisibility-by-7/)
* [Divisibility by 11](https://origin.geeksforgeeks.org/check-large-number-divisible-11-not/)
* [Divisibility by 13](https://www.geeksforgeeks.org/check-large-number-divisible-13-not/)
* [Divisibility by 29](https://www.geeksforgeeks.org/number-is-divisible-by-29-or-not/)

### ****Medium Problems****

* [Linear Diophantine Equations](https://www.geeksforgeeks.org/eulers-totient-function/)
* [Euler\'s Totient Function](https://www.geeksforgeeks.org/eulers-totient-function/)
* [Sieve of Eratosthenes](https://www.geeksforgeeks.org/find-all-factors-of-a-natural-number/)
* [All Divisors](https://www.geeksforgeeks.org/prime-factor/)
* [Prime Factorization](https://www.geeksforgeeks.org/find-largest-prime-factor-number/)
* [Largest Prime Factor](https://www.geeksforgeeks.org/factorial-large-number/)
* [Factorial of a Large Number](https://www.geeksforgeeks.org/factorial-large-number/)
* [Largest Power Divisible in Factorial](https://www.geeksforgeeks.org/largest-power-k-n-factorial-k-may-not-prime/)
* [Last Non-zero Digit of Factorial](https://www.geeksforgeeks.org/last-non-zero-digit-factorial/)
* [Power Set](https://www.geeksforgeeks.org/power-set/)
* [Add Two Polynomials](https://www.geeksforgeeks.org/program-add-two-polynomials/)
* [All Permutations of a String](https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/)
* [Next Permutation](https://www.geeksforgeeks.org/next-permutation/)
* [Check for Carmichael Numbers](https://www.geeksforgeeks.org/carmichael-numbers/)
* [Collatz sequence](https://www.geeksforgeeks.org/program-to-print-collatz-sequence/)
* [Grid Unique Paths](https://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/)
* [Nth Even Fibonacci Number](https://www.geeksforgeeks.org/nth-even-fibonacci-number/)
* [Last 2 Digits of Nth Fibonacci](https://www.geeksforgeeks.org/program-find-last-two-digits-nth-fibonacci-number/)

### ****Hard Problems****

* [Josephus Problem](https://www.geeksforgeeks.org/josephus-problem/)
* [Water Jug Tutorial](https://www.geeksforgeeks.org/water-jug-problem-complete-tutorial/)
* [Segmented Sieve](https://www.geeksforgeeks.org/segmented-sieve/)
* [k-th prime factor](https://www.geeksforgeeks.org/k-th-prime-factor-given-number/)
* [N-th Root](https://www.geeksforgeeks.org/n-th-root-number/)
* [Sum of Digits in Factorial](https://www.geeksforgeeks.org/find-sum-digits-factorial-number/)
* [Egg Dropping](https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/)
* [Next String](https://www.geeksforgeeks.org/lexicographically-next-string/)', e'The following is the list of mathematical concepts and related coding problems. The coding problems are ordered according to difficulty level. Please refer
Mathematical Algorithms (Topic Wise) for the topic wise list of problems.', 'Mathematical Algorithms (Difficulty Wise)', 23, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('c08fa70f-b522-438e-a134-46e4a754c0c8', e'
Given a fraction, find a recurring sequence of digits if it exists, otherwise, print “No recurring sequence”.

                                                                                                                                    **Examples:**

                                                                                                                                    ```
                                                                                                                                    Input  : Numerator = 8, Denominator = 3
                                                                                                                                    Output : Recurring sequence is 6
                                                                                                                                    Explanation : 8/3 = 2.66666666.......

                                                                                                                                    Input : Numerator = 50, Denominator = 22
                                                                                                                                    Output : Recurring sequence is 27
                                                                                                                                    Explanation : 50/22 = 2.272727272.....

                                                                                                                                    Input : Numerator = 11, Denominator = 2
                                                                                                                                    Output : No recurring sequence
                                                                                                                                    Explanation : 11/2 = 5.5
                                                                                                                                    ```

                                                                                                                                       [We strongly recommend that you click here and practice it, before moving on to the solution.](https://www.geeksforgeeks.org/problems/a-simple-fraction0921/1)
--------------------------------------------------------------------------------------------------------------------------------------------------------------

**When does the fractional part repeat?**


Let us simulate the process of converting fractions to decimals. Let us look at the part where we have already figured out the integer part, which is floor(numerator/denominator). Now we are left with ( remainder = numerator%denominator ) / denominator.

If you remember the process of converting to decimal, at each step we do the following :

                                                                                                                                    1. Multiply the remainder by 10.
                                                                                                                                    2. Append the remainder/denominator to the result.
                                                                                                                                    3. Remainder = remainder % denominator.

                                                                                                                                    At any moment, if the remainder becomes 0, we are done.


However, when there is a recurring sequence, the remainder never becomes 0. For example, if you look at 1/3, the remainder never becomes 0.

Below is one important observation :


If we start with the remainder ‘rem’ and if the remainder repeats at any point in time, the digits between the two occurrences of ‘rem’ keep repeating.


So the idea is to store seen remainders in a map. Whenever a remainder repeats, we return the sequence before the next occurrence.

Below is the implementation of the above idea.

C++
---

















```
// C++ program to find repeating
// sequence in a fraction
#include <bits/stdc++.h>
using namespace std;

// This function returns repeating sequence of
// a fraction.  If repeating sequence doesn\'t
// exist, then returns empty string
string fractionToDecimal( int numr, int denr)
{
string res; // Initialize result

// Create a map to store already
// seen remainders, remainder is used
// as key and its position in
// result is stored as value.
// Note that we need
// position for cases like 1/6.
// In this case,the recurring sequence
// doesn\'t start from first
// remainder.
map< int , int > mp;
mp.clear();

// Find first remainder
int rem = numr % denr;

// Keep finding remainder until either remainder
// becomes 0 or repeats
while ((rem != 0)
&& (mp.find(rem) == mp.end()))
{
// Store this remainder
mp[rem] = res.length();

// Multiply remainder with 10
rem = rem * 10;

// Append rem / denr to result
int res_part = rem / denr;
res += to_string(res_part);

// Update remainder
rem = rem % denr;
}

return (rem == 0) ? "" : res.substr(mp[rem]);
}

// Driver code
int main()
{
int numr = 50, denr = 22;
string res = fractionToDecimal(numr, denr);
if (res == "" )
cout << "No recurring sequence" ;
else
cout << "Recurring sequence is " << res;
return 0;
}
```





Java
----

















```
// Java program to find
// repeating sequence
// in a fraction
import java.util.*;
class GFG {

// This function returns repeating
// sequence of a fraction. If
// repeating sequence doesn\'t
// exist, then returns empty String
static String fractionToDecimal( int numr, int denr)
{
// Initialize result
String res = "" ;

// Create a map to store already
// seen remainders. Remainder is
// used as key and its position in
// result is stored as value.
// Note that we need position for
// cases like 1/6.  In this case,
// the recurring sequence doesn\'t
// start from first remainder.
HashMap<Integer, Integer> mp = new HashMap<>();
mp.clear();

// Find first remainder
int rem = numr % denr;

// Keep finding remainder until
//  either remainder becomes 0 or repeats
while ((rem != 0 ) && (!mp.containsKey(rem)))
{
// Store this remainder
mp.put(rem, res.length());

// Multiply remainder with 10
rem = rem * 10 ;

// Append rem / denr to result
int res_part = rem / denr;
res += String.valueOf(res_part);

// Update remainder
rem = rem % denr;
}

if (rem == 0 )
return "" ;
else if (mp.containsKey(rem))
return res.substring(mp.get(rem));

return "" ;
}

// Driver code
public static void main(String[] args)
{
int numr = 50 , denr = 22 ;
String res = fractionToDecimal(numr, denr);
if (res == "" )
System.out.print( "No recurring sequence" );
else
System.out.print( "Recurring sequence is "
+ res);
}
}

// This code is contributed by gauravrajput1
```





Python3
-------

















```
# Python3 program to find repeating
# sequence in a fraction

# This function returns repeating sequence
# of a fraction.If repeating sequence doesn\'t
# exist, then returns empty string


def fractionToDecimal(numr, denr):

# Initialize result
res = ""

# Create a map to store already seen
# remainders. Remainder is used as key
# and its position in result is stored
# as value. Note that we need position
# for cases like 1/6.  In this case,
# the recurring sequence doesn\'t start
# from first remainder.
mp = {}

# Find first remainder
rem = numr % denr

# Keep finding remainder until either
# remainder becomes 0 or repeats
while ((rem ! = 0 ) and (rem not in mp)):

# Store this remainder
mp[rem] = len (res)

# Multiply remainder with 10
rem = rem * 10

# Append rem / denr to result
res_part = rem / / denr
res + = str (res_part)

# Update remainder
rem = rem % denr

if (rem = = 0 ):
return ""
else :
return res[mp[rem]:]


# Driver code
numr, denr = 50 , 22
res = fractionToDecimal(numr, denr)

if (res = = ""):
print ( "No recurring sequence" )
else :
print ( "Recurring sequence is" , res)

# This code is contributed by divyeshrabadiya07
```





C#
--

















```
// C# program to find repeating sequence
// in a fraction
using System;
using System.Collections.Generic;

class GFG {

// This function returns repeating
// sequence of a fraction. If
// repeating sequence doesn\'t
// exist, then returns empty String
static string fractionToDecimal( int numr, int denr)
{
// Initialize result
string res = "" ;

// Create a map to store already
// seen remainders. Remainder is
// used as key and its position in
// result is stored as value.
// Note that we need position for
// cases like 1/6.  In this case,
// the recurring sequence doesn\'t
// start from first remainder.
Dictionary< int , int > mp
= new Dictionary< int , int >();

// Find first remainder
int rem = numr % denr;

// Keep finding remainder until
// either remainder becomes 0
// or repeats
while ((rem != 0) && (!mp.ContainsKey(rem)))
{

// Store this remainder
mp[rem] = res.Length;

// Multiply remainder with 10
rem = rem * 10;

// Append rem / denr to result
int res_part = rem / denr;
res += res_part.ToString();

// Update remainder
rem = rem % denr;
}

if (rem == 0)
return "" ;
else if (mp.ContainsKey(rem))
return res.Substring(mp[rem]);

return "" ;
}

// Driver code
public static void Main( string [] args)
{
int numr = 50, denr = 22;
string res = fractionToDecimal(numr, denr);

if (res == "" )
Console.Write( "No recurring sequence" );
else
Console.Write( "Recurring sequence is " + res);
}
}

// This code is contributed by rutvik_56
```





Javascript
----------

















```
<script>

// Javascript program to find
// repeating sequence
// in a fraction

// This function returns repeating
// sequence of a fraction. If
// repeating sequence doesn\'t
// exist, then returns empty String
function fractionToDecimal(numr, denr)
{
// Initialize result
let res = "" ;

// Create a map to store already
// seen remainders. Remainder is
// used as key and its position in
// result is stored as value.
// Note that we need position for
// cases like 1/6.  In this case,
// the recurring sequence doesn\'t
// start from first remainder.
let mp = new Map();
mp.clear();

// Find first remainder
let rem = numr % denr;

// Keep finding remainder until
//  either remainder becomes 0 or repeats
while ((rem != 0) && (!mp.has(rem)))
{
// Store this remainder
mp.set(rem, res.length);

// Multiply remainder with 10
rem = rem * 10;

// Append rem / denr to result
let res_part = Math.floor(rem / denr);
res += res_part.toString();

// Update remainder
rem = rem % denr;
}

if (rem == 0)
return "" ;
else if (mp.has(rem))
return res.substr(mp.get(rem));

return "" ;
}

// Driver program

let numr = 50, denr = 22;
let res = fractionToDecimal(numr, denr);
if (res == "" )
document.write( "No recurring sequence" );
else
document.write( "Recurring sequence is "
+ res);

</script>
```







**Output**
```
Recurring sequence is 27
```

**Time Complexity : O(N)**

**Auxiliary Space : O(N) ,**
                                                                                                                                        as we use map as extra space.
                                                                                                                                        ', '', 'Find Recurring Sequence in a Fraction', 24, null, '598d78e5-c34f-437f-88fb-31557168c07b', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('7d5f99f3-4391-444d-92b9-28764219d6c9', e'Table of Content

                                                                                                                                        * [Divide and Conquer Algorithm Definition](#divide-and-conquer-algorithm-definition)
                                                                                                                                        * [Working of Divide and Conquer Algorithm](#working-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Characteristics of Divide and Conquer Algorithm](#characteristics-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Examples of Divide and Conquer Algorithm](#examples-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Complexity Analysis of Divide and Conquer Algorithm](#complexity-analysis-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Applications of Divide and Conquer Algorithm](#applications-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Advantages of Divide and Conquer Algorithm](#advantages-of-divide-and-conquer-algorithm)
                                                                                                                                        * [Disadvantages of Divide and Conquer Algorithm](#disadvantages-of-divide-and-conquer-algorithm)

                                                                                                                                        ****Divide and Conquer****

                                                                                                                                        Algorithm Definition:
-------------------------------------------------

                                                                                                                                        > ****Divide and Conquer Algorithm****
                                                                                                                                        > involves breaking a larger problem into smaller subproblems, solving them independently, and then combining their solutions to solve the original problem. The basic idea is to recursively divide the problem into smaller subproblems until they become simple enough to be solved directly. Once the solutions to the subproblems are obtained, they are then combined to produce the overall solution.

Working of Divide and Conquer Algorithm:
----------------------------------------


Divide and Conquer Algorithm can be divided into three steps:

****Divide****
                                                                                                                                       ,

                                                                                                                                    ****Conquer****
                                                                                                                                        and

                                                                                                                                    ****Merge****
                                                                                                                                        .


![Working-of-Divide-and-Conquer-Algorithm](https://media.geeksforgeeks.org/wp-content/uploads/20240501171531/Working-of-Divide-and-Conquer-Algorithm.webp)

### ****1. Divide:****

* Break down the original problem into smaller subproblems.
* Each subproblem should represent a part of the overall problem.
* The goal is to divide the problem until no further division is possible.

### ****2. Conquer:****

* Solve each of the smaller subproblems individually.
* If a subproblem is small enough (often referred to as the “base case”), we solve it directly without further recursion.
* The goal is to find solutions for these subproblems independently.

### 3. Merge:

* Combine the sub-problems to get the final solution of the whole problem.
* Once the smaller subproblems are solved, we recursively combine their solutions to get the solution of larger problem.
* The goal is to formulate a solution for the original problem by merging the results from the subproblems.

Characteristics of Divide and Conquer Algorithm:
------------------------------------------------


Divide and Conquer Algorithm involves breaking down a problem into smaller, more manageable parts, solving each part individually, and then combining the solutions to solve the original problem. The characteristics of Divide and Conquer Algorithm are:



                                                                                                                                    * ****Dividing the Problem****
                                                                                                                                    : The first step is to break the problem into smaller, more manageable subproblems. This division can be done recursively until the subproblems become simple enough to solve directly.
* ****Independence of Subproblems****
  : Each subproblem should be independent of the others, meaning that solving one subproblem does not depend on the solution of another. This allows for parallel processing or concurrent execution of subproblems, which can lead to efficiency gains.
* ****Conquering Each Subproblem****
  : Once divided, the subproblems are solved individually. This may involve applying the same divide and conquer approach recursively until the subproblems become simple enough to solve directly, or it may involve applying a different algorithm or technique.
                                                                                                                                    * ****Combining Solutions****
                                                                                                                                    : After solving the subproblems, their solutions are combined to obtain the solution to the original problem. This combination step should be relatively efficient and straightforward, as the solutions to the subproblems should be designed to fit together seamlessly.

                                                                                                                                    ****Examples of Divide and Conquer Algorithm:****
-------------------------------------------------

                                                                                                                                    ### ****1. Finding the maximum element in the array:****


                                                                                                                                    We can use Divide and Conquer Algorithm to find the maximum element in the array by dividing the array into two equal sized subarrays, finding the maximum of those two individual halves by again dividing them into two smaller halves. This is done till we reach subarrays of size 1. After reaching the elements, we return the maximum element and combine the subarrays by returning the maximum in each subarray.



C++

````
// function to find the maximum no.
// in a given array.
int findMax(int a[], int lo, int hi)
{
    // If lo becomes greater than hi, then return minimum
                                                                                                                                    // integer possible
                                                                                                                                    if (lo > hi)
                                                                                                                                    return INT_MIN;
// If the subarray has only one element, return the
    // element
    if (lo == hi)
        return a[lo];
int mid = (lo + hi) / 2;
// Get the maximum element from the left half
    int leftMax = findMax(a, lo, mid);
// Get the maximum element from the right half
    int rightMax = findMax(a, mid + 1, hi);
// Return the maximum element from the left and right
    // half
    return max(leftMax, rightMax);
}

````

Java

````
// Function to find the maximum number
// in a given array.
static int findMax(int[] a, int lo, int hi)
{
    // If lo becomes greater than hi, then return
    // minimum integer possible
    if (lo > hi)
        return Integer.MIN_VALUE;
// If the subarray has only one element, return the
    // element
    if (lo == hi)
        return a[lo];
int mid = (lo + hi) / 2;
// Get the maximum element from the left half
    int leftMax = findMax(a, lo, mid);
// Get the maximum element from the right half
    int rightMax = findMax(a, mid + 1, hi);
// Return the maximum element from the left and
    // right half
    return Math.max(leftMax, rightMax);
}

````

Python3

````
# Function to find the maximum number
# in a given array.
def find_max(a, lo, hi):
    # If lo becomes greater than hi, then return minimum
    # integer possible
    if lo > hi:
        return float(\'-inf\')
    # If the subarray has only one element, return the
    # element
    if lo == hi:
        return a[lo]
    mid = (lo + hi) // 2
    # Get the maximum element from the left half
    left_max = find_max(a, lo, mid)
    # Get the maximum element from the right half
    right_max = find_max(a, mid + 1, hi)
    # Return the maximum element from the left and right
    # half
    return max(left_max, right_max)

````

C#

````
// Function to find the maximum number
// in a given array.
static int FindMax(int[] a, int lo, int hi)
{
    // If lo becomes greater than hi, then return
    // minimum integer possible
    if (lo > hi)
        return int.MinValue;
// If the subarray has only one element, return the
    // element
    if (lo == hi)
        return a[lo];
int mid = (lo + hi) / 2;
// Get the maximum element from the left half
    int leftMax = FindMax(a, lo, mid);
// Get the maximum element from the right half
    int rightMax = FindMax(a, mid + 1, hi);
// Return the maximum element from the left and
    // right half
    return Math.Max(leftMax, rightMax);
}

````

JavaScript

````
// Function to find the maximum number
// in a given array.
function findMax(a, lo, hi) {
    // If lo becomes greater than hi, then return minimum
    // integer possible
    if (lo > hi)
        return Number.MIN_VALUE;
// If the subarray has only one element, return the
    // element
    if (lo === hi)
        return a[lo];
    const mid = Math.floor((lo + hi) / 2);
// Get the maximum element from the left half
    const leftMax = findMax(a, lo, mid);
// Get the maximum element from the right half
    const rightMax = findMax(a, mid + 1, hi);
// Return the maximum element from the left and right
    // half
    return Math.max(leftMax, rightMax);
}

````

### ****2. Finding the minimum element in the array:****


Similarly, we can use Divide and Conquer Algorithm to find the minimum element in the array by dividing the array into two equal sized subarrays, finding the minimum of those two individual halves by again dividing them into two smaller halves. This is done till we reach subarrays of size 1. After reaching the elements, we return the minimum element and combine the subarrays by returning the minimum in each subarray.


### 3. [Merge Sort:](https://www.geeksforgeeks.org/merge-sort/)


We can use Divide and Conquer Algorithm to sort the array in ascending or descending order by dividing the array into smaller subarrays, sorting the smaller subarrays and then merging the sorted arrays to sort the original array.


Complexity Analysis of Divide and Conquer Algorithm:
----------------------------------------------------

> T(n) = aT(n/b) + f(n), where
> n = size of input
> a = number of subproblems in the recursion
> n/b = size of each subproblem. All subproblems are assumed to have the same size.
> f(n) = cost of the work done outside the recursive call, which includes the cost of dividing the problem and cost of merging the solutions

Applications of Divide and Conquer Algorithm:
---------------------------------------------


The following are some standard algorithms that follow Divide and Conquer algorithm:


* [****Quicksort****](https://www.geeksforgeeks.org/quick-sort/)
  is a sorting algorithm that picks a pivot element and rearranges the array elements so that all elements smaller than the picked pivot element move to the left side of the pivot, and all greater elements move to the right side. Finally, the algorithm recursively sorts the subarrays on the left and right of the pivot element.
* [****Merge Sort****](https://www.geeksforgeeks.org/merge-sort/)
  is also a sorting algorithm. The algorithm divides the array into two halves, recursively sorts them, and finally merges the two sorted halves.
* [****Closest Pair of Points****](https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/)
  The problem is to find the closest pair of points in a set of points in the x-y plane. The problem can be solved in O(n^2) time by calculating the distances of every pair of points and comparing the distances to find the minimum. The Divide and Conquer algorithm solves the problem in O(N log N) time.
* [****Strassen’s Algorithm****](https://www.geeksforgeeks.org/strassens-matrix-multiplication/)
  is an efficient algorithm to multiply two matrices. A simple method to multiply two matrices needs 3 nested loops and is O(n^3). Strassen’s algorithm multiplies two matrices in O(n^2.8974) time.
* [****Cooley–Tukey Fast Fourier Transform (FFT) algorithm****](http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm)
  is the most common algorithm for FFT. It is a divide and conquer algorithm which works in O(N log N) time.
* [****Karatsuba algorithm for fast multiplication****](https://www.geeksforgeeks.org/karatsuba-algorithm-for-fast-multiplication-using-divide-and-conquer-algorithm/)
  does the multiplication of two binary strings in O(n

  1.59
  ) where n is the length of binary string.

****Advantages of Divide and Conquer Algorithm:****
---------------------------------------------------

* ****Solving difficult problems:****
  Divide and conquer technique is a tool for solving difficult problems conceptually. e.g. Tower of Hanoi puzzle. It requires a way of breaking the problem into sub-problems, and solving all of them as an individual cases and then combining sub- problems to the original problem.
* ****Algorithm efficiency:****
  The divide-and-conquer algorithm often helps in the discovery of efficient algorithms. It is the key to algorithms like Quick Sort and Merge Sort, and fast Fourier transforms.
* ****Parallelism:****
  Normally Divide and Conquer algorithms are used in multi-processor machines having shared-memory systems where the communication of data between processors does not need to be planned in advance, because distinct sub-problems can be executed on different processors.
* ****Memory access:****
  These algorithms naturally make an efficient use of memory caches. Since the subproblems are small enough to be solved in cache without using the main memory that is slower one. Any algorithm that uses cache efficiently is called cache oblivious.

****Disadvantages of Divide and Conquer Algorithm:****
------------------------------------------------------

* ****Overhead:****
  The process of dividing the problem into subproblems and then combining the solutions can require additional time and resources. This overhead can be significant for problems that are already relatively small or that have a simple solution.
* ****Complexity:****
  Dividing a problem into smaller subproblems can increase the complexity of the overall solution. This is particularly true when the subproblems are interdependent and must be solved in a specific order.
* ****Difficulty of implementation:****
  Some problems are difficult to divide into smaller subproblems or require a complex algorithm to do so. In these cases, it can be challenging to implement a divide and conquer solution.
* ****Memory limitations:****
  When working with large data sets, the memory requirements for storing the intermediate results of the subproblems can become a limiting factor.

Frequently Asked Questions (FAQs) on Divide and Conquer Algorithm:
------------------------------------------------------------------

### ****1. What is the Divide and Conquer algorithm?****

> Divide and Conquer is a problem-solving technique where a problem is divided into smaller, more manageable subproblems. These subproblems are solved recursively, and then their solutions are combined to solve the original problem.

### ****2. What are the key steps involved in the Divide and Conquer algorithm?****

> The main steps are:
>
>
> ****Divide****
> : Break the problem into smaller subproblems.
>
>
> ****Conquer****
> : Solve the subproblems recursively.
>
>
> ****Combine****
> : Merge or combine the solutions of the subproblems to obtain the solution to the original problem.

### ****3. What are some examples of problems solved using Divide and Conquer?****

> Divide and Conquer Algorithm is used in sorting algorithms like Merge Sort and Quick Sort, finding closest pair of points, Strassen’s Algorithm, etc.

### ****4. How does Merge Sort use the Divide and Conquer approach?****

> Merge Sort divides the array into two halves, recursively sorts each half, and then merges the sorted halves to produce the final sorted array.

### ****5. What is the time complexity of Divide and Conquer algorithms?****

> The time complexity varies depending on the specific problem and how it’s implemented. Generally, many Divide and Conquer algorithms have a time complexity of O(n log n) or better.

### ****6. Can Divide and Conquer algorithms be parallelized?****

> Yes, Divide and Conquer algorithms are often naturally parallelizable because independent subproblems can be solved concurrently. This makes them suitable for parallel computing environments.

### ****7. What are some strategies for choosing the base case in Divide and Conquer algorithms?****

> The base case should be simple enough to solve directly, without further division. It’s often chosen based on the smallest input size where the problem can be solved trivially.

### ****8. Are there any drawbacks or limitations to using Divide and Conquer?****

> While Divide and Conquer can lead to efficient solutions for many problems, it may not be suitable for all problem types. Overhead from recursion and combining solutions can also be a concern for very large problem sizes.

### ****9. How do you analyze the space complexity of Divide and Conquer algorithms?****

> Space complexity depends on factors like the recursion depth and auxiliary space required for combining solutions. Analyzing space complexity typically involves considering the space used by each recursive call.

### ****10. What are some common advantages of Divide and Conquer Algorithm?****

> Divide and Conquer Algorithm has numerous advantages. Some of them include:
>
>
> * Solving difficult problems
> * Algorithm efficiency
> * Parallelism
> * Memory access


Divide and Conquer is a popular algorithmic technique in computer science that involves breaking down a problem into smaller sub-problems, solving each sub-problem independently, and then combining the solutions to the sub-problems to solve the original problem. The basic idea behind this technique is to divide a problem into smaller, more manageable sub-problems that can be solved more easily.

', 'Algorithm is a problem-solving technique used to solve problems by dividing the main problem into subproblems, solving them individually and then merging them to find solution to the original problem. In this article, we are going to discuss how Divide and Conquer Algorithm is helpful and how we can use it to solve problems.', 'Introduction to Divide and Conquer Algorithm', 2, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('0a6a3db2-efff-45ec-8886-b5862fbb75e1', e'Basic Terminologies of Linked List
----------------------------------

* ****Head:****
  The Head of a linked list is a pointer to the first node or reference of the first node of linked list. This pointer marks the beginning of the linked list.
* ****Node:****
  Linked List consists of a series of nodes where each node has two parts:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ****data****
                                              and

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ****next pointer****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Data:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Data is the part of node which stores the information in the linked list.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Next pointer:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Next pointer is the part of the node which points to the next node of the linked list.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Importance of Linked List
-------------------------


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Here are a few advantages of a linked list that is listed below, it will help you understand why it is necessary to know.


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Dynamic Data structure:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The size of memory can be allocated or de-allocated at run time based on the operation insertion or deletion.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Ease of Insertion/Deletion:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The insertion and deletion of elements are simpler than arrays since no elements need to be shifted after insertion and deletion, Just the address needed to be updated.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Efficient Memory Utilization:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           As we know Linked List is a dynamic data structure the size increases or decreases as per the requirement so this avoids the wastage of memory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Implementation:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Various advanced data structures can be implemented using a linked list like a stack, queue, graph, hash maps, etc.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Implementations of Basic Operations on Different Types of List
--------------------------------------------------------------

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Singly Linked List](https://www.geeksforgeeks.org/singly-linked-list-tutorial/)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Doubly Linked List](https://www.geeksforgeeks.org/doubly-linked-list/)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * [Circular Linked List](https://www.geeksforgeeks.org/circular-linked-list/)

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ### Basic Operations on Singly Linked List


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The following are some basic operations performed on a Single Linked List:


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * ****Insertion:****
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           The insertion operation can be performed in three ways. They are as follows:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           + [Inserting At the Beginning of the list](https://www.geeksforgeeks.org/linked-list-set-2-inserting-a-node/#:~:text=Add%20a%20node%20at%20the%20front%3A)
        + [Inserting At End of the list](https://www.geeksforgeeks.org/linked-list-set-2-inserting-a-node/#:~:text=Add%20a%20node%20at%20the%20end)
  + [Inserting At Specific location in the list](https://www.geeksforgeeks.org/linked-list-set-2-inserting-a-node/#:~:text=Add%20a%20node%20after%20a%20given%20node)
* ****Deletion:****
  The deletion operation can be performed in three ways. They are as follows:
  + [Deleting from the Beginning of the list](https://www.geeksforgeeks.org/linked-list-set-3-deleting-node/?ref=lbp#:~:text=Delete%20from%20Beginning,head%20%3D%20head%2D%3Enext)
  + [Deleting from the End of the list](https://www.geeksforgeeks.org/delete-nth-node-from-the-end-of-the-given-linked-list/)
  + [Deleting a Specific Node](https://www.geeksforgeeks.org/delete-a-linked-list-node-at-a-given-position/)
* [****Traverse****](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)
  ****:****
  This process displays the elements of a Single-linked list.
* [****Search:****](https://www.geeksforgeeks.org/search-an-element-in-a-linked-list-iterative-and-recursive/)

  It is a process of determining and retrieving a specific node either from the front, the end or anywhere in the list.

### ****Operations on Doubly Linked List:****


In a doubly linked list, we perform the following operations…


* ****Insertion:****
  The insertion operation can be performed in three ways as follows:
  + [Inserting At the Beginning of the list](https://www.geeksforgeeks.org/doubly-linked-list/#:~:text=Add%20a%20node%20at%20the%20front)
  + [Inserting after a given node.](https://www.geeksforgeeks.org/doubly-linked-list/#:~:text=Add%20a%20node%20after%20a%20given%20node.)
  + [Inserting at the end](https://www.geeksforgeeks.org/doubly-linked-list/#:~:text=Add%20a%20node%20at%20the%20end)
    .
  + [Inserting before a given node](https://www.geeksforgeeks.org/doubly-linked-list/#:~:text=Add%20a%20node%20before%20a%20given%20node)
* ****Deletion:****
  The deletion operation can be performed in three ways as follows…
  + [Deleting from the Beginning of the list](https://www.geeksforgeeks.org/delete-doubly-linked-list-node-given-position/)
  + [Deleting from the End of the list](https://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list/)
  + Deleting a Specific Node
* ****Display:****
  This process displays the elements of a double-linked list.

### ****Commonly used operations on Circular Linked List:****


The following operations are performed on a Circular Linked List



* ****Insertion:****
  The insertion operation can be performed in three ways:
  + [Insertion in an empty list](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/#:~:text=Insertion%20in%20an%20empty%20List%C2%A0)
  + [Insertion at the beginning of the list](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/#:~:text=Insertion%20at%20the%20beginning%20of%20the%20list%C2%A0)
  + [Insertion at the end of the list](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/#:~:text=Insertion%20at%20the%20end%20of%20the%20list%C2%A0)
  + [Insertion in between the nodes](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/#:~:text=Insertion%20in%20between%20the%20nodes%C2%A0)
* ****Deletion:****
  The deletion operation can be performed in three ways:
  + [Deleting from the Beginning of the list](https://www.geeksforgeeks.org/deletion-at-different-positions-in-a-circular-linked-list/)
  + [Deleting from the End of the list](https://www.geeksforgeeks.org/deletion-at-different-positions-in-a-circular-linked-list/)
  + [Deleting a Specific Node](https://www.geeksforgeeks.org/deletion-at-different-positions-in-a-circular-linked-list/)
* ****Display:****
  This process displays the elements of a Circular linked list.

[Linked List vs. Array:](https://www.geeksforgeeks.org/linked-list-vs-array/)
-----------------------------------------------------------------------------

Time Complexity Analysis of Linked List and Array:
--------------------------------------------------


Please refer

[Applications, Advantages and Disadvantages of Linked List](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-linked-list/)
for more details


Frequently Asked Questions (FAQs) about Linked List:
----------------------------------------------------

### 1. What is linked list data structure?

> Linked list are most commonly used to handle dynamic data elements. Linked list consists of nodes and a node consists of two fields one for storing data and other for keeping the reference of next node.

### 2. What is linked list example?

> A linked list can be assumed as a garland that is made up of flowers. Similarly, a linked list is made up of nodes. Every flower in this particular garland is referred to as a node. In addition, each node points to the next node in this list, and it contains data (in this case, the type of flower).

### 3. Why do we need linked list data structure??

> There are some important advantages to using linked lists over other linear data structures. This is unlike arrays, as they are resizable at runtime. Additionally, they can be easily inserted and deleted.

### 4. What are linked lists used for?

> The linked list is a linear data structure that stores data in nodes. these nodes hold both the data and a reference to the next node in the list. Linked are very efficient at adding and removing nodes because of their simple structure.

### 5. What is the difference between array and linked list?

> There are some following differences between them:
>
>
> * Arrays are data structures containing similar data elements, whereas linked lists are non-primitive data structures containing unordered linked elements.
> * In an array, elements are indexed, but in a linked list nodes are not indexed.
> * Accessing an element array is fast if we know the position of an element in the array, while in the Linked list it takes linear time so, the Linked list is quite bit slower.
> * Operations like insertion and deletion in arrays take a lot of time. Whereas, the performance of these operations is faster in Linked lists.
> * Arrays are of fixed size and their size is static but Linked lists are dynamic and flexible and can expand and shrink their size.

### 6. Why is a linked list preferred over an array?

> Following are the reason that linked lists are preferred over array
>
>
> * Nodes in a linked array, insertions, and deletions can be done at any point in the list at a constant time.
> * Arrays are of fixed size and their size is static but Linked lists are dynamic and flexible and can expand and shrink their size.
> * Linked lists provide an efficient way of storing related data and performing basic operations such as insertion, deletion, and updating of information at the cost of extra space required for storing the address.
> * Insertion and deletion operations in the linked list are faster as compared to the array.

### 7. Which is the best array or linked list?

> There are some advantages and disadvantages to both arrays and linked lists when it comes to storing linear data of similar types.
>
>
> #### Advantages of linked list over arrays:
>
> * ****Dynamic size:****
>   Linked lists are dynamic and flexible and can expand and shrink their size
> * ****Ease of Insertion/Deletion:****
>   Insertion and deletion operations in linked list are faster as compared to the array
>
> #### ****Disadvantages of linked list over arrays:****
>
> * If the array is sorted we can apply binary search to search any element which takes
>
>   ****O(log(n))****
>   time. But even if the linked list is sorted we cannot apply binary search and the complexity of searching elements in the linked list is
>
>   ****O(n)****
>   .
> * A linked list takes more memory as compared to the array because extra memory space is required for the pointer with each element in the linked list.

### 8. What are the limitations of linked list?

> Following are some limitations of the linked list:
>
>
> * The use of pointers is more in linked lists hence, complex and requires more memory.
> * Random access is not possible due to dynamic memory allocation.
> * Traversing is more time-consuming and reverse traversing is not possible in singly linked lists.
> * Searching for an element is costly and requires
>
>   ****O(n)****
>   time complexity.

### 9. Why insertion/deletion are faster in a linked list?

> If any element is inserted/ deleted from the array, all the other elements after it will be shifted in memory this takes a lot of time whereas manipulation in Linked List is faster because we just need to manipulate the addresses of nodes, so no bit shifting is required in memory, and it will not take that much of time.

### 10. What is the difference between a singly and doubly linked list?


Following are some

[difference between single and double linked list.](https://www.geeksforgeeks.org/difference-between-singly-linked-list-and-doubly-linked-list/)

Conclusion:
-----------


There are many advantages of the linked list compared to array, despite the fact that they solve the similar problem to arrays, we have also discussed the advantage, disadvantages, and its application, and we concluded the fact that we can use a linked list if we need the dynamic size of storage and list are good for adding and removing items quickly or for tasks that require sequence but are not suitable for querying or search elements in a large collection of data.


So, it becomes important that we should always keep in mind the

****positive****
and

****negative****
aspects of a

****data structure****
and how they relate to the problem you are trying to solve.', 'In this article, we will provide a complete introduction of Linked List, which will help you tackle any problem based on Linked List.', 'Introduction to Linked List – Data Structure and Algorithm Tutorials', 4, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('0f843284-a32b-478b-af5b-85f375980a0b', e'Properties of Heap:
-------------------

* The minimum or maximum element is always at the root of the heap, allowing constant-time access.
* The relationship between a parent node at index

  ****‘i’****
  and its children is given by the formulas: left child at index

  ****2i+1****
  and right child at index

  ****2i+2****
  for 0-based indexing of node numbers.
* As the tree is complete binary, all levels are filled except possibly the last level. And the last level is filled from left to right.
* When we insert an item, we insert it at the last available slot and then rearrange the nodes so that the heap property is maintained.
* When we remove an item, we swap root with the last node to make sure either the max or min item is removed. Then we rearrange the remaining nodes to ensure heap property (max or min)

Operations Supported by Heap:
-----------------------------


Operations supported by

****min – heap****
and

****max – heap****
are same. The difference is just that min-heap contains minimum element at root of the tree and max – heap contains maximum element at the root of the tree.


****Heapify:****
It is the process to rearrange the elements to maintain the property of heap data structure. It is done when root is removed (we replace root with the last node and then call heapify to ensure that heap property is maintained) or heap is built (we call heapify from the last internal node to root) to make sure that the heap property is maintained. This operation also takes

****O(log n)****
time.


* For

  ****max-heap,****
  it


  makes sure the maximum element is the root of that binary tree and all descendants also follow the same property.
* For

  ****min-heap,****
  it balances in such a way that the minimum element is the root and all descendants also follow the same property.

****Insertion****
: When a new element is inserted into the heap, it can disrupt the heap’s properties. To restore and maintain the heap structure, a heapify operation is performed. This operation ensures the heap properties are preserved and has a time complexity of

****O(log n)****
.



****Examples:****

> Assume initially heap(taking
>
> ****max-heap****
> ) is as follows
>
>
> 8
>
>
>
> /   \\
>
>
>
> 4     5
>
>
>
> / \\
>
>
>
> 1   2
>
>
> Now if we insert 10 into the heap
>
>
>
> 8
>
>
>
> /      \\
>
>
>
> 4       5
>
>
>
> /  \\      /
>
>
>
> 1     2  10
>
>
> After repeatedly comparing with the parent nodes and swapping if required, the final heap will be look like this
>
>
>
> 10
>
>
>
> /    \\
>
>
>
> 4      8
>
>
>
> /  \\     /
>
>
>
> 1     2 5

### Deletion:

* If we delete the element from the heap it always deletes the root element of the tree and replaces it with the last element of the tree.
* Since we delete the root element from the heap it will distort the properties of the heap so we need to perform heapify operations so that it maintains the property of the heap.


It takes

****O(log n)****
time.


****Example:****

> Assume initially heap(taking max-heap) is as follows
>
>
>
> 15
>
>
>
> /   \\
>
>
>
> 5     7
>
>
>
> /  \\
>
>
>
> 2     3
>
>
> Now if we delete 15 into the heap it will be replaced by leaf node of the tree for temporary.
>
>
>
> 3
>
>
>
> /   \\
>
>
>
> 5     7
>
>
>
> /
>
>
>
> 2
>
>
> After heapify operation final heap will be look like this
>
>
>
> 7
>
>
>
> /   \\
>
>
>
> 5     3
>
>
>
> /
>
>
>
> 2

### getMax (For max-heap) or getMin (For min-heap):


It finds the maximum element or minimum element for

****max-heap****
and

****min-heap****
respectively and as we know minimum and maximum elements will always be the root node itself for min-heap and max-heap respectively. It takes

****O(1)****
time.


### removeMin or removeMax:


This operation returns and deletes the maximum element and minimum element from the max-heap and min-heap respectively. In short, it deletes the root element of the heap binary tree.


Implementation of Heap Data Structure:-
---------------------------------------


The following code shows the implementation of a

****max-heap****
.


Let’s understand the

****maxHeapify****
function in detail:-


****maxHeapify****
is the function responsible for restoring the property of the Max Heap. It arranges the node

****i****
, and its subtrees accordingly so that the heap property is maintained.


1. Suppose we are given an array,

   ****arr[]****
   representing the complete binary tree. The left and the right child of

   ****i****
   ****th****
   node are in indices

   ****2\\*i+1****
   and

   ****2\\*i+2****
   .
2. We set the index of the current element,

   ****i****
   , as the ‘MAXIMUM’.
3. If

   ****arr[2 \\* i + 1] > arr[i]****
   , i.e., the left child is larger than the current value, it is set as ‘MAXIMUM’.
4. Similarly if

   ****arr[2 \\* i + 2] > arr[i]****
   , i.e., the right child is larger than the current value, it is set as ‘MAXIMUM’.
5. Swap the ‘MAXIMUM’ with the current element.
6. Repeat steps

   ****2 to 5****
   till the property of the heap is restored.

C++

````
// C++ code to depict
// the implementation of a max heap.

#include <bits/stdc++.h>
using namespace std;

// A class for Max Heap.
class MaxHeap {
    // A pointer pointing to the elements
    // in the array in the heap.
    int* arr;

// Maximum possible size of
    // the Max Heap.
    int maxSize;

// Number of elements in the
    // Max heap currently.
    int heapSize;

public:
    // Constructor function.
    MaxHeap(int maxSize);

// Heapifies a sub-tree taking the
    // given index as the root.
    void MaxHeapify(int);

// Returns the index of the parent
    // of the element at ith index.
    int parent(int i)
    {
        return (i - 1) / 2;
}

    // Returns the index of the left child.
    int lChild(int i)
    {
        return (2 * i + 1);
}

    // Returns the index of the
    // right child.
    int rChild(int i)
    {
        return (2 * i + 2);
}

    // Removes the root which in this
    // case contains the maximum element.
    int removeMax();

// Increases the value of the key
    // given by index i to some new value.
    void increaseKey(int i, int newVal);

// Returns the maximum key
    // (key at root) from max heap.
    int getMax()
    {
        return arr[0];
}

    int curSize()
    {
        return heapSize;
}

    // Deletes a key at given index i.
    void deleteKey(int i);

// Inserts a new key \'x\' in the Max Heap.
    void insertKey(int x);
};

// Constructor function builds a heap
// from a given array a[]
// of the specified size.
MaxHeap::MaxHeap(int totSize)
{
    heapSize = 0;
    maxSize = totSize;
    arr = new int[totSize];
}

// Inserting a new key \'x\'.
void MaxHeap::insertKey(int x)
{
    // To check whether the key
    // can be inserted or not.
    if (heapSize == maxSize) {
        cout << "\\nOverflow: Could not insertKey\\n";
        return;
}

    // The new key is initially
    // inserted at the end.
    heapSize++;
int i = heapSize - 1;
    arr[i] = x;

// The max heap property is checked
    // and if violation occurs,
    // it is restored.
    while (i != 0 && arr[parent(i)] < arr[i]) {
        swap(arr[i], arr[parent(i)]);
        i = parent(i);
}
}

// Increases value of key at
// index \'i\' to new_val.
void MaxHeap::increaseKey(int i, int newVal)
{
    arr[i] = newVal;
    while (i != 0 && arr[parent(i)] < arr[i]) {
        swap(arr[i], arr[parent(i)]);
        i = parent(i);
}
}

// To remove the root node which contains
// the maximum element of the Max Heap.
int MaxHeap::removeMax()
{
    // Checking whether the heap array
    // is empty or not.
    if (heapSize <= 0)
        return INT_MIN;
    if (heapSize == 1) {
        heapSize--;
        return arr[0];
}

    // Storing the maximum element
    // to remove it.
    int root = arr[0];
    arr[0] = arr[heapSize - 1];
    heapSize--;

// To restore the property
    // of the Max heap.
    MaxHeapify(0);

return root;
}

// In order to delete a key
// at a given index i.
void MaxHeap::deleteKey(int i)
{
    // It increases the value of the key
    // to infinity and then removes
    // the maximum value.
    increaseKey(i, INT_MAX);
    removeMax();
}

// To heapify the subtree this method
// is called recursively
void MaxHeap::MaxHeapify(int i)
{
    int l = lChild(i);
int r = rChild(i);
int largest = i;
    if (l < heapSize && arr[l] > arr[i])
        largest = l;
    if (r < heapSize && arr[r] > arr[largest])
        largest = r;
    if (largest != i) {
        swap(arr[i], arr[largest]);
        MaxHeapify(largest);
}
}

// Driver program to test above functions.
int main()
{
    // Assuming the maximum size of the heap to be 15.
    MaxHeap h(15);

// Asking the user to input the keys:
    int k, i, n = 6, arr[10];
    cout << "Entered 6 keys:- 3, 10, 12, 8, 2, 14 \\n";
    h.insertKey(3);
    h.insertKey(10);
    h.insertKey(12);
    h.insertKey(8);
    h.insertKey(2);
    h.insertKey(14);

// Printing the current size
    // of the heap.
    cout << "The current size of the heap is "
         << h.curSize() << "\\n";

// Printing the root element which is
    // actually the maximum element.
    cout << "The current maximum element is " << h.getMax()
         << "\\n";

// Deleting key at index 2.
    h.deleteKey(2);

// Printing the size of the heap
    // after deletion.
    cout << "The current size of the heap is "
         << h.curSize() << "\\n";

// Inserting 2 new keys into the heap.
    h.insertKey(15);
    h.insertKey(5);
    cout << "The current size of the heap is "
         << h.curSize() << "\\n";
    cout << "The current maximum element is " << h.getMax()
         << "\\n";

return 0;
}

````

Java

````
// Java code to depict
// the implementation of a max heap.
import java.util.Arrays;
import java.util.Scanner;

public class MaxHeap {
    // A pointer pointing to the elements
    // in the array in the heap.
    int[] arr;

// Maximum possible size of
    // the Max Heap.
    int maxSize;

// Number of elements in the
    // Max heap currently.
    int heapSize;

// Constructor function.
    MaxHeap(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
        heapSize = 0;
}

    // Heapifies a sub-tree taking the
    // given index as the root.
    void MaxHeapify(int i) {
        int l = lChild(i);
int r = rChild(i);
int largest = i;
        if (l < heapSize && arr[l] > arr[i])
            largest = l;
        if (r < heapSize && arr[r] > arr[largest])
            largest = r;
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            MaxHeapify(largest);
}
    }

    // Returns the index of the parent
    // of the element at ith index.
    int parent(int i) {
        return (i - 1) / 2;
}

    // Returns the index of the left child.
    int lChild(int i) {
        return (2 * i + 1);
}

    // Returns the index of the
    // right child.
    int rChild(int i) {
        return (2 * i + 2);
}

    // Removes the root which in this
    // case contains the maximum element.
    int removeMax() {
        // Checking whether the heap array
        // is empty or not.
        if (heapSize <= 0)
            return Integer.MIN_VALUE;
        if (heapSize == 1) {
            heapSize--;
            return arr[0];
}

        // Storing the maximum element
        // to remove it.
        int root = arr[0];
        arr[0] = arr[heapSize - 1];
        heapSize--;

// To restore the property
        // of the Max heap.
        MaxHeapify(0);

return root;
}

    // Increases value of key at
    // index \'i\' to new_val.
    void increaseKey(int i, int newVal) {
        arr[i] = newVal;
        while (i != 0 && arr[parent(i)] < arr[i]) {
            int temp = arr[i];
            arr[i] = arr[parent(i)];
            arr[parent(i)] = temp;
            i = parent(i);
}
    }

    // Returns the maximum key
    // (key at root) from max heap.
    int getMax() {
        return arr[0];
}

    int curSize() {
        return heapSize;
}

    // Deletes a key at given index i.
    void deleteKey(int i) {
        // It increases the value of the key
        // to infinity and then removes
        // the maximum value.
        increaseKey(i, Integer.MAX_VALUE);
        removeMax();
}

    // Inserts a new key \'x\' in the Max Heap.
    void insertKey(int x) {
        // To check whether the key
        // can be inserted or not.
        if (heapSize == maxSize) {
            System.out.println("\\nOverflow: Could not insertKey\\n");
            return;
}

        // The new key is initially
        // inserted at the end.
        heapSize++;
int i = heapSize - 1;
        arr[i] = x;

// The max heap property is checked
        // and if violation occurs,
        // it is restored.
        while (i != 0 && arr[parent(i)] < arr[i]) {
            int temp = arr[i];
            arr[i] = arr[parent(i)];
            arr[parent(i)] = temp;
            i = parent(i);
}
    }

    // Driver program to test above functions.
    public static void main(String[] args) {
        // Assuming the maximum size of the heap to be 15.
        MaxHeap h = new MaxHeap(15);

// Asking the user to input the keys:
        int k, i, n = 6;
        System.out.println("Entered 6 keys:- 3, 10, 12, 8, 2, 14 \\n");
        h.insertKey(3);
        h.insertKey(10);
        h.insertKey(12);
        h.insertKey(8);
        h.insertKey(2);
        h.insertKey(14);

// Printing the current size
        // of the heap.
        System.out.println("The current size of the heap is "
                + h.curSize() + "\\n");

// Printing the root element which is
        // actually the maximum element.
        System.out.println("The current maximum element is " + h.getMax()
                + "\\n");

// Deleting key at index 2.
        h.deleteKey(2);

// Printing the size of the heap
        // after deletion.
        System.out.println("The current size of the heap is "
                + h.curSize() + "\\n");

// Inserting 2 new keys into the heap.
        h.insertKey(15);
        h.insertKey(5);
        System.out.println("The current size of the heap is "
                + h.curSize() + "\\n");
        System.out.println("The current maximum element is " + h.getMax()
                + "\\n");
}
}

````

Python

````
# Python code to depict
# the implementation of a max heap.

class MaxHeap:
    # A pointer pointing to the elements
    # in the array in the heap.
    arr = []

    # Maximum possible size of
    # the Max Heap.
    maxSize = 0

    # Number of elements in the
    # Max heap currently.
    heapSize = 0

    # Constructor function.
    def __init__(self, maxSize):
        self.maxSize = maxSize
        self.arr = [None]*maxSize
        self.heapSize = 0

    # Heapifies a sub-tree taking the
    # given index as the root.
    def MaxHeapify(self, i):
        l = self.lChild(i)
        r = self.rChild(i)
        largest = i
        if l < self.heapSize and self.arr[l] > self.arr[i]:
            largest = l
        if r < self.heapSize and self.arr[r] > self.arr[largest]:
            largest = r
        if largest != i:
            temp = self.arr[i]
            self.arr[i] = self.arr[largest]
            self.arr[largest] = temp
            self.MaxHeapify(largest)

    # Returns the index of the parent
    # of the element at ith index.
    def parent(self, i):
        return (i - 1) // 2

    # Returns the index of the left child.
    def lChild(self, i):
        return (2 * i + 1)

    # Returns the index of the
    # right child.
    def rChild(self, i):
        return (2 * i + 2)

    # Removes the root which in this
    # case contains the maximum element.
    def removeMax(self):
        # Checking whether the heap array
        # is empty or not.
        if self.heapSize <= 0:
            return None
        if self.heapSize == 1:
            self.heapSize -= 1
            return self.arr[0]

        # Storing the maximum element
        # to remove it.
        root = self.arr[0]
        self.arr[0] = self.arr[self.heapSize - 1]
        self.heapSize -= 1

        # To restore the property
        # of the Max heap.
        self.MaxHeapify(0)

        return root

    # Increases value of key at
    # index \'i\' to new_val.
    def increaseKey(self, i, newVal):
        self.arr[i] = newVal
        while i != 0 and self.arr[self.parent(i)] < self.arr[i]:
            temp = self.arr[i]
            self.arr[i] = self.arr[self.parent(i)]
            self.arr[self.parent(i)] = temp
            i = self.parent(i)

    # Returns the maximum key
    # (key at root) from max heap.
    def getMax(self):
        return self.arr[0]

    def curSize(self):
        return self.heapSize

    # Deletes a key at given index i.
    def deleteKey(self, i):
        # It increases the value of the key
        # to infinity and then removes
        # the maximum value.
        self.increaseKey(i, float("inf"))
        self.removeMax()

    # Inserts a new key \'x\' in the Max Heap.
    def insertKey(self, x):
        # To check whether the key
        # can be inserted or not.
        if self.heapSize == self.maxSize:
            print("\\nOverflow: Could not insertKey\\n")
            return

        # The new key is initially
        # inserted at the end.
        self.heapSize += 1
        i = self.heapSize - 1
        self.arr[i] = x

        # The max heap property is checked
        # and if violation occurs,
        # it is restored.
        while i != 0 and self.arr[self.parent(i)] < self.arr[i]:
            temp = self.arr[i]
            self.arr[i] = self.arr[self.parent(i)]
            self.arr[self.parent(i)] = temp
            i = self.parent(i)


# Driver program to test above functions.
if __name__ == \'__main__\':
    # Assuming the maximum size of the heap to be 15.
    h = MaxHeap(15)

    # Asking the user to input the keys:
    k, i, n = 6, 0, 6
    print("Entered 6 keys:- 3, 10, 12, 8, 2, 14 \\n")
    h.insertKey(3)
    h.insertKey(10)
    h.insertKey(12)
    h.insertKey(8)
    h.insertKey(2)
    h.insertKey(14)

    # Printing the current size
    # of the heap.
    print("The current size of the heap is "
          + str(h.curSize()) + "\\n")

    # Printing the root element which is
    # actually the maximum element.
    print("The current maximum element is " + str(h.getMax())
          + "\\n")

    # Deleting key at index 2.
    h.deleteKey(2)

    # Printing the size of the heap
    # after deletion.
    print("The current size of the heap is "
          + str(h.curSize()) + "\\n")

    # Inserting 2 new keys into the heap.
    h.insertKey(15)
    h.insertKey(5)
    print("The current size of the heap is "
          + str(h.curSize()) + "\\n")
    print("The current maximum element is " + str(h.getMax())
          + "\\n")

````

JavaScript

````
// JavaScript code to depict
// the implementation of a max heap.

class MaxHeap {
    constructor(maxSize) {
        // the array in the heap.
        this.arr = new Array(maxSize).fill(null);

// Maximum possible size of
        // the Max Heap.
        this.maxSize = maxSize;

// Number of elements in the
        // Max heap currently.
        this.heapSize = 0;
}

    // Heapifies a sub-tree taking the
    // given index as the root.
    MaxHeapify(i) {
        const l = this.lChild(i);
        const r = this.rChild(i);
        let largest = i;
        if (l < this.heapSize && this.arr[l] > this.arr[i]) {
            largest = l;
}
        if (r < this.heapSize && this.arr[r] > this.arr[largest]) {
            largest = r;
}
        if (largest !== i) {
            const temp = this.arr[i];
            this.arr[i] = this.arr[largest];
            this.arr[largest] = temp;
            this.MaxHeapify(largest);
}
    }

    // Returns the index of the parent
    // of the element at ith index.
    parent(i) {
        return Math.floor((i - 1) / 2);
}

    // Returns the index of the left child.
    lChild(i) {
        return 2 * i + 1;
}

    // Returns the index of the
    // right child.
    rChild(i) {
        return 2 * i + 2;
}

    // Removes the root which in this
    // case contains the maximum element.
    removeMax() {
        // Checking whether the heap array
        // is empty or not.
        if (this.heapSize <= 0) {
            return null;
}
        if (this.heapSize === 1) {
            this.heapSize -= 1;
return this.arr[0];
}

        // Storing the maximum element
        // to remove it.
        const root = this.arr[0];
        this.arr[0] = this.arr[this.heapSize - 1];
        this.heapSize -= 1;

// To restore the property
        // of the Max heap.
        this.MaxHeapify(0);

return root;
}

    // Increases value of key at
    // index \'i\' to new_val.
    increaseKey(i, newVal) {
        this.arr[i] = newVal;
        while (i !== 0 && this.arr[this.parent(i)] < this.arr[i]) {
            const temp = this.arr[i];
            this.arr[i] = this.arr[this.parent(i)];
            this.arr[this.parent(i)] = temp;
            i = this.parent(i);
}
    }

    // Returns the maximum key
    // (key at root) from max heap.
    getMax() {
        return this.arr[0];
}

    curSize() {
        return this.heapSize;
}

    // Deletes a key at given index i.
    deleteKey(i) {
        // It increases the value of the key
        // to infinity and then removes
        // the maximum value.
        this.increaseKey(i, Infinity);
        this.removeMax();
}

    // Inserts a new key \'x\' in the Max Heap.
    insertKey(x) {
        // To check whether the key
        // can be inserted or not.
        if (this.heapSize === this.maxSize) {
            console.log("\\nOverflow: Could not insertKey\\n");
            return;
}

        let i = this.heapSize;
        this.arr[i] = x;

// The new key is initially
        // inserted at the end.
        this.heapSize += 1;



// The max heap property is checked
        // and if violation occurs,
        // it is restored.
        while (i !== 0 && this.arr[this.parent(i)] < this.arr[i]) {
            const temp = this.arr[i];
            this.arr[i] = this.arr[this.parent(i)];
            this.arr[this.parent(i)] = temp;
            i = this.parent(i);
}
    }
}


// Driver program to test above functions.

// Assuming the maximum size of the heap to be 15.
const h = new MaxHeap(15);

// Asking the user to input the keys:
console.log("Entered 6 keys:- 3, 10, 12, 8, 2, 14 \\n");

h.insertKey(3);
h.insertKey(10);
h.insertKey(12);
h.insertKey(8);
h.insertKey(2);
h.insertKey(14);


// Printing the current size
// of the heap.
console.log(
    "The current size of the heap is " + h.curSize() + "\\n"
);


// Printing the root element which is
// actually the maximum element.
console.log(
    "The current maximum element is " + h.getMax() + "\\n"
);


// Deleting key at index 2.
h.deleteKey(2);


// Printing the size of the heap
// after deletion.
console.log(
    "The current size of the heap is " + h.curSize() + "\\n"
);


// Inserting 2 new keys into the heap.
h.insertKey(15);
h.insertKey(5);

console.log(
    "The current size of the heap is " + h.curSize() + "\\n"
);

console.log(
    "The current maximum element is " + h.getMax() + "\\n"
);

// Contributed by sdeadityasharma

````




**Output**
```
Entered 6 keys:- 3, 10, 12, 8, 2, 14
The current size of the heap is 6
The current maximum element is 14
The current size of the heap is 5
The current size of the heap is 7
The current maximum element is 15
```
', '', 'Introduction to Heap – Data Structure and Algorithm Tutorials', 5, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('f6b69eae-bbcf-44ad-9b2d-18253be9e546', e'Features of Pattern Searching Algorithm:
----------------------------------------

* Pattern searching algorithms should recognize familiar patterns quickly and accurately.
* Recognize and classify unfamiliar patterns.
* Identify patterns even when partly hidden.
* Recognize patterns quickly with ease, and with automaticity.

[Naive Pattern Searching algorithm](https://www.geeksforgeeks.org/naive-algorithm-for-pattern-searching/)
---------------------------------------------------------------------------------------------------------


Naive pattern searching is the simplest method among other pattern-searching algorithms. It checks for all characters of the main string to the pattern. This algorithm is helpful for smaller texts. It does not need any pre-processing phases. We can find the substring by checking once for the string. It also does not occupy extra space to perform the operation.


![Compare text characters with pattern characters](https://media.geeksforgeeks.org/wp-content/uploads/20220809155713/image.png)

Compare text characters with pattern characters


The time complexity of Naive Pattern Search method is O(m\\*n). The m is the size of pattern and n is the size of the main string.


C++

````
// C++ program for Naive Pattern
// Searching algorithm
#include <bits/stdc++.h>
using namespace std;

void search(char* pat, char* txt)
{
    int M = strlen(pat);
int N = strlen(txt);

    /* A loop to slide pat[] one by one */
for (int i = 0; i <= N - M; i++) {
        int j;

        /* For current index i, check for pattern match */
for (j = 0; j < M; j++)
            if (txt[i + j] != pat[j])
                break;

        if (j
            == M) // if pat[0...M-1] = txt[i, i+1, ...i+M-1]
            cout << "Pattern found at index " << i << endl;
}
}

// Driver\'s Code
int main()
{
    char txt[] = "AABAACAADAABAAABAA";
    char pat[] = "AABA";

    // Function call
    search(pat, txt);
    return 0;
}

````

Java

````
// Java program for Naive Pattern
// Searching algorithm
class GFG {

  static void search(char[] pat, char[] txt)
  {
    int M = pat.length;
    int N = txt.length;

    /* A loop to slide pat[] one by one */
    for (int i = 0; i <= N - M; i++) {
      int j;

      /* For current index i, check for pattern match
             */
      for (j = 0; j < M; j++)
        if (txt[i + j] != pat[j])
          break;

      // if pat[0...M-1] = txt[i, i+1, ...i+M-1]
      if (j == M)
        System.out.println("Pattern found at index "
                           + i);
    }
  }

  // Driver\'s Code

  public static void main(String[] args)
  {
    char txt[] = "AABAACAADAABAAABAA".toCharArray();

char pat[] = "AABA".toCharArray();

// Function call
    search(pat, txt);
}
}

// This code is contributed by karandeep1234

````

Python

````
def search(pat, txt):
    M = len(pat)
    N = len(txt)

    # A loop to slide pat[] one by one
    for i in range(N - M + 1):
        j = 0

        # For current index i, check for pattern match
        while j < M:
            if txt[i + j] != pat[j]:
                break
            j += 1

        if j == M:  # if pat[0...M-1] = txt[i, i+1, ...i+M-1]
            print(f"Pattern found at index {i}")


# Driver\'s Code
txt = "AABAACAADAABAAABAA"
pat = "AABA"

# Function call
search(pat, txt)

````

C#

````
using System;

public class GFG {

  public static void search(char[] pat, char[] txt)
  {
    int M = pat.Length;
    int N = txt.Length;

    /* A loop to slide pat[] one by one */
    for (int i = 0; i <= N - M; i++) {
      int j;

      /* For current index i, check for pattern match
             */
      for (j = 0; j < M; j++)
        if (txt[i + j] != pat[j])
          break;

      if (j == M) // if pat[0...M-1] = txt[i, i+1,
        // ...i+M-1]
        Console.WriteLine("Pattern found at index "
                          + i);
    }
  }

  static public void Main()
  {

    char[] txt = "AABAACAADAABAAABAA".ToCharArray();
    char[] pat = "AABA".ToCharArray();

    // Function call
    search(pat, txt);
  }
}
// This code is contributed by akashish__

````

JavaScript

````
// JS program for Naive Pattern
// Searching algorithm
function search(pat, txt)
{
    let M = pat.length;
    let N = txt.length;

    /* A loop to slide pat[] one by one */
    for (let i = 0; i <= N - M; i++) {
        let j = 0;

        /* For current index i, check for pattern match */
        for (j = 0; j < M; j++)
            if (txt[i + j] != pat[j])
                break;
        if (j == M) // if pat[0...M-1] = txt[i, i+1, ...i+M-1]
            console.log("Pattern found at index",i);
    }
}

// Driver\'s Code
    let txt = "AABAACAADAABAAABAA";
    let pat = "AABA";

// Function call
    search(pat, txt);

// This code is contributed by ishankhandelwals.

````




**Output**
```
Pattern found at index 0
Pattern found at index 9
Pattern found at index 13
```

****Time Complexity:****
O(N\\*M)



****Auxiliary Space:****
O(1)


[KMP algorithm](https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/)
-----------------------------------------------------------------------------------


KMP algorithm is used to find a “Pattern” in a “Text”. This algorithm compares character by character from left to right. But whenever a mismatch occurs, it uses a preprocessed table called “Prefix Table” to skip characters comparison while matching. Sometimes prefix table is also known as LPS Table. Here LPS stands for “Longest proper Prefix which is also Suffix”.


### How to use LPS Table


We use the LPS table to decide how many characters are to be skipped for comparison when a mismatch has occurred.



When a mismatch occurs, check the LPS value of the previous character of the mismatched character in the pattern. If it is ‘0’ then start comparing the first character of the pattern with the next character to the mismatched character in the text. If it is not ‘0’ then start comparing the character which is at an index value equal to the LPS value of the previous character to the mismatched character in pattern with the mismatched character in the Text.







![Example of KMP algorithm](https://media.geeksforgeeks.org/wp-content/uploads/20221108112045/KMP2.png)

Example of KMP algorithm


![Compare first character of pattern with first character of text from left to right](https://media.geeksforgeeks.org/wp-content/uploads/20221108112046/step1.png)

Compare first character of pattern with first character of text from left to right


![Compare first character of pattern with next character of text](https://media.geeksforgeeks.org/wp-content/uploads/20221108112307/step2.png)

Compare first character of pattern with next character of text


![Compare pattern[0] and pattern[1] values](https://media.geeksforgeeks.org/wp-content/uploads/20221108112047/step3.png)

Compare pattern[0] and pattern[1] values


![Compare pattern[0] with next characters in text.](https://media.geeksforgeeks.org/wp-content/uploads/20221108112048/step4.png)

Compare pattern[0] with next characters in text.


![Compare pattern[2] with mismatched characters in text.](https://media.geeksforgeeks.org/wp-content/uploads/20221108112049/step5.png)

Compare pattern[2] with mismatched characters in text.

### How the KMP Algorithm Works


Let’s take a look on working example of KMP Algorithm to find a Pattern in a Text.



![LPS table](https://media.geeksforgeeks.org/wp-content/uploads/20221108112550/kmp.png)

LPS table


![Define variables](https://media.geeksforgeeks.org/wp-content/uploads/20221108112551/step1.png)

Define variables


![Compare A with B](https://media.geeksforgeeks.org/wp-content/uploads/20221108112552/step2.png)

Compare A with B


![Compare A with C](https://media.geeksforgeeks.org/wp-content/uploads/20221108112552/step3.png)

Compare A with C


![Compare A with D](https://media.geeksforgeeks.org/wp-content/uploads/20221108112553/step4.png)

Compare A with D


![Compare A with A](https://media.geeksforgeeks.org/wp-content/uploads/20221108112554/step5.png)

Compare A with A


![Compare B with B](https://media.geeksforgeeks.org/wp-content/uploads/20221108112555/step6.png)

Compare B with B


![Compare C with D](https://media.geeksforgeeks.org/wp-content/uploads/20221108112555/step7.png)

Compare C with D


![Compare A with D](https://media.geeksforgeeks.org/wp-content/uploads/20221108112556/step8.png)

Compare A with D


Implementation of the KMP algorithm:


C++

````
// C++ program for implementation of KMP pattern searching
// algorithm
#include <bits/stdc++.h>

void computeLPSArray(char* pat, int M, int* lps);

// Prints occurrences of txt[] in pat[]
void KMPSearch(char* pat, char* txt)
{
    int M = strlen(pat);
int N = strlen(txt);

// create lps[] that will hold the longest prefix suffix
    // values for pattern
    int lps[M];

// Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);

int i = 0; // index for txt[]
    int j = 0; // index for pat[]
    while ((N - i) >= (M - j)) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
}

        if (j == M) {
            printf("Found pattern at index %d ", i - j);
            j = lps[j - 1];
}

        // mismatch after j matches
        else if (i < N && pat[j] != txt[i]) {
            // Do not match lps[0..lps[j-1]] characters,
            // they will match anyway
            if (j != 0)
                j = lps[j - 1];
else
                i = i + 1;
}
    }
}

// Fills lps[] for given pattern pat[0..M-1]
void computeLPSArray(char* pat, int M, int* lps)
{
    // length of the previous longest prefix suffix
    int len = 0;

    lps[0] = 0; // lps[0] is always 0

    // the loop calculates lps[i] for i = 1 to M-1
    int i = 1;
    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
}
        else // (pat[i] != pat[len])
        {
            // This is tricky. Consider the example.
            // AAACAAAA and i = 7. The idea is similar
            // to search step.
            if (len != 0) {
                len = lps[len - 1];

// Also, note that we do not increment
                // i here
            }
            else // if (len == 0)
            {
                lps[i] = 0;
                i++;
}
        }
    }
}

// Driver program to test above function
int main()
{
    char txt[] = "ABABDABACDABABCABAB";
char pat[] = "ABABCABAB";
    KMPSearch(pat, txt);
return 0;
}

````

Java

````
// Java program for implementation of KMP pattern searching
// algorithm
public class KMP_String_Matching {
    void KMPSearch(String pat, String txt)
    {
        int M = pat.length();
int N = txt.length();

// create lps[] that will hold the longest prefix suffix
        // values for pattern
        int lps[] = new int[M];
int j = 0; // index for pat[]

        // Preprocess the pattern (calculate lps[] array)
        computeLPSArray(pat, M, lps);

int i = 0; // index for txt[]
        while (i < N) {
            if (pat.charAt(j) == txt.charAt(i)) {
                j++;
                i++;
}
            if (j == M) {
                System.out.println("Found pattern " + "at index " + (i - j));
                j = lps[j - 1];
}

            // mismatch after j matches
            else if (i < N && pat.charAt(j) != txt.charAt(i)) {
                // Do not match lps[0..lps[j-1]] characters,
                // they will match anyway
                if (j != 0)
                    j = lps[j - 1];
else
                    i = i + 1;
}
        }
    }

    void computeLPSArray(String pat, int M, int lps[])
    {
        // length of the previous longest prefix suffix
        int len = 0;
int i = 1;
        lps[0] = 0; // lps[0] is always 0

        // the loop calculates lps[i] for i = 1 to M-1
        while (i < M) {
            if (pat.charAt(i) == pat.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
}
            else // (pat[i] != pat[len])
            {
                // This is tricky. Consider the example.
                // AAACAAAA and i = 7. The idea is similar
                // to search step.
                if (len != 0) {
                    len = lps[len - 1];

// Also, note that we do not increment
                    // i here
                }
                else // if (len == 0)
                {
                    lps[i] = len;
                    i++;
}
            }
        }
    }

    // Driver program to test above function
    public static void main(String[] args)
    {
        String txt = "ABABDABACDABABCABAB";
        String pat = "ABABCABAB";
        new KMP_String_Matching().KMPSearch(pat, txt);
}
}

````

Python

````
# Python program for implementation of KMP pattern searching
# algorithm
def computeLPSArray(pat, M, lps):
    len = 0  # length of the previous longest prefix suffix

    lps[0]  # lps[0] is always 0
    i = 1

    # the loop calculates lps[i] for i = 1 to M-1
    while i < M:
        if pat[i] == pat[len]:
            len += 1
            lps[i] = len
            i += 1
        else:
            # This is tricky. Consider the example.
            # AAACAAAA and i = 7. The idea is similar
            # to search step.
            if len != 0:
                len = lps[len-1]

            # Also, note that we do not increment i here
            else:
                lps[i] = 0
                i += 1

def KMPSearch(pat, txt):
    M = len(pat)
    N = len(txt)

    # create lps[] that will hold the longest prefix suffix
    # values for pattern
    lps = [0]*M
    j = 0  # index for pat[]

    # Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps)

    i = 0  # index for txt[]
    while (N - i) >= (M - j):
        if pat[j] == txt[i]:
            j += 1
            i += 1

        if j == M:
            print("Found pattern at index:", i-j)
            j = lps[j-1]

        # mismatch after j matches
        elif i < N and pat[j] != txt[i]:
            # Do not match lps[0..lps[j-1]] characters,
            # they will match anyway
            if j != 0:
                j = lps[j-1]
            else:
                i += 1

txt = "ABABDABACDABABCABAB"
pat = "ABABCABAB"
KMPSearch(pat, txt)

# This code is contributed by ishankhandelwals.

````

C#

````
using System;
using System.Collections.Generic;

public class GFG {

  // Prints occurrences of txt[] in pat[]
  public static void KMPSearch(char[] pat, char[] txt)
  {
    int M = pat.Length;
int N = txt.Length;

// create lps[] that will hold the longest prefix
    // suffix values for pattern
    int[] lps = new int[M];

// Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);

int i = 0; // index for txt[]
    int j = 0; // index for pat[]
    while ((N - i) >= (M - j)) {
      if (pat[j] == txt[i]) {
        j++;
        i++;
}

      if (j == M) {
        int temp = i - j;
        Console.WriteLine("Found pattern at index "
                          + temp);
        j = lps[j - 1];
}

      // mismatch after j matches
      else if (i < N && pat[j] != txt[i]) {
        // Do not match lps[0..lps[j-1]] characters,
        // they will match anyway
        if (j != 0)
          j = lps[j - 1];
else
          i = i + 1;
}
    }
  }

  // Fills lps[] for given pattern pat[0..M-1]
  public static void computeLPSArray(char[] pat, int M,
                                     int[] lps)
  {
    // length of the previous longest prefix suffix
    int len = 0;

    lps[0] = 0; // lps[0] is always 0

    // the loop calculates lps[i] for i = 1 to M-1
    int i = 1;
    while (i < M) {
      if (pat[i] == pat[len]) {
        len++;
        lps[i] = len;
        i++;
}
      else // (pat[i] != pat[len])
      {
        // This is tricky. Consider the example.
        // AAACAAAA and i = 7. The idea is similar
        // to search step.
        if (len != 0) {
          len = lps[len - 1];

// Also, note that we do not increment
          // i here
        }
        else // if (len == 0)
        {
          lps[i] = 0;
          i++;
}
      }
    }
  }

  static public void Main()
  {

    char[] txt = "ABABDABACDABABCABAB".ToCharArray();
char[] pat = "ABABCABAB".ToCharArray();
    KMPSearch(pat, txt);
}
}

// This code is contributed by akashish__

````

JavaScript

````
// JS program for implementation of KMP pattern searching
// algorithm
// Prlets occurrences of txt[] in pat[]
function computeLPSArray(pat, M, lps)
{

    // length of the previous longest prefix suffix
    let len = 0;
    lps[0] = 0; // lps[0] is always 0
    // the loop calculates lps[i] for i = 1 to M-1
    let i = 1;
    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
}
        else // (pat[i] != pat[len])
        {

            // This is tricky. Consider the example.
            // AAACAAAA and i = 7. The idea is similar
            // to search step.
            if (len != 0) {
                len = lps[len - 1];

// Also, note that we do not increment
                // i here
            }
            else // if (len == 0)
            {
                lps[i] = 0;
                i++;
}
        }
    }
}
function KMPSearch(pat, txt) {
    let M = pat.length;
    let N = txt.length

    // create lps[] that will hold the longest prefix suffix
    // values for pattern
    let lps = [];

// Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps);
    let i = 0; // index for txt[]
    let j = 0; // index for pat[]
    while ((N - i) >= (M - j)) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
}
        if (j == M) {
            console.log("Found pattern at index:", i - j);
            j = lps[j - 1];
}

        // mismatch after j matches
        else if (i < N && pat[j] != txt[i])
        {

            // Do not match lps[0..lps[j-1]] characters,
            // they will match anyway
            if (j != 0)
                j = lps[j - 1];
else
                i = i + 1;
}
    }
}

// Fills lps[] for given pattern pat[0..M-1]
// Driver program to test above function
let txt = "ABABDABACDABABCABAB";
let pat = "ABABCABAB";
KMPSearch(pat, txt);

// This code is contributed by ishankhandelwals.

````




**Output**
```
Found pattern at index 10
```

****Time complexity:****
O(n + m)



****Auxiliary Space:****
O(M)


[Rabin Karp algorithm](https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/)
:
---------------------------------------------------------------------------------------------------


Rabin-Karp algorithm is an algorithm used for searching/matching patterns in the text using a hash function. Unlike Naive string-matching algorithm, it does not travel through every character in the initial phase rather it filters the characters that do not match and then perform the comparison.


Rabin-Karp compares a string’s hash values, rather than the strings themselves. For efficiency, the hash value of the next position in the text is easily computed from the hash value of the current position.


### Working of Rabin-Karp algorithm

* Initially calculate the hash value of the pattern P.
* Start iterating from the start of the string:
  + Calculate the hash value of the current substring having length m.
  + If the hash value of the current substring and the pattern are same check if the substring is same as the pattern.
  + If they are same, store the starting index as a valid answer. Otherwise, continue for the next substrings.
* Return the starting indices as the required answer.

![Example of Rabin Karp](https://media.geeksforgeeks.org/wp-content/uploads/20221108112930/rabinkarp.png)

Example of Rabin Karp


Below is the implementation of the Rabin-Karp algorithm.



C++

````
/* Following program is a C++ implementation of Rabin Karp
Algorithm given in the CLRS book */
#include <bits/stdc++.h>
using namespace std;

// d is the number of characters in the input alphabet
#define d 256

/* pat -> pattern
    txt -> text
    q -> A prime number
*/
void search(char pat[], char txt[], int q)
{
    int M = strlen(pat);
int N = strlen(txt);
int i, j;
int p = 0; // hash value for pattern
    int t = 0; // hash value for txt
    int h = 1;

// The value of h would be "pow(d, M-1)%q"
    for (i = 0; i < M - 1; i++)
        h = (h * d) % q;

// Calculate the hash value of pattern and first
    // window of text
    for (i = 0; i < M; i++) {
        p = (d * p + pat[i]) % q;
        t = (d * t + txt[i]) % q;
}

    // Slide the pattern over text one by one
    for (i = 0; i <= N - M; i++) {

        // Check the hash values of current window of text
        // and pattern. If the hash values match then only
        // check for characters one by one
        if (p == t) {
            /* Check for characters one by one */
            for (j = 0; j < M; j++) {
                if (txt[i + j] != pat[j]) {
                    break;
}
            }

            // if p == t and pat[0...M-1] = txt[i, i+1,
            // ...i+M-1]

            if (j == M)
                cout << "Pattern found at index " << i
                     << endl;
}

        // Calculate hash value for next window of text:
        // Remove leading digit, add trailing digit
        if (i < N - M) {
            t = (d * (t - txt[i] * h) + txt[i + M]) % q;

// We might get negative value of t, converting
            // it to positive
            if (t < 0)
                t = (t + q);
}
    }
}

/* Driver code */
int main()
{
    char txt[] = "GEEKS FOR GEEKS";
char pat[] = "GEEK";

// we mod to avoid overflowing of value but we should
    // take as big q as possible to avoid the collison
    int q = INT_MAX;

// Function Call
    search(pat, txt, q);
return 0;
}

// This is code is contributed by rathbhupendra

````

Java

````
import java.io.*;
import java.lang.*;
import java.util.*;

/* pat -> pattern
    txt -> text
    q -> A prime number
*/
public class GFG {
  // d is the number of characters in the input alphabet
  public final static int d = 256;
public static void search(String pat, String txt, int q)
  {
    int M = pat.length();
int N = txt.length();
int i, j;
int p = 0; // hash value for pattern
    int t = 0; // hash value for txt
    int h = 1;

// The value of h would be "pow(d, M-1)%q"
    for (i = 0; i < M - 1; i++)
      h = (h * d) % q;
// Calculate the hash value of pattern and first
    // window of text
    for (i = 0; i < M; i++) {
      p = (d * p + pat.charAt(i)) % q;
      t = (d * t + txt.charAt(i)) % q;
}

    // Slide the pattern over text one by one
    for (i = 0; i <= N - M; i++) {

      // Check the hash values of current window of
      // text and pattern. If the hash values match
      // then only check for characters one by one
      if (p == t) {
        /* Check for characters one by one */
        for (j = 0; j < M; j++) {
          if (txt.charAt(i + j)
              != pat.charAt(j)) {
            break;
}
        }

        // if p == t and pat[0...M-1] = txt[i, i+1,
        // ...i+M-1]

        if (j == M) {
          System.out.println(
            "Pattern found at index " + i);
}
      }
      // Calculate hash value for next window of text:
      // Remove leading digit, add trailing digit
      if (i < N - M) {
        t = (d * (t - txt.charAt(i) * h)
             + txt.charAt(i + M))
          % q;

// We might get negative value of t,
        // converting it to positive
        if (t < 0)
          t = (t + q);
}
    }
  }

  /* Driver code */
  public static void main(String[] args)
  {
    String txt = "GEEKS FOR GEEKS";
    String pat = "GEEK";

// A prime number
    int q = 101;

// Function Call
    search(pat, txt, q);
}
}

// This code is contributed by ishankhandelwals.

````

Python

````
# d is the number of characters in the input alphabet
d = 256

\'\'\' pat -> pattern
txt -> text
q -> A prime number \'\'\'
def search(pat, txt, q):

    M = len(pat)
    N = len(txt)
    p = 0 # hash value for pattern
    t = 0 # hash value for txt
    h = 1

    # The value of h would be "pow(d, M-1)%q"
    for i in range(M - 1):
        h = (h * d) % q

    # Calculate the hash value of pattern and first
    # window of text
    for i in range(M):
        p = (d * p + ord(pat[i])) % q
        t = (d * t + ord(txt[i])) % q

    # Slide the pattern over text one by one
    for i in range(N - M + 1):
        # Check the hash values of current window of text
        # and pattern. If the hash values match then only
        # check for characters one by one
        if p == t:
            # Check for characters one by one
            for j in range(M):
                if txt[i + j] != pat[j]:
                    break
            # if p == t and pat[0...M-1] = txt[i, i+1,
            # ...i+M-1]
            if j == M - 1:
                print("Pattern found at index " + str(i))

        # Calculate hash value for next window of text:
        # Remove leading digit, add trailing digit
        if i < N - M:
            t = (d * (t - ord(txt[i]) * h) + ord(txt[i + M])) % q
            # We might get negative value of t, converting
            # it to positive
            if t < 0:
                t = (t + q)

# Driver code
txt = "GEEKS FOR GEEKS"
pat = "GEEK"

# we mod to avoid overflowing of value but we should
# take as big q as possible to avoid the collison
q = float(\'inf\')

# Function Call
search(pat, txt, q)

# This code is contributed by akashish__

````

C#

````
// C# code
using System;

/* pat -> pattern
    txt -> text
    q -> A prime number
*/

class GFG {
  // d is the number of characters in the input alphabet
  public static int d = 256;
public static void search(string pat, string txt, int q)
  {
    int M = pat.Length;
int N = txt.Length;
int i, j;
int p = 0; // hash value for pattern
    int t = 0; // hash value for txt
    int h = 1;
// The value of h would be "pow(d, M-1)%q"
    for (i = 0; i < M - 1; i++)
      h = (h * d) % q;
// Calculate the hash value of pattern and first
    // window of text
    for (i = 0; i < M; i++) {
      p = (d * p + pat[i]) % q;
      t = (d * t + txt[i]) % q;
}

    // Slide the pattern over text one by one
    for (i = 0; i <= N - M; i++) {

      // Check the hash values of current window of
      // text and pattern. If the hash values match
      // then only check for characters one by one
      if (p == t) {
        /* Check for characters one by one */
        for (j = 0; j < M; j++) {
          if (txt[i + j] != pat[j]) {
            break;
}
        }

        // if p == t and pat[0...M-1] = txt[i, i+1,
        // ...i+M-1]

        if (j == M) {
          Console.WriteLine(
            "Pattern found at index " + i);
}
      }
      // Calculate hash value for next window of text:
      // Remove leading digit, add trailing digit
      if (i < N - M) {
        t = (d * (t - txt[i] * h) + txt[i + M]) % q;

// We might get negative value of t,
        // converting it to positive
        if (t < 0)
          t = (t + q);
}
    }
  }

  /* Driver code */
  public static void Main(string[] args)
  {
    string txt = "GEEKS FOR GEEKS";
    string pat = "GEEK";

// A prime number
    int q = 101;

// Function Call
    search(pat, txt, q);
}
}

// This code is contributed by akashish__

````

JavaScript

````
// d is the number of characters in the input alphabet
const d = 256;

/* pat -> pattern
    txt -> text
    q -> A prime number
*/
function search(pat, txt, q) {
  const M = pat.length;
  const N = txt.length;
  let p = 0; // hash value for pattern
  let t = 0; // hash value for txt
  let h = 1;

// The value of h would be "pow(d, M-1)%q"
  for (let i = 0; i < M - 1; i++) {
    h = (h * d) % q;
}

  // Calculate the hash value of pattern and first
  // window of text
  for (let i = 0; i < M; i++) {
    p = (d * p + pat.charCodeAt(i)) % q;
    t = (d * t + txt.charCodeAt(i)) % q;
}

  // Slide the pattern over text one by one
  for (let i = 0; i <= N - M; i++) {
    // Check the hash values of current window of text
    // and pattern. If the hash values match then only
    // check for characters one by one
    if (p === t) {
    /* Check for characters one by one */
    for (j = 0; j < M; j++) {
        if (txt.charAt(i + j) !== pat.charAt(j)) {
        break;
}
    }

    // if p == t and pat[0...M-1] = txt[i, i+1,
    // ...i+M-1]

    if (j === M)
        console.log("Pattern found at index " + i);
}

    // Calculate hash value for next window of text:
    // Remove leading digit, add trailing digit
    if (i < N - M) {
    t = (d * (t - txt.charCodeAt(i) * h) + txt.charCodeAt(i + M)) % q;

// We might get negative value of t, converting
    // it to positive
    if (t < 0)
        t = (t + q);
}
  }
}

/* Driver code */
const txt = "GEEKS FOR GEEKS";
const pat = "GEEK";

// we mod to avoid overflowing of value but we should
// take as big q as possible to avoid the collison
const q = Number.MAX_SAFE_INTEGER;

// Function Call
search(pat, txt, q);

// This code is contributed by ishankhandelwals.

````




**Output**
```
Pattern found at index 0
Pattern found at index 10
```

****Time Complexity:****

* The average and best-case running time of the Rabin-Karp algorithm is O(n+m), but its worst-case time is O(nm).
* The worst case of the Rabin-Karp algorithm occurs when all characters of pattern and text are the same as the hash values of all the substrings of txt[] match with the hash value of pat[].

****Space Complexity :****


The space complexity of the Rabin-Karp algorithm is O(1), which means that it is a constant amount of memory that is required, regardless of the size of the input text and pattern. This is because the algorithm only needs to store a few variables that are updated as the algorithm progresses through the text and pattern. Specifically, the algorithm needs to store the hash value of the pattern, the hash value of the current window in the text, and a few loop counters and temporary variables. Since the size of these variables is fixed, the space complexity is constant.


[Z algorithm](https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/)
:
---------------------------------------------------------------------------------------------------


This algorithm finds all occurrences of a pattern in a text in linear time. Let length of text be n and of pattern be m, then total time taken is O(m + n) with linear space complexity. Z algorithm works by maintaining an auxiliary array called the Z array. This Z array stores the length of the longest substring, starting from the current index, that also it’s prefix.


### What is Z Array?


For a string str[0..n-1], Z array is of same length as string. An element Z[i] of Z array stores length of the longest substring starting from str[i] which is also a prefix of str[0..n-1]. The first entry of Z array is meaning less as complete string is always prefix of itself.


****Example:****

> Index            0   1   2   3   4   5   6   7   8   9  10  11
>
>
>
> Text             a   a   b   c   a   a   b   x   a   a   a   z
>
>
>
> Z values         X   1   0   0   3   1   0   0   2   2   1   0

### How to construct Z array?


A Simple Solution is to run two nested loops, the outer loop goes to every index and the inner loop finds length of the longest prefix that matches the substring starting at current index. The time complexity of this solution is O(n2).


We can construct Z array in linear time. The idea is to maintain an interval [L, R] which is the interval with max R



such that [L, R] is prefix substring (substring which is also a prefix.


****Steps for maintaining this interval are as follows –****

> 1. If
>
>    ****i > R****
>    then there is no prefix substring that starts before i and ends after i, so we reset L and R and compute new [L, R] by comparing
>
>    ****str[0..]****
>    to
>
>    ****str[i..]****
>    and get
>
>    ****Z[i] (= R-L+1)****
>    .
> 2. If
>
>    ****i <= R****
>    then let
>
>    ****K = i-L****
>    ,  now
>
>    ****Z[i] >= min(Z[K], R-i+1)****
>    because str[i..] matches with
>
>    ****str[K..]****
>    for atleast
>
>    ****R-i+1****
>    characters (they are in[L, R] interval which we know is a prefix substring).
>
>
>
>    Now two sub cases arise:
>    * If
>
>      ****Z[K] < R-i+1****
>      then there is no prefix substring starting at str[i] (otherwise
>
>      ****Z[K]****
>      would be larger)  so  Z[i] = Z[K]and interval [L, R] remains same.
>    * If
>
>      ****Z[K] >= R-i+1****
>      then it is possible to extend the [L, R] interval thus we will set L as i and start matching from
>
>      ****str[R]****
>      onwards  and get new R then we will update interval [L, R] and calculate
>
>      ****Z[i] (=R-L+1)****
>      .

![Construction of Z array](https://media.geeksforgeeks.org/wp-content/uploads/20200224124754/Untitled-Diagram371.jpg)

Construction of Z array


Below is the implementation of the Z algorithm:


C++

````
// A C++ program that implements Z algorithm for pattern
// searching
#include <iostream>
using namespace std;

void getZarr(string str, int Z[]);

// prints all occurrences of pattern in text using Z algo
void search(string text, string pattern)
{
    // Create concatenated string "P$T"
    string concat = pattern + "$" + text;
    int l = concat.length();

    // Construct Z array
    int Z[l];
    getZarr(concat, Z);

    // now looping through Z array for matching condition
    for (int i = 0; i < l; ++i) {
        // if Z[i] (matched region) is equal to pattern
        // length we got the pattern
        if (Z[i] == pattern.length())
            cout << "Pattern found at index "
                 << i - pattern.length() - 1 << endl;
    }
}

// Fills Z array for given string str[]
void getZarr(string str, int Z[])
{
    int n = str.length();
    int L, R, k;

    // [L, R] make a window which matches with prefix of s
    L = R = 0;
    for (int i = 1; i < n; ++i) {
        // if i>R nothing matches so we will calculate.
        // Z[i] using naive way.
        if (i > R) {
            L = R = i;

            // R-L = 0 in starting, so it will start
            // checking from 0\'th index. For example,
            // for "ababab" and i = 1, the value of R
            // remains 0 and Z[i] becomes 0. For string
            // "aaaaaa" and i = 1, Z[i] and R become 5
            while (R < n && str[R - L] == str[R])
                R++;
            Z[i] = R - L;
            R--;
        }
        else {
            // k = i-L so k corresponds to number which
            // matches in [L, R] interval.
            k = i - L;

            // if Z[k] is less than remaining interval
            // then Z[i] will be equal to Z[k].
            // For example, str = "ababab", i = 3, R = 5
            // and L = 2
            if (Z[k] < R - i + 1)
                Z[i] = Z[k];

            // For example str = "aaaaaa" and i = 2, R is 5,
            // L is 0
            else {
                // else start from R and check manually
                L = i;
                while (R < n && str[R - L] == str[R])
                    R++;
                Z[i] = R - L;
                R--;
            }
        }
    }
}

// Driver program
int main()
{
    string text = "GEEKS FOR GEEKS";
    string pattern = "GEEK";
    search(text, pattern);
    return 0;
}

````

Java

````
// A Java program that implements Z algorithm for pattern
// searching
import java.io.*;

class GFG
{

  // prints all occurrences of pattern in text using Z
  // algo
  static void search(String text, String pattern)
  {

    // Create concatenated string "P$T"
    String concat = pattern + "$" + text;
    int l = concat.length();

    // Construct Z array
    int[] Z = new int[l];
    getZarr(concat, Z);

    // now looping through Z array for matching
    // condition
    for (int i = 0; i < l; i++) {
      // if Z[i] (matched region) is equal to pattern
      // length we got the pattern
      if (Z[i] == pattern.length()) {
        System.out.println(
          "Pattern found at index "
          + (i - pattern.length() - 1));
      }
    }
  }

  // Fills Z array for given string str[]
  static void getZarr(String str, int[] Z)
  {
    int n = str.length();
    // [L, R] make a window which matches with prefix of
    // s
    int L = 0, R = 0, k;

    for (int i = 1; i < n; ++i) {
      // if i>R nothing matches so we will calculate.
      // Z[i] using naive way.
      if (i > R) {
        L = R = i;
        // R-L = 0 in starting, so it will start
        // checking from 0\'th index. For example,
        // for "ababab" and i = 1, the value of R
        // remains 0 and Z[i] becomes 0. For string
        // "aaaaaa" and i = 1, Z[i] and R become 5
        while (R < n
               && str.charAt(R - L)
               == str.charAt(R)) {
          R++;
        }
        Z[i] = R - L;
        R--;
      }
      else {
        // k = i-L so k corresponds to number which
        // matches in [L, R] interval.
        k = i - L;

        // if Z[k] is less than remaining interval
        // then Z[i] will be equal to Z[k].
        // For example, str = "ababab", i = 3, R = 5
        // and L = 2
        if (Z[k] < R - i + 1)
          Z[i] = Z[k];

        // For example str = "aaaaaa" and i = 2, R
        // is 5, L is 0
        else {
          // else start from R and check manually
          L = i;
          while (R < n
                 && str.charAt(R - L)
                 == str.charAt(R)) {
            R++;
          }
          Z[i] = R - L;
          R--;
        }
      }
    }
  }

  public static void main(String[] args)
  {
    String text = "GEEKS FOR GEEKS";
    String pattern = "GEEK";
    search(text, pattern);
  }
}

// This code is contributed by lokeshmvs21.

````

Python

````
# A Python program that implements Z algorithm for pattern
# searching
# Fills Z array for given string str[]
def getZarr(string, Z):
    n = len(string)

    # [L, R] make a window which matches with prefix of s
    L, R, k = 0, 0, 0
    Z[0] = n

    for i in range(1, n):

      # if i>R nothing matches so we will calculate.
        # Z[i] using naive way.
        if i > R:
            L, R = i, i

            # R-L = 0 in starting, so it will start
            # checking from 0\'th index. For example,
            # for "ababab" and i = 1, the value of R
            # remains 0 and Z[i] becomes 0. For string
            # "aaaaaa" and i = 1, Z[i] and R become 5
            while R < n and string[R - L] == string[R]:
                R += 1
            Z[i] = R - L
            R -= 1
        else:

          # k = i-L so k corresponds to number which
            # matches in [L, R] interval.
            k = i - L

            # if Z[k] is less than remaining interval
            # then Z[i] will be equal to Z[k].
            # For example, str = "ababab", i = 3, R = 5
            # and L = 2
            if Z[k] < R - i + 1:
                Z[i] = Z[k]

            # For example str = "aaaaaa" and i = 2, R is 5,
            # L is 0
            else:

              # else start from R and check manually
                L = i
                while R < n and string[R - L] == string[R]:
                    R += 1
                Z[i] = R - L
                R -= 1

# prints all occurrences of pattern in text using Z algo
def search(text, pattern):

  # Create concatenated string "P$T"
    concat = pattern + "$" + text
    l = len(concat)

    # Construct Z array
    Z = [0] * l
    getZarr(concat, Z)

    # now looping through Z array for matching condition
    for i in range(l):

      # if Z[i] (matched region) is equal to pattern
        # length we got the pattern
        if Z[i] == len(pattern):
            print("Pattern found at index", i - len(pattern) - 1)

# Driver program
if __name__ == "__main__":
    text = "GEEKS FOR GEEKS"
    pattern = "GEEK"
    search(text, pattern)

# This code is contributed by akashish__

````

C#

````
using System;
using System.Linq;

public class GFG {

  // prints all occurrences of pattern in text using Z
  // algo
  static void search(string text, string pattern)
  {
    // Create concatenated string "P$T"
    string concat = pattern + "$" + text;
    int l = concat.Length;

    // Construct Z array
    int[] Z = new int[l];
    GetZarr(concat, Z);

    // now looping through Z array for matching
    // condition
    for (int i = 0; i < l; i++) {
      // if Z[i] (matched region) is equal to
      // pattern length we got the pattern
      if (Z[i] == pattern.Length) {
        Console.WriteLine(
          "Pattern found at index "
          + (i - pattern.Length - 1));
      }
    }
  }

  // Fills Z array for given string str[]
  static void GetZarr(string str, int[] Z)
  {
    int n = str.Length;
    // [L, R] make a window which matches with
    // prefix of
    // s
    int L = 0, R = 0, k;

    for (int i = 1; i < n; ++i) {
      // if i>R nothing matches so we will
      // calculate. Z[i] using naive way.
      if (i > R) {
        L = R = i;
        // R-L = 0 in starting, so it will start
        // checking from 0\'th index. For
        // example, for "ababab" and i = 1, the
        // value of R remains 0 and Z[i] becomes
        // 0. For string "aaaaaa" and i = 1,
        // Z[i] and R become 5
        while (R < n && str[R - L] == str[R]) {
          R++;
        }
        Z[i] = R - L;
        R--;
      }
      else {
        // k = i-L so k corresponds to number
        // which matches in [L, R] interval.
        k = i - L;

        // if Z[k] is less than remaining
        // interval then Z[i] will be equal to
        // Z[k]. For example, str = "ababab", i
        // = 3, R = 5 and L = 2
        if (Z[k] < R - i + 1)
          Z[i] = Z[k];

        // For example str = "aaaaaa" and i = 2,
        // R is 5, L is 0
        else {
          // else start from R and check
          // manually
          L = i;
          while (R < n && str[R - L] == str[R]) {
            R++;
          }
          Z[i] = R - L;
          R--;
        }
      }
    }
  }

  static public void Main()
  {
    string text = "GEEKS FOR GEEKS";
    string pattern = "GEEK";
    search(text, pattern);
  }
}
// This code is contributed by akashish__

````

JavaScript

````
function search(text, pattern) {
  // Create concatenated string "P$T"
  let concat = pattern + "$" + text;
  let l = concat.length;

  // Construct Z array
  let Z = [];
  getZarr(concat, Z);

  // now looping through Z array for matching condition
  for (let i = 0; i < l; i++) {
    // if Z[i] (matched region) is equal to pattern
    // length we got the pattern
    if (Z[i] == pattern.length) {
      console.log(`Pattern found at index ${i - pattern.length - 1}`);
    }
  }
}

// Fills Z array for given string str[]
function getZarr(str, Z) {
  let n = str.length;
  let L, R, k;

  // [L, R] make a window which matches with prefix of s
  L = R = 0;
  for (let i = 1; i < n; i++) {
    // if i>R nothing matches so we will calculate.
    // Z[i] using naive way.
    if (i > R) {
      L = R = i;

      // R-L = 0 in starting, so it will start
      // checking from 0\'th index. For example,
      // for "ababab" and i = 1, the value of R
      // remains 0 and Z[i] becomes 0. For string
      // "aaaaaa" and i = 1, Z[i] and R become 5
      while (R < n && str[R - L] == str[R]) {
        R++;
      }
      Z[i] = R - L;
      R--;
    } else {
      // k = i-L so k corresponds to number which
      // matches in [L, R] interval.
      k = i - L;

      // if Z[k] is less than remaining interval
      // then Z[i] will be equal to Z[k].
      // For example, str = "ababab", i = 3, R = 5
      // and L = 2
      if (Z[k] < R - i + 1) {
        Z[i] = Z[k];
      }

      // For example str = "aaaaaa" and i = 2, R is 5,
      // L is 0
      else {
        // else start from R and check manually
        L = i;
        while (R < n && str[R - L] == str[R]) {
          R++;
        }
        Z[i] = R - L;
        R--;
      }
    }
  }
}

// Driver program
let text = "GEEKS FOR GEEKS";
let pattern = "GEEK";
search(text, pattern);

// This code is contributed by akashish__

````




**Output**
```
Pattern found at index 0
Pattern found at index 10
```

****Time Complexity:****
O(m+n), where m is length of pattern and n is length of text.



****Auxiliary Space:****
O(m+n)


[Aho-Corasick algorithm](https://www.geeksforgeeks.org/aho-corasick-algorithm-pattern-searching/)
:
---------------------------------------------------------------------------------------------------

****Aho-Corasick Algorithm****
finds all words in O(n + m + z) time where z is the total number of occurrences of words in text. The Aho–Corasick string matching algorithm formed the basis of the original Unix command

****“fgrep”****
.


****Preprocessing:****
Build an automaton of all words in arr[] The automaton has mainly three functions:


> ****Go To:****
> This function simply follows edges of Trie of all words in arr[].
>
>
>
> It is represented as 2D array g[][] where we store next state for current state and character.
>
>
> ****Failure:****
> This function stores all edges that are followed when current character doesn’t have edge in Trie.
>
>
>
> It is represented as1D array f[] where we store next state for current state.
>
>
> ****Output:****
> Stores indexes of all words that end at current state.
>
>
>
> It is represented as 1D  array o[] where we store indices of all matching words as a bitmap for current state.

****Matching:****
Traverse the given text over built automaton to find all matching words.



Preprocessing:


### ****Illustration of Aho-Corasick algorithm****

****Preprocessing:****
We first Build a Trie (or Keyword Tree) of all words.


![ Build a Trie (or Keyword Tree) of all words.](https://media.geeksforgeeks.org/wp-content/uploads/20221108113210/aho.png)

Build a Trie (or Keyword Tree) of all words.

* This part fills entries in goto g[][] and output o[].
* Next, we extend Trie into an automaton to support linear time matching.

![ills entries in goto g[][] and output o[]](https://media.geeksforgeeks.org/wp-content/uploads/20221108113225/aho2.png)

Fills entries in goto g[][] and output o[]

* This part fills entries in failure f[] and output o[].

****Go to:****
We build Trie. And for all characters which don’t have an edge at the root, we add an edge back to root.



****Failure:****
For a state s, we find the longest proper suffix which is a proper prefix of some pattern. This is done using Breadth First Traversal of Trie.



****Output:****
For a state s, indexes of all words ending at s are stored. These indexes are stored as bitwise map (by doing bitwise OR of values). This is also computing using Breadth First Traversal with Failure.


Below is the implementation of the Aho-Corasick Algorithm:


C++

````
// C++ program for implementation of
// Aho Corasick algorithm for String
// matching
#include <bits/stdc++.h>
using namespace std;

// Max number of states in the matching
// machine. Should be equal to the sum
// of the length of all keywords.

#define MAXS 500

// Maximum number of characters
// in input alphabet

#define MAXC 26

// OUTPUT FUNCTION IS IMPLEMENTED USING out[]
// Bit i in this mask is one if the word with
// index i appears when the machine enters
// this state.
int out[MAXS];

// FAILURE FUNCTION IS IMPLEMENTED USING f[]
int f[MAXS];

// GOTO FUNCTION (OR TRIE) IS
// IMPLEMENTED USING g[][]
int g[MAXS][MAXC];

// Builds the String matching machine.
// arr - array of words. The index of each keyword is
// important:
//"out[state] & (1 << i)" is > 0 if we just found
// word[i] in the text.
// Returns the number of states that the built machine
// has. States are numbered 0 up to the return value -
// 1, inclusive.

int buildMatchingMachine(string arr[], int k)
{
    // Initialize all values in output function as 0.
    memset(out, 0, sizeof out);

    // Initialize all values in goto function as -1.
    memset(g, -1, sizeof g);

    // Initially, we just have the 0 state
    int states = 1;

    // Convalues for goto function, i.e., fill g[][]
    // This is same as building a Trie for arr[]
    for (int i = 0; i < k; i++) {
        string word = arr[i];
        int currentState = 0;

        // Insert all characters of current
        // word in arr[]
        for (int j = 0; j < word.length(); j++) {
            int ch = word[j] - \'a\';

            // Allocate a new node (create a new state)
            // if a node for ch doesn\'t exist.
            if (g[currentState][ch] == -1)
                g[currentState][ch] = states++;

            currentState = g[currentState][ch];
        }

        // Add current word in output function
        out[currentState] |= (1 << i);
    }

    // For all characters which don\'t have
    // an edge from root (or state 0) in Trie,
    // add a goto edge to state 0 itself
    for (int ch = 0; ch < MAXC; ch++)
        if (g[0][ch] == -1)
            g[0][ch] = 0;

    // Now, let\'s build the failure function
    // Initialize values in fail function
    memset(f, -1, sizeof f);

    // Failure function is computed in
    // breadth first order
    // using a queue
    queue<int> q;

    // Iterate over every possible input
    for (int ch = 0; ch < MAXC; ch++) {

        // All nodes of depth 1 have failure
        // function value as 0. For example,
        // in above diagram we move to 0
        // from states 1 and 3.
        if (g[0][ch] != 0) {
            f[g[0][ch]] = 0;
            q.push(g[0][ch]);
        }
    }

    // Now queue has states 1 and 3
    while (!q.empty()) {

        // Remove the front state from queue
        int state = q.front();
        q.pop();

        // For the removed state, find failure
        // function for all those characters
        // for which goto function is
        // not defined.
        for (int ch = 0; ch < MAXC; ch++) {

            // If goto function is defined for
            // character \'ch\' and \'state\'
            if (g[state][ch] != -1) {

                // Find failure state of removed state
                int failure = f[state];

                // Find the deepest node labeled by
                // proper suffix of String from root to
                // current state.
                while (g[failure][ch] == -1)
                    failure = f[failure];
                failure = g[failure][ch];
                f[g[state][ch]] = failure;

                // Merge output values
                out[g[state][ch]] |= out[failure];

                // Insert the next level node
                // (of Trie) in Queue
                q.push(g[state][ch]);
            }
        }
    }
    return states;
}

// Returns the next state the machine will transition to
// using goto and failure functions. currentState - The
// current state of the machine. Must be between
// 0 and the number of states - 1,
// inclusive.
// nextInput - The next character that enters into the
// machine.

// This function finds all occurrences of
// all array words in text.
void searchWords(string arr[], int k, string text)
{

    // Preprocess patterns.
    // Build machine with goto, failure
    // and output functions
    buildMatchingMachine(arr, k);

    // Initialize current state
    int currentState = 0;

    // Traverse the text through the
    // built machine to find all
    // occurrences of words in arr[]
    for (int i = 0; i < text.length(); i++) {
        int ch = text[i] - \'a\';

        // If goto is not defined, use
        // failure function
        while (g[currentState][ch] == -1)
            currentState = f[currentState];
        currentState = g[currentState][ch];

        // If match not found, move to next state
        if (out[currentState] == 0)
            continue;

        // Match found, print all matching
        // words of arr[]
        // using output function.
        for (int j = 0; j < k; j++) {
            if (out[currentState] & (1 << j))
                cout << "Word " << arr[j]
                     << " appears from "
                     << i - arr[j].length() + 1 << " to "
                     << i << endl;
        }
    }
}
// Driver code

int main()
{
    string arr[] = { "he", "she", "hers", "his" };
    int k = sizeof(arr) / sizeof(arr[0]);
    string text = "ahishers";
    searchWords(arr, k, text);
    return 0;
}

````

Java

````
// Java program for implementation of
// Aho Corasick algorithm for String
// matching
import java.util.*;

class GFG {

    // Max number of states in the matching
    // machine. Should be equal to the sum
    // of the length of all keywords.
    static int MAXS = 500;

    // Maximum number of characters
    // in input alphabet
    static int MAXC = 26;

    // OUTPUT FUNCTION IS IMPLEMENTED USING out[]
    // Bit i in this mask is one if the word with
    // index i appears when the machine enters
    // this state.
    static int[] out = new int[MAXS];

    // FAILURE FUNCTION IS IMPLEMENTED USING f[]
    static int[] f = new int[MAXS];

    // GOTO FUNCTION (OR TRIE) IS
    // IMPLEMENTED USING g[][]
    static int[][] g = new int[MAXS][MAXC];

    // Builds the String matching machine.
    // arr - array of words. The index of each keyword is
    // important:
    //         "out[state] & (1 << i)" is > 0 if we just
    //         found
    // word[i]          in the text.
    // Returns the number of states that the built machine
    // has. States are numbered 0 up to the return value -
    // 1, inclusive.
    static int buildMatchingMachine(String arr[], int k)
    {

        // Initialize all values in output function as 0.
        Arrays.fill(out, 0);

        // Initialize all values in goto function as -1.
        for (int i = 0; i < MAXS; i++)
            Arrays.fill(g[i], -1);

        // Initially, we just have the 0 state
        int states = 1;

        // Convalues for goto function, i.e., fill g[][]
        // This is same as building a Trie for arr[]
        for (int i = 0; i < k; ++i) {
            String word = arr[i];
            int currentState = 0;

            // Insert all characters of current
            // word in arr[]
            for (int j = 0; j < word.length(); ++j) {
                int ch = word.charAt(j) - \'a\';

                // Allocate a new node (create a new state)
                // if a node for ch doesn\'t exist.
                if (g[currentState][ch] == -1)
                    g[currentState][ch] = states++;

                currentState = g[currentState][ch];
            }

            // Add current word in output function
            out[currentState] |= (1 << i);
        }

        // For all characters which don\'t have
        // an edge from root (or state 0) in Trie,
        // add a goto edge to state 0 itself
        for (int ch = 0; ch < MAXC; ++ch)
            if (g[0][ch] == -1)
                g[0][ch] = 0;

        // Now, let\'s build the failure function
        // Initialize values in fail function
        Arrays.fill(f, -1);

        // Failure function is computed in
        // breadth first order
        // using a queue
        Queue<Integer> q = new LinkedList<>();

        // Iterate over every possible input
        for (int ch = 0; ch < MAXC; ++ch) {

            // All nodes of depth 1 have failure
            // function value as 0. For example,
            // in above diagram we move to 0
            // from states 1 and 3.
            if (g[0][ch] != 0) {
                f[g[0][ch]] = 0;
                q.add(g[0][ch]);
            }
        }

        // Now queue has states 1 and 3
        while (!q.isEmpty()) {

            // Remove the front state from queue
            int state = q.peek();
            q.remove();

            // For the removed state, find failure
            // function for all those characters
            // for which goto function is
            // not defined.
            for (int ch = 0; ch < MAXC; ++ch) {

                // If goto function is defined for
                // character \'ch\' and \'state\'
                if (g[state][ch] != -1) {

                    // Find failure state of removed state
                    int failure = f[state];

                    // Find the deepest node labeled by
                    // proper suffix of String from root to
                    // current state.
                    while (g[failure][ch] == -1)
                        failure = f[failure];

                    failure = g[failure][ch];
                    f[g[state][ch]] = failure;

                    // Merge output values
                    out[g[state][ch]] |= out[failure];

                    // Insert the next level node
                    // (of Trie) in Queue
                    q.add(g[state][ch]);
                }
            }
        }
        return states;
    }

    // Returns the next state the machine will transition to
    // using goto and failure functions. currentState - The
    // current state of the machine. Must be between
    // 0 and the number of states - 1,
    // inclusive.
    // nextInput - The next character that enters into the
    // machine.
    static int findNextState(int currentState,
                             char nextInput)
    {
        int answer = currentState;
        int ch = nextInput - \'a\';

        // If goto is not defined, use
        // failure function
        while (g[answer][ch] == -1)
            answer = f[answer];

        return g[answer][ch];
    }

    // This function finds all occurrences of
    // all array words in text.
    static void searchWords(String arr[], int k,
                            String text)
    {

        // Preprocess patterns.
        // Build machine with goto, failure
        // and output functions
        buildMatchingMachine(arr, k);

        // Initialize current state
        int currentState = 0;

        // Traverse the text through the
        // built machine to find all
        // occurrences of words in arr[]
        for (int i = 0; i < text.length(); ++i) {
            currentState = findNextState(currentState,
                                         text.charAt(i));

            // If match not found, move to next state
            if (out[currentState] == 0)
                continue;

            // Match found, print all matching
            // words of arr[]
            // using output function.
            for (int j = 0; j < k; ++j) {
                if ((out[currentState] & (1 << j)) > 0) {
                    System.out.print(
                        "Word " + arr[j] + " appears from "
                        + (i - arr[j].length() + 1) + " to "
                        + i + "\\n");
                }
            }
        }
    }

    // Driver code
    public static void main(String[] args)
    {
        String arr[] = { "he", "she", "hers", "his" };
        String text = "ahishers";
        int k = arr.length;

        searchWords(arr, k, text);
    }
}
// This code is wriiten by Sundaram.

````

Python

````
# Python program for implementation of
# Aho-Corasick algorithm for string matching

# defaultdict is used only for storing the final output
# We will return a dictionary where key is the matched word
# and value is the list of indexes of matched word
from collections import defaultdict

# For simplicity, Arrays and Queues have been implemented using lists.
# If you want to improve performance try using them instead


class AhoCorasick:
    def __init__(self, words):

        # Max number of states in the matching machine.
        # Should be equal to the sum of the length of all keywords.
        self.max_states = sum([len(word) for word in words])

        # Maximum number of characters.
        # Currently supports only alphabets [a, z]
        self.max_characters = 26

        # OUTPUT FUNCTION IS IMPLEMENTED USING out []
        # Bit i in this mask is 1 if the word with
        # index i appears when the machine enters this state.
        # Lets say, a state outputs two words "he" and "she" and
        # in our provided words list, he has index 0 and she has index 3
        # so value of out[state] for this state will be 1001
        # It has been initialized to all 0.
        # We have taken one extra state for the root.
        self.out = [0]*(self.max_states + 1)

        # FAILURE FUNCTION IS IMPLEMENTED USING fail []
        # There is one value for each state + 1 for the root
        # It has been initialized to all -1
        # This will contain the fail state value for each state
        self.fail = [-1]*(self.max_states + 1)

        # GOTO FUNCTION (OR TRIE) IS IMPLEMENTED USING goto [[]]
        # Number of rows = max_states + 1
        # Number of columns = max_characters i.e 26 in our case
        # It has been initialized to all -1.
        self.goto = [
            [-1]*self.max_characters for _ in range(self.max_states + 1)]

        # Convert all words to lowercase
        # so that our search is case insensitive
        for i in range(len(words)):
            words[i] = words[i].lower()

        # All the words in dictionary which will be used to create Trie
        # The index of each keyword is important:
        # "out[state] & (1 << i)" is > 0 if we just found word[i]
        # in the text.
        self.words = words

        # Once the Trie has been built, it will contain the number
        # of nodes in Trie which is total number of states required <= max_states
        self.states_count = self.__build_matching_machine()

    # Builds the String matching machine.
    # Returns the number of states that the built machine has.
    # States are numbered 0 up to the return value - 1, inclusive.

    def __build_matching_machine(self):
        k = len(self.words)

        # Initially, we just have the 0 state
        states = 1

        # Convalues for goto function, i.e., fill goto
        # This is same as building a Trie for words[]
        for i in range(k):
            word = self.words[i]
            current_state = 0

            # Process all the characters of the current word
            for character in word:
                ch = ord(character) - 97  # Ascii value of \'a\' = 97

                # Allocate a new node (create a new state)
                # if a node for ch doesn\'t exist.
                if self.goto[current_state][ch] == -1:
                    self.goto[current_state][ch] = states
                    states += 1

                current_state = self.goto[current_state][ch]

            # Add current word in output function
            self.out[current_state] |= (1 << i)

        # For all characters which don\'t have
        # an edge from root (or state 0) in Trie,
        # add a goto edge to state 0 itself
        for ch in range(self.max_characters):
            if self.goto[0][ch] == -1:
                self.goto[0][ch] = 0

        # Failure function is computed in
        # breadth first order using a queue
        queue = []

        # Iterate over every possible input
        for ch in range(self.max_characters):

            # All nodes of depth 1 have failure
            # function value as 0. For example,
            # in above diagram we move to 0
            # from states 1 and 3.
            if self.goto[0][ch] != 0:
                self.fail[self.goto[0][ch]] = 0
                queue.append(self.goto[0][ch])

        # Now queue has states 1 and 3
        while queue:

            # Remove the front state from queue
            state = queue.pop(0)

            # For the removed state, find failure
            # function for all those characters
            # for which goto function is not defined.
            for ch in range(self.max_characters):

                # If goto function is defined for
                # character \'ch\' and \'state\'
                if self.goto[state][ch] != -1:

                    # Find failure state of removed state
                    failure = self.fail[state]

                    # Find the deepest node labeled by proper
                    # suffix of String from root to current state.
                    while self.goto[failure][ch] == -1:
                        failure = self.fail[failure]

                    failure = self.goto[failure][ch]
                    self.fail[self.goto[state][ch]] = failure

                    # Merge output values
                    self.out[self.goto[state][ch]] |= self.out[failure]

                    # Insert the next level node (of Trie) in Queue
                    queue.append(self.goto[state][ch])

        return states

    # Returns the next state the machine will transition to using goto
    # and failure functions.
    # current_state - The current state of the machine. Must be between
    # 0 and the number of states - 1, inclusive.
    # next_input - The next character that enters into the machine.

    def __find_next_state(self, current_state, next_input):
        answer = current_state
        ch = ord(next_input) - 97  # Ascii value of \'a\' is 97

        # If goto is not defined, use
        # failure function
        while self.goto[answer][ch] == -1:
            answer = self.fail[answer]

        return self.goto[answer][ch]

    # This function finds all occurrences of all words in text.

    def search_words(self, text):
        # Convert the text to lowercase to make search case insensitive
        text = text.lower()

        # Initialize current_state to 0
        current_state = 0

        # A dictionary to store the result.
        # Key here is the found word
        # Value is a list of all occurrences start index
        result = defaultdict(list)

        # Traverse the text through the built machine
        # to find all occurrences of words
        for i in range(len(text)):
            current_state = self.__find_next_state(current_state, text[i])

            # If match not found, move to next state
            if self.out[current_state] == 0:
                continue

            # Match found, store the word in result dictionary
            for j in range(len(self.words)):
                if (self.out[current_state] & (1 << j)) > 0:
                    word = self.words[j]

                    # Start index of word is (i-len(word)+1)
                    result[word].append(i-len(word)+1)

        # Return the final result dictionary
        return result


# Driver code
if __name__ == "__main__":
    words = ["he", "she", "hers", "his"]
    text = "ahishers"

    # Create an Object to initialize the Trie
    aho_chorasick = AhoCorasick(words)

    # Get the result
    result = aho_chorasick.search_words(text)

    # Print the result
    for word in result:
        for i in result[word]:
            print("Word", word, "appears from", i, "to", i + len(word)-1)

````

JavaScript

````
const MAXS = 500;
const MAXC = 26;

let out = new Array(MAXS).fill(0);
let f = new Array(MAXS).fill(-1);
let g = Array.from(Array(MAXS), () => new Array(MAXC).fill(-1));

function buildMatchingMachine(arr, k) {
  out.fill(0);
  g.forEach(row => row.fill(-1));
  let states = 1;
  for (let i = 0; i < k; i++) {
    const word = arr[i];
    let currentState = 0;
    for (let j = 0; j < word.length; j++) {
      const ch = word.charCodeAt(j) - \'a\'.charCodeAt(0);
      if (g[currentState][ch] === -1) g[currentState][ch] = states++;
      currentState = g[currentState][ch];
    }
    out[currentState] |= 1 << i;
  }
  for (let ch = 0; ch < MAXC; ch++) {
    if (g[0][ch] === -1) g[0][ch] = 0;
  }
  f.fill(-1);
  const q = [];
  for (let ch = 0; ch < MAXC; ch++) {
    if (g[0][ch] !== 0) {
      f[g[0][ch]] = 0;
      q.push(g[0][ch]);
    }
  }
  while (q.length) {
    const state = q.shift();
    for (let ch = 0; ch < MAXC; ch++) {
      if (g[state][ch] !== -1) {
        let failure = f[state];
        while (g[failure][ch] === -1) failure = f[failure];
        failure = g[failure][ch];
        f[g[state][ch]] = failure;
        out[g[state][ch]] |= out[failure];
        q.push(g[state][ch]);
      }
    }
  }
  return states;
}

function searchWords(arr, k, text) {
  buildMatchingMachine(arr, k);
  let currentState = 0;
  for (let i = 0; i < text.length; i++) {
    const ch = text.charCodeAt(i) - \'a\'.charCodeAt(0);
    while (g[currentState][ch] === -1) currentState = f[currentState];
    currentState = g[currentState][ch];
    if (out[currentState] === 0) continue;
    for (let j = 0; j < k; j++) {
      if (out[currentState] & (1 << j)) {
        console.log(`Word ${arr[j]} appears from ${i - arr[j].length + 1} to ${i}`);
      }
    }
  }
}

// Driver code
const arr = ["he", "she", "hers", "his"];
const k = arr.length;
const text = "ahishers";
searchWords(arr, k, text);

````




**Output**
```
Word his appears from 1 to 3
Word he appears from 4 to 5
Word she appears from 3 to 5
Word hers appears from 4 to 7
```

****Time Complexity:****
O(n + l + z), where ‘n’ is the length of the text, ‘l’ is the length of keywords, and ‘z’ is the number of matches.



****Auxiliary Space:****
O(l \\* q), where ‘q’ is the length of the alphabet since that is the maximum number of children a node can have.', 'We use certain algorithms to do the search process. The complexity of pattern searching varies from algorithm to algorithm. They are very useful when performing a search in a database. The Pattern Searching algorithm is useful for finding patterns in substrings of larger strings. This process can be accomplished using a variety of algorithms that we are going to discuss in this blog.', 'Introduction to Pattern Searching – Data Structure and Algorithm Tutorial', 6, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('b8165176-c256-44f6-bc1a-a32a3626fad5', e'Table of Content

* [What is Backtracking?](#what-is-backtracking)
* [Types of Backtracking Problems](#types-of-backtracking-problems)
* [How does Backtracking works?](#how-does-backtracking-works)
* [Determining Backtracking Problems](#determining-backtracking-problems)
* [Pseudocode for Backtracking](#pseudocode-for-backtracking)
* [Complexity Analysis of Backtracking](#complexity-analysis-of-backtracking)
* [How Backtracking is different from Recursion?](#how-backtracking-is-different-from-recursion)
* [Applications of Backtracking](#applications-of-backtracking)
* [Must Do Backtracking Problems](#must-do-backtracking-problems)

What is Backtracking?
---------------------


Backtracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying

****different options****
and

****undoing****
them if they lead to a

****dead end****
. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted.


> Backtracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem.

![backtracking-banner-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20231016112106/backtracking-banner-(1).png)

Introduction to Backtracking

### Basic Terminologies

* ****Candidate:****
  A candidate is a potential choice or element that can be added to the current solution.
* ****Solution:****
  The solution is a valid and complete configuration that satisfies all problem constraints.
* ****Partial Solution:****
  A partial solution is an intermediate or incomplete configuration being constructed during the backtracking process.
* ****Decision Space:****
  The decision space is the set of all possible candidates or choices at each decision point.
* ****Decision Point:****
  A decision point is a specific step in the algorithm where a candidate is chosen and added to the partial solution.
* ****Feasible Solution:****
  A feasible solution is a partial or complete solution that adheres to all constraints.
* ****Dead End:****
  A dead end occurs when a partial solution cannot be extended without violating constraints.
* ****Backtrack:****
  Backtracking involves undoing previous decisions and returning to a prior decision point.
* ****Search Space:****
  The search space includes all possible combinations of candidates and choices.
* ****Optimal Solution:****
  In optimization problems, the optimal solution is the best possible solution.

Types of Backtracking Problems
------------------------------


Problems associated with backtracking can be categorized into 3 categories:


* ****Decision Problems:****
  Here, we search for a feasible solution.
* ****Optimization Problems:****
  For this type, we search for the best solution.
* ****Enumeration Problems:****
  We find set of all possible feasible solution to the problems of this type.

How does Backtracking works?
----------------------------

> As we know backtracking algorithm explores each and every possible path in order to find a valid solution, this exploration of path can be easily understood via given images:
>
>
> ![backtracking](https://media.geeksforgeeks.org/wp-content/uploads/20231010124142/backtracking.png)
>
>
> As shown in the image, “
>
> ****IS”****
> represents the
>
> ****Initial State****
> where the recursion call starts to find a valid solution.
>
>
>
> ****C :****
> it represents different
>
> ****Checkpoints****
> for recursive calls
>
>
> ****TN****
> : it represents the
>
> ****Terminal Nodes****
> where no further recursive calls can be made, these nodes act as base case of recursion and we determine whether the current solution is valid or not at this state.
>
>
> At each Checkpoint, our program makes some decisions and move to other checkpoints untill it reaches a terminal Node, after determining whether a solution is valid or not, the program starts to revert back to the checkpoints and try to explore other paths. For example in the above image
>
> ****TN1…TN5****
> are the terminal node where the solution is not acceptable, while
>
> ****TN6****
> is the state where we found a valid solution.
>
>
> The back arrows in the images shows backtracking in actions, where we revert the changes made by some checkpoint.

Determining Backtracking Problems:
----------------------------------


Generally every constraint satisfaction problem can be solved using backtracking but, Is it optimal to use backtracking every time? Turns out

****NO****
, there are a vast number of problem that can be solved using

[Greedy](https://www.geeksforgeeks.org/introduction-to-greedy-algorithm-data-structures-and-algorithm-tutorials/)
or

[Dynamic programming](https://www.geeksforgeeks.org/dynamic-programming/)
in logarithmic or polynomial time complexity which is far better than exponential complexity of Backtracking. However many problems still exists that can only be solved using Backtracking.


> To understand whether a problem is Backtracking based or not, let us take a simple problem:
>
>
>
> ****Problem:****
>
> Imagine you have 3 closed boxes, among which 2 are empty and 1 has a gold coin. Your task is to get the gold coin.
>
>
> ****Why dynamic programming fails to solve this question:****
>
> ****D****
> oes opening or closing one box has any effect on the other box? Turns out NO, each and every box is independent of each other and opening/closing state of one box can not determine the transition for other boxes. Hence DP fails.
>
>
> ****Why greedy fails to solve this question:****
>
>
> Greedy algorithm chooses a local maxima in order to get global maxima, but in this problem each and every box has equal probability of having a gold coin i.e 1/3 hence there is no criteria to make a greedy choice.
>
>
> ****Why Backtracking works:****
>
> As discussed already, backtracking algorithm is simply brute forcing each and every choice, hence we can one by one choose every box to find the gold coin, If a box is found empty we can close it back which acts as a Backtracking step.
>
>
> Technically, for backtracking problems:
>
>
> * The algorithm builds a solution by exploring all possible paths created by the choices in the problem, this solution begins with an empty set
>
>   ****S={}****
> * Each choice creates a new sub-tree ‘
>
>   ****s’****
>   which we add into are set.
> * Now there exist two cases:
>   + ****S+s is valid set****
>   + ****S+s is not valid set****
> * In case the set is valid then we further make choices and repeat the process until a solution is found, otherwise we backtrack our decision of including ‘
>
>   ****s’****
>   and explore other paths until a solution is found or all the possible paths are exhausted.

Pseudocode for Backtracking
---------------------------


The best way to implement backtracking is through recursion, and all backtracking code can be summarised as per the given Pseudocode:


> void
>
> ****FIND\\_SOLUTIONS****
> ( parameters):
>
>
> if (valid
>
> ****solution****
> ):
>
>
> store the
>
> ****solution****
>
>
> Return
>
>
> for (all
>
> ****choice****
> ):
>
>
> if (valid
>
> ****choice****
> ):
>
>
> ****APPLY****
> (
>
> ****choice****
> )
>
>
> ****FIND\\_SOLUTIONS****
> (parameters)
>
>
> ****BACKTRACK****
> (remove
>
> ****choice****
> )
>
>
> Return

Complexity Analysis of Backtracking
-----------------------------------


Since backtracking algorithm is purely brute force therefore in terms of time complexity, it performs very poorly. Generally backtracking can be seen having below mentioned time complexities:


* Exponential (O(K^N))
* Factorial (O(N!))


These complexities are due to the fact that at each state we have multiple choices due to which the number of paths increases and sub-trees expand rapidly.


How Backtracking is different from Recursion?
---------------------------------------------


Recursion and Backtracking are related concepts in computer science and programming, but they are not the same thing. Let’s explore the key differences between them:


Applications of Backtracking
----------------------------

* Creating smart bots to play Board Games such as Chess.
* Solving mazes and puzzles such as N-Queen problem.
* Network Routing and Congestion Control.
* Decryption
* Text Justification', 'Backtracking is like trying different paths, and when you hit a dead end, you backtrack to the last choice and try a different route. In this article, we’ll explore the basics of backtracking, how it works, and how it can help solve all sorts of challenging problems. It’s like a method for finding the right way through a complex choices.', 'Introduction to Backtracking', 1, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', '8f893dfd-b897-4bd5-9c29-097703871710');
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('2250b823-d1c9-4781-9d3d-71a989d37c49', e'What is a Doubly Linked List?
-----------------------------

A ****doubly linked list****
is a data structure that consists of a set of nodes, each of which
contains a ****value**** and ****two pointers****, one pointing to the ****previous node**** in the list and one pointing to the ****next node****
in the list. This allows for efficient traversal of the list in ****both directions****, making it suitable for applications where frequent ****insertions**** and ****deletions**** are required.

![Insertion-at-the-End-in-Doubly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20240809123741/Insertion-at-the-End-in-Doubly-Linked-List-copy.webp)

Doubly Linked List


Representation of Doubly Linked List in Data Structure
------------------------------------------------------

In a data structure, a doubly linked list is represented using nodes
that have three fields:

1. Data
2. A pointer to the next node (****next****)
3. A pointer to the previous node (****prev****)

![Node-Structure-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124907/Node-Structure-of-Doubly-Linked-List.webp)

Node Structure of Doubly Linked List


Node Definition
---------------

Here is how a node in a Doubly Linked List is typically
represented:

[Try it on GfG Practice
![redirect icon](https://media.geeksforgeeks.org/auth-dashboard-uploads/Group-arrow.svg)](https://www.geeksforgeeks.org/problems/display-doubly-linked-list--154650/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card)
C++
````
struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;

    // Constructor
    Node(int d) {
       data = d;
       prev = next = nullptr;
    }
};

````

C
````
struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;
};

// Function to create a new node
struct Node *createNode(int new_data) {
    struct Node *new_node = (struct Node *)
    malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}

````

Java
````
class Node {

    // To store the Value or data.
    int data;

    // Reference to the Previous Node
    Node prev;

    // Reference to the next Node
    Node next;

    // Constructor
    Node(int d) {
       data = d;
       prev = next = null;
    }
};

````

Python
````
class Node:

    def __init__(self, data):
        # To store the value or data.
        self.data = data

        # Reference to the previous node
        self.prev = None

        # Reference to the next node
        self.next = None

````

C#
````
class Node
{
  	// To store the value or data
    public int Data;

  	// Pointer to the next node
    public Node Next;

  	// Pointer to the previous node
    public Node Prev;

    // Constructor
    public Node(int d)
    {
        Data = d;
        Prev = Next = null;
    }
}

````

JavaScript
````
class Node {
    constructor(data)
    {
        // To store the value or data.
        this.data = data;

        // Reference to the previous node
        this.prev = null;

        // Reference to the next node
        this.next = null;
    }
}

````

Each node in a ****Doubly Linked List**** contains the ****data**** it holds, a pointer to the ****next**** node in the list, and a pointer to the ****previous****
node in the list. By linking these nodes together through the ****next**** and ****prev****
pointers, we can traverse the list in both directions (forward and
backward), which is a key feature of a Doubly Linked List.

[Operations on Doubly Linked List](https://www.geeksforgeeks.org/doubly-linked-list-tutorial)
---------------------------------------------------------------------------------------------

* ****Traversal in Doubly Linked List****
* ****Searching in Doubly Linked List****
* ****Finding Length of Doubly Linked List****
* [****Insertion in Doubly Linked List****:](https://www.geeksforgeeks.org/introduction-and-insertion-in-a-doubly-linked-list)
  + Insertion at the beginning of Doubly Linked List
  + Insertion at the end of the Doubly Linked List
  + Insertion at a specific position in Doubly Linked List
* [****Deletion in Doubly Linked List****:](https://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list)
  + Deletion of a node at the beginning of Doubly Linked List
  + Deletion of a node at the end of Doubly Linked List
  + Deletion of a node at a specific position in Doubly Linked
    List

Let\'s go through each of the operations mentioned above, one by
one.

[Traversal in Doubly Linked List](https://www.geeksforgeeks.org/traversal-in-doubly-linked-list/)
-------------------------------------------------------------------------------------------------

To Traverse the doubly list, we can use the following steps:

****a. Forward Traversal:****

* Initialize a pointer to the head of the linked list.
* While the pointer is not null:
  + Visit the data at the current node.
  + Move the pointer to the next node.

****b. Backward Traversal:****

* Initialize a pointer to the tail of the linked list.
* While the pointer is not null:
  + Visit the data at the current node.
  + Move the pointer to the previous node.

Below are the implementation of the above approach:

C++
````
#include <iostream>
using namespace std;

// Define the Node structure
struct Node {
    int data;
    Node* next;
    Node* prev;

// Constructor to initialize Node with data
    Node(int data) : data(data), next(nullptr),
  	prev(nullptr) {}
};

// Function to traverse the doubly linked list
// in forward direction
void forwardTraversal(Node* head) {

    // Start traversal from the head of the list
    Node* curr = head;

// Continue until current node is not null
    // (end of list)
    while (curr != nullptr) {

        // Output data of the current node
        cout << curr->data << " ";

// Move to the next node
        curr = curr->next;
}

    // Print newline after traversal
    cout << endl;
}

// Function to traverse the doubly linked list
// in backward direction
void backwardTraversal(Node* tail) {

    // Start traversal from the tail of the list
    Node* curr = tail;

// Continue until current node is not null
    // (end of list)
    while (curr != nullptr) {

        // Output data of the current node
        cout << curr->data << " ";

// Move to the previous node
        curr = curr->prev;
}

    // Print newline after traversal
    cout << endl;
}

int main() {

    // Sample usage of the doubly linked list and
    // traversal functions
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    cout << "Forward Traversal:" << endl;
    forwardTraversal(head);

    cout << "Backward Traversal:" << endl;
    backwardTraversal(third);

return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data; // Data stored in the node
    struct Node* next; // Pointer to the next node
    struct Node* prev; // Pointer to the previous node
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode =
      (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
return newNode;
}

// Function to traverse the doubly linked list
// in forward direction
void forwardTraversal(struct Node* head) {

    // Start traversal from the head of the list
    struct Node* curr = head;

// Continue until the current node is not
    // null (end of list)
    while (curr != NULL) {

        // Output data of the current node
        printf("%d ", curr->data);

// Move to the next node
        curr = curr->next;
}

    // Print newline after traversal
    printf("\\n");
}

// Function to traverse the doubly linked list
// in backward direction
void backwardTraversal(struct Node* tail) {

    // Start traversal from the tail of the list
    struct Node* curr = tail;

// Continue until the current node is not
    // null (end of list)
    while (curr != NULL) {

        // Output data of the current node
        printf("%d ", curr->data);

// Move to the previous node
        curr = curr->prev;
}

    // Print newline after traversal
    printf("\\n");
}

int main() {

    // Sample usage of the doubly linked list and
    // traversal functions
    struct Node* head = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    printf("Forward Traversal:\\n");
    forwardTraversal(head);

    printf("Backward Traversal:\\n");
    backwardTraversal(third);

// Free memory allocated for nodes
    free(head);
    free(second);
    free(third);

return 0;
}

````

Java
````
// Define the Node class
class Node {
    int data; // Data stored in the node
    Node next; // Pointer to the next node
    Node prev; // Pointer to the previous node

    // Constructor to initialize the node with data
    public Node(int data) {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

// Class to manage the doubly linked list
class GfG {

    // Function to traverse the doubly linked list
    // in forward direction
    static void forwardTraversal(Node head) {

        // Start traversal from the head of the list
        Node curr = head;

// Continue until the current node is
        // null (end of the list)
        while (curr != null) {

            // Output data of the current node
            System.out.print(curr.data + " ");

// Move to the next node
            curr = curr.next;
}

        // Print newline after traversal
        System.out.println();
}

    // Function to traverse the doubly linked list
  	//in backward direction
    static void backwardTraversal(Node tail) {

        // Start traversal from the tail of the list
        Node curr = tail;

// Continue until the current node is
        // null (end of the list)
        while (curr != null) {

            // Output data of the current node
            System.out.print(curr.data + " ");

// Move to the previous node
            curr = curr.prev;
}

        // Print newline after traversal
        System.out.println();
}

    public static void main(String[] args) {

        // Sample usage of the doubly linked
        // list and traversal functions
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        System.out.println("Forward Traversal:");
        forwardTraversal(head);

        System.out.println("Backward Traversal:");
        backwardTraversal(third);
}
}

````

Python
````
# Define the Node class
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Function to traverse the doubly linked list
# in forward direction
def forward_traversal(head):

    # Start traversal from the head of the list
    curr = head

    # Continue until the current node is
    # null (end of the list)
    while curr is not None:

        # Output data of the current node
        print(curr.data, end=" ")

        # Move to the next node
        curr = curr.next

    # Print newline after traversal
    print()

# Function to traverse the doubly linked
# list in backward direction
def backward_traversal(tail):

    # Start traversal from the tail of the list
    curr = tail

    # Continue until the current node
    # is null (end of the list)
    while curr is not None:

        # Output data of the current node
        print(curr.data, end=" ")

        # Move to the previous node
        curr = curr.prev

    # Print newline after traversal
    print()

# Sample usage of the doubly linked list
# and traversal functions
if __name__ == "__main__":

    # Create a doubly linked list with 3 nodes
    head = Node(1)
    second = Node(2)
    third = Node(3)

    head.next = second
    second.prev = head
    second.next = third
    third.prev = second

    print("Forward Traversal:")
    forward_traversal(head)

    print("Backward Traversal:")
    backward_traversal(third)

````

C#
````
using System;

// Define the Node class
class Node
{
    public int Data; // Data stored in the node
    public Node Next; // Pointer to the next node
    public Node Prev; // Pointer to the previous node

    // Constructor to initialize the node with data
    public Node(int data)
    {
        Data = data;
Next = null;
        Prev = null;
}
}

// Class to manage the doubly linked list
class GfG
{
    // Function to traverse the doubly linked list
  	//in forward direction
    static void ForwardTraversal(Node head)
    {
        // Start traversal from the head of the list
        Node curr = head;

// Continue until the current node is null
      	//(end of the list)
        while (curr != null)
        {
            // Output data of the current node
            Console.Write(curr.Data + " ");

// Move to the next node
            curr = curr.Next;
}

        // Print newline after traversal
        Console.WriteLine();
}

    // Function to traverse the doubly linked list
  	//in backward direction
    static void BackwardTraversal(Node tail)
    {
        // Start traversal from the tail of the list
        Node curr = tail;

// Continue until the current node is null
      	//(end of the list)
        while (curr != null)
        {
            // Output data of the current node
            Console.Write(curr.Data + " ");

// Move to the previous node
            curr = curr.Prev;
}

        // Print newline after traversal
        Console.WriteLine();
}

    public static void Main()
    {
        // Sample usage of the doubly linked list
      	//and traversal functions
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.Next = second;
second.Prev = head;
second.Next = third;
        third.Prev = second;

        Console.WriteLine("Forward Traversal:");
        ForwardTraversal(head);

        Console.WriteLine("Backward Traversal:");
        BackwardTraversal(third);
}
}

````

JavaScript
````
// Define the Node class
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Function to traverse the doubly linked list
// in forward direction
function forwardTraversal(head) {

    // Start traversal from the head of the list
    let curr = head;

// Continue until the current node is null
    // (end of the list)
    while (curr !== null) {

        // Output data of the current node
        console.log(curr.data + " ");

// Move to the next node
        curr = curr.next;
}

    // Print newline after traversal
    console.log();
}

// Function to traverse the doubly linked list
// in backward direction
function backwardTraversal(tail) {

    // Start traversal from the tail of the list
    let curr = tail;

// Continue until the current node is null
    // (end of the list)
    while (curr !== null) {

        // Output data of the current node
        console.log(curr.data + " ");

// Move to the previous node
        curr = curr.prev;
}

    // Print newline after traversal
    console.log();
}

// Sample usage of the doubly linked list
//and traversal functions
// Create a doubly linked list with 3 nodes
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);

head.next = second;
second.prev = head;
second.next = third;
third.prev = second;

console.log("Forward Traversal:");
forwardTraversal(head);

console.log("Backward Traversal:");
backwardTraversal(third);

````



**Output**
```

Forward Traversal:
1 2 3
Backward Traversal:
3 2 1

```

[Finding Length of Doubly Linked List](https://www.geeksforgeeks.org/program-find-size-doubly-linked-list/)
-----------------------------------------------------------------------------------------------------------

To find the length of doubly list, we can use the following
steps:

* Start at the head of the list.
* Traverse through the list, counting each node visited.
* Return the total count of nodes as the length of the list.

Below are the implementation of the above approach:

C++
````
#include <iostream>

using namespace std;

// Node structure for doubly linked list
struct Node {
    int data;
    Node * prev;
    Node * next;

    Node(int val) {
        data = val;
        prev = next = nullptr;
}
};

// Function to find the length of a doubly
//linked list
int findLength(Node * head) {
    int count = 0;
for (Node * cur = head; cur != nullptr; cur = cur -> next)
        count++;
return count;
}

int main() {

    // Create a DLL with 3 nodes
    Node * head = new Node(1);
    Node * second = new Node(2);
    Node * third = new Node(3);
    head -> next = second;
second -> prev = head;
second -> next = third;
    third -> prev = second;

    cout << "Length of the doubly linked list: " <<
        findLength(head) << endl;

return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Node structure for doubly linked list
struct Node {
    int data; // Data stored in the node
    struct Node* prev; // Pointer to the previous node
    struct Node* next; // Pointer to the next node
};

// Constructor function to create a new node
struct Node* createNode(int val) {
    struct Node* newNode =
         (struct Node*)malloc(sizeof(struct Node));
    newNode->data = val;
    newNode->prev = NULL;
    newNode->next = NULL;
return newNode;
}

// Function to find the length of a doubly linked list
int findLength(struct Node* head) {
    int count = 0;
for (struct Node* cur = head; cur != NULL; cur = cur->next)
        count++;
return count;
}

int main() {
    // Create a DLL with 3 nodes
    struct Node* head = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    printf("Length of the doubly linked list: %d\\n",
           findLength(head));

return 0;
}

````

Java
````
class Node {
    int data;
    Node prev;
    Node next;

// Constructor
    public Node(int val) {
        data = val;
        prev = null;
next = null;
}
}

class GfG {

    // Function to find the length of
    // a doubly linked list
    static int FindLength(Node head) {
        int count = 0;
for (Node cur = head; cur != null; cur = cur.next)
            count++;
return count;
}

    // Driver code
    public static void main(String[] args) {

        // Create a doubly linked list
        // with 3 nodes
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        System.out.println("Length of doubly linked list: "
                           + FindLength(head));
}
}

````

Python
````
class Node:
    def __init__(self, val):
        self.data = val
        self.prev = None
        self.next = None

# Function to find the length of
# a doubly linked list
def find_length(head):
    count = 0
    cur = head
    while cur is not None:
        count += 1
        cur = cur.next
    return count

# Driver code
if __name__ == "__main__":

    # Create a doubly linked list
    # with 3 nodes
    head = Node(1)
    second = Node(2)
    third = Node(3)

    head.next = second
    second.prev = head
    second.next = third
    third.prev = second

    print("Length of the doubly linked list: " +
          str(find_length(head)))

````

C#
````
using System;

class Node {
    public int data;
public Node prev;
public Node next;

// Constructor
    public Node(int val) {
        data = val;
        prev = null;
next = null;
}
}

public class GfG {

    // Function to find the length of
    // a doubly linked list
    static int FindLength(Node head) {
        int count = 0;
for (Node cur = head; cur != null; cur = cur.next)
            count++;
return count;
}

    // Driver code
    public static void Main(string[] args) {

        // Create a doubly linked list
        // with 3 nodes
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        Console.WriteLine("Length of doubly linked list: "
                                 + FindLength(head));
}
}

````

JavaScript
````
class Node {
    constructor(val) {
        this.data = val;
        this.prev = null;
        this.next = null;
}
}

// Function to find the length of
// a doubly linked list
function findLength(head) {
    let count = 0;
    let cur = head;
    while (cur !== null) {
        count++;
        cur = cur.next;
}
    return count;
}

// Create a doubly linked list with 3 nodes
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);

head.next = second;
second.prev = head;
second.next = third;
third.prev = second;

console.log("Length of the doubly linked list: " +
            findLength(head));

````





**Output**
```

Length of the doubly linked list: 3

```

[Insertion at the Beginning in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-frontbeginning-of-doubly-linked-list/)
----------------------------------------------------------------------------------------------------------------------------------------

![Insertion-at-the-Beginning-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809123903/Insertion-at-the-Beginning-in-Doubly-Linked-List.webp)

Insertion at the Beginning in Doubly Linked List


To insert a new node at the beginning of the doubly list, we can use
the following steps:

* Create a new node, say ****new\\_node****with the given data and set its previous pointer to null, ****new\\_node->prev =**** ****NULL****.
* Set the next pointer of new\\_node to current head, ****new\\_node->next = head.****
* If the linked list is not empty, update the previous pointer of the
                                                                                                                                                                                                                current head to new\\_node, ****head->prev = new\\_node****.
                                                                                                                                                                                                                * Return new\\_node as the head of the updated linked list.

                                                                                                                                                                                                                Below are the implementation of the above approach:

                                                                                                                                                                                                                C++
                                                                                                                                                                                                                ````
                                                                                                                                                                                                                // C++ Program to insert a new node at the
                                   // beginning of doubly linked list

                                   #include <iostream>
                                   using namespace std;

// Node structure for the doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;

    Node(int d) {
      data = d;
      prev = next = NULL;
}
};

// Insert a node at the beginning
Node* insertBegin(Node* head, int data) {

    // Create a new node
    Node* new_node = new Node(data);

// Make next of it as head
    new_node->next = head;

// Set previous of head as new node
    if (head != NULL) {
        head->prev = new_node;
}

    // Return new node as new head
    return new_node;
}

void printList(Node* head) {
    Node* curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
  	cout << "\\n";
}

int main() {

    // Create a hardcoded linked list:
  	// 2 <-> 3 <-> 4
    Node* head = new Node(2);
    Node* temp1 = new Node(3);
    Node* temp2 = new Node(4);
    head->next = temp1;
    temp1->prev = head;
    temp1->next = temp2;
    temp2->prev = temp1;

// Print the original list
    cout << "Original Linked List: ";
    printList(head);

// Insert a new node at the front of the list
    head = insertBegin(head, 1);

// Print the updated list
  	cout << "After inserting Node 1 at the front: ";
    printList(head);

return 0;
}

````

C
````
// C Program to insert a node at the beginning
//of doubly linked list


#include <stdio.h>

// Node structure for the doubly linked list
struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

// Create a new node
struct Node* createNode(int data) {
    struct Node* new_node =
      (struct Node*)malloc(sizeof(struct Node));
    new_node->data = data;
    new_node->prev = NULL;
    new_node->next = NULL;
return new_node;
}

// Insert a node at the beginning
struct Node* insertBegin(struct Node* head, int data) {

    // Create a new node
    struct Node* new_node = createNode(data);

// Make next of it as head
    new_node->next = head;

// Set previous of head as new node
    if (head != NULL) {
        head->prev = new_node;
}

    // Return new node as new head
    return new_node;
}

// Print the doubly linked list
void printList(struct Node* head) {
    struct Node* curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
}
  	printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 2 <-> 3 <-> 4
    struct Node *head = createNode(2);
    head->next = createNode(3);
    head->next->prev = head;
    head->next->next = createNode(4);
    head->next->next->prev = head->next;

// Print the original list
    printf("Original Linked List: ");
    printList(head);

// Insert a new node at the front of the list
    head = insertBegin(head, 1);

// Print the updated list
  	printf("After inserting Node 1 at the front: ");
    printList(head);

return 0;
}

````

Java
````
// Java Program to insert a node at the beginning of a
// doubly linked list

class Node {
    int data;
    Node prev, next;

// Node structure for the doubly linked list
    Node(int d) {
        data = d;
        prev = null;
next = null;
}
}

class GfG {

    // Insert a node at the beginning
    static Node insertBegin(Node head, int data) {

        // Create a new node
        Node new_node = new Node(data);

// Make next of it as head
        new_node.next = head;

// Set previous of head as new node
        if (head != null) {
            head.prev = new_node;
}

        // Return new node as new head
        return new_node;
}

    // Print the doubly linked list
    static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
      	System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 2 <-> 3 <-> 4
        Node head = new Node(2);
        head.next = new Node(3);
        head.next.prev = head;
        head.next.next = new Node(4);
        head.next.next.prev = head.next;

// Print the original list
        System.out.print("Original Linked List: ");
        printList(head);

// Insert a new node at the front of the list
        head = insertBegin(head, 1);

// Print the updated list
      	System.out.print(
            "After inserting Node 1 at the front: ");
        printList(head);
}
}

````

Python
````
# Python Program to insert a node at the beginning
#of doubly linked list

# Node structure for the doubly linked list
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Insert a node at the beginning
def insertBegin(head, data):

    # Create a new node
    new_node = Node(data)

    # Make next of it as head
    new_node.next = head

    # Set previous of head as new node
    if head is not None:
        head.prev = new_node

    # Return new node as new head
    return new_node

# Print the doubly linked list
def printList(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 2 <-> 3 <-> 4
    head = Node(2)
    head.next = Node(3)
    head.next.prev = head
    head.next.next = Node(4)
    head.next.next.prev = head.next

    # Print the original list
    print("Original Linked List:", end=\' \')
    printList(head)

    # Insert a new node at the front of the list
    head = insertBegin(head, 1)

    # Print the updated list
    print("After inserting Node 1 at the front:", end=\' \')
    printList(head)

````

C#
````
// C# Program to insert a node at the beginning of a
// doubly linked list

using System;

// Node structure for the doubly linked list
class Node {
    public int data;
public Node prev, next;

// Constructor for creating a new node
    public Node(int d) {
        data = d;
        prev = null;
next = null;
}
}

class GfG {

    // Insert a node at the beginning
    public static
    Node insertBegin(Node head, int data) {

        // Create a new node
        Node new_node = new Node(data);

// Make next of it as head
        new_node.next = head;

// Set previous of head as new node
        if (head != null) {
            head.prev = new_node;
}

        // Return new node as new head
        return new_node;
}

    // Print the doubly linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.data + " ");
            curr = curr.next;
}
      	Console.WriteLine();
}

    public static void Main(string[] args) {

        // Create a hardcoded doubly linked list:
        // 2 <-> 3 <-> 4
        Node head = new Node(2);
        head.next = new Node(3);
        head.next.prev = head;
        head.next.next = new Node(4);
        head.next.next.prev = head.next;

// Print the original list
        Console.Write("Original Linked List: ");
        printList(head);

// Insert a new node at the front of the list
        head = insertBegin(head, 1);

// Print the updated list
      	Console.Write
        ("After inserting Node 1 at the front: ");
        printList(head);
}
}

````

JavaScript
````
// JavaScript Program to insert a node at the
//beginning of doubly linked list

// Node structure for the doubly linked list
function Node(data) {
    this.data = data;
    this.prev = null;
    this.next = null;
}

// Insert a node at the beginning
function insertBegin(head, data) {

    // Create a new node
    const new_node = new Node(data);

// Make next of it as head
    new_node.next = head;

// Set previous of head as new node
    if (head !== null) {
        head.prev = new_node;
}

    // Return new node as new head
    return new_node;
}

// Print the doubly linked list
function printList(head) {
    let curr = head;
    while (curr !== null) {
        console.log(curr.data);
        curr = curr.next;
}
}

// Create a hardcoded doubly linked list:
// 2 <-> 3 <-> 4
let head = new Node(2);
head.next = new Node(3);
head.next.prev = head;
head.next.next = new Node(4);
head.next.next.prev = head.next;

// Print the original list
console.log("Original Linked List:");
printList(head);

// Insert a new node at the front of the list
console.log
("After inserting Node 1 at the front:");
let data = 1;
head = insertBegin(head, data);

// Print the updated list
printList(head);

````








**Output**
```

Original Linked List: 2 3 4
After inserting Node 1 at the front: 1 2 3 4

```

[Insertion at the End of Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-the-end-of-doubly-linked-list/)
---------------------------------------------------------------------------------------------------------------------------

![Insertion-at-the-End-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809123955/Insertion-at-the-End-in-Doubly-Linked-List.webp)

Insertion at the End in the Doubly Linked List


To insert a new node at the end of the doubly linked list, we can use
the following steps:

* Allocate memory for a new node and assign the provided value to its
  data field.
* Initialize the next pointer of the new node to nullptr.
* If the list is empty:
  + Set the previous pointer of the new node to nullptr.
  + Update the head pointer to point to the new node.
                                                                                          * If the list is not empty:
                                                                                          + Traverse the list starting from the head to reach the last
                                                                                          node.
                                                                                          + Set the next pointer of the last node to point to the new
                                                                                          node.
                                                                                          + Set the previous pointer of the new node to point to the last
                                                                                          node.

                                                                                          Below are the implementation of the above approach:

                                                                                          C++
                                                                                          ````
                                                                                          // C++ Program to insert a node at the end of
//doubly linked list

#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node *next, *prev;

    Node(int new_data) {
        data = new_data;
next = prev = nullptr;
}
};

// Function to insert a new node at the end of
//doubly linked list
Node *insertEnd(Node *head, int new_data) {

    // Create a new node
    Node *new_node = new Node(new_data);

// If the linked list is empty, set the new
  	//node as the head of linked list
    if (head == NULL) {
        head = new_node;
}
    else {
          Node *curr = head;
        while (curr->next != NULL) {
            curr = curr->next;
}

        // Set the next of last node to new node
        curr->next = new_node;

// Set prev of new node to last node
        new_node->prev = curr;
}

    // Return the head of the doubly linked list
    return head;
}

void printList(Node *head) {
    Node *curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
    cout << endl;
}

int main() {

    // Create a harcoded doubly linked list:
    // 1 <-> 2 <-> 3
    Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;

// Print the original list
    cout << "Original Linked List: ";
    printList(head);

// Insert a new node with data 4 at the end
    cout << "Inserting Node with data 4 at the end: ";
int data = 4;
    head = insertEnd(head, data);

// Print the updated list
    printList(head);

return 0;
}

````

C
````
// C Program to insert a node at the end of
//doubly linked list

#include <stdio.h>

struct Node {
    int data;
    struct Node *next;
    struct Node *prev;
};

// Function to create a new node with the given data
struct Node *createNode(int new_data) {
    struct Node *new_node =
    (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
return new_node;
}

// Function to insert a new node at the end of the
//doubly linked list
struct Node* insertEnd(struct Node *head, int new_data) {
    struct Node *new_node = createNode(new_data);

// If the linked list is empty, set the
 	//new node as the head
    if (head == NULL) {
        head = new_node;
} else {
        struct Node *curr = head;
        while (curr->next != NULL) {
            curr = curr->next;
}

        // Set the next of last node to new node
        curr->next = new_node;
// Set prev of new node to last node
        new_node->prev = curr;
}

    return head;
}

void printList(struct Node *head) {
    struct Node *curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
}
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;

// Print the original list
    printf("Original Linked List: ");
    printList(head);

// Insert a new node with data 4 at the end
    printf("Inserting Node with data 4 at the end: ");
    head = insertEnd(head, 4);

// Print the updated list
    printList(head);

return 0;
}

````

Java
````
// Java Program to insert a node at the end of
// doubly linked list

class Node {
    int data;
    Node next, prev;

    Node(int newData) {
        data = newData;
next = prev = null;
}
}

class GFG {

    // Function to insert a new node at the end of the
    // doubly linked list
    public static Node insertEnd(Node head, int newData) {

        // Create a new node
        Node newNode = new Node(newData);

// If the linked list is empty, set the new node as
        // the head
        if (head == null) {
            head = newNode;
}
        else {
            Node curr = head;
            while (curr.next != null) {
                curr = curr.next;
}

            // Set the next of last node to the new node
            curr.next = newNode;

// Set the prev of new node to the last node
            newNode.prev = curr;
}

        return head;
}

    // Function to print the doubly linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

// Print the original list
        System.out.println("Original Linked List: ");
        printList(head);

// Insert a new node with data 4 at the end
        System.out.println(
            "Inserting Node with data 4 at the end: ");
int data = 4;
        head = insertEnd(head, data);

// Print the updated list
        printList(head);
}
}

````

Python
````
# Python Program to insert a node at the end of
#doubly linked list

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

# Function to insert a new node at the end of the
#doubly linked list
def insert_end(head, new_data):

    # Create a new node
    new_node = Node(new_data)

    # If the linked list is empty, set the new node
    #as the head
    if head is None:
        head = new_node
    else:
        curr = head
        while curr.next is not None:
            curr = curr.next

        # Set the next of the last node to the new node
        curr.next = new_node

        # Set the prev of the new node to the last node
        new_node.prev = curr

    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    # Print the original list
    print("Original Linked List: ", end="")
    print_list(head)

    # Insert a new node with data 4 at the end
    print("Inserting Node with data 4 at the end: ", end="")
    data = 4
    head = insert_end(head, data)

    # Print the updated list
    print_list(head)

````

C#
````
// C# Program to insert a node at the end of
//doubly linked list

using System;

class Node {
    public int Data;
public Node Next;
public Node Prev;

public Node(int data) {
        Data = data;
Next = null;
        Prev = null;
}
}

class GFG {

    // Function to insert a new node at the end
  	//of the doubly linked list
    public static Node InsertEnd(Node head, int newData) {

          // Create a new node
        Node newNode = new Node(newData);

// If the linked list is empty, set the
      	//new node as the head
        if (head == null) {
            head = newNode;
}
        else {
            Node curr = head;
            while (curr.Next != null) {
                curr = curr.Next;
}

            // Set the next of the last node to
          	//the new node
            curr.Next = newNode;

// Set the prev of the new node to
          	//the last node
            newNode.Prev = curr;
}

        return head;
}

    // Function to print the doubly linked list
    public static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

// Print the original list
        Console.Write("Original Linked List: ");
        PrintList(head);

// Insert a new node with data 4 at the end
        Console.Write("Inserting Node with data 4 at the end: ");
int data = 4;
        head = InsertEnd(head, data);

// Print the updated list
        PrintList(head);
}
}

````

JavaScript
````
// Javascript Program to insert a node at the end of
//doublylinked list

class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

function insertEnd(head, newData) {

    // Create a new node
    const newNode = new Node(newData);

// If the linked list is empty, set the
    //new node as the head
    if (head === null) {
        head = newNode;
}
    else {
        let curr = head;
        while (curr.next !== null) {
            curr = curr.next;
}

        // Set the next of the last node to the
        //new node
        curr.next = newNode;

// Set the prev of the new node to the
        //last node
        newNode.prev = curr;
}

    return head;
}

function printList(head)
{
    let curr = head;
    let result = "";
    while (curr !== null) {
        result += curr.data + " ";
        curr = curr.next;
}
    console.log(result.trim());
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

// Print the original list
console.log("Original Linked List: ");
printList(head);

// Insert a new node with data 4 at the end
console.log("Inserting Node with data 4 at the end: ");
const data = 4;
head = insertEnd(head, data);

// Print the updated list
printList(head);

````




**Output**
```

Original Linked List: 1 2 3
Inserting Node with data 4 at the end: 1 2 3 4

```

[Insertion at a Specific Position in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-doubly-linked-list/)
---------------------------------------------------------------------------------------------------------------------------------------------------

To insert a node at a specific Position in doubly linked list, we can
use the following steps:

![Insertion-at-a-Specific-Position-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124039/Insertion-at-a-Specific-Position-in-Doubly-Linked-List.webp)


Insertion at a Specific Position in Doubly Linked List



To insert a new node at a specific position,

* If position = 1, create a new node and make it the head of the linked
  list and return it.
* Otherwise, traverse the list to reach the node at position – 1,
  say ****curr****.
* If the position is valid, create a new node with given data,
  say ****new\\_node****.
* Update the next pointer of new node to the next
                                                                                                                                             of current node and prev pointer of new node to current
                                                                                                                                             node, ****new\\_node->next = curr->next****and ****new\\_node->prev = curr.****
                                                                                                                                             * Similarly, update next pointer of current node to
                                                                                                                                                              thenew node, ****curr->next = new\\_node****.
                                                                                                                                                              * If the new node is not the last node, update prev pointer of new
                                                                                                                                                                                                          node’s next to the new node, ****new\\_node->next->prev = new\\_node.****

                                                                                                                                                                                                          Below is the implementation of the above approach:

                                                                                                                                                                                                          C++
                                                                                                                                                                                                          ````
                                                                                                                                                                                                          // C++ Program to insert a node at a given position

                                                                                                                                                                                                      #include <bits/stdc++.h>
                                                                                                                                                                                                      using namespace std;

struct Node {
    int data;
    Node *next, *prev;

    Node(int new_data) {
        data = new_data;
next = prev = nullptr;
}
};

// Function to insert a new node at a given position
Node *insertAtPosition(Node *head, int pos, int new_data) {

    // Create a new node
    Node *new_node = new Node(new_data);

// Insertion at the beginning
    if (pos == 1) {
        new_node->next = head;

// If the linked list is not empty, set the prev
      	//of head to new node
        if (head != NULL)
            head->prev = new_node;

// Set the new node as the head of linked list
        head = new_node;
return head;
}

    Node *curr = head;
// Traverse the list to find the node before the
    // insertion point
    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {
        curr = curr->next;
}

    // If the position is out of bounds
    if (curr == NULL) {
        cout << "Position is out of bounds." << endl;
        delete new_node;
return head;
}

    // Set the prev of new node to curr
    new_node->prev = curr;

// Set the new of new node to next of curr
    new_node->next = curr->next;

// Update the next of current node to new node
       curr->next = new_node;

// If the new node is not the last node, update prev
                                             //of next node to new node
                                             if (new_node->next != NULL)
                                             new_node->next->prev = new_node;

// Return the head of the doubly linked list
    return head;
}

void printList(Node *head) {
    Node *curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
    cout << endl;
}

int main() {

    // Create a harcoded doubly linked list:
    // 1 <-> 2 <-> 4
    Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(4);
    head->next->next->prev = head->next;

// Print the original list
    cout << "Original Linked List: ";
    printList(head);

// Insert new node with data 3 at position 3
    cout << "Inserting Node with data 3 at position 3: ";
int data = 3;
int pos = 3;
    head = insertAtPosition(head, pos, data);

// Print the updated list
    printList(head);

return 0;
}

````

C
````
// C Program to insert a node at a given position

#include <stdio.h>

struct Node {
    int data;
    struct Node * next;
    struct Node * prev;
};

// Function to create a new node with the given data
struct Node * createNode(int new_data) {
    struct Node * new_node =
        (struct Node * ) malloc(sizeof(struct Node));
    new_node -> data = new_data;
    new_node -> next = NULL;
return new_node;
}

// Function to insert a new node at a given position
struct Node * insertAtPosition(struct Node * head, int pos, int new_data) {
    // Create a new node
    struct Node * new_node = createNode(new_data);

// Insertion at the beginning
    if (pos == 1) {
        new_node -> next = head;

// If the linked list is not empty, set the
      //prev of head to new node
        if (head != NULL) {
            head -> prev = new_node;
}

        // Set the new node as the head of linked list
        head = new_node;
return head;
}

    struct Node * curr = head;

// Traverse the list to find the node before the insertion point
    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {
        curr = curr -> next;
}

    // If the position is out of bounds
    if (curr == NULL) {
        printf("Position is out of bounds.\\n");
        free(new_node);
return head;
}

    // Set the prev of new node to curr
    new_node -> prev = curr;

// Set the next of new node to next of curr
    new_node -> next = curr -> next;

// Update the next of current node to new node
       curr -> next = new_node;

// If the new node is not the last node, update
                                             //the prev of next node to new node
                                             if (new_node -> next != NULL) {
                                             new_node -> next -> prev = new_node;
}

    // Return the head of the doubly linked list
    return head;
}

// Function to print the linked list
void printList(struct Node * head) {
    struct Node * curr = head;
    while (curr != NULL) {
        printf("%d ", curr -> data);
        curr = curr -> next;
}
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 4
    struct Node * head = createNode(1);
    head -> next = createNode(2);
    head -> next -> prev = head;
    head -> next -> next = createNode(4);
    head -> next -> next -> prev = head -> next;

// Print the original list
    printf("Original Linked List: ");
    printList(head);

// Insert new node with data 3 at position 3
    printf("Inserting Node with data 3 at position 3: ");
int data = 3;
int pos = 3;
    head = insertAtPosition(head, pos, data);

// Print the updated list
    printList(head);

return 0;
}

````

Java
````
// Java Program to insert a node at a given position

class Node {
    int data;
    Node next;
    Node prev;

    Node(int new_data) {
        data = new_data;
next = prev = null;
}
}

class GFG {

    // Function to insert a new node at a given position
    public static Node insertAtPosition(Node head, int pos, int new_data) {
        // Create a new node
        Node new_node = new Node(new_data);

// Insertion at the beginning
        if (pos == 1) {
            new_node.next = head;

// If the linked list is not empty, set
          	//the prev of head to new node
            if (head != null) {
                head.prev = new_node;
}

            // Set the new node as the head of linked list
            head = new_node;
return head;
}

        Node curr = head;

// Traverse the list to find the node before
      	//the insertion point
        for (int i = 1; i < pos - 1 && curr != null; ++i) {
            curr = curr.next;
}

        // If the position is out of bounds
        if (curr == null) {
            System.out.println("Position is out of bounds.");
return head;
}

        // Set the prev of new node to curr
        new_node.prev = curr;

// Set the next of new node to next of curr
        new_node.next = curr.next;

// Update the next of current node to new node
       curr.next = new_node;

// If the new node is not the last node, update
                                             //prev of next node to new node
                                             if (new_node.next != null) {
                                             new_node.next.prev = new_node;
}

        // Return the head of the doubly linked list
        return head;
}

    // Function to print the linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 4
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(4);
        head.next.next.prev = head.next;

// Print the original list
        System.out.print("Original Linked List: ");
        printList(head);

// Insert new node with data 3 at position 3
        System.out.print("Inserting Node with data 3 at position 3: ");
int data = 3;
int pos = 3;
        head = insertAtPosition(head, pos, data);

// Print the updated list
        printList(head);
}
}

````

Python
````
# Python Program to insert a node at a given position

class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None
        self.prev = None

def insert_at_position(head, pos, new_data):

    # Create a new node
    new_node = Node(new_data)

    # Insertion at the beginning
    if pos == 1:
        new_node.next = head

        # If the linked list is not empty, set the
        #prev of head to new node
        if head is not None:
            head.prev = new_node

        # Set the new node as the head of the linked list
        head = new_node
        return head

    curr = head

    # Traverse the list to find the node before the
    #insertion point
    for _ in range(1, pos - 1):
        if curr is None:
            print("Position is out of bounds.")
            return head
        curr = curr.next

    # If the position is out of bounds
    if curr is None:
        print("Position is out of bounds.")
        return head

    # Set the prev of new node to curr
    new_node.prev = curr

    # Set the next of new node to next of curr
    new_node.next = curr.next

    # Update the next of current node to new node
                       curr.next = new_node

                       # If the new node is not the last node, update
                                                                   #prev of next node to new node
                                                                   if new_node.next is not None:
                                                                   new_node.next.prev = new_node

                                                                   return head

                                                                   def print_list(head):
                                                                   curr = head
                                                                   while curr is not None:
                                                                   print(curr.data, end=" ")
                                                                   curr = curr.next
                                                                   print()

                                                                   if __name__ == "__main__":

                                                                   # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 4
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(4)
    head.next.next.prev = head.next

    # Print the original list
    print("Original Linked List: ", end="")
    print_list(head)

    # Insert new node with data 3 at position 3
    print("Inserting Node with data 3 at position 3: ", end="")
    data = 3
    pos = 3
    head = insert_at_position(head, pos, data)

    # Print the updated list
    print_list(head)

````

C#
````
// C# Program to insert a node at a given position

using System;

class Node {
    public int Data;
public Node Next;
public Node Prev;

public Node(int data) {
        Data = data;
Next = null;
        Prev = null;
}
}

class GFG {

    // Function to insert a new node at a given position
    static Node InsertAtPosition(Node head, int pos, int newData) {

        // Create a new node
        Node newNode = new Node(newData);

// Insertion at the beginning
        if (pos == 1) {
            newNode.Next = head;
            if (head != null)
                head.Prev = newNode;
            head = newNode;
return head;
}

        Node curr = head;

// Traverse the list to find the node
      	 //before the insertion point
        for (int i = 1; i < pos - 1 && curr != null; ++i) {
            curr = curr.Next;
}

        // If the position is out of bounds
        if (curr == null) {
            Console.WriteLine("Position is out of bounds.");
return head;
}

        // Set the prev of new node to curr
        newNode.Prev = curr;

// Set the next of new node to the next of curr
        newNode.Next = curr.Next;

// Update the next of current node to new node
       curr.Next = newNode;

// If the new node is not the last node, update
                                             //prev of next node to new node
                                             if (newNode.Next != null)
                                             newNode.Next.Prev = newNode;

return head;
}

    // Function to print the list
    static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 4
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(4);
        head.Next.Next.Prev = head.Next;

// Print the original list
        Console.WriteLine("Original Linked List: ");
        PrintList(head);

// Insert new node with data 3 at position 3
        Console.WriteLine("Inserting Node with data 3 at position 3: ");
        head = InsertAtPosition(head, 3, 3);

// Print the updated list
        PrintList(head);
}
}

````

JavaScript
````
// Javascript Program to insert a node at a given position

class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

// Function to insert a new node at a given position
function insertAtPosition(head, pos, newData) {

    // Create a new node
    let newNode = new Node(newData);

// Insertion at the beginning
    if (pos === 1) {
        newNode.next = head;
        if (head !== null) {
            head.prev = newNode;
}
        head = newNode;
return head;
}

    let curr = head;

// Traverse the list to find the node
    //before the insertion point
    for (let i = 1; i < pos - 1 && curr !== null; ++i) {
        curr = curr.next;
}

    // If the position is out of bounds
    if (curr === null) {
        console.log("Position is out of bounds.");
return head;
}

    // Set the prev of new node to curr
    newNode.prev = curr;

// Set the next of new node to the next of curr
    newNode.next = curr.next;

// Update the next of current node to new node
       curr.next = newNode;

// If the new node is not the last node,
    // update prev of next node to new node
           if (newNode.next !== null) {
           newNode.next.prev = newNode;
}

    return head;
}

// Function to print the list
function printList(head) {
    let curr = head;
    while (curr !== null) {
        console.log(curr.data + " ");
        curr = curr.next;
}
    console.log();
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 4
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(4);
head.next.next.prev = head.next;

// Print the original list
console.log("Original Linked List:");
printList(head);

// Insert new node with data 3 at position 3
console.log("Inserting Node with data 3 at position 3:");
head = insertAtPosition(head, 3, 3);

// Print the updated list
printList(head);

````





**Output**
```

Original Linked List: 1 2 4
Inserting Node with data 3 at position 3: 1 2 3 4

```

[Deletion at the Beginning of Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-beginning-removal-of-first-node-in-a-doubly-linked-list/)
-----------------------------------------------------------------------------------------------------------------------------------------------------

![Deletion-at-the-Beginning-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124112/Deletion-at-the-Beginning-of-Doubly-Linked-List.webp)

Deletion at the Beginning of Doubly Linked List


To delete a node at the beginning in doubly linked list, we can use the
following steps:

* Check if the list is empty, there is nothing to delete. Return.
* Store the head pointer in a variable, say ****temp****.
* Update the head of linked list to the node next to the current head, ****head = head->next****.
                                                                        * If the new head is not NULL, update the previous pointer of new head
                                                                                                           to NULL, ****head->prev = NULL****.

                                                                                                           Below is the implementation of the above approach:

                                                                                                           C++
                                                                                                           ````
                                                                                                           // C++ Program to delete a node from the
// beginning of Doubly Linked List

#include <bits/stdc++.h>
using namespace std;

struct Node{
    int data;
    Node *prev;
    Node *next;
    Node(int d) {
      	data = d;
      	prev = next = nullptr;
}
};

// Deletes the first node (head) of the list
// and returns the second node as new head
Node *delHead(Node *head) {

    // If empty, return
    if (head == nullptr)
        return nullptr;

// Store in temp for deletion later
    Node *temp = head;

// Move head to the next node
    head = head->next;

// Set prev of the new head
    if (head != nullptr)
        head->prev = nullptr;

// Free memory and return new head
    delete temp;
return head;
}

void printList(Node *head) {
    for (Node *curr = head; curr != nullptr; curr = curr->next)
        cout << curr->data << " ";
    cout << endl;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the beginning: ");
    head = delHead(head);

    printList(head);

return 0;
}

````

C
````
// C Program to delete a node from the
// beginning of Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node *prev;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int data) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
return newNode;
}

// Function to delete the first node (head) of the list
// and return the second node as the new head
struct Node *delHead(struct Node *head) {
    // If empty, return NULL
    if (head == NULL)
        return NULL;

// Store in temp for deletion later
    struct Node *temp = head;

// Move head to the next node
    head = head->next;

// Set prev of the new head
    if (head != NULL)
        head->prev = NULL;

// Free memory and return new head
    free(temp);
return head;
}

void printList(struct Node *head) {
    struct Node *curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
}
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the beginning: ");
    head = delHead(head);

    printList(head);

return 0;
}

````

Java
````
// Java Program to delete a node from the
// beginning of Doubly Linked List

class Node {
    int data;
    Node prev;
    Node next;

    Node(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

class GFG {

    // Function to delete the first node (head) of the list
    // and return the second node as the new head
    public static Node delHead(Node head) {
        // If empty, return null
        if (head == null) {
            return null;
}

        // Store in temp for deletion later
        Node temp = head;

// Move head to the next node
        head = head.next;

// Set prev of the new head
        if (head != null) {
            head.prev = null;
}

        // Return new head
        return head;
}

    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

        System.out.print("Original Linked List: ");
        printList(head);

        System.out.print("After Deletion at the beginning: ");
        head = delHead(head);

        printList(head);
}
}

````

Python
````
# Python Program to delete a node from the
# beginning of Doubly Linked List

class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Function to delete the first node (head) of the list
# and return the second node as the new head
def del_head(head):

    # If empty, return None
    if head is None:
        return None

    # Store in temp for deletion later
    temp = head

    # Move head to the next node
    head = head.next

    # Set prev of the new head
    if head is not None:
        head.prev = None

    # Return new head
    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()


if __name__ == "__main__":

	# Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    print("Original Linked List: ", end="")
    print_list(head)

    print("After Deletion at the beginning: ", end="")
    head = del_head(head)

    print_list(head)

````

C#
````
// C# Program to delete a node from the
// beginning of Doubly Linked List

using System;

class Node {
    public int Data;
public Node Prev;
public Node Next;

public Node(int data) {
        Data = data;
        Prev = null;
Next = null;
}
}

class GFG {

    // Deletes the first node (head) of the list
    // and returns the second node as the new head
    public static Node DelHead(Node head) {

        // If empty, return null
        if (head == null)
            return null;

// Move head to the next node
        head = head.Next;

// Set prev of the new head
        if (head != null)
            head.Prev = null;

// Return new head
        return head;
}

    public static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

        Console.Write("Original Linked List: ");
        PrintList(head);

        Console.Write("After Deletion at the beginning: ");
        head = DelHead(head);

        PrintList(head);
}
}

````

JavaScript
````
// JavaScript Program to delete a node from the
// beginning of Doubly Linked List
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Deletes the first node (head) of the list and returns the second node as the new head
function delHead(head) {
    // If empty, return null
    if (head === null) {
        return null;
}

    // Store in temp for deletion later
    let temp = head;

// Move head to the next node
    head = head.next;

// Set prev of the new head
    if (head !== null) {
        head.prev = null;
}

    // Return new head
    return head;
}

// Function to print the list
function printList(head) {
    let curr = head;
    let output = \'\';
    while (curr !== null) {
        output += curr.data + \' \';
        curr = curr.next;
}
    console.log(output.trim());
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

console.log("Original Linked List: ");
printList(head);

console.log("After Deletion at the beginning: ");
head = delHead(head);

printList(head);

````



**Output**
```

Original Linked List: 1 2 3
After Deletion at the beginning: 2 3

```

[Deletion at the End of Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-end-removal-of-last-node-in-a-doubly-linked-list/)
----------------------------------------------------------------------------------------------------------------------------------------

![Deletion-at-the-End-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124140/Deletion-at-the-End-in-Doubly-Linked-List.webp)

Deletion at the End in Doubly Linked List


To delete a node at the end in doubly linked list, we can use the
following steps:

* Check if the doubly linked list is empty. If it is empty, then there
  is nothing to delete.
* If the list is not empty, then move to the last node of the doubly
  linked list, say ****curr****.
* Update the second-to-last node\'s next pointer to NULL, ****curr->prev->next = NULL****.
* Free the memory allocated for the node that was deleted.

Below is the implementation of the above approach:

C++
````
// C++ Program to delete a node from the end of
//Doubly Linked List

#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node *prev;
    Node *next;
    Node(int d) {
        data = d;
        prev = NULL;
        next = NULL;
    }
};

// Function to delete the last node of the doubly
// linked list
Node *delLast(Node *head) {

    // Corner cases
    if (head == NULL)
        return NULL;
    if (head->next == NULL) {
        delete head;
        return NULL;
    }

    // Traverse to the last node
    Node *curr = head;
    while (curr->next != NULL)
        curr = curr->next;

    // Update the previous node\'s next pointer
                                                                                         curr->prev->next = NULL;

// Delete the last node
    delete curr;

// Return the updated head
    return head;
}

void printList(Node *head) {
    Node *curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
    cout << endl;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the end: ");
    head = delLast(head);

    printList(head);

return 0;
}

````

C
````
// C Program to delete a node from the end of
//Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

// Function to delete the last node of the
//doubly linked list
struct Node* delLast(struct Node *head) {

    // Corner cases
    if (head == NULL)
        return NULL;
    if (head->next == NULL) {
        free(head);
return NULL;
}

    // Traverse to the last node
    struct Node *curr = head;
    while (curr->next != NULL)
        curr = curr->next;

// Update the previous node\'s next pointer
    curr->prev->next = NULL;

    // Delete the last node
    free(curr);

    // Return the updated head
    return head;
}

// Function to print the list
void printList(struct Node *head) {
    struct Node *curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }
    printf("\\n");
}

// Function to create a new node
struct Node* createNode(int data) {
    struct Node *newNode =
      (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the end: ");
    head = delLast(head);

    printList(head);

    return 0;
}

````

Java
````
// Java Program to delete a node from the end of
//Doubly Linked List

class Node {
    int data;
    Node prev;
    Node next;

    Node(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}

class GFG {

    // Function to delete the last node of the
  	//doubly linked list
    public static Node delLast(Node head) {

        // Corner cases
        if (head == null) {
            return null;
        }
        if (head.next == null) {
            return null;
        }

        // Traverse to the last node
        Node curr = head;
        while (curr.next != null) {
            curr = curr.next;
        }

        // Update the previous node\'s next pointer
       if (curr.prev != null) {
       curr.prev.next = null;
}

        // Return the updated head
        return head;
}

    // Function to print the list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

        System.out.print("Original Linked List: ");
        printList(head);

        System.out.print("After Deletion at the end: ");
        head = delLast(head);

        printList(head);
}
}

````

Python
````
# Python Program to delete a node from the end of
#Doubly Linked List

class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

def del_last(head):

    # Corner cases
    if head is None:
        return None
    if head.next is None:
        return None

    # Traverse to the last node
    curr = head
    while curr.next is not None:
        curr = curr.next

    # Update the previous node\'s next pointer
    if curr.prev is not None:
        curr.prev.next = None

    # Return the updated head
    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    print("Original Linked List: ", end="")
    print_list(head)

    print("After Deletion at the end: ", end="")
    head = del_last(head)

    print_list(head)

````

C#
````
// C# Program to delete a node from the end of
//Doubly Linked List

using System;

class Node {
    public int Data;
    public Node Prev;
    public Node Next;

    public Node(int data) {
        Data = data;
        Prev = null;
        Next = null;
    }
}

class GFG {

    // Function to delete the last node of the
  	//doubly linked list
    static Node DelLast(Node head) {

      	// Corner cases
        if (head == null)
            return null;
        if (head.Next == null) {
            return null;
        }

        // Traverse to the last node
        Node curr = head;
        while (curr.Next != null)
            curr = curr.Next;

        // Update the previous node\'s next pointer
                                     if (curr.Prev != null)
                                     curr.Prev.Next = null;

// Delete the last node
        curr = null;

// Return the updated head
        return head;
}

    // Function to print the list
    static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

        Console.Write("Original Linked List: ");
        PrintList(head);

        Console.Write("After Deletion at the end: ");
        head = DelLast(head);

        PrintList(head);
}
}

````

JavaScript
````
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Function to delete the last node of the
//doubly linked list
function delLast(head) {
    // Corner cases
    if (head === null) return null;
    if (head.next === null) {
        // Only one node in the list
        return null;
}

    // Traverse to the last node
    let curr = head;
    while (curr.next !== null) {
        curr = curr.next;
}

    // Update the previous node\'s next pointer
    if (curr.prev !== null) {
        curr.prev.next = null;
    }

    // Node curr is now deleted (garbage collected in JS)
    return head;
}

// Function to print the list
function printList(head) {
    let curr = head;
    while (curr !== null) {
        console.log(curr.data + " ");
        curr = curr.next;
    }
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

console.log("Original Linked List:");
printList(head);

console.log("After Deletion at the end:");
head = delLast(head);

printList(head);

````




**Output**
```

Original Linked List: 1 2 3
After Deletion at the end: 1 2

```

[Deletion at a Specific Position in Doubly Linked List](https://www.geeksforgeeks.org/delete-doubly-linked-list-node-given-position)
------------------------------------------------------------------------------------------------------------------------------------

![Deletion-at-a-Specific-Position-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124205/Deletion-at-a-Specific-Position-in-Doubly-Linked-List.webp)


Deletion at a Specific Position in Doubly Linked List



To delete a node at a specific position in doubly linked list, we can
use the following steps:

* Traverse to the node at the specified position, say ****curr****.
* If the position is valid, adjust the pointers to skip the node to be
  deleted.
  + If curr is not the head of the linked list, update the next
    pointer of the node before curr to point to the node after curr, ****curr->prev->next = curr-next****.
  + If curr is not the last node of the linked list, update the
    previous pointer of the node after curr to the node before curr, ****curr->next->prev = curr->prev****.
* Free the memory allocated for the deleted node.

Below is the implementation of the above approach:

C++
````
// C++ Program to delete node at a specific position
// in Doubly Linked List

#include <iostream>

using namespace std;

struct Node {
    int data;
    Node * prev;
    Node * next;
    Node(int d) {
        data = d;
        prev = next = NULL;
    }
};

// Function to delete a node at a specific position
// in the doubly linked list
Node * delPos(Node * head, int pos) {

    // If the list is empty
    if (!head)
        return head;

    Node * curr = head;

    // Traverse to the node at the given position
    for (int i = 1; curr && i < pos; ++i) {
        curr = curr -> next;
    }

    // If the position is out of range
    if (!curr)
        return head;

    // Update the previous node\'s next pointer
           if (curr -> prev)
           curr -> prev -> next = curr -> next;

// Update the next node\'s prev pointer
    if (curr -> next)
        curr -> next -> prev = curr -> prev;

    // If the node to be deleted is the head node
    if (head == curr)
        head = curr -> next;

    // Deallocate memory for the deleted node
    delete curr;
    return head;
}

// Function to print the doubly linked list
void printList(Node * head) {
    Node * curr = head;
    while (curr != nullptr) {
        cout << curr -> data << " ";
        curr = curr -> next;
    }
    cout << endl;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node * head = new Node(1);
    head -> next = new Node(2);
    head -> next -> prev = head;
    head -> next -> next = new Node(3);
    head -> next -> next -> prev = head -> next;

    cout << "Original Linked List: ";
    printList(head);

    cout << "After Deletion at the position 2: ";
    head = delPos(head, 2);

    printList(head);

    return 0;
}

````

C
````
// C Program to delete node at a specific position
//in Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node * prev;
    struct Node * next;
};

struct Node * createNode(int data) {
    struct Node * newNode = (struct Node * )
    malloc(sizeof(struct Node));
    newNode -> data = data;
    newNode -> prev = NULL;
    newNode -> next = NULL;
    return newNode;
}

// Function to delete a node at a specific
//position in the doubly linked list
struct Node * delPos(struct Node * head, int pos) {

    // If the list is empty
    if (head == NULL)
        return head;

    struct Node * curr = head;

    // Traverse to the node at the given position
    for (int i = 1; curr && i < pos; ++i) {
        curr = curr -> next;
    }

    // If the position is out of range
    if (curr == NULL)
        return head;

    // Update the previous node\'s next pointer
       if (curr -> prev)
       curr -> prev -> next = curr -> next;

// Update the next node\'s prev pointer
    if (curr -> next)
        curr -> next -> prev = curr -> prev;

    // If the node to be deleted is the head node
    if (head == curr)
        head = curr -> next;

    // Deallocate memory for the deleted node
    free(curr);
    return head;
}

// Function to print the doubly linked list
void printList(struct Node * head) {
    struct Node * curr = head;
    while (curr != NULL) {
        printf("%d ", curr -> data);
        curr = curr -> next;
    }
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node * head = createNode(1);
    struct Node * temp1 = createNode(2);
    struct Node * temp2 = createNode(3);

    // Link the nodes together
    head -> next = temp1;
    temp1 -> prev = head;
    temp1 -> next = temp2;
    temp2 -> prev = temp1;

    printf("Original Linked List: ");
    printList(head);

    // Delete node at position 2
    head = delPos(head, 2);

    printf("After Deletion at position 2: ");
    printList(head);

    return 0;
}

````

Java
````
// Java Program to delete node at a specific position in Doubly Linked List

class Node {
    int data;
    Node prev;
    Node next;

    Node(int d) {
        data = d;
        prev = null;
        next = null;
    }
}

class GFG {

    // Function to delete a node at a
  	//specific position in the doubly linked list
    public static Node delPos(Node head, int pos) {

        // If the list is empty
        if (head == null) {
            return head;
        }

        Node curr = head;

        // Traverse to the node at the given position
        for (int i = 1; curr != null && i < pos; ++i) {
            curr = curr.next;
        }

        // If the position is out of range
        if (curr == null) {
            return head;
        }

        // Update the previous node\'s next pointer
       if (curr.prev != null) {
       curr.prev.next = curr.next;
}

        // Update the next node\'s prev pointer
        if (curr.next != null) {
            curr.next.prev = curr.prev;
        }

        // If the node to be deleted is the head node
        if (head == curr) {
            head = curr.next;
        }

        // Return the updated head
        return head;
    }

    // Function to print the doubly linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

        System.out.print("Original Linked List: ");
        printList(head);

        System.out.print("After Deletion at position 2: ");
        head = delPos(head, 2);

        printList(head);
    }
}

````

Python
````
# Python Program to delete node at a specific position
#in Doubly Linked List


class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None


# Function to delete a node at a specific position
#in the doubly linked list
def del_pos(head, pos):
    # If the list is empty
    if head is None:
        return head

    curr = head

    # Traverse to the node at the given position
    for i in range(1, pos):
        if curr is None:
            return head
        curr = curr.next

    # If the position is out of range
    if curr is None:
        return head

    # Update the previous node\'s next pointer
               if curr.prev is not None:
               curr.prev.next = curr.next

               # Update the next node\'s prev pointer
    if curr.next is not None:
        curr.next.prev = curr.prev

    # If the node to be deleted is the head node
    if head == curr:
        head = curr.next

    # Return the updated head
    return head


def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()


if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    print("Original Linked List: ", end="")
    print_list(head)

    print("After Deletion at the position 2: ", end="")
    head = del_pos(head, 2)

    print_list(head)

````

C#
````
// C# Program to delete node at a specific position
//in Doubly Linked List

using System;

class Node {
    public int Data;
    public Node Prev;
    public Node Next;

    public Node(int data) {
        Data = data;
        Prev = null;
        Next = null;
    }
}

class Program {
    // Function to delete a node at a specific position
    // in the doubly linked list
    static Node DelPos(Node head, int pos) {
        // If the list is empty
        if (head == null)
            return head;

        Node curr = head;

        // Traverse to the node at the given position
        for (int i = 1; curr != null && i < pos; ++i) {
            curr = curr.Next;
        }

        // If the position is out of range
        if (curr == null)
            return head;

        // Update the previous node\'s next pointer
                     if (curr.Prev != null)
                     curr.Prev.Next = curr.Next;

// Update the next node\'s prev pointer
        if (curr.Next != null)
            curr.Next.Prev = curr.Prev;

        // If the node to be deleted is the head node
        if (head == curr)
            head = curr.Next;

        // Deallocate memory for the deleted node
        // In C#, garbage collection will handle this
      	//automatically

        return head;
    }

    // Function to print the doubly linked list
    static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
        }
        Console.WriteLine();
    }

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

        Console.Write("Original Linked List: ");
        PrintList(head);

        Console.Write("After Deletion at position 2: ");
        head = DelPos(head, 2);

        PrintList(head);
    }
}

````

JavaScript
````
class Node {
	constructor(data) {
		this.data = data;
		this.prev = null;
		this.next = null;
	}
}

// Function to delete a node at a specific position
// in the doubly linked list
function delPos(head, pos) {
	// If the list is empty
	if (head === null) return head;

	let curr = head;

	// Traverse to the node at the given position
	for (let i = 1; curr && i < pos; ++i) {
		curr = curr.next;
	}

	// If the position is out of range
	if (curr === null) return head;

	// Update the previous node\'s next pointer
       if (curr.prev) {
       curr.prev.next = curr.next;
}

	// Update the next node\'s prev pointer
	if (curr.next) {
		curr.next.prev = curr.prev;
	}

	// If the node to be deleted is the head node
	if (head === curr) {
		head = curr.next;
	}

	// Deallocate memory for the deleted node
	// In JavaScript, garbage collection handles
    //this automatically

	return head;
}

// Function to print the doubly linked list
function printList(head) {
	let curr = head;
	let result = [];
	while (curr !== null) {
		result.push(curr.data);
		curr = curr.next;
	}
	console.log(result.join(\' \'));
}


// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

console.log("Original Linked List:");
printList(head);

console.log("After Deletion at the position 2:");
head = delPos(head, 2);

printList(head);

````


**Output**
```

Original Linked List: 1 2 3
After Deletion at the position 2: 1 3

```

Advantages of Doubly Linked List
--------------------------------

* ****Efficient traversal in both directions:**** Doubly linked lists allow for efficient traversal of the list in both
  directions, making it suitable for applications where frequent
  insertions and deletions are required.
* ****Easy insertion and deletion of nodes:**** The presence of pointers to both the previous and next nodes makes it
  easy to insert or delete nodes from the list, without having to
  traverse the entire list.
* ****Can be used to implement a stack or queue:**** Doubly linked lists can be used to implement both stacks and queues,
  which are common data structures used in programming.

Disadvantages of Doubly Linked List
-----------------------------------

* ****More complex than singly linked lists:****
  Doubly linked lists are more complex than singly linked lists, as they
  require additional pointers for each node.
* ****More memory overhead:**** Doubly linked lists require more memory overhead than singly linked
  lists, as each node stores two pointers instead of one.', 'A doubly linked list is a more complex data structure than a singly linked list, but it offers several advantages. The main advantage of a doubly linked list is that it allows for efficient traversal of the list in both directions. This is because each node in the list contains a pointer to the previous node and a pointer to the next node. This allows for quick and easy insertion and deletion of nodes from the list, as well as efficient traversal of the list in both directions.', 'Doubly Linked List Tutorial', 2, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('c8c6920e-7046-48a4-8dbe-89905c592b0d', e'
[Time Complexity](https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/)
is a concept in computer science that deals with the quantification of the amount of time taken by a set of code or

[algorithm](https://www.geeksforgeeks.org/fundamentals-of-algorithms/)
to process or run as a function of the amount of input. In other words, the time complexity is how long a program takes to process a given input. The efficiency of an algorithm depends on two parameters:


* Time Complexity
* Space Complexity

****Time Complexity:****
It is defined as the number of times a particular instruction set is executed rather than the total time taken. It is because the total time taken also depends on some external factors like the compiler used, the processor’s speed, etc.


****Space Complexity:****
It is the total memory space required by the program for its execution.


### Best case time complexity of different data structures for different operations

### ****Worst Case time complexity of different data structures for different operations****

### ****The average time complexity of different data structures for different operations****

### Related Article on Time and Space Complexity:

* [Time and Space Complexity of Binary Search](https://www.geeksforgeeks.org/complexity-analysis-of-binary-search/)
* [Time and Space Complexity of Linear Search](https://www.geeksforgeeks.org/time-and-space-complexity-of-linear-search-algorithm/)
* [Time and Space Complexity of Ternary Search](https://www.geeksforgeeks.org/time-and-space-complexity-of-ternary-search/)
* [Time and Space Complexity of Breadth First Search (BFS)](https://www.geeksforgeeks.org/time-and-space-complexity-of-breadth-first-search-bfs/)
* [Time and Space Complexity of Depth First Search (DFS)](https://www.geeksforgeeks.org/time-and-space-complexity-of-depth-first-search-dfs/)
* [Time and Space Complexity of Insertion Sort](https://www.geeksforgeeks.org/time-and-space-complexity-of-insertion-sort-algorithm/)
* [Time and Space Complexity of Selection Sort](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-selection-sort/)
* [Time and Space Complexity of Bubble Sort](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-bubble-sort/)
* [Time and Space Complexity of Quick Sort](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-quick-sort/)
* [Time and Space Complexity of Merge Sort](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-merge-sort/)
* [Time and Space complexity of Radix Sort Algorithm](https://www.geeksforgeeks.org/time-and-space-complexity-of-radix-sort-algorithm/)
* [Time and Space Complexity of Linked List](https://www.geeksforgeeks.org/time-and-space-complexity-of-linked-list/)
* [Time and Space Complexity of Floyd Warshall Algorithm](https://www.geeksforgeeks.org/time-and-space-complexity-of-floyd-warshall-algorithm/)
* [Time and Space Complexity of Bellman–Ford Algorithm](https://www.geeksforgeeks.org/time-and-space-complexity-of-bellman-ford-algorithm/)
* [Time and Space Complexity of Dijkstra’s Algorithm](https://www.geeksforgeeks.org/time-and-space-complexity-of-dijkstras-algorithm/)
* [Time and Space Complexity Analysis of Prim’s Algorithm](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-prims-algorithm/)', 'Time Complexity: It is defined as the number of times a particular instruction set is executed rather than the total time taken. It is because the total time taken also depends on some external factors like the compiler used, the processor’s speed, etc.', 'Time complexities of different data structures', 7, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('aa9a9fdb-517e-4bec-ad2a-32a18c54993c', e'Representation of Stack Data Structure:
---------------------------------------


Stack follows LIFO (Last In First Out) Principle so the element which is pushed last is popped first.


![Stack-representation-in-Data-Structures-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp)

****Types of Stack:****
-----------------------

* ****Fixed Size Stack****
  : As the name suggests, a fixed size stack has a fixed size and cannot grow or shrink dynamically. If the stack is full and an attempt is made to add an element to it, an overflow error occurs. If the stack is empty and an attempt is made to remove an element from it, an underflow error occurs.
* ****Dynamic Size Stack****
  : A dynamic size stack can grow or shrink dynamically. When the stack is full, it automatically increases its size to accommodate the new element, and when the stack is empty, it decreases its size. This type of stack is implemented using a linked list, as it allows for easy resizing of the stack.

Basic Operations on Stack:
--------------------------


In order to make manipulations in a stack, there are certain operations provided to us.


* ****push()****
  to insert an element into the stack
* ****pop()****
  to remove an element from the stack
* ****top()****
  Returns the top element of the stack.
* ****isEmpty()****
  returns true if stack is empty else false.
* ****isFull()****
  returns true if the stack is full else false.


To implement stack, we need to maintain reference to the top item.


### ****Push Operation on Stack****


Adds an item to the stack. If the stack is full, then it is said to be an

****Overflow condition.****

****Algorithm for Push Operation:****


* Before pushing the element to the stack, we check if the stack is

  ****full****
  .
* If the stack is full

  ****(top == capacity-1)****
  , then

  ****Stack Overflows****
  and we cannot insert the element to the stack.
* Otherwise, we increment the value of top by 1

  ****(top = top + 1)****
  and the new value is inserted at

  ****top position****
  .
* The elements can be pushed into the stack till we reach the

  ****capacity****
  of the stack.

![Push-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180844/Push-Operation-in-Stack-(1).webp)
### ****Pop Operation in Stack****


Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an

****Underflow condition.****

****Algorithm for Pop Operation:****

* Before popping the element from the stack, we check if the stack is

  ****empty****
  .
* If the stack is empty (top == -1), then

  ****Stack Underflows****
  and we cannot remove any element from the stack.
* Otherwise, we store the value at top, decrement the value of top by 1

  ****(top = top – 1)****
  and return the stored top value.

![Pop-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180943/Pop-Operation-in-Stack-(1).webp)
### ****Top or Peek Operation on Stack****


Returns the top element of the stack.


****Algorithm for Top Operation:****

* Before returning the top element from the stack, we check if the stack is empty.
* If the stack is empty (top == -1), we simply print “Stack is empty”.
* Otherwise, we return the element stored at

  ****index = top****
  .

![Top-or-Peek-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181023/Top-or-Peek-Operation-in-Stack-(1).webp)
### ****isEmpty Operation in Stack Data Structure:****


Returns true if the stack is empty, else false.


****Algorithm for isEmpty Operation****
:


* Check for the value of

  ****top****
  in stack.
* If

  ****(top == -1)****
  , then the stack is

  ****empty****
  so return

  ****true****
  .
* Otherwise, the stack is not empty so return

  ****false****
  .

![isEmpty-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181101/isEmpty-Operation-in-Stack-(1).webp)
### isFull ****Operation in Stack**** ****Data Structure**** :


Returns true if the stack is full, else false.


****Algorithm for isFull Operation:****

* Check for the value of

  ****top****
  in stack.
* If

  ****(top == capacity-1),****
  then the stack is

  ****full****
  so return

  ****true****
  .
* Otherwise, the stack is not full so return

  ****false****
  .

![isFull-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181147/isFull-Operation-in-Stack-(1).webp)

Implementation of Stack
-----------------------


The basic operations that can be performed on a stack include push, pop, and peek. There are two ways to implement a stack –


* [****Implementation of Stack using Array****](https://www.geeksforgeeks.org/implement-stack-using-array/)
* [****Implementation of Stack using Linked List****](https://www.geeksforgeeks.org/implement-a-stack-using-singly-linked-list/)

', 'Stack is a linear data structure that follows LIFO (Last In First Out) Principle, the last element inserted is the first to be popped out. It means both insertion and deletion operations happen at one end only.', 'What is Stack Data Structure? A Complete Tutorial', 8, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('22607c58-8b6f-45e8-ab9c-6da9a201ea46', e'What is a Hash Function?
------------------------


A

****hash function****
is a function that takes an input (or ‘message’) and returns a fixed-size string of bytes. The output, typically a number, is called the

****hash code****
or

****hash value****
. The main purpose of a hash function is to efficiently map data of arbitrary size to fixed-size values, which are often used as indexes in hash tables.


### Key Properties of Hash Functions

* ****Deterministic****
  : A hash function must consistently produce the same output for the same input.
* ****Fixed Output Size****
  : The output of a hash function should have a fixed size, regardless of the size of the input.
* ****Efficiency****
  : The hash function should be able to process input quickly.
* ****Uniformity****
  : The hash function should distribute the hash values uniformly across the output space to avoid clustering.
* ****Pre-image Resistance****
  : It should be computationally infeasible to reverse the hash function, i.e., to find the original input given a hash value.
* ****Collision Resistance****
  : It should be difficult to find two different inputs that produce the same hash value.
* ****Avalanche Effect****
  : A small change in the input should produce a significantly different hash value.

Applications of Hash Functions
------------------------------

* ****Hash Tables****
  : The most common use of hash functions in DSA is in hash tables, which provide an efficient way to store and retrieve data.
* ****Data Integrity****
  : Hash functions are used to ensure the integrity of data by generating checksums.
* ****Cryptography****
  : In cryptographic applications, hash functions are used to create secure hash algorithms like SHA-256.
* ****Data Structures****
  : Hash functions are utilized in various data structures such as Bloom filters and hash sets.

Types of Hash Functions
-----------------------


There are many hash functions that use numeric or alphanumeric keys. This article focuses on discussing different hash functions:


1. Division Method.
2. Multiplication Method
3. Mid-Square Method
4. Folding Method
5. Cryptographic Hash Functions
6. Universal Hashing
7. Perfect Hashing


Let’s begin discussing these methods in detail.


1. Division Method
------------------


The division method involves dividing the key by a prime number and using the remainder as the hash value.


> **h**
> (
>
> **k**
> )=
>
> **k**
> mod
>
> **m**
>
>
> Where
>
> **k**
> is the key and 𝑚
>
> **m**
> is a prime number.

****Advantages****
:


* Simple to implement.
* Works well when 𝑚

  **m**
  is a prime number.

****Disadvantages****
:


* Poor distribution if 𝑚

  **m**
  is not chosen wisely.

2. Multiplication Method
------------------------


In the multiplication method, a constant 𝐴

**A**
(0 < A < 1) is used to multiply the key. The fractional part of the product is then multiplied by 𝑚

**m**
to get the hash value.


> **h**
> (
>
> **k**
> )=⌊
>
> **m**
> (
>
> **kA**
> mod1)⌋
>
>
> Where ⌊ ⌋ denotes the floor function.

****Advantages****
:


* Less sensitive to the choice of 𝑚

  **m**
  .

****Disadvantages****
:


* More complex than the division method.

3. Mid-Square Method
--------------------


In the mid-square method, the key is squared, and the middle digits of the result are taken as the hash value.


****Steps****
:


1. Square the key.
2. Extract the middle digits of the squared value.

****Advantages****
:


* Produces a good distribution of hash values.

****Disadvantages****
:


* May require more computational effort.

4. Folding Method
-----------------


The folding method involves dividing the key into equal parts, summing the parts, and then taking the modulo with respect to 𝑚

**m**
.


****Steps****
:


1. Divide the key into parts.
2. Sum the parts.
3. Take the modulo 𝑚

   **m**
   of the sum.

****Advantages****
:


* Simple and easy to implement.

****Disadvantages****
:


* Depends on the choice of partitioning scheme.

5. Cryptographic Hash Functions
-------------------------------


Cryptographic hash functions are designed to be secure and are used in cryptography. Examples include MD5, SHA-1, and SHA-256.


****Characteristics****
:


* Pre-image resistance.
* Second pre-image resistance.
* Collision resistance.

****Advantages****
:


* High security.

****Disadvantages****
:


* Computationally intensive.

6. Universal Hashing
--------------------


Universal hashing uses a family of hash functions to minimize the chance of collision for any given set of inputs.


> **h**
> (
>
> **k**
> )=((
>
> **a**
> ⋅
>
> **k**
> +
>
> **b**
> )mod
>
> **p**
> )mod
>
> **m**
>
>
> Where
>
> **a**
> and
>
> **b**
> are randomly chosen constants,
>
> **p**
> is a prime number greater than
>
> **m**
> , and
>
> **k**
> is the key.

****Advantages****
:


* Reduces the probability of collisions.

****Disadvantages****
:


* Requires more computation and storage.

7. Perfect Hashing
------------------


Perfect hashing aims to create a collision-free hash function for a static set of keys. It guarantees that no two keys will hash to the same value.


****Types****
:


* Minimal Perfect Hashing: Ensures that the range of the hash function is equal to the number of keys.
* Non-minimal Perfect Hashing: The range may be larger than the number of keys.

****Advantages****
:


* No collisions.

****Disadvantages****
:


* Complex to construct.

Conclusion
----------


In conclusion, hash functions are very important tools that help store and find data quickly. Knowing the different types of hash functions and how to use them correctly is key to making software work better and more securely. By choosing the right hash function for the job, developers can greatly improve the efficiency and reliability of their systems.
', 'Hash functions are a fundamental concept in computer science and play a crucial role in various applications such as data storage, retrieval, and cryptography. In data structures and algorithms (DSA), hash functions are primarily used in hash tables, which are essential for efficient data management. This article delves into the intricacies of hash functions, their properties, and the different types of hash functions used in DSA.', 'Hash Functions and Types of Hash functions', 12, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('1c6f4928-3c61-463e-8c84-f82e57915477', e'
****What is Hash Table?****
---------------------------


A Hash table is defined as a data structure used to insert, look up, and remove key-value pairs quickly. It operates on the

[hashing concept](https://www.geeksforgeeks.org/what-is-hashing/)
, where each key is translated by a hash function into a distinct index in an array. The index functions as a storage location for the matching value. In simple words, it maps the keys with the value.


![Components-of-Hashing](https://media.geeksforgeeks.org/wp-content/uploads/20240508162721/Components-of-Hashing.webp)

Hash Function and Table

What is Load factor?
--------------------


A hash table’s load factor is determined by how many elements are kept there in relation to how big the table is. The table may be cluttered and have longer search times and collisions if the load factor is high. An ideal load factor can be maintained with the use of a good hash function and proper table resizing.


What is a Hash function?
------------------------


A Function that translates keys to array indices is known as a hash function. The keys should be evenly distributed across the array via a decent hash function to reduce collisions and ensure quick lookup speeds.


* ****Integer universe assumption:****

  The keys are assumed to be integers within a certain range according to the integer universe assumption. This enables the use of basic hashing operations like division or multiplication hashing.
* ****Hashing by division:****

  This straightforward hashing technique uses the key’s remaining value after dividing it by the array’s size as the index. When an array size is a prime number and the keys are evenly spaced out, it performs well.
* ****Hashing by multiplication:****

  This straightforward hashing operation multiplies the key by a constant between 0 and 1 before taking the fractional portion of the outcome. After that, the index is determined by multiplying the fractional component by the array’s size. Also, it functions effectively when the keys are scattered equally.

### [Choosing a hash function](https://www.geeksforgeeks.org/what-are-hash-functions-and-how-to-choose-a-good-hash-function/) :


Selecting a decent hash function is based on the properties of the keys and the intended functionality of the hash table. Using a function that evenly distributes the keys and reduces collisions is crucial.


****Criteria based on which a hash function is chosen:****


* To ensure that the number of collisions is kept to a minimum, a good hash function should distribute the keys throughout the hash table in a uniform manner. This implies that for all pairings of keys, the likelihood of two keys hashing to the same position in the table should be rather constant.
* To enable speedy hashing and key retrieval, the hash function should be computationally efficient.
* It ought to be challenging to deduce the key from its hash value. As a result, attempts to guess the key using the hash value are less likely to succeed.
* A hash function should be flexible enough to adjust as the data being hashed changes. For instance, the hash function needs to continue to perform properly if the keys being hashed change in size or format.

### [Collision resolution techniques](https://www.geeksforgeeks.org/collision-resolution-techniques/) :


Collisions happen when two or more keys point to the same array index. Chaining, open addressing, and double hashing are a few techniques for resolving collisions.


![collision-in-hashing](https://media.geeksforgeeks.org/wp-content/uploads/20240514124239/collision-in-hashing.webp)




* [****Open addressing****](https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/)
  ****:****
  collisions are handled by looking for the following empty space in the table. If the first slot is already taken, the hash function is applied to the subsequent slots until one is left empty. There are various ways to use this approach, including double hashing, linear probing, and quadratic probing.
* [****Separate Chaining****](https://www.geeksforgeeks.org/separate-chaining-collision-handling-technique-in-hashing/)
  ****:****
  In separate chaining, a linked list of objects that hash to each slot in the hash table is present. Two keys are included in the linked list if they hash to the same slot. This method is rather simple to use and can manage several collisions.
* ****Robin Hood hashing:****
  To reduce the length of the chain, collisions in Robin Hood hashing are addressed by switching off keys. The algorithm compares the distance between the slot and the occupied slot of the two keys if a new key hashes to an already-occupied slot. The existing key gets swapped out with the new one if it is closer to its ideal slot. This brings the existing key closer to its ideal slot. This method has a tendency to cut down on collisions and average chain length.

### Dynamic resizing:


This feature enables the hash table to expand or contract in response to changes in the number of elements contained in the table. This promotes a load factor that is ideal and quick lookup times.


Example Implementation of Hash Table
------------------------------------


Python, Java, C++, and Ruby are just a few of the programming languages that support hash tables. They can be used as a customized data structure in addition to frequently being included in the standard library.


****Example: hashIndex = key % noOfBuckets****


****Insert****
: Move to the bucket corresponding to the above-calculated hash index and insert the new node at the end of the list.



****Delete****
: To delete a node from hash table, calculate the hash index for the key, move to the bucket corresponding to the calculated hash index, and search the list in the current bucket to find and remove the node with the given key (if found).


![](https://media.geeksforgeeks.org/wp-content/uploads/chain-hashing-1.png)


Please refer

[****Hashing | Set 2 (Separate Chaining)****](https://www.geeksforgeeks.org/hashing-set-2-separate-chaining/)

for details.


C++

````
#include <bits/stdc++.h>
using namespace std;

struct Hash {
    int BUCKET; // No. of buckets

    // Vector of vectors to store the chains
    vector<vector<int>> table;

    // Inserts a key into hash table
    void insertItem(int key) {
        int index = hashFunction(key);
        table[index].push_back(key);
    }

    // Deletes a key from hash table
    void deleteItem(int key);

    // Hash function to map values to key
    int hashFunction(int x) {
        return (x % BUCKET);
    }

    void displayHash();

    // Constructor to initialize bucket count and table
    Hash(int b) {
        this->BUCKET = b;
        table.resize(BUCKET);
    }
};

// Function to delete a key from the hash table
void Hash::deleteItem(int key) {
    int index = hashFunction(key);

    // Find and remove the key from the table[index] vector
    auto it = find(table[index].begin(), table[index].end(), key);
    if (it != table[index].end()) {
        table[index].erase(it); // Erase the key if found
    }
}

// Function to display the hash table
void Hash::displayHash() {
    for (int i = 0; i < BUCKET; i++) {
        cout << i;
        for (int x : table[i]) {
            cout << " --> " << x;
        }
        cout << endl;
    }
}

// Driver program
int main() {
    // Vector that contains keys to be mapped
    vector<int> a = {15, 11, 27, 8, 12};

    // Insert the keys into the hash table
    Hash h(7); // 7 is the number of buckets
    for (int key : a)
        h.insertItem(key);

    // Delete 12 from the hash table
    h.deleteItem(12);

    // Display the hash table
    h.displayHash();

    return 0;
}

````

Java

````
import java.util.ArrayList;

public class Hash {
    // Number of buckets
    private final int bucket;
    // Hash table of size bucket
    private final ArrayList<Integer>[] table;

    public Hash(int bucket)
    {
        this.bucket = bucket;
        this.table = new ArrayList[bucket];
        for (int i = 0; i < bucket; i++) {
            table[i] = new ArrayList<>();
        }
    }

    // hash function to map values to key
    public int hashFunction(int key)
    {
        return (key % bucket);
    }

    public void insertItem(int key)
    {
        // get the hash index of key
        int index = hashFunction(key);
        // insert key into hash table at that index
        table[index].add(key);
    }

    public void deleteItem(int key)
    {
        // get the hash index of key
        int index = hashFunction(key);

        // Check if key is in hash table
        if (!table[index].contains(key)) {
            return;
        }

        // delete the key from hash table
        table[index].remove(Integer.valueOf(key));
    }

    // function to display hash table
    public void displayHash()
    {
        for (int i = 0; i < bucket; i++) {
            System.out.print(i);
            for (int x : table[i]) {
                System.out.print(" --> " + x);
            }
            System.out.println();
        }
    }

    // Drive Program
    public static void main(String[] args)
    {
        // array that contains keys to be mapped
        int[] a = { 15, 11, 27, 8, 12 };

        // Create a empty has of BUCKET_SIZE
        Hash h = new Hash(7);

        // insert the keys into the hash table
        for (int x : a) {
            h.insertItem(x);
        }

        // delete 12 from the hash table
        h.deleteItem(12);

        // Display the hash table
        h.displayHash();
    }
}

````

Python

````
# Python3 program to implement hashing with chaining
BUCKET_SIZE = 7


class Hash(object):
    def __init__(self, bucket):
        # Number of buckets
        self.__bucket = bucket
        # Hash table of size bucket
        self.__table = [[] for _ in range(bucket)]

    # hash function to map values to key
    def hashFunction(self, key):
        return (key % self.__bucket)

    def insertItem(self, key):
        # get the hash index of key
        index = self.hashFunction(key)
        self.__table[index].append(key)

    def deleteItem(self, key):
        # get the hash index of key
        index = self.hashFunction(key)

        # Check the key in the hash table
        if key not in self.__table[index]:
            return

        # delete the key from hash table
        self.__table[index].remove(key)

    # function to display hash table
    def displayHash(self):
        for i in range(self.__bucket):
            print("[%d]" % i, end=\'\')
            for x in self.__table[i]:
                print(" --> %d" % x, end=\'\')
            print()


# Drive Program
if __name__ == "__main__":
    # array that contains keys to be mapped
    a = [15, 11, 27, 8, 12]

    # Create a empty has of BUCKET_SIZE
    h = Hash(BUCKET_SIZE)

    # insert the keys into the hash table
    for x in a:
        h.insertItem(x)

    # delete 12 from the hash table
    h.deleteItem(x)
    # Display the hash table
    h.displayHash()

````

C#

````
using System;
using System.Collections.Generic;

class Hash
{
    int BUCKET; // No. of buckets

    // List of integers to store values
    List<int>[] table;

    public Hash(int V)
    {
        this.BUCKET = V;
        table = new List<int>[BUCKET];
        for (int i = 0; i < BUCKET; i++)
            table[i] = new List<int>();
    }

    // Hash function to map values to key
    int hashFunction(int x)
    {
        return (x % BUCKET);
    }

    // Inserts a key into the hash table
    public void insertItem(int key)
    {
        int index = hashFunction(key);
        table[index].Add(key);
    }

    // Deletes a key from the hash table
    public void deleteItem(int key)
    {
        int index = hashFunction(key);
        table[index].Remove(key);
    }

    // Displays the hash table
    public void displayHash()
    {
        for (int i = 0; i < BUCKET; i++)
        {
            Console.Write(i + " --> ");
            foreach (int x in table[i])
                Console.Write(x + " ");
            Console.WriteLine();
        }
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Array that contains keys to be mapped
        int[] a = { 15, 11, 27, 8, 12 };
        int n = a.Length;

        // Insert the keys into the hash table
        Hash h = new Hash(7); // 7 is the count of buckets in the hash table
        for (int i = 0; i < n; i++)
            h.insertItem(a[i]);

        // Delete 12 from the hash table
        h.deleteItem(12);

        // Display the hash table
        h.displayHash();
    }
}

````

JavaScript

````
class Hash {
    constructor(V) {
        this.BUCKET = V; // No. of buckets
        this.table = new Array(V); // Pointer to an array containing buckets
        for (let i = 0; i < V; i++) {
            this.table[i] = new Array();
        }
    }

    // inserts a key into hash table
    insertItem(x) {
        const index = this.hashFunction(x);
        this.table[index].push(x);
    }

    // deletes a key from hash table
    deleteItem(key) {
        // get the hash index of key
        const index = this.hashFunction(key);

        // find the key in (index)th list
        const i = this.table[index].indexOf(key);

        // if key is found in hash table, remove it
        if (i !== -1) {
            this.table[index].splice(i, 1);
        }
    }

    // hash function to map values to key
    hashFunction(x) {
        return x % this.BUCKET;
    }

    // function to display hash table
    displayHash() {
        for (let i = 0; i < this.BUCKET; i++) {
            let str = `${i}`;
            for (let j = 0; j < this.table[i].length; j++) {
                str += ` --> ${this.table[i][j]}`;
            }
            console.log(str);
        }
    }
}

// Driver program
const a = [15, 11, 27, 8, 12];
const n = a.length;

// insert the keys into the hash table
const h = new Hash(7);   // 7 is count of buckets in hash table
for (let i = 0; i < n; i++) {
    h.insertItem(a[i]);
}

// delete 12 from hash table
h.deleteItem(12);

// display the Hash table
h.displayHash();

````




**Output**
```
0
1 --> 15 --> 8
2
3
4 --> 11
5
6 --> 27
```

Complexity Analysis of a Hash Table:
------------------------------------


For lookup, insertion, and deletion operations, hash tables have an average-case time complexity of O(1). Yet, these operations may, in the worst case, require O(n) time, where n is the number of elements in the table.


Applications of Hash Table:
---------------------------

* Hash tables are frequently used for indexing and searching massive volumes of data. A search engine might use a hash table to store the web pages that it has indexed.
* Data is usually cached in memory via hash tables, enabling rapid access to frequently used information.
* Hash functions are frequently used in cryptography to create digital signatures, validate data, and guarantee data integrity.
* Hash tables can be used for implementing database indexes, enabling fast access to data based on key values.', '', 'Hash Table Data Structure', 13, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('98378e7c-1240-46fe-be25-0032ad7aa554', e'****Example:****


> ****Input:****
>
>
> {{1, 2, 3}
>
>
>
> {4, 5, 6}
>
>
>
> {7, 8, 9}}
>
>
>
> ****Output:****
> 1 2 4 7 5 3 6 8 9
>
>
> ****Input :****
> [[1, 2, 3, 4],
>
>
>
> [5, 6, 7, 8],
>
>
>
> [9, 10, 11, 12],
>
>
>
> [13, 14, 15, 16]]
>
>
>
> ****Output::****
> 1 2 5 9 6 3 4 7 10 13 14 11 8 12 15 16


This approach uses a diagonal traversal technique to print the matrix in a zig-zag pattern. It iterates through the matrix diagonally, switching between incrementing the row and column indices based on the current position. This creates a zig-zag path that covers all elements of the matrix.


Below is the implementation of the above approach:


C++

````
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Utility function to print matrix in zig-zag form
void zigZagMatrix(vector<vector<int>>& mat) {
    int n = mat.size();
    int m = mat[0].size();
    int row = 0, col = 0;

    // Boolean variable that is true if we need
    // to increment \'row\' value;
    // otherwise, false if we increment \'col\' value.
    bool row_inc = 0;

    // Print the first half of the zig-zag pattern
    int mn = min(m, n);
    for (int len = 1; len <= mn; ++len) {
        for (int i = 0; i < len; ++i) {
            cout << mat[row][col] << " ";

            if (i + 1 == len) break;

            // If row_inc is true, increment row
            // and decrement col;
            // otherwise, decrement row and increment col.
            if (row_inc) ++row, --col;
            else --row, ++col;
        }

        if (len == mn) break;

        // Update row or col value based on the
        // last increment
        if (row_inc) ++row, row_inc = false;
        else ++col, row_inc = true;
    }

    // Adjust row and col for the second half of the matrix
    if (row == 0) {
        if (col == m - 1) ++row;
        else ++col;
        row_inc = 1;
    } else {
        if (row == n - 1) ++col;
        else ++row;
        row_inc = 0;
    }

    // Print the second half of the zig-zag pattern
    int MAX = max(m, n) - 1;
    for (int len, diag = MAX; diag > 0; --diag) {
        len = (diag > mn) ? mn : diag;
        for (int i = 0; i < len; ++i) {
            cout << mat[row][col] << " ";

            if (i + 1 == len) break;

            // Update row or col value based on the last increment
            if (row_inc) ++row, --col;
            else ++col, --row;
        }

        // Update row and col based on position in the matrix
        if (row == 0 || col == m - 1) {
            if (col == m - 1) ++row;
            else ++col;
            row_inc = true;
        } else if (col == 0 || row == n - 1) {
            if (row == n - 1) ++col;
            else ++row;
            row_inc = false;
        }
    }
}

// Driver code
int main() {
    vector<vector<int>> mat = { { 1, 2, 3 },
                                { 4, 5, 6 },
                                { 7, 8, 9 } };
    zigZagMatrix(mat);

    return 0;
}

````

Java

````
public class ZigZagMatrix {

    // Utility function to print matrix in zig-zag form
    public static void zigZagMatrix(int[][] mat) {
        int n = mat.length;
        int m = mat[0].length;
        int row = 0, col = 0;

        // Boolean variable that is true if we need to
        // increment \'row\' value;
        // otherwise, false if we increment \'col\' value.
        boolean rowInc = false;

        // Print the first half of the zig-zag pattern
        int minDim = Math.min(m, n);
        for (int len = 1; len <= minDim; ++len) {
            for (int i = 0; i < len; ++i) {
                System.out.print(mat[row][col] + " ");

                if (i + 1 == len) break;

                // If rowInc is true, increment row and decrement col;
                // otherwise, decrement row and increment col.
                if (rowInc) {
                    row++;
                    col--;
                } else {
                    row--;
                    col++;
                }
            }

            if (len == minDim) break;

            // Update row or col value based on the last increment
            if (rowInc) {
                row++;
                rowInc = false;
            } else {
                col++;
                rowInc = true;
            }
        }

        // Adjust row and col for the second half of the matrix
        if (row == 0) {
            if (col == m - 1) row++;
            else col++;
            rowInc = true;
        } else {
            if (row == n - 1) col++;
            else row++;
            rowInc = false;
        }

        // Print the second half of the zig-zag pattern
        int maxDim = Math.max(m, n) - 1;
        for (int len, diag = maxDim; diag > 0; --diag) {
            len = (diag > minDim) ? minDim : diag;
            for (int i = 0; i < len; ++i) {
                System.out.print(mat[row][col] + " ");

                if (i + 1 == len) break;

                // Update row or col value based on the last increment
                if (rowInc) {
                    row++;
                    col--;
                } else {
                    col++;
                    row--;
                }
            }

            // Update row and col based on position in the matrix
            if (row == 0 || col == m - 1) {
                if (col == m - 1) row++;
                else col++;
                rowInc = true;
            } else if (col == 0 || row == n - 1) {
                if (row == n - 1) col++;
                else row++;
                rowInc = false;
            }
        }
    }

    // Driver code
    public static void main(String[] args) {
        int[][] mat = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        zigZagMatrix(mat);
    }
}

````

Python

````
# Utility function to print matrix in zig-zag form

def zig_zag_matrix(mat):
    n = len(mat)
    m = len(mat[0])
    row = 0
    col = 0

    # Boolean variable that is true if we need
    # to increment \'row\' value;
    # otherwise, false if we increment \'col\' value.
    row_inc = False

    # Print the first half of the zig-zag pattern
    mn = min(m, n)
    for length in range(1, mn + 1):
        for i in range(length):
            print(mat[row][col], end=\' \')

            if i + 1 == length:
                break

            # If row_inc is true, increment row
            # and decrement col;
            # otherwise, decrement row and increment col.
            if row_inc:
                row += 1
                col -= 1
            else:
                row -= 1
                col += 1

        if length == mn:
            break

        # Update row or col value based on the
        # last increment
        if row_inc:
            row += 1
            row_inc = False
        else:
            col += 1
            row_inc = True

    # Adjust row and col for the second half of the matrix
    if row == 0:
        if col == m - 1:
            row += 1
        else:
            col += 1
        row_inc = True
    else:
        if row == n - 1:
            col += 1
        else:
            row += 1
        row_inc = False

    # Print the second half of the zig-zag pattern
    MAX = max(m, n) - 1
    for diag in range(MAX, 0, -1):
        length = mn if diag > mn else diag
        for i in range(length):
            print(mat[row][col], end=\' \')

            if i + 1 == length:
                break

            # Update row or col value based on the last increment
            if row_inc:
                row += 1
                col -= 1
            else:
                col += 1
                row -= 1

        # Update row and col based on position in the matrix
        if row == 0 or col == m - 1:
            if col == m - 1:
                row += 1
            else:
                col += 1
            row_inc = True
        elif col == 0 or row == n - 1:
            if row == n - 1:
                col += 1
            else:
                row += 1
            row_inc = False

# Driver code
if __name__ == \'__main__\':
    mat = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]
    zig_zag_matrix(mat)

````

C#

````
using System;
using System.Collections.Generic;

class Program
{
    static void ZigZagMatrix(int[,] mat)
    {
        int n = mat.GetLength(0);
        int m = mat.GetLength(1);
        int row = 0;
        int col = 0;

        // Boolean variable that is true if we need
        // to increment \'row\' value;
        // otherwise, false if we increment \'col\' value.
        bool rowInc = false;

        // Print the first half of the zig-zag pattern
        int mn = Math.Min(m, n);
        for (int length = 1; length <= mn; length++)
        {
            for (int i = 0; i < length; i++)
            {
                Console.Write(mat[row, col] + " ");

                if (i + 1 == length)
                    break;

                // If rowInc is true, increment row
                // and decrement col;
                // otherwise, decrement row and increment col.
                if (rowInc)
                {
                    row++;
                    col--;
                }
                else
                {
                    row--;
                    col++;
                }
            }

            if (length == mn)
                break;

            // Update row or col value based on the
            // last increment
            if (rowInc)
            {
                row++;
                rowInc = false;
            }
            else
            {
                col++;
                rowInc = true;
            }
        }

        // Adjust row and col for the second half of the matrix
        if (row == 0)
        {
            if (col == m - 1)
                row++;
            else
                col++;
            rowInc = true;
        }
        else
        {
            if (row == n - 1)
                col++;
            else
                row++;
            rowInc = false;
        }

        // Print the second half of the zig-zag pattern
        int MAX = Math.Max(m, n) - 1;
        for (int diag = MAX; diag > 0; diag--)
        {
            int length = (diag > mn) ? mn : diag;
            for (int i = 0; i < length; i++)
            {
                Console.Write(mat[row, col] + " ");

                if (i + 1 == length)
                    break;

                // Update row or col value based on the last increment
                if (rowInc)
                {
                    row++;
                    col--;
                }
                else
                {
                    col++;
                    row--;
                }
            }

            // Update row and col based on position in the matrix
            if (row == 0 || col == m - 1)
            {
                if (col == m - 1)
                    row++;
                else
                    col++;
                rowInc = true;
            }
            else if (col == 0 || row == n - 1)
            {
                if (row == n - 1)
                    col++;
                else
                    row++;
                rowInc = false;
            }
        }
    }

    // Driver code
    static void Main()
    {
        int[,] mat = new int[,] {
            { 1, 2, 3 },
            { 4, 5, 6 },
            { 7, 8, 9 }
        };
        ZigZagMatrix(mat);
    }
}

````

JavaScript

````
function zigZagMatrix(mat) {
    const n = mat.length;
    const m = mat[0].length;
    let row = 0;
    let col = 0;

    // Boolean variable that is true if we need
    // to increment \'row\' value;
    // otherwise, false if we increment \'col\' value.
    let rowInc = false;

    // Print the first half of the zig-zag pattern
    const mn = Math.min(m, n);
    for (let length = 1; length <= mn; length++) {
        for (let i = 0; i < length; i++) {
            process.stdout.write(mat[row][col] + \' \');

            if (i + 1 === length) break;

            // If rowInc is true, increment row
            // and decrement col;
            // otherwise, decrement row and increment col.
            if (rowInc) {
                row++;
                col--;
            } else {
                row--;
                col++;
            }
        }

        if (length === mn) break;

        // Update row or col value based on the
        // last increment
        if (rowInc) {
            row++;
            rowInc = false;
        } else {
            col++;
            rowInc = true;
        }
    }

    // Adjust row and col for the second half of the matrix
    if (row === 0) {
        if (col === m - 1) row++;
        else col++;
        rowInc = true;
    } else {
        if (row === n - 1) col++;
        else row++;
        rowInc = false;
    }

    // Print the second half of the zig-zag pattern
    const MAX = Math.max(m, n) - 1;
    for (let diag = MAX; diag > 0; diag--) {
        const length = diag > mn ? mn : diag;
        for (let i = 0; i < length; i++) {
            process.stdout.write(mat[row][col] + \' \');

            if (i + 1 === length) break;

            // Update row or col value based on the last increment
            if (rowInc) {
                row++;
                col--;
            } else {
                col++;
                row--;
            }
        }

        // Update row and col based on position in the matrix
        if (row === 0 || col === m - 1) {
            if (col === m - 1) row++;
            else col++;
            rowInc = true;
        } else if (col === 0 || row === n - 1) {
            if (row === n - 1) col++;
            else row++;
            rowInc = false;
        }
    }
}

// Driver code
const mat = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
zigZagMatrix(mat);

````




**Output**
```
1 2 4 7 5 3 6 8 9
```

****Time complexity:****
O(n\\*m)



****Auxiliary space:****
O(1), since no extra space has been taken.

', 'Given a matrix of 2D array of n rows and m columns. Print this matrix in ZIG-ZAG fashion as shown in figure.', 'Print matrix in zig-zag fashion', 2, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('630b6281-246f-490e-bb03-77b0b5ea16f1', e'Two common ways of traversing a matrix are row-major-order and column-major-order



****Row Major Order:****
When matrix is accessed row by row.



****Column Major Order:****
When matrix is accessed column by column.



****Examples:****

> ****Input :****
> mat[][] = {{1, 2, 3},
>
>
>
> {4, 5, 6},
>
>
>
> {7, 8, 9}}
>
>
> ****Output :****
> Row-wise: 1 2 3 4 5 6 7 8 9
>
>
>
> Col-wise : 1 4 7 2 5 8 3 6 9


In many problems (like

[Search in a Matrix](https://www.geeksforgeeks.org/search-in-a-matrix-or-2d-array/)
), we can use any of the above two, so the question arises which one to use?


If we see according to time complexity, both lead to

****O(n****
****2****
****)****
, but when it comes to cache level one of the orders access will be faster as compare to other one. It depends on the language we are using. Most of the languages including C, C++, Java, Python, C# and JavaScrtipt


store matrix in row major form so while accessing the i+1

th
element after i

th
, most probably it will lead to a hit, which will further reduce the time of program.


The following codes are showing the time difference in row major and column major access.


C++

````
#include <iostream>
#include <vector>
#include <ctime>

using namespace std;

void rowMajor(vector<vector<int>>& arr) {
    int rows = arr.size();
    int cols = arr[0].size();

    // Accessing elements row-wise
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            arr[i][j]++;
        }
    }
}

void colMajor(vector<vector<int>>& arr) {
    int rows = arr.size();
    int cols = arr[0].size();

    // Accessing elements column-wise
    for (int j = 0; j < cols; j++) {
        for (int i = 0; i < rows; i++) {
            arr[i][j]++;
        }
    }
}

int main() {
    int n = 1000; // Size of the matrix (n x n)
    vector<vector<int>> arr(n, vector<int>(n, 0));

    // Time taken by row-major order
    clock_t t = clock();
    rowMajor(arr);
    t = clock() - t;
    cout << "Row major access time: " << t / (double)CLOCKS_PER_SEC << " s\\n";

    // Time taken by column-major order
    t = clock();
    colMajor(arr);
    t = clock() - t;
    cout << "Column major access time: " << t / (double)CLOCKS_PER_SEC << " s\\n";

    return 0;
}

````

C

````
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

#define MAX 1000 // Size of the matrix (MAX x MAX)

void rowMajor(int arr[MAX][MAX]) {
    // Accessing elements row-wise
    for (int i = 0; i < MAX; i++) {
        for (int j = 0; j < MAX; j++) {
            arr[i][j]++;
        }
    }
}

void colMajor(int arr[MAX][MAX]) {
    // Accessing elements column-wise
    for (int j = 0; j < MAX; j++) {
        for (int i = 0; i < MAX; i++) {
            arr[i][j]++;
        }
    }
}

int main() {
    int arr[MAX][MAX] = {0}; // Initialize matrix with zeros

    // Time taken by row-major order
    clock_t t = clock();
    rowMajor(arr);
    t = clock() - t;
    printf("Row major access time: %f s\\n", (double)t / CLOCKS_PER_SEC);

    // Time taken by column-major order
    t = clock();
    colMajor(arr);
    t = clock() - t;
    printf("Column major access time: %f s\\n", (double)t / CLOCKS_PER_SEC);

    return 0;
}

````

Java

````
import java.time.Duration;
import java.time.Instant;
import java.util.*;

class GFG {

    static void rowMajor(int[][] arr) {
        int rows = arr.length;
        int cols = arr[0].length;

        // Accessing elements row-wise
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                arr[i][j]++;
            }
        }
    }

    static void colMajor(int[][] arr) {
        int rows = arr.length;
        int cols = arr[0].length;

        // Accessing elements column-wise
        for (int j = 0; j < cols; j++) {
            for (int i = 0; i < rows; i++) {
                arr[i][j]++;
            }
        }
    }

    public static void main(String[] args) {
        int n = 1000; // Size of the matrix (n x n)
        int[][] arr = new int[n][n];

        // Time taken by row-major order
        Instant start = Instant.now();
        rowMajor(arr);
        Instant end = Instant.now();
        System.out.println("Row major access time: " + Duration.between(start, end));

        // Time taken by column-major order
        start = Instant.now();
        colMajor(arr);
        end = Instant.now();
        System.out.println("Column major access time: " + Duration.between(start, end));
    }
}

````

Python

````
from time import perf_counter

def row_major(arr):
    rows = len(arr)
    cols = len(arr[0])

    # Accessing elements row-wise
    for i in range(rows):
        for j in range(cols):
            arr[i][j] += 1

def col_major(arr):
    rows = len(arr)
    cols = len(arr[0])

    # Accessing elements column-wise
    for j in range(cols):
        for i in range(rows):
            arr[i][j] += 1

if __name__ == \'__main__\':

    n = 1000  # Size of the matrix (n x n)
    arr = [[0] * n for _ in range(n)]

    # Time taken by row-major order
    t_start = perf_counter()
    row_major(arr)
    t_row = perf_counter() - t_start
    print("Row major access time: {:.2f} s".format(t_row))

    # Time taken by column-major order
    t_start = perf_counter()
    col_major(arr)
    t_col = perf_counter() - t_start
    print("Column major access time: {:.2f} s".format(t_col))

````

C#

````
using System;

public class GFG {
    public static void RowMajor(int[,] arr) {
        int rows = arr.GetLength(0);
        int cols = arr.GetLength(1);

        // Accessing elements row-wise
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                arr[i, j]++;
            }
        }
    }

    public static void ColMajor(int[,] arr) {
        int rows = arr.GetLength(0);
        int cols = arr.GetLength(1);

        // Accessing elements column-wise
        for (int j = 0; j < cols; j++) {
            for (int i = 0; i < rows; i++) {
                arr[i, j]++;
            }
        }
    }

    public static void Main(string[] args) {
        int n = 1000; // Size of the matrix (n x n)
        int[,] arr = new int[n, n];

        // Time taken by row-major order
        var start = DateTime.UtcNow;
        RowMajor(arr);
        var end = DateTime.UtcNow;
        TimeSpan spanR = end - start;
        Console.WriteLine("Row major access time: " + spanR.TotalSeconds + " s");

        // Time taken by column-major order
        start = DateTime.UtcNow;
        ColMajor(arr);
        end = DateTime.UtcNow;
        TimeSpan spanC = end - start;
        Console.WriteLine("Column major access time: " + spanC.TotalSeconds + " s");
    }
}

````

JavaScript

````
function rowMajor(arr) {
    let rows = arr.length;
    let cols = arr[0].length;

    // Accessing elements row-wise
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            arr[i][j]++;
        }
    }
}

function colMajor(arr) {
    let rows = arr.length;
    let cols = arr[0].length;

    // Accessing elements column-wise
    for (let j = 0; j < cols; j++) {
        for (let i = 0; i < rows; i++) {
            arr[i][j]++;
        }
    }
}

// Driver code
let n = 1000; // Size of the matrix (n x n)
let arr = Array.from({ length: n }, () => Array(n).fill(0));

// Time taken by row-major order
let start = Date.now();
rowMajor(arr);
let end = Date.now();
console.log(`Row major access time: ${end - start} ms`);

// Time taken by column-major order
start = Date.now();
colMajor(arr);
end = Date.now();
console.log(`Column major access time: ${end - start} ms`);

````

****Time Complexity:****
O(MAX\\*MAX)



****Auxiliary Space:****
O(MAX\\*MAX)', '', 'Row-wise vs column-wise traversal of matrix', 3, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('c009b1a3-025d-4295-841e-6faecee91690', e'Given a matrix

****mat[n][m]****
and an element

****target****
. return true if the target is present in the matrix, else return false.


****Examples:****

> ****Input****
> : mat[][] = { {10, 51, 9},
>
>
>
> {14, 20, 21},
>
>
>
> {30, 24, 43} }
>
>
>
> ****target****
> = 14
>
>
>
> ****Output****
> : Found
>
>
>
>
>
> ****Input****
> : mat[][] = {{31, 5, 9, 11},
>
>
>
> {14, 7, 21, 26},
>
>
>
> {30, 4, 43, 50} }
>
>
>
> ****target****
> = 42
>
>
>
> ****Output****
> : Not Found


We traverse the mat[][] and compare target with every element of the matrix. If matches, then return true If we reach the end we will return false.


C++

````
// C++ program to search target in a matrix
#include <bits/stdc++.h>
using namespace std;

bool matrixSearch(vector<vector<int> >& mat, int x)
{
    int n = mat.size(), m = mat[0].size();

    // Compare each element one by one
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (mat[i][j] == x)
                return true;
    return false;
}

int main() {
    vector<vector<int> > mat = { { 1, 5, 9, 11 },
                                 { 14, 20, 21, 26 },
                                 { 30, 34, 43, 50 } };
    if (matrixSearch(mat, 14))
        cout << "Found\\n";
    else
        cout << "Not Found\\n";

    return 0;
}

````

C

````
// C program to check position of target Linearly
#include <stdbool.h>
#include <stdio.h>

#define MAX 100

bool matrixSearch(int mat[MAX][MAX], int n, int m,
                        int x)
{
    // Compare each element one by one
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (mat[i][j] == x) {
                return true;
            }
        }
    }
    return false;
}

int main()
{
    int mat[MAX][MAX] = { { 1, 5, 9, 11 },
                          { 14, 20, 21, 26 },
                          { 30, 34, 43, 50 } };
    // Number of rows
  	int n = 3;

    // Number of columns
    int m = 4;

    // Element to search
    int x = 14;

    if (matrixSearch(mat, n, m, x)) {
        printf("Found\\n");
    }
    else {
        printf("Not Found\\n");
    }

    return 0;
}

````

Java

````
// Java program to check position of target Linearly
import java.util.*;

class GfG {

    public static boolean matrixSearch(int[][] mat,
                                             int x)
    {
        int n = mat.length;
        int m = mat[0].length;

        // Compare each element one by one
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (mat[i][j] == x) {
                    return true;
                }
            }
        }
        return false;
    }

    public static void main(String[] args)
    {
        int[][] mat = { { 1, 5, 9, 11 },
                        { 14, 20, 21, 26 },
                        { 30, 34, 43, 50 } };
        if (matrixSearch(mat, 14)) {
            System.out.println("Found");
        }
        else {
            System.out.println("Not Found");
        }
    }
}

````

Python

````
# Python program to check position of target Linearly
def matrixSearch(mat, x):
    n = len(mat)
    m = len(mat[0])

    # Compare each element one by one
    for i in range(n):
        for j in range(m):
            if mat[i][j] == x:
                return True
    return False


if __name__ == "__main__":
    mat = [
        [1, 5, 9, 11],
        [14, 20, 21, 26],
        [30, 34, 43, 50]
    ]
    if matrixSearch(mat, 14):
        print("Found")
    else:
        print("Not Found")

````

C#

````
// C# program to check position of target Linearly
using System;

class GfG {
    public static bool matrixSearch(int[, ] mat, int x)
    {
        int n = mat.GetLength(0);
        int m = mat.GetLength(1);

        // Compare each element one by one
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (mat[i, j] == x)
                    return true;

        return false;
    }

    public static void Main()
    {
        int[, ] mat = { { 1, 5, 9, 11 },
                        { 14, 20, 21, 26 },
                        { 30, 34, 43, 50 } };

        if (matrixSearch(mat, 14))
            Console.WriteLine("Found");
        else
            Console.WriteLine("Not Found");
    }
}

````

JavaScript

````
// Javascript program to check position of target Linearly
function matrixSearch(mat, x)
{
    let n = mat.length;
    let m = mat[0].length;

    // Compare each element one by one
    for (let i = 0; i < n; i++)
        for (let j = 0; j < m; j++)
            if (mat[i][j] === x)
                return true;

    return false;
}

let mat = [
    [ 1, 5, 9, 11 ], [ 14, 20, 21, 26 ], [ 30, 34, 43, 50 ]
];

if (matrixSearch(mat, 14))
    console.log("Found");
else
    console.log("Not Found");

````




**Output**
```
Found

```



****Time Complexity :****
O(n \\* m), where n and m are the rows and column of matrix.



****Auxiliary Space :****
O(1)', '', 'Search in a Matrix or 2D Array', 4, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('c810809a-8425-4105-91f6-cc98e64ead3e', e'

Given two

****N****
x

****M matrices****
. Find a

****N****
x

****M****
matrix as the sum of given matrices each value at the sum of values of corresponding elements of the given two matrices.


![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/program-for-addition-of-two-matrices-1024x512.png)

****Approach:****
Below is the idea to solve the problem.


> Iterate over every cell of matrix (i, j), add the corresponding values of the two matrices and store in a single matrix i.e. the resultant matrix.


Follow the below steps to Implement the idea:


* Initialize a resultant matrix res[N][M].
* Run a for loop for counter

  ****i****
  as each row and in each iteration:
  + Run a for loop for counter

    ****j****
    as each column and in each iteration:
    - Add values of the two matrices for index i, j and store in res[i][j].
* Return res.


Below is the Implementation of above approach.


C++

````
#include <iostream>
#include <vector>
using namespace std;

void add(vector<vector<int>>& A, vector<vector<int>>& B,
                                 vector<vector<int>>& C) {
    int n = A.size();
    int m = A[0].size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
}

int main() {
    vector<vector<int>> A = { {1, 1, 1},
                              {2, 2, 2},
                              {3, 3, 3},
                              {4, 4, 4} };

    vector<vector<int>> B = { {1, 1, 1},
                              {2, 2, 2},
                              {3, 3, 3},
                              {4, 4, 4} };

    int n = A.size();
    int m = A[0].size();
    vector<vector<int>> C(n, vector<int>(m));

    add(A, B, C);

    cout << "Result matrix is:" << endl;
    for (const auto& row : C) {
        for (int val : row) {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define N 4  // Number of rows
#define M 3  // Number of columns

void add(int A[][M], int B[][M], int C[][M]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
}

int main() {
    int A[N][M] = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };
    int B[N][M] = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };
    int C[N][M];

    add(A, B, C);

    printf("Result matrix is:\\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            printf("%d ", C[i][j]);
        }
        printf("\\n");
    }
    return 0;
}

````

Java

````
public class GfG {
    public static void add(int[][] A, int[][] B, int[][] C) {
        int n = A.length;
        int m = A[0].length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                C[i][j] = A[i][j] + B[i][j];
            }
        }
    }

    public static void main(String[] args) {
        int[][] A = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };
        int[][] B = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };
        int[][] C = new int[4][3];
        add(A, B, C);

        System.out.println("Result matrix is:");
        for (int[] row : C) {
            for (int val : row) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
    }
}

````

Python

````
def add(A, B):
    n = len(A)
    m = len(A[0])
    C = [[0] * m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            C[i][j] = A[i][j] + B[i][j]
    return C

A = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ]
B = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ]
C = add(A, B)

print("Result matrix is:")
for row in C:
    print(\' \'.join(map(str, row)))

````

JavaScript

````
function add(A, B) {
    let n = A.length;
    let m = A[0].length;
    let C = Array.from({ length: n }, () => Array(m).fill(0));
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
    return C;
}

const A = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];
const B = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];
const C = add(A, B);

console.log("Result matrix is:");
C.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
function add($A, $B) {
    $n = count($A);
    $m = count($A[0]);
    $C = array_fill(0, $n, array_fill(0, $m, 0));
    for ($i = 0; $i < $n; $i++) {
        for ($j = 0; $j < $m; $j++) {
            $C[$i][$j] = $A[$i][$j] + $B[$i][$j];
        }
    }
    return $C;
}

$A = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];
$B = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];
$C = add($A, $B);

echo "Result matrix is:\\n";
foreach ($C as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is
2 2 2 2
4 4 4 4
6 6 6 6
8 8 8 8
```

****Time complexity:****
O(n x m).



****Auxiliary space:****
O(n x m).  since n

2
extra space has been taken for storing results


The program can be extended for rectangular matrices. The following post can be useful for extending this program.', '', 'Program for addition of two matrices', 5, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('1196e9db-ba66-4fc1-af17-824bf7fd8444', e'

Given two

[matrices](https://www.geeksforgeeks.org/matrices/)
, the task is to multiply them. Matrices can either be square or rectangular:


****Examples:****


> ****(Square Matrix Multiplication)****
>
> ****Input:****
> m1[m][n] = { {1, 1}, {2, 2} }
>
>
>
> m2[n][p] = { {1, 1}, {2, 2} }
>
>
>
> ****Output:****
> res[m][p] = { {3, 3}, {6, 6} }
>
>
> ****(Rectangular Matrix Multiplication)****
>
> ****Input:****
> m1[3][2] = { {1, 1}, {2, 2}, {3, 3} }
>
>
>
> m2[2][3] = { {1, 1, 1}, {2, 2, 2} }
>
>
>
> ****Output:****
> res[3][3] = { {3, 3, 3}, {6, 6, 6}, {9, 9, 9} }
>
>
> ![](https://media.geeksforgeeks.org/wp-content/uploads/20210902010632/MatrixMultiply1001jpeg001.jpeg)

****Multiplication of two Square or Rectangular Matrices****
------------------------------------------------------------

> * The number of columns in Matrix-1 must be equal to the number of rows in Matrix-2.
> * Output of multiplication of Matrix-1 and Matrix-2, results with equal to the number of rows of Matrix-1 and  the number of columns of Matrix-2 i.e. rslt[R1][C2]


Below is the implementation of the multiplication of two

[matrices](https://www.geeksforgeeks.org/matrices/)
:





C++

````
#include <iostream>
#include <vector>
using namespace std;

void mulMat(vector<vector<int>>& m1, vector<vector<int>>& m2,
            vector<vector<int>>& res) {
    int r1 = m1.size();
    int c1 = m1[0].size();
    int r2 = m2.size();
    int c2 = m2[0].size();

    if (c1 != r2) {
        cout << "Invalid Input" << endl;
        exit(EXIT_FAILURE);
    }

    // Resize result matrix to fit the result dimensions
    res.resize(r1, vector<int>(c2, 0));

    for (int i = 0; i < r1; i++) {
        for (int j = 0; j < c2; j++) {
            for (int k = 0; k < c1; k++) {
                res[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
}

// Driver code
int main() {
    vector<vector<int>> m1 = { {1, 1}, {2, 2} };
    vector<vector<int>> m2 = { {1, 1}, {2, 2} };
    vector<vector<int>> res;

    mulMat(m1, m2, res);

    cout << "Multiplication of given two matrices is:\\n";
    for (const auto& row : res) {
        for (int val : row) {
            cout << val << "\\t";
        }
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R1 2 // number of rows in Matrix-1
#define C1 2 // number of columns in Matrix-1
#define R2 2 // number of rows in Matrix-2
#define C2 2 // number of columns in Matrix-2

void mulMat(int m1[][C1], int m2[][C2], int rslt[][C2]) {
    if (C1 != R2) {
       printf("Invalid Input");
       return;
    }

    for (int i = 0; i < R1; i++) {
        for (int j = 0; j < C2; j++) {
            rslt[i][j] = 0;

            // Changed R2 to C1 for correct multiplication
            for (int k = 0; k < C1; k++) {
                rslt[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
}

int main() {
    int m1[R1][C1] = { { 1, 1 },
                       { 2, 2 } };

    int m2[R2][C2] = { { 1, 1 },
                       { 2, 2 } };

    int rslt[R1][C2]; // Result matrix

    // Function call to multiply matrices
    mulMat(m1, m2, rslt);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R1; i++) {
        for (int j = 0; j < C2; j++) {
            printf("%d\\t", rslt[i][j]);
        }
        printf("\\n");
    }

    return 0;
}

````

Java

````
public class MatrixMultiplication {

    public static void mulMat(int[][] m1, int[][] m2, int[][] res) {
        int r1 = m1.length;
        int c1 = m1[0].length;
        int r2 = m2.length;
        int c2 = m2[0].length;

        if (c1 != r2) {
            System.out.println("Invalid Input");
            System.exit(1);
        }

        // Perform matrix multiplication
        for (int i = 0; i < r1; i++) {
            for (int j = 0; j < c2; j++) {
                res[i][j] = 0; // Initialize result cell
                for (int k = 0; k < c1; k++) {
                    res[i][j] += m1[i][k] * m2[k][j];
                }
            }
        }
    }

    public static void main(String[] args) {
        int[][] m1 = {
            {1, 1},
            {2, 2}
        };

        int[][] m2 = {
            {1, 1},
            {2, 2}
        };

        int r1 = m1.length;
        int c2 = m2[0].length;
        int[][] res = new int[r1][c2]; // Resultant matrix

        mulMat(m1, m2, res);

        System.out.println("Multiplication of given two matrices is:");
        for (int i = 0; i < r1; i++) {
            for (int j = 0; j < c2; j++) {
                System.out.print(res[i][j] + "\\t");
            }
            System.out.println();
        }
    }
}

````

Python

````
def mulMat(m1, m2):
    r1 = len(m1)
    c1 = len(m1[0])
    r2 = len(m2)
    c2 = len(m2[0])

    if c1 != r2:
        print("Invalid Input")
        return None

    # Initialize the result matrix with zeros
    res = [[0] * c2 for _ in range(r1)]

    # Perform matrix multiplication
    for i in range(r1):
        for j in range(c2):
            for k in range(c1):
                res[i][j] += m1[i][k] * m2[k][j]

    return res

# Driver code
if __name__ == "__main__":
    m1 = [
        [1, 1],
        [2, 2]
    ]

    m2 = [
        [1, 1],
        [2, 2]
    ]

    result = mulMat(m1, m2)

    print("Multiplication of given two matrices is:")
    for row in result:
        print(" ".join(map(str, row)))

````

C#

````
using System;

class Program
{
    static int[,] MulMat(int[,] m1, int[,] m2)
    {
        int r1 = m1.GetLength(0);
        int c1 = m1.GetLength(1);
        int r2 = m2.GetLength(0);
        int c2 = m2.GetLength(1);

        if (c1 != r2)
        {
            Console.WriteLine("Invalid Input");
            return null;
        }

        // Initialize the result matrix
        int[,] res = new int[r1, c2];

        // Perform matrix multiplication
        for (int i = 0; i < r1; i++)
        {
            for (int j = 0; j < c2; j++)
            {
                for (int k = 0; k < c1; k++)
                {
                    res[i, j] += m1[i, k] * m2[k, j];
                }
            }
        }

        return res;
    }

    static void Main()
    {
        int[,] m1 = { { 1, 1 }, { 2, 2 } };
        int[,] m2 = { { 1, 1 }, { 2, 2 } };

        int[,] result = MulMat(m1, m2);

        if (result != null)
        {
            Console.WriteLine("Multiplication of given two matrices is:");
            for (int i = 0; i < result.GetLength(0); i++)
            {
                for (int j = 0; j < result.GetLength(1); j++)
                {
                    Console.Write(result[i, j] + "\\t");
                }
                Console.WriteLine();
            }
        }
    }
}

````

JavaScript

````
function mulMat(m1, m2) {
    const r1 = m1.length;
    const c1 = m1[0].length;
    const r2 = m2.length;
    const c2 = m2[0].length;

    if (c1 !== r2) {
        console.log("Invalid Input");
        return null;
    }

    // Initialize the result matrix
    const res = Array.from({ length: r1 }, () => Array(c2).fill(0));

    // Perform matrix multiplication
    for (let i = 0; i < r1; i++) {
        for (let j = 0; j < c2; j++) {
            for (let k = 0; k < c1; k++) {
                res[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }

    return res;
}

// Driver code
const m1 = [
    [1, 1],
    [2, 2]
];

const m2 = [
    [1, 1],
    [2, 2]
];

const result = mulMat(m1, m2);

if (result) {
    console.log("Multiplication of given two matrices is:");
    for (const row of result) {
        console.log(row.join(" "));
    }
}

````




**Output**
```
Multiplication of given two matrices is:
3    3
6    6
```

****Time complexity:****
O(R1 \\* C2 \\* R2) for given matrices mat1[R1][C1] and mat2[R2][C2]



****Auxiliary space:****
O(R1 \\* C2)


****Multiplication of Rectangular Matrices using Pointers in C/C++:****
-----------------------------------------------------------------------


To solve the problem follow the below idea:


> We use pointers in C/C++ to multiply matrices

****Prerequisite:****

[How to pass a 2D array as a parameter in C?](https://www.geeksforgeeks.org/pass-2d-array-parameter-c/)


Below is the implementation of the above approach:


C

````
#include <stdio.h>
#include <stdlib.h>

#define R1 2 // number of rows in Matrix-1
#define C1 2 // number of columns in Matrix-1
#define R2 2 // number of rows in Matrix-2
#define C2 2 // number of columns in Matrix-2

void mulMat(int (*m1)[C1], int (*m2)[C2], int (*rslt)[C2]) {
    if (C1 != R2) {
        printf("Invalid Input");
        return;
    }

    for (int i = 0; i < R1; i++) {
        for (int j = 0; j < C2; j++) {
            rslt[i][j] = 0; // Initialize result matrix element

            for (int k = 0; k < C1; k++) { // Use C1 for multiplication
                rslt[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
}

int main() {
    int m1[R1][C1] = { { 1, 1 },
                       { 2, 2 } };

    int m2[R2][C2] = { { 1, 1 },
                       { 2, 2 } };

    int rslt[R1][C2]; // Result matrix

    // Function call to multiply matrices
    mulMat(m1, m2, rslt);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R1; i++) {
        for (int j = 0; j < C2; j++) {
            printf("%d\\t", rslt[i][j]);
        }
        printf("\\n");
    }

    return 0;
}

````




**Output**
```
3 3
6 6
```

  ', '', 'Program to multiply two matrices', 6, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('40524f43-e22b-4dcf-9a51-965bd4affe1e', e'Given a

****sorted****
matrix

****mat[][]****
of size

****nxm****
and an


element

****x****
, the task is to find if x is

****present****
in the matrix or not. Matrix is

****sorted****
in a way such that all elements in a

****row are sorted in increasing order****
and for row i, where 1 <= i <= n-1, the

****first element****
of

****row i****
is

****greater than or equal****
to the

****last element****
of

****row i-1.****


****Examples:****

> ****Input:****
> x = 14, mat[][] = [[ 1, 5, 9],
>
>
>
> [14, 20, 21],
>
>
>
> [30, 34, 43]]
>
>
>
> ****Output:****
> true
>
>
> ****Input:****
> x = 42, mat[][] = [[ 1, 5, 9, 11],
>
>
>
> [14, 20, 21, 26],
>
>
>
> [30, 34, 43, 50]]
>
>
>
> ****Output:****
> false

Table of Content

* [[Naive Approach] Comparing with all elements – O(n\\*m) Time and O(1) Space](#naive-solution-onm-time-and-o1-space)
* [[Better Approach] Using Binary Search Twice – O(logn + logm) Time and O(1) Space](#using-binary-search-two-times-olog-n-log-m-time-and-o1-space)
* [[Expected Approach] Using Binary Search Once – O(log(n\\*m)) and O(1) Space](#using-one-binary-search-olognm-and-o1-space)
### ****[Naive Approach] Comparing with all elements – O(n\\*m) Time and O(1) Space****


In this approach, we will iterate through the entire

****matrix mat[][]****
and compare

****each element****
with

****x****
. If an element matches the x, we will

****return true****
. Otherwise, at the end of the traversal, we will

****return false.****
Please refer to

[Searching Algorithms for 2D Arrays (Matrix)](https://www.geeksforgeeks.org/searching-algorithms-for-a-2d-arrays-matrix/)
to know more about the implementation.


### ****[Better Approach] Using Binary Search Twice –**** O(logn + logm) Time and O(1) Space


First, we locate the row where the

****target x****
might be by using

****binary search****
, and then we apply binary search again within that row.



> To find the correct row, we perform
>
> ****binary search****
> on the
>
> ****first****
> elements of the middle row.
>
>
>
> Start with l
>
> ****ow = 0****
> and
>
> ****high = n – 1.****
>
> 1. If
>
>    ****x is smaller****
>    than the
>
>    ****first element****
>    of the middle row
>
>    ****(a[mid][0]),****
>    then x will be smaller than all elements in rows >= mid, so update
>
>    ****high = mid – 1.****
> 2. If
>
>    ****x is greater****
>    than the
>
>    ****first element****
>    of the middle row
>
>    ****(a[mid][0])****
>    , then x will be greater than all elements in rows < mid, so store the current mid row and update
>
>    ****low = mid + 1****
>    .
>
>
> Once we have found the
>
> ****correct row,****
> we can apply
>
> ****binary search****
> within that row to search for the
>
> ****target****
> element
>
> ****x****
> .

C++

````
// C++ program to search in the sorted matrix using
// Binary Search two times

#include <iostream>
#include <vector>
using namespace std;

// Function to binary search for x in arr[]
bool search(vector<int> &arr, int x) {
    int lo = 0, hi = arr.size() - 1;

    while (lo <= hi) {
        int mid = (lo + hi) / 2;

        if (x == arr[mid])
            return true;
        if (x < arr[mid])
            hi = mid - 1;
        else
            lo = mid + 1;
    }
    return false;
}

bool searchMatrix(vector<vector<int>> &mat, int x) {
    int n = mat.size(), m = mat[0].size();
    int lo = 0, hi = n - 1;
    int row = -1;

    while (lo <= hi) {
        int mid = (lo + hi) / 2;

        // If the first element of mid row is equal to x,
        // return true
        if (x == mat[mid][0])
            return true;

        // If x is greater than first element of mid row,
        // store the mid row and search in lower half
        if (x > mat[mid][0]) {
            row = mid;
            lo = mid + 1;
        }

        // If x is smaller than first element of mid row,
        // search in upper half
        else
            hi = mid - 1;
    }

    // If x is smaller than all elements of mat[][]
    if (row == -1)
        return false;

    return search(mat[row], x);
}

int main() {
    vector<vector<int>> mat = {{1, 5, 9}, {14, 20, 21}, {30, 34, 43}};
    int x = 14;

    if (searchMatrix(mat, x))
        cout << "true";
    else
        cout << "false";

    return 0;
}

````

Java

````
// Java program to search in the sorted matrix using
// Binary Search two times

class GfG {

    // Function to binary search for x in arr[]
    static boolean search(int[] arr, int x) {
        int lo = 0, hi = arr.length - 1;

        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            if (x == arr[mid])
                return true;
            if (x < arr[mid])
                hi = mid - 1;
            else
                lo = mid + 1;
        }
        return false;
    }

    static boolean searchMatrix(int[][] mat, int x) {
        int n = mat.length, m = mat[0].length;
        int lo = 0, hi = n - 1;
        int row = -1;

        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            // If the first element of mid row is equal to x,
            // return true
            if (x == mat[mid][0])
                return true;

            // If x is greater than first element of mid row,
            // store the mid row and search in lower half
            if (x > mat[mid][0]) {
                row = mid;
                lo = mid + 1;
            }

            // If x is smaller than first element of mid row,
            // search in upper half
            else
                hi = mid - 1;
        }

        // If x is smaller than all elements of mat[][]
        if (row == -1)
            return false;

        return search(mat[row], x);
    }

    public static void main(String[] args) {
        int[][] mat = {
            {1, 5, 9},
            {14, 20, 21},
            {30, 34, 43}
        };
        int x = 14;

        if (searchMatrix(mat, x))
            System.out.println("true");
        else
            System.out.println("false");
    }
}

````

Python

````
# Python program to search in the sorted matrix using
# Binary Search two times

# Function to binary search for x in arr[]
def search(arr, x):
    lo = 0
    hi = len(arr) - 1

    while lo <= hi:
        mid = (lo + hi) // 2

        if x == arr[mid]:
            return True
        if x < arr[mid]:
            hi = mid - 1
        else:
            lo = mid + 1
    return False

def searchMatrix(mat, x):
    n = len(mat)
    m = len(mat[0])
    lo = 0
    hi = n - 1
    row = -1

    while lo <= hi:
        mid = (lo + hi) // 2

        # If the first element of mid row is equal to x,
        # return true
        if x == mat[mid][0]:
            return True

        # If x is greater than first element of mid row,
        # store the mid row and search in lower half
        if x > mat[mid][0]:
            row = mid
            lo = mid + 1

        # If x is smaller than first element of mid row,
        # search in upper half
        else:
            hi = mid - 1

    # If x is smaller than all elements of mat[][]
    if row == -1:
        return False

    return search(mat[row], x)

if __name__ == "__main__":
    mat = [[1, 5, 9], [14, 20, 21], [30, 34, 43]]
    x = 14

    if searchMatrix(mat, x):
        print("true")
    else:
        print("false")

````

C#

````
// C# program to search in the sorted matrix using
// Binary Search two times

using System;

class GfG {

    // Function to binary search for x in arr[]
    static bool Search(int[] arr, int x) {
        int lo = 0, hi = arr.Length - 1;

        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            if (x == arr[mid])
                return true;
            if (x < arr[mid])
                hi = mid - 1;
            else
                lo = mid + 1;
        }
        return false;
    }

    static bool SearchMatrix(int[][] mat, int x) {
        int n = mat.Length, m = mat[0].Length;
        int lo = 0, hi = n - 1;
        int row = -1;

        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            // If the first element of mid row is equal to x,
            // return true
            if (x == mat[mid][0])
                return true;

            // If x is greater than first element of mid row,
            // store the mid row and search in lower half
            if (x > mat[mid][0]) {
                row = mid;
                lo = mid + 1;
            }

            // If x is smaller than first element of mid row,
            // search in upper half
            else
                hi = mid - 1;
        }

        // If x is smaller than all elements of mat[][]
        if (row == -1)
            return false;

        return Search(mat[row], x);
    }

    static void Main(string[] args) {
        int[][] mat = new int[][] {
            new int[] {1, 5, 9},
            new int[] {14, 20, 21},
            new int[] {30, 34, 43}
        };
        int x = 14;

        if (SearchMatrix(mat, x))
            Console.WriteLine("true");
        else
            Console.WriteLine("false");
    }
}

````

JavaScript

````
// JavaScript program to search in the sorted matrix using
// Binary Search two times

// Function to binary search for x in arr[]
function search(arr, x) {
    let lo = 0, hi = arr.length - 1;

    while (lo <= hi) {
        let mid = Math.floor((lo + hi) / 2);

        if (x === arr[mid])
            return true;
        if (x < arr[mid])
            hi = mid - 1;
        else
            lo = mid + 1;
    }
    return false;
}

function searchMatrix(mat, x) {
    let n = mat.length, m = mat[0].length;
    let lo = 0, hi = n - 1;
    let row = -1;

    while (lo <= hi) {
        let mid = Math.floor((lo + hi) / 2);

        // If the first element of mid row is equal to x,
        // return true
        if (x === mat[mid][0])
            return true;

        // If x is greater than first element of mid row,
        // store the mid row and search in lower half
        if (x > mat[mid][0]) {
            row = mid;
            lo = mid + 1;
        }

        // If x is smaller than first element of mid row,
        // search in upper half
        else
            hi = mid - 1;
    }

    // If x is smaller than all elements of mat[][]
    if (row === -1)
        return false;

    return search(mat[row], x);
}

// Driver Code
const mat = [
    [1, 5, 9],
    [14, 20, 21],
    [30, 34, 43]
];
const x = 14;

if (searchMatrix(mat, x))
    console.log("true");
else
    console.log("false");

````




**Output**
```
true
```
### ****[Expected Approach] Using Binary Search Once –**** O(log(n\\*m)) and O(1) Space

> The idea is to
>
> ****consider the given matrix as 1D array****
> and
>
> ****apply****
> only one
>
> ****binary search.****
> For example, for a matrix of size
>
> ****n x m a****
> nd we can consider it as a
>
> ****1D array****
> of size n\\*m
>
> ****,****
> then the
>
> ****first index****
> would be
>
> ****0****
> and
>
> ****last index****
> would
>
> ****n\\*m-1.****
> So
>
> ****,****
> we need to do binary search from low = 0 to high = (n\\*m-1)
>
> ****.****
>
> ****How to find the element in 2D matrix corresponding to index = mid?****
>
>
> Since each row of mat[][] will have
>
> ****m****
> elements, so we can find the row of the element as
>
> ****(mid / m)****
> and the column of the element as
>
> ****(mid % m)****
> . Then, we can compare
>
> ****x****
> with
>
> ****arr[mid/m][mid%m]****
> for each mid and complete our binary search.












C++

````
// C++ program to search in the sorted matrix using
// binary search

#include <iostream>
#include <vector>
using namespace std;

bool searchMatrix(vector<vector<int>>& mat, int x) {
    int n = mat.size(), m = mat[0].size();

    int lo = 0, hi = n * m - 1;
    while (lo <= hi) {
        int mid = (lo + hi) / 2;

        // Find row and column of element at mid index
        int row = mid / m;
        int col = mid % m;

        // If x is found, return true
        if (mat[row][col] == x)
            return true;

        // If x is greater than mat[row][col], search in
        // right half
        if (mat[row][col] < x)
            lo = mid + 1;

        // If x is less than mat[row][col], search in
        // left half
        else
            hi = mid - 1;
    }
    return false;
}

int main() {
    vector<vector<int>> mat = {{1, 5, 9}, {14, 20, 21}, {30, 34, 43}};
    int x = 14;

    if (searchMatrix(mat, x))
        cout << "true";
    else
        cout << "false";

    return 0;
}

````

Java

````
// Java program to search in the sorted matrix using
// binary search

class GfG {

    // Function to search for x in the matrix using binary search
    static boolean searchMatrix(int[][] mat, int x) {
        int n = mat.length, m = mat[0].length;

        int lo = 0, hi = n * m - 1;
        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            // Find row and column of element at mid index
            int row = mid / m;
            int col = mid % m;

            // If x is found, return true
            if (mat[row][col] == x)
                return true;

            // If x is greater than mat[row][col], search in
            // right half
            if (mat[row][col] < x)
                lo = mid + 1;

            // If x is less than mat[row][col], search in
            // left half
            else
                hi = mid - 1;
        }
        return false;
    }

    public static void main(String[] args) {
        int[][] mat = {{1, 5, 9}, {14, 20, 21}, {30, 34, 43}};
        int x = 14;

        if (searchMatrix(mat, x))
            System.out.println("true");
        else
            System.out.println("false");
    }
}

````

Python

````
# Python program to search in the sorted matrix using
# binary search

# Function to search for x in the matrix using binary search
def searchMatrix(mat, x):
    n = len(mat)
    m = len(mat[0])

    lo, hi = 0, n * m - 1
    while lo <= hi:
        mid = (lo + hi) // 2

        # Find row and column of element at mid index
        row = mid // m
        col = mid % m

        # If x is found, return true
        if mat[row][col] == x:
            return True

        # If x is greater than mat[row][col], search in
        # right half
        if mat[row][col] < x:
            lo = mid + 1

        # If x is less than mat[row][col], search in
        # left half
        else:
            hi = mid - 1

    return False

if __name__ == "__main__":
    mat = [[1, 5, 9], [14, 20, 21], [30, 34, 43]]
    x = 14

    if searchMatrix(mat, x):
        print("true")
    else:
        print("false")

````

C#

````
// C# program to search in the sorted matrix using
// binary search

using System;

class GfG {

    // Function to search for x in the matrix using binary search
    static bool searchMatrix(int[,] mat, int x) {
        int n = mat.GetLength(0), m = mat.GetLength(1);

        int lo = 0, hi = n * m - 1;
        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            // Find row and column of element at mid index
            int row = mid / m;
            int col = mid % m;

            // If x is found, return true
            if (mat[row, col] == x)
                return true;

            // If x is greater than mat[row, col], search in
            // right half
            if (mat[row, col] < x)
                lo = mid + 1;

            // If x is less than mat[row, col], search in
            // left half
            else
                hi = mid - 1;
        }
        return false;
    }

    static void Main() {
        int[,] mat = { { 1, 5, 9 }, { 14, 20, 21 }, { 30, 34, 43 } };
        int x = 14;

        if (searchMatrix(mat, x))
            Console.WriteLine("true");
        else
            Console.WriteLine("false");
    }
}

````

JavaScript

````
// JavaScript program to search in the sorted matrix using
// binary search

// Function to search for x in the matrix using binary search
function searchMatrix(mat, x) {
    let n = mat.length, m = mat[0].length;

    let lo = 0, hi = n * m - 1;
    while (lo <= hi) {
        let mid = Math.floor((lo + hi) / 2);

        // Find row and column of element at mid index
        let row = Math.floor(mid / m);
        let col = mid % m;

        // If x is found, return true
        if (mat[row][col] === x)
            return true;

        // If x is greater than mat[row][col], search in
        // right half
        if (mat[row][col] < x)
            lo = mid + 1;

        // If x is less than mat[row][col], search in
        // left half
        else
            hi = mid - 1;
    }
    return false;
}

// Driver Code
let mat = [[1, 5, 9], [14, 20, 21], [30, 34, 43]];
let x = 14;

if (searchMatrix(mat, x))
    console.log("true");
else
    console.log("false");

````




**Output**
```
true
```', '', 'Search element in a sorted matrix', 7, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('aaf04cd6-13a7-415f-ac21-67a4c001f409', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 1, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', '19759307-a805-4bfd-b1a3-648921705a71');
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('0436340a-ef23-4fd2-9d0b-e233b60563e6', e'Collision Resolution Techniques
-------------------------------


There are mainly two methods to handle collision:


1. Separate Chaining
2. Open Addressing

![Collision-Resolution-Techniques](https://media.geeksforgeeks.org/wp-content/uploads/20240514124402/Collision-Resolution-Techniques.webp)

### 1) Separate Chaining


The idea behind

[Separate Chaining](https://www.geeksforgeeks.org/hashing-set-2-separate-chaining/)
is to make each cell of the hash table point to a linked list of records that have the same hash function value. Chaining is simple but requires additional memory outside the table.


****Example****
: We have given a hash function and we have to insert some elements in the hash table using a separate chaining method for collision resolution technique.


> Hash function = key % 5,
>
>
>
> Elements = 12, 15, 22, 25 and 37.


Let’s see step by step approach to how to solve the above problem:









Hence In this way, the separate chaining method is used as the collision resolution technique.


### 2) Open Addressing


In

[open addressing](https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/)
, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we examine the table slots one by one until the desired element is found or it is clear that the element is not in the table.


#### 2.a) Linear Probing


In linear probing, the hash table is searched sequentially that starts from the original location of the hash. If in case the location that we get is already occupied, then we check for the next location.


****Example:****
Let us consider a simple hash function as “key mod 5” and a sequence of keys that are to be inserted are 50, 70, 76, 85, 93.










#### 2.b) Quadratic Probing


Quadratic probing is an open addressing scheme in computer programming for resolving hash collisions in hash tables. Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open slot is found.


This method is also known as the mid-square method because in this method we look for i

2
-th probe (slot) in i-th iteration and the value of i = 0, 1, . . . n – 1. We always start from the original hash location. If only the location is occupied then we check the other slots.



Example: Let us consider table Size = 7, hash function as Hash(x) = x % 7 and collision resolution strategy to be f(i) = i

2
. Insert = 22, 30, and 50








#### 2.c) Double Hashing


Double hashing is a collision resolving technique in

[Open Addressed](https://www.geeksforgeeks.org/hashing-set-3-open-addressing/)
Hash tables. Double hashing make use of two hash function,


* The first hash function is

  ****h1(k)****
  which takes the key and gives out a location on the hash table. But if the new location is not occupied or empty then we can easily place our key.
* But in case the location is occupied (collision) we will use secondary hash-function

  ****h2(k)****
  in combination with the first hash-function

  ****h1(k)****
  to find the new location on the hash table.


This combination of hash functions is of the form


> ****h(k, i) = (h1(k) + i \\* h2(k)) % n****


where


* i is a non-negative integer that indicates a collision number,
* k = element/key which is being hashed
* n = hash table size.

****Complexity of the Double hashing algorithm:****

> Time complexity: O(n)

****Example:****
Insert the keys 27, 43, 692, 72 into the Hash Table of size 7. where first hash-function is

****h1​(k) = k mod 7****
and second hash-function is

****h2(k) = 1 + (k mod 5)****

', 'In Hashing, hash functions were used to generate hash values. The hash value is used to create an index for the keys in the hash table. The hash function may return the same hash value for two or more keys. When two or more keys have the same hash value, a collision happens. To handle this collision, we use Collision Resolution Techniques', 'Collision Resolution Techniques', 14, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('bdde6e1b-edc4-4731-a95b-bd1a61a42a7d', e'Basic terminologies of Array
----------------------------

* ****Array Index:****
  In an array, elements are identified by their indexes. Array index
  starts from 0.
* ****Array element:**** Elements are items stored in an array and can be accessed by their
  index.
* ****Array Length:****
  The length of an array is determined by the number of elements it can
  contain.

Memory representation of Array
------------------------------

In an array, all the elements are stored in contiguous memory
locations. So, if we initialize an array, the elements will be allocated
sequentially in memory. This allows for efficient access and
manipulation of elements.

![Memory-Representation-of-Array-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240405101013/Memory-Representation-of-Array-(1).webp)

Declaration of Array
--------------------

Arrays can be declared in various ways in different languages. For
better illustration, below are some language-specific array
declarations:

C++
````
// This array will store integer type element
int arr[5];

// This array will store char type element
char arr[10];

// This array will store float type element
float arr[20];

````

C
````
// This array will store integer type element
int arr[5];

// This array will store char type element
char arr[10];

// This array will store float type element
float arr[20];

````

Java
````
// This array will store integer type element
int arr[];

// This array will store char type element
char arr[];

// This array will store float type element
float arr[];

````

Python
````
# In Python, all types of lists are created same way
arr = []

````

C#
````
// This array will store integer type element
int[] arr;

// This array will store char type element
char[] arr2;

// This array will store float type element
float[] arr3;

````







Initialization of Array
-----------------------

Arrays can be initialized in different ways in different languages.
Below are some language-specific array initializations:

C++
````
int arr[] = { 1, 2, 3, 4, 5 };
char arr[5] = { \'a\', \'b\', \'c\', \'d\', \'e\' };
float arr[10] = { 1.4, 2.0, 24, 5.0, 0.0 };

````

C
````
int arr[] = { 1, 2, 3, 4, 5 };
char arr[5] = { \'a\', \'b\', \'c\', \'d\', \'e\' };
float arr[10] = { 1.4, 2.0, 24, 5.0, 0.0 };

````

Java
````
int arr[] = { 1, 2, 3, 4, 5 };
char arr[] = { \'a\', \'b\', \'c\', \'d\', \'e\' };
float arr[] = { 1.4f, 2.0f, 24f, 5.0f, 0.0f };

````

Python
````
# This list will store integer type elements
arr = [1, 2, 3, 4, 5]

# This list will store character type elements (strings in Python)
arr = [\'a\', \'b\', \'c\', \'d\', \'e\']

# This list will store float type elements
arr = [1.4, 2.0, 24.0, 5.0, 0.0]  # All float values

````

C#
````
int[] arr = { 1, 2, 3, 4, 5 };
char[] arr = { \'a\', \'b\', \'c\', \'d\', \'e\' };
float[] arr = { 1.4f, 2.0f, 24f, 5.0f, 0.0f };

````

JavaScript
````
let arr = [ 1, 2, 3, 4, 5 ];
let arr = [ \'a\', \'b\', \'c\', \'d\', \'e\' ];
let arr = [ 1.4, 2.0, 24, 5.0, 0.0 ];

````




Why do we Need Arrays?
----------------------

Assume there is a class of five students and if we have to keep records
of their marks in examination then, we can do this by declaring five
variables individual and keeping track of records but what if the number
of students becomes very large, it would be challenging to manipulate
and maintain the data.

What it means is that, we can use normal variables (v1, v2, v3, ..)
when we have a small number of objects. But if we want to store a large
number of instances, it becomes difficult to manage them with normal
variables. ****The idea of an array is to represent many instances in one
variable****.


![Importance-of-Array](https://media.geeksforgeeks.org/wp-content/uploads/20240405123859/Importance-of-Array.webp)

Types of Arrays
---------------

Arrays can be classified in two ways:

* On the basis of Size
* On the basis of Dimensions

![Types-of-Arrays](https://media.geeksforgeeks.org/wp-content/uploads/20240731124259/Types-of-Arrays.webp)
### Types of Arrays on the basis of Size:

****1. Fixed Sized Arrays:****

We cannot alter or update the size of this array. Here only a fixed
size (i,e. the size that is mentioned in square brackets ****[]****) of memory will be allocated for storage. In case, we don’t know the
size of the array then if we declare a larger size and store a lesser
number of elements will result in a wastage of memory or we declare a
lesser size than the number of elements then we won’t get enough memory
to store all the elements. In such cases, static memory allocation is
not preferred.


C++
````
// Method 1 to create a fixed sized array.
// Here the memory is allocated at compile time.
int arr[5];
// Another way (creation and initialization both)
int arr2[5] = {1, 2, 3, 4, 5};

// Method 2 to create a fixed sized array
// Here memory is allocated at run time (Also
// known as dynamically allocated arrays)
int *arr = new int[5];
// Method 1 to create a fixed sized array.
// Here the memory is allocated at compile time.
int arr[5];
// Another way (creation and initialization both)
int arr2[5] = {1, 2, 3, 4, 5};
// Method 2 to create a fixed sized array
// Here memory is allocated at run time (Also
// known as dynamically allocated arrays)
int *arr = new int[5];
````









C
````
// Method 1 to create a fixed sized array.
// Here the memory is allocated at compile time.
int arr1[5];
// Another way (creation and initialization both)
int arr2[5] = {1, 2, 3, 4, 5};


// Method 2 to create a fixed sized array
// Here memory is allocated at run time (Also
// known as dynamically allocated arrays)
int *arr = (int*)malloc(n * sizeof(int));

````

Java
````
// Fixed sized array examples
int[] arr1 = new int [5];

// Another way (Array creation and
// initialization both)
int[] arr2 = {1, 2, 3, 4, 5};

````

Python
````
# Create a fixed-size list of length 5,
# initialized with zeros
arr = [0] * 5

# Output the fixed-size list
print(arr)

````

C#
````
// Fixed sized array examples
int[] arr1 = new int [5];

// Another way (Array creation and
// initialization both)
int[] arr2 = {1, 2, 3, 4, 5};

````




****2. Dynamic Sized Arrays:****

The size of the array changes as per user requirements during execution
of code so the coders do not have to worry about sizes. They can add and
removed the elements as per the need. The memory is mostly dynamically
allocated and de-allocated in these arrays.

C++
````
#include<vector>

// Dynamic Integer Array
vector<int> v;

````

C
````
// C does not seem to support
// dynamic sized arrays as of now

````

Java
````
// Dynamic Integer Array
ArrayList<Integer> arr = new ArrayList<>();

````

Python
````
# Dynamic Array
arr = []

````

C#
````
// Similar to Java
ArrayList myList = new ArrayList();

````

JavaScript
````
// Dynamic Sized Array
let arr = new Array();

````




### Types of Arrays on the basis of Dimensions:

****1. One-dimensional Array(1-D Array):**** You can imagine a 1d array as a row, where elements are stored one
after another.

![One-Dimensional-Array(1-D-Array)](https://media.geeksforgeeks.org/wp-content/uploads/20240405123929/One-Dimensional-Array(1-D-Array).webp)

****2. Multi-dimensional Array:****
A multi-dimensional array is an array with more than one dimension. We
can use multidimensional array to store complex data in the form of
tables, etc. We can have 2-D arrays, 3-D arrays, 4-D arrays and so on.


* [****Two-Dimensional Array(2-D Array or Matrix):****](https://www.geeksforgeeks.org/matrix)2-D Multidimensional arrays can be considered as an array of
  arrays or as a matrix consisting of rows and columns.

![Two-Dimensional-Array(2-D-Array-or-Matrix)](https://media.geeksforgeeks.org/wp-content/uploads/20240408165401/Two-Dimensional-Array(2-D-Array-or-Matrix).webp)

* ****Three-Dimensional Array(3-D Array):**** A 3-D Multidimensional array contains three dimensions, so
  it can be considered an array of two-dimensional arrays.

![Three-Dimensional-Array(3-D-Array)](https://media.geeksforgeeks.org/wp-content/uploads/20240408165421/Three-Dimensional-Array(3-D-Array).webp)

Operations on Array
-------------------

### 1. Array Traversal:

Array traversal involves visiting all the elements of the array once.
Below is the implementation of Array traversal in different
Languages:

C++14
````
int arr[] = { 1, 2, 3, 4, 5 };
int len = sizeof(arr) / sizeof(arr[0]);
// Traversing over arr[]
for (int i = 0; i < len; i++) {
    cout << arr[i] << " ";

````

C
````
int arr[] = { 1, 2, 3, 4, 5 };
int len = sizeof(arr) / sizeof(arr[0]);
// Traversing over arr[]
for (int i = 0; i < len; i++) {
    printf("%d ", arr[i]);
}

````

Java
````
int arr[] = { 1, 2, 3, 4, 5 };
// Traversing over arr[]
for (int i = 0; i < arr.length; i++) {
    System.out.print(arr[i] + " ");

````

Python
````
# This list will store integer type elements
arr = [1, 2, 3, 4, 5]

# Traversing over arr
for i in range(len(arr)):
    print(arr[i], end=" ")

````

C#
````
int[] arr = { 1, 2, 3, 4, 5 };
// Traversing over arr[]
for (int i = 0; i < arr.Length; i++)
    Console.Write(" " + arr[i]);

````

JavaScript
````
let arr = [1, 2, 3, 4, 5]
// Traversing over arr[]
for (let x of arr)
    console.log(x)

````

### 2. Insertion in Array:

We can insert one or multiple elements at any position in the array.
Below is the implementation of Insertion in Array in different
languages:

C++
````
// Function to insert element
// at a specific position
void insertElement(int arr[], int n, int x, int pos)
{
    // shift elements to the right
    // which are on the right side of pos
    for (int i = n - 1; i >= pos; i--)
        arr[i + 1] = arr[i];

    arr[pos] = x;
}

````

C
````
// Function to insert element
// at a specific position
void insertElement(int arr[], int n, int x, int pos)
{
    // shift elements to the right
    // which are on the right side of pos
    for (int i = n - 1; i >= pos; i--)
        arr[i + 1] = arr[i];

    arr[pos] = x;
}

````

Java
````
static void insertElement(int arr[], int n, int x, int pos)
{
    // shift elements to the right
    // which are on the right side of pos
    for (int i = n - 1; i >= pos; i--)
        arr[i + 1] = arr[i];
    arr[pos] = x;
}

````

Python
````
# Example usage
arr = [1, 2, 3, 4, 5]
x = 10  # Element to be inserted
pos = 2  # Position to insert the element

arr.insert(pos, x)

# Print the updated list
print("Updated List:", arr)

````

C#
````
static void insertElement(int[] arr, int n, int x, int pos)
{
    // shift elements to the right
    // which are on the right side of pos
    for (int i = n - 1; i >= pos; i--)
        arr[i + 1] = arr[i];
    arr[pos] = x;
}

````

JavaScript
````
// javascript Program to Insert an element
// at a specific position in an Array
function insertElement(arr, n, x, pos)
{
    // shift elements to the right
    // which are on the right side of pos
    var i = n - 1;
    for (i; i >= pos; i--)
    {
        arr[i + 1] = arr[i];
    }
    arr[pos] = x;
}

````


### 3. Deletion in Array:

We can delete an element at any index in an array. Below is the
implementation of Deletion of element in an array:

C++
````
// To search a key to be deleted
int findElement(int arr[], int n, int key);

// Function to delete an element
int deleteElement(int arr[], int n, int key)
{
    // Find position of element to be deleted
    int pos = findElement(arr, n, key);

    if (pos == -1) {
        cout << "Element not found";
        return n;
    }

    // Deleting element
    int i;
    for (i = pos; i < n - 1; i++)
        arr[i] = arr[i + 1];

    return n - 1;
}

// Function to implement search operation
int findElement(int arr[], int n, int key)
{
    int i;
    for (i = 0; i < n; i++)
        if (arr[i] == key)
            return i;
    // Return -1 if key is not found
    return -1;
}

````

C
````
// C program to implement delete operation in a
// unsorted array
#include <stdio.h>

// To search a key to be deleted
int findElement(int arr[], int n, int key);

// Function to delete an element
int deleteElement(int arr[], int n, int key)
{
    // Find position of element to be deleted
    int pos = findElement(arr, n, key);

    if (pos == -1) {
        printf("Element not found");
        return n;
    }

    // Deleting element
    int i;
    for (i = pos; i < n - 1; i++)
        arr[i] = arr[i + 1];

    return n - 1;
}

// Function to implement search operation
int findElement(int arr[], int n, int key)
{
    int i;
    for (i = 0; i < n; i++)
        if (arr[i] == key)
            return i;
     // Return -1 if key is not found
    return -1;
}

````

Java
````
// function to search a key to
    // be deleted
    static int findElement(int arr[], int n, int key)
    {
        int i;
        for (i = 0; i < n; i++)
            if (arr[i] == key)
                return i;
         // Return -1 if key is not found
        return -1;
    }

    // Function to delete an element
    static int deleteElement(int arr[], int n, int key)
    {
        // Find position of element to be
        // deleted
        int pos = findElement(arr, n, key);

        if (pos == -1) {
            System.out.println("Element not found");
            return n;
        }

        // Deleting element
        int i;
        for (i = pos; i < n - 1; i++)
            arr[i] = arr[i + 1];

        return n - 1;
    }

````

Python
````
# Initialize a list
arr = [10, 20, 30, 40, 50]

# Value to delete
key = 40

# Remove the element with the specified value
# if present in the list
if key in arr:
   arr.remove(key)
else:
   print("Element Not Found")

# Output the modified list
print(arr)  # Output: [10, 20, 30, 50]

````

C#
````
int findElement(int[] arr, int n, int key)
{

    int i;
    for (i = 0; i < n; i++)
        if (arr[i] == key)
            return i;

    return -1;
}

// Function to delete an element
int deleteElement(int[] arr, int n, int key)
{
    // Find position of element
    // to be deleted
    int pos = findElement(arr, n, key);

    if (pos == -1) {
        Console.WriteLine("Element not found");
        return n;
    }

    // Deleting element
    int i;
    for (i = pos; i < n - 1; i++)
        arr[i] = arr[i + 1];

    return n - 1;
}

````

JavaScript
````
// function to search a key to  be deleted
function findElement(arr,n,key)
{
    let i;
    for (i = 0; i < n; i++)
        if (arr[i] == key)
            return i;
    return -1;
}

// Function to delete an element
function deleteElement(arr,n,key)
{
    // Find position of element to be deleted
    let pos = findElement(arr, n, key);

    if (pos == -1)
    {
        document.write("Element not found");
        return n;
    }
    // Deleting element
    let i;
    for (i = pos; i< n - 1; i++)
        arr[i] = arr[i + 1];
    return n - 1;
}

````






### 4. Searching in Array:

We can traverse over an array and search for an element. Below is the
implementation of Searching of element in an array:


C++
````
// Function to implement search operation
int findElement(int arr[], int n, int key)
{
    int i;
    for (i = 0; i < n; i++)
        if (arr[i] == key)
            return i;

    // If the key is not found
    return -1;
}

````

C
````
// Function to implement search operation
int findElement(int arr[], int n, int key)
{
    int i;
    for (i = 0; i < n; i++)
        if (arr[i] == key)
            return i;

    // If the key is not found
    return -1;
}

````

Java
````
// Function to implement search operation
int findElement(int arr[], int n, int key)
{
    for (int i = 0; i < n; i++)
        if (arr[i] == key)
            return i;

    // If the key is not found
    return -1;
}

````

Python
````
# Function to implement search operation
def find_element(arr, n, key):
    for i in range(n):
        if arr[i] == key:
            return i
    return -1

````

C#
````
// Function to implement
// search operation
int findElement(int[] arr, int n, int key)
{
    for (int i = 0; i < n; i++)
        if (arr[i] == key)
            return i;

    // If the key is not found
    return -1;
}

````

JavaScript
````
// Function to implement search operation
function findElement( arr, n, key)
{
    let i;
    for (i = 0; i < n; i++)
        if (arr[i] == key)
            return i;

    return -1;
}

````


Complexity Analysis of Operations on Array
------------------------------------------

### Time Complexity:

| Operation | Best Case | Average Case | Worst Case |
| --- | --- | --- | --- |
| ****Traversal**** | θ(N) | θ(N) | θ((N) |
| ****Insertion**** | θ((1) | θ(N) | θ(N) |
| ****Deletion**** | θ(1) | θ(N) | θ(N) |
| ****Searching**** | θ(1) | θ(N) | θ(N) |

### Auxiliary Space

| Operation | Best Case | Average Case | Worst Case |
| --- | --- | --- | --- |
| ****Traversal**** | θ(1) | θ(1) | θ(1) |
| ****Insertion**** | θ(1) | θ(N) | θ(N) |
| ****Deletion**** | θ(1) | θ(N) | θ(N) |
| ****Searching**** | θ(1) | θ(1) | θ(1) |
', e'Array is a collection of items of the same variable type that are stored at
contiguous memory locations. It is one of the most popular and simple
data structures used in programming.', 'Getting Started with Array Data Structure', 1, '7328995b-6079-4bd9-8be0-7c9152d5a73b', 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', '73a96fec-0145-4ffd-b7c0-ee6d6ff34aef');
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('9d3e7774-66e8-4f47-8589-0f78ccd0f6ea', e'Given a

[matrix](https://www.geeksforgeeks.org/matrix/)

****mat[][]****
of size

****n x m****
, the task is to traverse this matrix

[using recursion](https://www.geeksforgeeks.org/recursion/)
.



****Examples:****


> ****Input:****
> mat[][] = [[1, 2, 3],
>
>
>
> [4, 5, 6],
>
>
>
> [7, 8, 9]]
>
>
>
> ****Output:****
> 1 2 3 4 5 6 7 8 9
>
>
>
>
>
> ****Input:****
> mat[][] = [[11, 12, 13],
>
>
>
> [14, 15, 16],
>
>
>
> [17, 18, 19]]
>
>
>
> ****Output:****
> 11 12 13 14 15 16 17 18 19

****Approach:****


* Check If the current position is in the bottom-right corner of the matrix
  + Print the value at that position
  + End the recursion
* Print the value at the current position
* Check If the end of the current row has not been reached
  + Move right
* Check If the end of the current column has been reached
  + Move down to the next row


Below is the implementation of the above approach:


C++

````
//C++ program to traverse the matrix using recursion
#include <iostream>
#include <vector>

using namespace std;

// Recursive function to traverse the matrix
void traverse(vector<vector<int>>& mat, int i, int j) {

    // If the current position is the bottom-right
      // corner of the matrix
    if (i == mat.size() - 1 && j == mat[0].size() - 1) {
        cout << mat[i][j] << endl;
        return;
    }

    // Print the value at the current position
    cout << mat[i][j] << " ";

    // If the end of the current row has
      // not been reached
    if (j < mat[0].size() - 1) {

        // Move right
        traverse(mat, i, j + 1);
    }

    // If the end of the current column has been reached
    else if (i < mat.size() - 1) {

        // Move down to the next row
        traverse(mat, i + 1, 0);
    }
}

int main() {
    vector<vector<int>> mat = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
    traverse(mat, 0, 0);
    return 0;
}

````

Java

````
//Java program to traverse the matrix using recursion
import java.util.Arrays;

class GfG {

    // Recursive function to traverse the matrix
    static void traverse(int[][] mat, int i, int j) {

        // If the current position is the bottom-right
        // corner of the matrix
        if (i == mat.length - 1 && j == mat[0].length - 1) {
            System.out.println(mat[i][j]);
            return;
        }

        // Print the value at the current position
        System.out.print(mat[i][j] + " ");

        // If the end of the current row has not
          // been reached
        if (j < mat[0].length - 1) {

            // Move right
            traverse(mat, i, j + 1);
        }

        // If the end of the current column has been reached
        else if (i < mat.length - 1) {

            // Move down to the next row
            traverse(mat, i + 1, 0);
        }
    }

    public static void main(String[] args) {
        int[][] mat = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
        traverse(mat, 0, 0);
    }
}

````

Python

````
#Python program to traverse the matrix using recursion
def traverse(mat, i, j):

    # If the current position is the bottom-
    # right corner of the matrix
    if i == len(mat) - 1 and j == len(mat[0]) - 1:
        print(mat[i][j])
        return

    # Print the value at the current position
    print(mat[i][j], end=" ")

    # If the end of the current row has not
    # been reached
    if j < len(mat[0]) - 1:

        # Move right
        traverse(mat, i, j + 1)

    # If the end of the current column
    # has been reached
    elif i < len(mat) - 1:

        # Move down to the next row
        traverse(mat, i + 1, 0)

mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
traverse(mat, 0, 0)

````

C#

````
//C# program to traverse the matrix using recursion
using System;

class GfG {

    // Recursive function to traverse the matrix
    static void Traverse(int[,] mat, int i, int j) {
        int rows = mat.GetLength(0);
        int cols = mat.GetLength(1);

        // If the current position is the bottom-right
          // corner of the matrix
        if (i == rows - 1 && j == cols - 1) {
            Console.WriteLine(mat[i, j]);
            return;
        }

        // Print the value at the current position
        Console.Write(mat[i, j] + " ");

        // If the end of the current row has
          // not been reached
        if (j < cols - 1) {

            // Move right
            Traverse(mat, i, j + 1);
        }

        // If the end of the current column
          // has been reached
        else if (i < rows - 1) {

            // Move down to the next row
            Traverse(mat, i + 1, 0);
        }
    }

    static void Main() {

        int[,] mat = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
        Traverse(mat, 0, 0);
    }
}

````

JavaScript

````
//Javascript program to traverse the matrix using recursion
function traverse(mat, i, j) {
    const rows = mat.length;
    const cols = mat[0].length;

    // If the current position is the bottom-right
    // corner of the matrix
    if (i === rows - 1 && j === cols - 1) {
        console.log(mat[i][j]);
        return;
    }

    // Print the value at the current position
    console.log(mat[i][j] + " ");

    // If the end of the current row has not been reached
    if (j < cols - 1) {

        // Move right
        traverse(mat, i, j + 1);
    }
    // If the end of the current column has been reached
    else if (i < rows - 1) {

        // Move down to the next row
        traverse(mat, i + 1, 0);
    }
}

const mat = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
traverse(mat, 0, 0);

````




**Output**
```
1 2 3 4 5 6 7 8 9

```

****Time Complexity:****
O(N \\* M)



****Auxiliary Space:****
O(M), because of recursive calling

', '', 'Traverse a given Matrix using Recursion', 8, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('86b60543-2809-4779-a1f3-bb6d01a8db8b', e'
Given a matrix of size n X m, find the transpose of the matrix.

[Transpose of a matrix](https://www.geeksforgeeks.org/transpose-of-a-matrix/)
is obtained by changing rows to columns and columns to rows. In other words, transpose of mat[n][m] is obtained by changing mat[i][j] to mat[j][i].


****Example:****

> ![matrix-transpose](https://media.geeksforgeeks.org/wp-content/cdn-uploads/matrix-transpose.jpg)


Follow the given steps to solve the problem:


* Run a nested loop using two integer pointers i and j for 0 <= i < n and 0 <= j < m
* Set mat[i][j] equal to mat[j][i]


Below is the implementation of the above approach:


C++

````
#include <iostream>
#include <vector>
using namespace std;

// Function to store the transpose of mat in res
void transpose(vector<vector<int>>& mat, vector<vector<int>>& res) {
    int rows = mat.size();
    int cols = mat[0].size();

    // Resize res to have dimensions swapped
    res.resize(cols, vector<int>(rows));

    // Fill res with transposed values of mat
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            res[j][i] = mat[i][j];
        }
    }
}

// Driver code
int main() {
    vector<vector<int>> mat = {
        { 1, 2, 3 },
        { 4, 5, 6 }
    };

    // Create a result matrix for the transpose
    vector<vector<int>> res;

    // Function call to calculate the transpose
    transpose(mat, res);

    // Print the result matrix
    cout << "Result matrix is:\\n";
    for (auto& row : res) {
        for (auto& elem : row) {
            cout << " " << elem;
        }
        cout << "\\n";
    }

    return 0;
}

````

C

````
// Import necessary libraries
#include <stdio.h>

// Define macros for matrix dimensions
#define M 2  // Number of rows in the original matrix
#define N 3  // Number of columns in the original matrix

// Function to store the transpose of mat in res
void transpose(int mat[M][N], int res[N][M]) {

    // Fill res with transposed values of mat
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            res[j][i] = mat[i][j];
        }
    }
}

// Driver code
int main() {
    int mat[M][N] = {
        { 1, 2, 3 },
        { 4, 5, 6 }
    };

    // Create a result matrix for the transpose
    int res[N][M];

    // Function call to calculate the transpose
    transpose(mat, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            printf("%d ", res[i][j]);
        }
        printf("\\n");
    }
    return 0;
}

````

Java

````
// Import necessary classes
import java.util.Arrays;
import java.util.Scanner;

public class TransposeMatrix {

    // Function to store the transpose of mat in res
    public static void transpose(int[][] mat, int[][] res) {
        int rows = mat.length;
        int cols = mat[0].length;

        // Fill res with transposed values of mat
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                res[j][i] = mat[i][j];
            }
        }
    }

    // Driver code
    public static void main(String[] args) {
        int[][] mat = {
            { 1, 2, 3 },
            { 4, 5, 6 }
        };

        // Create a result matrix for the transpose
        int[][] res = new int[mat[0].length][mat.length];

        // Function call to calculate the transpose
        transpose(mat, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            System.out.println(Arrays.toString(row));
        }
    }
}

````

Python

````
# Function to store the transpose of mat in res
def transpose(mat):

    # Fill res with transposed values of mat
    return [[mat[j][i] for j in range(len(mat))] for i in range(len(mat[0]))]

# Driver code
if __name__ == \'__main__\':
    mat = [
        [1, 2, 3],
        [4, 5, 6]
    ]

    # Function call to calculate the transpose
    res = transpose(mat)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(" ".join(map(str, row)))

````

C#

````
// Function to store the transpose of mat in res
void Transpose(int[][] mat, out int[][] res) {
    int rows = mat.Length;
    int cols = mat[0].Length;

    // Resize res to have dimensions swapped
    res = new int[cols][];
    for (int i = 0; i < cols; i++) {
        res[i] = new int[rows];
    }

    // Fill res with transposed values of mat
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            res[j][i] = mat[i][j];
        }
    }
}

// Driver code
public static void Main() {
    int[][] mat = {
        new int[] { 1, 2, 3 },
        new int[] { 4, 5, 6 }
    };

    // Create a result matrix for the transpose
    int[][] res;

    // Function call to calculate the transpose
    Transpose(mat, out res);

    // Print the result matrix
    Console.WriteLine("Result matrix is:");
    foreach (var row in res) {
        foreach (var elem in row) {
            Console.Write(" " + elem);
        }
        Console.WriteLine();
    }
}

````

JavaScript

````
// Function to store the transpose of mat in res
function transpose(mat) {
    let rows = mat.length;
    let cols = mat[0].length;

    // Create a result matrix for the transpose
    let res = Array.from({ length: cols }, () => new Array(rows));

    // Fill res with transposed values of mat
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[j][i] = mat[i][j];
        }
    }
    return res;
}

// Driver code
let mat = [
    [ 1, 2, 3 ],
    [ 4, 5, 6 ]
];

// Function call to calculate the transpose
let res = transpose(mat);

// Print the result matrix
console.log("Result matrix is:");
for (let row of res) {
    console.log(" "+ row.join(\' \'));
}

````




**Output**
```
Result matrix is
 1 2 3 4
 1 2 3 4
 1 2 3 4
 1 2 3 4

```

****Time complexity:****
O(m x n).



****Auxiliary Space:****
O(m x n)


### ****Approach using constant space for Square Matrix****

**This approach works only for square matrices (i.e., – where no. of rows are equal to the number of columns). This algorithm is also known as an “in-place” algorithm as it uses no extra space to solve the problem.**


Follow the given steps to solve the problem:


* Run a nested loop using two integer pointers i and j for 0 <= i < N and i+1 <= j < N
* Swap mat[i][j] with mat[j][i]


Below is the implementation of the above approach:


C++

````
#include <iostream>
#include <vector>
using namespace std;

// Function to convert mat to its transpose
void transpose(vector<vector<int>>& mat) {
    int n = mat.size();
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(mat[i][j], mat[j][i]);
        }
    }
}

// Driver code
int main() {
    vector<vector<int>> mat = {
        { 1, 1, 1, 1 },
        { 2, 2, 2, 2 },
        { 3, 3, 3, 3 },
        { 4, 4, 4, 4 }
    };

    transpose(mat);

    cout << "Modified matrix is:" << endl;
    for (const auto& row : mat) {
        for (int elem : row) {
            cout << elem << " ";
        }
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#define N 4

// Function to convert mat to its transpose
void transpose(int mat[N][N]) {
    for (int i = 0; i < N; i++) {
        for (int j = i + 1; j < N; j++) {
            int temp = mat[i][j];
            mat[i][j] = mat[j][i];
            mat[j][i] = temp;
        }
    }
}

// Driver code
int main() {
    int mat[N][N] = {
        { 1, 1, 1, 1 },
        { 2, 2, 2, 2 },
        { 3, 3, 3, 3 },
        { 4, 4, 4, 4 }
    };

    transpose(mat);

    printf("Modified matrix is:\\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%d ", mat[i][j]);
        }
        printf("\\n");
    }

    return 0;
}

````

Java

````
import java.util.Arrays;

public class GfG {
    static void transpose(int[][] mat) {
        int n = mat.length;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = mat[i][j];
                mat[i][j] = mat[j][i];
                mat[j][i] = temp;
            }
        }
    }

    // Driver code
    public static void main(String[] args) {
        int[][] mat = {
            { 1, 1, 1, 1 },
            { 2, 2, 2, 2 },
            { 3, 3, 3, 3 },
            { 4, 4, 4, 4 }
        };

        transpose(mat);

        System.out.println("Modified matrix is:");
        for (int[] row : mat) {
            System.out.println(Arrays.toString(row));
        }
    }
}

````

Python

````
# Function to convert mat to its transpose

def transpose(mat):
    n = len(mat)
    for i in range(n):
        for j in range(i + 1, n):
            mat[i][j], mat[j][i] = mat[j][i], mat[i][j]

# Driver code
if __name__ == \'__main__\':
    mat = [
        [1, 1, 1, 1],
        [2, 2, 2, 2],
        [3, 3, 3, 3],
        [4, 4, 4, 4]
    ]

    transpose(mat)

    print("Modified matrix is:")
    for row in mat:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;

class Program {

    // Function to convert mat to its transpose
    static void Transpose(int[,] mat) {
        int n = mat.GetLength(0);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = mat[i, j];
                mat[i, j] = mat[j, i];
                mat[j, i] = temp;
            }
        }
    }

    // Driver code
    static void Main() {
        int[,] mat = {
            { 1, 1, 1, 1 },
            { 2, 2, 2, 2 },
            { 3, 3, 3, 3 },
            { 4, 4, 4, 4 }
        };

        Transpose(mat);

        Console.WriteLine("Modified matrix is:");
        for (int i = 0; i < mat.GetLength(0); i++) {
            for (int j = 0; j < mat.GetLength(1); j++) {
                Console.Write(mat[i, j] + " ");
            }
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// Function to convert mat to its transpose
function transpose(mat) {
    let n = mat.length;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            [mat[i][j], mat[j][i]] = [mat[j][i], mat[i][j]];
        }
    }
}

// Driver code
const mat = [
    [1, 1, 1, 1],
    [2, 2, 2, 2],
    [3, 3, 3, 3],
    [4, 4, 4, 4]
];

transpose(mat);

console.log("Modified matrix is:");
mat.forEach(row => {
    console.log(row.join(\' \'));
});

````




**Output**
```
Modified matrix is
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4

```

****Time complexity:****
O(n

2
).



****Auxiliary Space:****
O(1)
', '', 'Program to find transpose of a matrix', 9, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('ea4cc83e-26cf-46c3-84f6-5b4086825afb', e'
****Determinant of 2 x 2 Matrix:****
------------------------------------

![](https://media.geeksforgeeks.org/wp-content/uploads/20220822110357/2x2.png)

Determinant of 2 x 2 matrix

****Determinant of 3 x 3 Matrix:****
------------------------------------

![](https://media.geeksforgeeks.org/wp-content/uploads/20220822110402/3x3.png)

Determinant of 3 x 3 matrix

****How to calculate?****
-------------------------


The value of the determinant of a matrix can be calculated by the following procedure:


* For each element of the first row or first column get the cofactor of those elements.
* Then multiply the element with the determinant of the corresponding cofactor.
* Finally, add them with alternate signs. As a base case, the value of the determinant of a 1\\*1 matrix is the single value itself.


The

****cofactor****
of an element is a matrix that we can get by removing the row and column of that element from that matrix.


C++

````
#include <iostream>
#include <vector>
using namespace std;

// Function for finding the determinant of a matrix.
int getDet(vector<vector<int>>& mat, int n) {

    // Base case: if the matrix is 1x1
    if (n == 1) {
        return mat[0][0];
    }

    // Base case for 2x2 matrix
    if (n == 2) {
        return mat[0][0] * mat[1][1] -
               mat[0][1] * mat[1][0];
    }

    // Recursive case for larger matrices
    int res = 0;
    for (int col = 0; col < n; ++col) {

        // Create a submatrix by removing the first
        // row and the current column
        vector<vector<int>> sub(n - 1, vector<int>(n - 1));
        for (int i = 1; i < n; ++i) {
            int subcol = 0;
            for (int j = 0; j < n; ++j) {

                // Skip the current column
                if (j == col) continue;

                // Fill the submatrix
                sub[i - 1][subcol++] = mat[i][j];
            }
        }

        // Cofactor expansion
        int sign = (col % 2 == 0) ? 1 : -1;
        res += sign * mat[0][col] * getDet(sub, n - 1);
    }

    return res;
}

// Driver program to test the above function
int main() {
    vector<vector<int>> mat = { { 1, 0, 2, -1 },
                                 { 3, 0, 0, 5 },
                                 { 2, 1, 4, -3 },
                                 { 1, 0, 5, 0 } };
    cout << getDet(mat, mat.size()) << endl;
    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define N 4

// Function for finding the determinant of a matrix.
int getDet(int mat[N][N], int n) {

    // Base case: if the matrix is 1x1
    if (n == 1) {
        return mat[0][0];
    }

    // Base case for 2x2 matrix
    if (n == 2) {
        return mat[0][0] * mat[1][1] -
               mat[0][1] * mat[1][0];
    }

    // Recursive case for larger matrices
    int res = 0;
    for (int col = 0; col < n; ++col) {

        // Create a submatrix by removing the
        // first row and the current column
        int sub[N][N]; // Submatrix
        for (int i = 1; i < n; ++i) {
            int subcol = 0;
            for (int j = 0; j < n; ++j) {

                // Skip the current column
                if (j == col) continue;

                // Fill the submatrix
                sub[i - 1][subcol++] = mat[i][j];
            }
        }

        // Cofactor expansion
        int sign = (col % 2 == 0) ? 1 : -1;
        res += sign * mat[0][col] * getDet(sub, n - 1);
    }

    return res;
}

// Driver program to test the above function
int main() {
    int mat[N][N] = { { 1, 0, 2, -1 },
                      { 3, 0, 0, 5 },
                      { 2, 1, 4, -3 },
                      { 1, 0, 5, 0 } };
    printf("%d\\n", getDet(mat, N));
    return 0;
}

````

Java

````
// Function for finding the determinant of a matrix.
public class GfG {
    public static int getDet(int[][] mat, int n) {

        // Base case: if the matrix is 1x1
        if (n == 1) {
            return mat[0][0];
        }

        // Base case for 2x2 matrix
        if (n == 2) {
            return mat[0][0] * mat[1][1] -
                   mat[0][1] * mat[1][0];
        }

        // Recursive case for larger matrices
        int res = 0;
        for (int col = 0; col < n; ++col) {

            // Create a submatrix by removing the first
            // row and the current column
            int[][] sub = new int[n - 1][n - 1];
            for (int i = 1; i < n; ++i) {
                int subcol = 0;
                for (int j = 0; j < n; ++j) {

                    // Skip the current column
                    if (j == col) continue;

                    // Fill the submatrix
                    sub[i - 1][subcol++] = mat[i][j];
                }
            }

            // Cofactor expansion
            int sign = (col % 2 == 0) ? 1 : -1;
            res += sign * mat[0][col] * getDet(sub, n - 1);
        }

        return res;
    }

    // Driver program to test the above function
    public static void main(String[] args) {
        int[][] mat = { { 1, 0, 2, -1 },
                         { 3, 0, 0, 5 },
                         { 2, 1, 4, -3 },
                         { 1, 0, 5, 0 } };
        System.out.println(getDet(mat, mat.length));
    }
}

````

Python

````
# Function for finding the determinant of a matrix.
def getDet(mat, n):

    # Base case: if the matrix is 1x1
    if n == 1:
        return mat[0][0]

    # Base case for 2x2 matrix
    if n == 2:
        return mat[0][0] * mat[1][1] - \\
               mat[0][1] * mat[1][0]

    # Recursive case for larger matrices
    res = 0
    for col in range(n):

        # Create a submatrix by removing the first
        # row and the current column
        sub = [[0] * (n - 1) for _ in range(n - 1)]
        for i in range(1, n):
            subcol = 0
            for j in range(n):

                # Skip the current column
                if j == col:
                    continue

                # Fill the submatrix
                sub[i - 1][subcol] = mat[i][j]
                subcol += 1

        # Cofactor expansion
        sign = 1 if col % 2 == 0 else -1
        res += sign * mat[0][col] * getDet(sub, n - 1)

    return res

# Driver program to test the above function
mat = [[1, 0, 2, -1],
       [3, 0, 0, 5],
       [2, 1, 4, -3],
       [1, 0, 5, 0]]
print(getDet(mat, len(mat)))

````

C#

````
// Function for finding the determinant of a matrix.
using System;
using System.Linq;

class Determinant {
    public static int GetDet(int[,] mat, int n) {

        // Base case: if the matrix is 1x1
        if (n == 1) {
            return mat[0, 0];
        }

        // Base case for 2x2 matrix
        if (n == 2) {
            return mat[0, 0] * mat[1, 1] -
                   mat[0, 1] * mat[1, 0];
        }

        // Recursive case for larger matrices
        int res = 0;
        for (int col = 0; col < n; col++) {

            // Create a submatrix by removing the first
            // row and the current column
            int[,] sub = new int[n - 1, n - 1];
            for (int i = 1; i < n; i++) {
                int subcol = 0;
                for (int j = 0; j < n; j++) {

                    // Skip the current column
                    if (j == col) continue;

                    // Fill the submatrix
                    sub[i - 1, subcol++] = mat[i, j];
                }
            }

            // Cofactor expansion
            int sign = (col % 2 == 0) ? 1 : -1;
            res += sign * mat[0, col] * GetDet(sub, n - 1);
        }

        return res;
    }

    // Driver program to test the above function
    static void Main() {
        int[,] mat = { { 1, 0, 2, -1 },
                        { 3, 0, 0, 5 },
                        { 2, 1, 4, -3 },
                        { 1, 0, 5, 0 } };
        Console.WriteLine(GetDet(mat, mat.GetLength(0)));
    }
}

````

JavaScript

````
// Function for finding the determinant of a matrix.
function getDet(mat, n) {

    // Base case: if the matrix is 1x1
    if (n === 1) {
        return mat[0][0];
    }

    // Base case for 2x2 matrix
    if (n === 2) {
        return mat[0][0] * mat[1][1] -
               mat[0][1] * mat[1][0];
    }

    // Recursive case for larger matrices
    let res = 0;
    for (let col = 0; col < n; col++) {

        // Create a submatrix by removing the first
        // row and the current column
        let sub = Array.from({ length: n - 1 }, () => new Array(n - 1));
        for (let i = 1; i < n; i++) {
            let subcol = 0;
            for (let j = 0; j < n; j++) {

                // Skip the current column
                if (j === col) continue;

                // Fill the submatrix
                sub[i - 1][subcol++] = mat[i][j];
            }
        }

        // Cofactor expansion
        let sign = (col % 2 === 0) ? 1 : -1;
        res += sign * mat[0][col] * getDet(sub, n - 1);
    }

    return res;
}

// Driver program to test the above function
let mat = [ [ 1, 0, 2, -1 ],
            [ 3, 0, 0, 5 ],
            [ 2, 1, 4, -3 ],
            [ 1, 0, 5, 0 ] ];
console.log(getDet(mat, mat.length));

````






**Output**
```
Determinant of the matrix is : 30
```

****Time Complexity:****
O(n

4
)



****Space Complexity:****
O(n

2
), Auxiliary space used for storing cofactors.


****Note:****
In the above recursive approach when the size of the matrix is large it consumes more stack size.


Determinant of a Matrix using Determinant properties:
-----------------------------------------------------


We calculates the determinant of an

`N x N`
matrix using Gaussian elimination and a series of transformations that reduce the matrix to upper triangular form.



> * Converting the given matrix into an
>
>   ****upper triangular matrix****
>   using determinant properties
> * The determinant of the upper triangular matrix is the product of all diagonal elements.
> * Iterating every diagonal element and making all the elements down the diagonal as zero using determinant properties
> * If the diagonal element is zero then search for the next non-zero element in the same column.


There exist two cases:


* ****Case 1:****
  If there is no non-zero element. In this case, the determinant of a matrix is zero
* ****Case 2:****
  If there exists a non-zero element there exist two cases
  + ****Case A:****
    If the index is with a respective diagonal row element. Using the determinant properties make all the column elements down to it zero
  + ****Case B:****
    Swap the row with respect to the diagonal element column and continue the

    ****Case A****
    operation.


Below is the implementation of the above approach:


C++

````
#include <iostream>
#include <vector>
#include <cmath> // For pow function
using namespace std;

// Function to get determinant of a matrix
int getDet(vector<vector<int>>& mat) {

    int n = mat.size();

    int num1, num2, det = 1, index, total = 1;

    // Temporary array for storing row
    vector<int> temp(n + 1);

    // Loop for traversing the diagonal elements
    for (int i = 0; i < n; i++) {
        index = i;

        // Finding the index which has non-zero value
        while (index < n && mat[index][i] == 0) {
            index++;
        }

        if (index == n) // If there is no non-zero element
        {
            continue; // The determinant of the matrix is zero
        }
        if (index != i) {

            // Loop for swapping the diagonal element row and index row
            for (int j = 0; j < n; j++) {
                swap(mat[index][j], mat[i][j]);
            }

            // Determinant sign changes when we shift rows
            det *= pow(-1, index - i);
        }

        // Storing the values of diagonal row elements
        for (int j = 0; j < n; j++) {
            temp[j] = mat[i][j];
        }

        // Traversing every row below the diagonal element
        for (int j = i + 1; j < n; j++) {
            num1 = temp[i]; // Value of diagonal element
            num2 = mat[j][i]; // Value of next row element

            // Traversing every column of row and
            // multiplying to every row
            for (int k = 0; k < n; k++) {

                // Making the diagonal element and next row element equal
                mat[j][k] = (num1 * mat[j][k]) - (num2 * temp[k]);
            }
            total *= num1;
        }
    }

    // Multiplying the diagonal elements to get determinant
    for (int i = 0; i < n; i++) {
        det *= mat[i][i];
    }

    return (det / total); // Det(kA)/k = Det(A);
}

// Driver code
int main() {
    vector<vector<int>> mat = {
        { 1, 0, 2, -1 },
        { 3, 0, 0, 5 },
        { 2, 1, 4, -3 },
        { 1, 0, 5, 0 }
    };
    cout << getDet(mat) << endl;
    return 0;
}

````

Java

````
import java.util.Arrays;

public class GfG {

    // Function to get the determinant of a matrix
    static int getDet(int[][] mat) {
        int n = mat.length;

        int num1, num2, det = 1, index, total = 1;

        // Temporary array for storing row
        int[] temp = new int[n + 1];

        // Loop for traversing the diagonal elements
        for (int i = 0; i < n; i++) {
            index = i;

            // Finding the index which has a non-zero value
            while (index < n && mat[index][i] == 0) {
                index++;
            }
            if (index == n) { // If there is no non-zero element
                continue; // The determinant of the matrix is zero
            }
            if (index != i) {

                // Loop for swapping the diagonal element
                // row and index row
                for (int j = 0; j < n; j++) {
                    int tempSwap = mat[index][j];
                    mat[index][j] = mat[i][j];
                    mat[i][j] = tempSwap;
                }
                // Determinant sign changes when we shift rows
                det *= Math.pow(-1, index - i);
            }

            // Storing the values of diagonal row elements
            for (int j = 0; j < n; j++) {
                temp[j] = mat[i][j];
            }
            // Traversing every row below the diagonal element
            for (int j = i + 1; j < n; j++) {
                num1 = temp[i]; // Value of diagonal element
                num2 = mat[j][i]; // Value of next row element

                // Traversing every column of row and multiplying
                // to every row
                for (int k = 0; k < n; k++) {

                    // Making the diagonal element and next row
                    // element equal
                    mat[j][k] = (num1 * mat[j][k]) - (num2 * temp[k]);
                }
                total *= num1;
            }
        }

        // Multiplying the diagonal elements to get determinant
        for (int i = 0; i < n; i++) {
            det *= mat[i][i];
        }

        return (det / total); // Det(kA)/k = Det(A);
    }

    // Driver code
    public static void main(String[] args) {
        int[][] mat = {
            { 1, 0, 2, -1 },
            { 3, 0, 0, 5 },
            { 2, 1, 4, -3 },
            { 1, 0, 5, 0 }
        };
        System.out.println(getDet(mat));
    }
}

````

Python

````
# Python program to find Determinant of a matrix
def getDet(mat):

    n  = len(mat)
    temp = [0]*n  # temporary array for storing row
    total = 1
    det = 1  # initialize result

    # loop for traversing the diagonal elements
    for i in range(0, n):
        index = i  # initialize the index

        # finding the index which has non zero value
        while(index < n and mat[index][i] == 0):
            index += 1

        if(index == n):  # if there is non zero element
            # the determinant of matrix as zero
            continue

        if(index != i):

            # loop for swapping the diagonal element
            # row and index row
            for j in range(0, n):
                mat[index][j], mat[i][j] = mat[i][j], mat[index][j]

            # determinant sign changes when we shift rows
            # go through determinant properties
            det = det*int(pow(-1, index-i))

        # storing the values of diagonal row elements
        for j in range(0, n):
            temp[j] = mat[i][j]

        # traversing every row below the diagonal element
        for j in range(i+1, n):
            num1 = temp[i]     # value of diagonal element
            num2 = mat[j][i]   # value of next row element

            # traversing every column of row
            # and multiplying to every row
            for k in range(0, n):

                # multiplying to make the diagonal
                # element and next row element equal
                mat[j][k] = (num1*mat[j][k]) - (num2*temp[k])

            total = total * num1  # Det(kA)=kDet(A);

    # multiplying the diagonal elements to get determinant
    for i in range(0, n):
        det = det*mat[i][i]

    return int(det/total)  # Det(kA)/k=Det(A);


# Drivers code
if __name__ == "__main__":
    # mat=[[6 1 1][4 -2 5][2 8 7]]

    mat = [[1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0]]

    print(getDet(mat))

````

C#

````
using System;

class MatrixDeterminant
{
    // Function to get the determinant of a matrix
    static int getDet(int[,] mat)
    {
        int n = mat.GetLength(0);

        int num1, num2, det = 1, index, total = 1;

        // Temporary array for storing row
        int[] temp = new int[n + 1];

        // Loop for traversing the diagonal elements
        for (int i = 0; i < n; i++)
        {
            index = i;

            // Finding the index which has a non-zero value
            while (index < n && mat[index, i] == 0)
            {
                index++;
            }

             // If there is no non-zero element
            if (index == n)
            {
                // The determinant of the matrix is zero
                continue;
            }
            if (index != i)
            {
                // Loop for swapping the diagonal element
                // row and index row
                for (int j = 0; j < n; j++)
                {
                    int tempSwap = mat[index, j];
                    mat[index, j] = mat[i, j];
                    mat[i, j] = tempSwap;
                }

                // Determinant sign changes when we shift rows
                det *= (int)Math.Pow(-1, index - i);
            }

            // Storing the values of diagonal row elements
            for (int j = 0; j < n; j++)
            {
                temp[j] = mat[i, j];
            }

            // Traversing every row below the diagonal element
            for (int j = i + 1; j < n; j++)
            {
                num1 = temp[i]; // Value of diagonal element
                num2 = mat[j, i]; // Value of next row element

                // Traversing every column of row and multiplying
                // to every row
                for (int k = 0; k < n; k++)
                {
                    // Making the diagonal element and next row
                    // element equal
                    mat[j, k] = (num1 * mat[j, k]) - (num2 * temp[k]);
                }
                total *= num1;
            }
        }

        // Multiplying the diagonal elements to get determinant
        for (int i = 0; i < n; i++)
        {
            det *= mat[i, i];
        }

        return (det / total); // Det(kA)/k = Det(A);
    }

    // Driver code
    static void Main()
    {
        int[,] mat = {
            { 1, 0, 2, -1 },
            { 3, 0, 0, 5 },
            { 2, 1, 4, -3 },
            { 1, 0, 5, 0 }
        };
        Console.WriteLine(getDet(mat));
    }
}

````

JavaScript

````
// Function to get the determinant of a matrix
function determinantOfMatrix(mat) {
    const n = mat.length;
    let det = 1;
    let total = 1;

    // Temporary array for storing row
    const temp = new Array(n + 1).fill(0);

    // Loop for traversing the diagonal elements
    for (let i = 0; i < n; i++) {
        let index = i;

        // Finding the index which has a non-zero value
        while (index < n && mat[index][i] === 0) {
            index++;
        }
        if (index === n) {
            continue; // The determinant of the matrix is zero
        }
        if (index !== i) {

            // Swapping the diagonal element row and index row
            for (let j = 0; j < n; j++) {
                [mat[index][j], mat[i][j]] = [mat[i][j], mat[index][j]];
            }

            // Determinant sign changes when we shift rows
            det *= Math.pow(-1, index - i);
        }

        // Storing the values of diagonal row elements
        for (let j = 0; j < n; j++) {
            temp[j] = mat[i][j];
        }

        // Traversing every row below the diagonal element
        for (let j = i + 1; j < n; j++) {
            const num1 = temp[i]; // Value of diagonal element
            const num2 = mat[j][i]; // Value of next row element

            // Traversing every column of row and multiplying
            // to every row
            for (let k = 0; k < n; k++) {

                // Making the diagonal element and next row
                // element equal
                mat[j][k] = (num1 * mat[j][k]) - (num2 * temp[k]);
            }
            total *= num1;
        }
    }

    // Multiplying the diagonal elements to get determinant
    for (let i = 0; i < n; i++) {
        det *= mat[i][i];
    }

    return (det / total); // Det(kA)/k = Det(A);
}

// Driver code
const mat = [
    [1, 0, 2, -1],
    [3, 0, 0, 5],
    [2, 1, 4, -3],
    [1, 0, 5, 0]
];
console.log(determinantOfMatrix(mat));

````




**Output**
```
Determinant of the matrix is : 30
```

****Time complexity:****
O(n

3
)



****Auxiliary Space:****
O(n), Space used for storing row.





****Determinant of a Matrix****
-------------------------------


There is a built-in function or method in

****linalg****
module of

****NumPy****
package in python. It can be called

****numpy.linalg.det(mat)****
which returns the determinant value of the matrix mat passed in the argument.


Python

````
# importing the numpy package
# as np
import numpy as np

def determinant(mat):

    # calling the det() method
    det = np.linalg.det(mat)
    return round(det)

# Driver Code
# declaring the matrix
mat = [[1, 0, 2, -1],
       [3, 0, 0, 5],
       [2, 1, 4, -3],
       [1, 0, 5, 0]]

# Function call
print(\'Determinant of the matrix is:\',
      determinant(mat))

````

****Output:****

```
Determinant of the matrix is: 30
```

****Time Complexity:****
O(n

3
), as the time complexity of np.linalg.det is O(n

3
) for an n x n order matrix.



****Auxiliary Space:****
O(1)
', 'The determinant of a Matrix is defined as a special number that is defined only for square matrices (matrices that have the same number of rows and columns). A determinant is used in many places in calculus and other matrices related to algebra, it actually represents the matrix in terms of a real number which can be used in solving a system of a linear equation and finding the inverse of a matrix.', 'Program to find Determinant of a Matrix', 10, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('9d98daa6-0e42-485d-be16-d4ef0b03c5c6', e'Given a square matrix, find the adjoint and

[inverse](https://www.geeksforgeeks.org/inverse-of-matrix/)
of the matrix. We strongly recommend you to refer

[determinant of matrix](https://www.geeksforgeeks.org/determinant-of-a-matrix/)
as a prerequisite for this.


****Adjoint****
(or Adjugate) of a matrix is the matrix obtained by taking the transpose of the cofactor matrix of a given square matrix is called its Adjoint or Adjugate matrix. The Adjoint of any square matrix ‘A’ (say) is represented as Adj(A).


****Example:****


```
5  -2  2  7
1   0  0  3
-3  1  5  0
3  -1 -9  4
For instance, the cofactor of the top left corner \'5\' is
 + |0   0   3|
...|1   5   0| = 3(1 * -9 - (-1) * 5) = -12.
...|-1 -9   4|
(The minor matrix is formed by deleting the row
 and column of the given entry.)
As another sample, the cofactor of the top row corner \'-2\' is
  -|1   0  3|
...|-3  5  0| = - [1 (20 - 0) - 0 + 3 (27 - 15)] = -56.
...|3  -9  4|
Proceeding like this, we obtain the matrix
[-12  -56   4   4]
[76   208   4   4]
[-60  -82  -2  20]
[-36  -58  -10 12]
Finally, to get the adjoint, just take the previous
matrix\'s transpose:
[-12   76 -60  -36]
[-56  208 -82  -58]
[4     4   -2  -10]
[4     4   20   12]
```

****Important properties:****


Product of a square matrix A with its adjoint yields a diagonal matrix, where each diagonal entry is equal to determinant of A.



i.e.


```
A.adj(A) = det(A).I
I  => Identity matrix of same order as of A.
det(A) => Determinant value of A
```


A non-zero square matrix ‘A’ of order n is said to be

****invertible****
if there exists a unique square matrix ‘B’ of order n such that,


```
A.B = B.A = I
The matrix \'B\' is said to be inverse of \'A\'.
i.e.,  B = A-1
    ```

* adj(AB) = (adj B).(adj A)
* adj( k A) = k

  n-1
  adj(A)
* A

  -1
  = (adj A) / |A|
* (A

  -1
  )

  -1
  = A
* (AB)

  -1
  = B

  -1
  A

  -1

****How to find Adjoint?****



We follow the definition given above.


```
Let A[N][N] be input matrix.
1) Create a matrix adj[N][N] store the adjoint matrix.
2) For every entry A[i][j] in input matrix where 0 <= i < N
                                             and 0 <= j < N.
    a) Find cofactor of A[i][j]
    b) Find sign of entry.  Sign is + if (i+j) is even else
    sign is odd.
    c) Place the cofactor at adj[j][i]
    ```

    ****How to find Inverse?****


    Inverse of a matrix exists only if the matrix is non-singular i.e., determinant should not be 0.



    Using determinant and adjoint, we can easily find the inverse of a square matrix using the below formula,


    ```
    If det(A) != 0
    A-1 = adj(A)/det(A)
    Else
    "Inverse doesn\'t exist"
    ```


    Inverse is used to find the solution to a system of linear equations.


    Below are implementations for finding adjoint and inverse of a matrix.


    C++

    ````
    #include <iostream>
    #include <vector>
    using namespace std;

    // Function to get cofactor of mat[p][q] in cof[][]. n is
    // current dimension of mat[][]
    void getCof(vector<vector<int>>& mat, vector<vector<int>>& cof,
                                            int p, int q, int n) {
        int i = 0, j = 0;
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                if (row != p && col != q) {
                    cof[i][j++] = mat[row][col];
                    if (j == n - 1) {
                        j = 0;
                        i++;
                    }
                }
            }
        }
    }

    // Recursive function for finding determinant
    // of matrix mat of dimension n
    int getDet(vector<vector<int>>& mat, int n) {
        if (n == 1) return mat[0][0];

        int det = 0;

        // To store cofactors
        vector<vector<int>> cof(mat.size(), vector<int>(mat.size()));

        int sign = 1;
        for (int f = 0; f < n; f++) {
            getCof(mat, cof, 0, f, n);
            det += sign * mat[0][f] * getDet(cof, n - 1);
            sign = -sign;
        }
        return det;
    }

    // Function to get adjoint of mat in adj
    void adjoint(vector<vector<int>>& mat, vector<vector<int>>& adj) {
        int n = mat.size();
        if (n == 1) {
            adj[0][0] = 1;
            return;
        }

        int sign = 1;
        vector<vector<int>> cof(n, vector<int>(n));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                getCof(mat, cof, i, j, n);
                sign = ((i + j) % 2 == 0) ? 1 : -1;
                adj[j][i] = sign * getDet(cof, n - 1);
            }
        }
    }

    // Function to calculate and store inverse, returns
    // false if matrix is singular
    bool inverse(vector<vector<int>>& mat, vector<vector<float>>& inv) {
        int n = mat.size();
        int det = getDet(mat, n);
        if (det == 0) {
            cout << "Singular matrix, can\'t find its inverse";
            return false;
        }

        vector<vector<int>> adj(n, vector<int>(n));
        adjoint(mat, adj);

        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                inv[i][j] = adj[i][j] / float(det);

        return true;
    }

    int main() {
        vector<vector<int>> mat = { { 5, -2, 2, 7 },
                                    { 1, 0, 0, 3 },
                                    { -3, 1, 5, 0 },
                                    { 3, -1, -9, 4 } };

        int n = mat.size();
        vector<vector<int>> adj(n, vector<int>(n)); // To store adjoint
        vector<vector<float>> inv(n, vector<float>(n)); // To store inverse

        // Print the input matrix
        cout << "Input matrix is:\\n";
        for (auto& row : mat) {
            for (int val : row) cout << val << " ";
            cout << endl;
        }

        // Print the adjoint matrix
        cout << "\\nThe Adjoint is:\\n";
        adjoint(mat, adj);
        for (auto& row : adj) {
            for (int val : row) cout << val << " ";
            cout << endl;
        }

        // Print the inverse matrix if it exists
        cout << "\\nThe Inverse is:\\n";
        if (inverse(mat, inv)) {
            for (auto& row : inv) {
                for (float val : row) cout << val << " ";
                cout << endl;
            }
        }

        return 0;
    }

    ````

    C

    ````
    #include <stdio.h>

    #define N 4

    // Function to get cofactor of mat[p][q] in cof[][]. n is
    // current dimension of mat[][]
    void getCof(int mat[N][N], int cof[N][N], int p, int q, int n) {
        int i = 0, j = 0;
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                if (row != p && col != q) {
                    cof[i][j++] = mat[row][col];
                    if (j == n - 1) {
                        j = 0;
                        i++;
                    }
                }
            }
        }
    }

    // Recursive function for finding determinant of matrix mat of dimension n
    int getDet(int mat[N][N], int n) {
        if (n == 1) return mat[0][0];
        int det = 0;

        int cof[N][N];
        int sign = 1;
        for (int f = 0; f < n; f++) {
            getCof(mat, cof, 0, f, n);
            det += sign * mat[0][f] * getDet(cof, n - 1);
            sign = -sign;
        }
        return det;
    }

    // Function to get adjoint of mat in adj
    void adjoint(int mat[N][N], double adj[N][N]) {
        if (N == 1) {
            adj[0][0] = 1;
            return;
        }

        int sign = 1;
        int cof[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                getCof(mat, cof, i, j, N);
                sign = ((i + j) % 2 == 0) ? 1 : -1;
                adj[j][i] = sign * getDet(cof, N - 1);
            }
        }
    }

    // Function to calculate and store inverse, returns 0 if matrix is singular
    int inverse(int mat[N][N], double inv[N][N]) {
        int det = getDet(mat, N);
        if (det == 0) {
            printf("Singular matrix, can\'t find its inverse\\n");
            return 0;
        }

        double adj[N][N];
        adjoint(mat, adj);

        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                inv[i][j] = adj[i][j] / det;

        return 1;
    }

    int main() {
        int mat[N][N] = { { 5, -2, 2, 7 },
                          { 1, 0, 0, 3 },
                          { -3, 1, 5, 0 },
                          { 3, -1, -9, 4 } };

        double adj[N][N];
        double inv[N][N];

        // Print the input matrix
        printf("Input matrix is:\\n");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                printf("%d ", mat[i][j]);
            }
            printf("\\n");
        }

        // Print the adjoint matrix
        printf("\\nThe Adjoint is:\\n");
        adjoint(mat, adj);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                printf("%lf ", adj[i][j]);
            }
            printf("\\n");
        }

        // Print the inverse matrix if it exists
        printf("\\nThe Inverse is:\\n");
        if (inverse(mat, inv)) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    printf("%lf ", inv[i][j]);
                }
                printf("\\n");
            }
        }
        return 0;
    }

    ````

    Java

    ````
    // Importing required classes
    import java.util.Arrays;
    import java.util.Scanner;

    public class GfG {

        // Function to get cofactor of mat[p][q] in cof[][]
        static void getCof(int[][] mat, int[][] cof, int p, int q, int n) {
            int i = 0, j = 0;
            for (int row = 0; row < n; row++) {
                for (int col = 0; col < n; col++) {
                    if (row != p && col != q) {
                        cof[i][j++] = mat[row][col];
                        if (j == n - 1) {
                            j = 0;
                            i++;
                        }
                    }
                }
            }
        }

        // Recursive function for finding determinant of
        // matrix mat of dimension n
        static int getDet(int[][] mat, int n) {
            if (n == 1) return mat[0][0];
            int det = 0;
            int[][] cof = new int[n][n];
            int sign = 1;
            for (int f = 0; f < n; f++) {
                getCof(mat, cof, 0, f, n);
                det += sign * mat[0][f] * getDet(cof, n - 1);
                sign = -sign;
            }
            return det;
        }

        // Function to get adjoint of mat in adj
        static void adjoint(int[][] mat, int[][] adj) {
            int n = mat.length;
            if (n == 1) {
                adj[0][0] = 1;
                return;
            }
            int sign;
            int[][] cof = new int[n][n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    getCof(mat, cof, i, j, n);
                    sign = ((i + j) % 2 == 0) ? 1 : -1;
                    adj[j][i] = sign * getDet(cof, n - 1);
                }
            }
        }

        // Function to calculate and store inverse, returns
        // false if matrix is singular
        static boolean inverse(int[][] mat, float[][] inv) {
            int n = mat.length;
            int det = getDet(mat, n);
            if (det == 0) {
                System.out.println("Singular matrix, can\'t find its inverse");
                return false;
            }
            int[][] adj = new int[n][n];
            adjoint(mat, adj);
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    inv[i][j] = (float) adj[i][j] / det;
            return true;
        }

        public static void main(String[] args) {
            int[][] mat = { { 5, -2, 2, 7 }, { 1, 0, 0, 3 },
                            { -3, 1, 5, 0 }, { 3, -1, -9, 4 } };
            int n = mat.length;
            int[][] adj = new int[n][n]; // To store adjoint
            float[][] inv = new float[n][n]; // To store inverse

            // Print the input matrix
            System.out.println("Input matrix is:");
            for (int[] row : mat) {
                System.out.println(Arrays.toString(row));
            }

            // Print the adjoint matrix
            System.out.println("\\nThe Adjoint is:");
            adjoint(mat, adj);
            for (int[] row : adj) {
                System.out.println(Arrays.toString(row));
            }

            // Print the inverse matrix if it exists
            System.out.println("\\nThe Inverse is:");
            if (inverse(mat, inv)) {
                for (float[] row : inv) {
                    System.out.println(Arrays.toString(row));
                }
            }
        }
    }

    ````

    Python

    ````
    # Function to get cofactor of mat[p][q] in cof[][]
    def get_cof(mat, cof, p, q, n):
        i = 0
        j = 0
        for row in range(n):
            for col in range(n):
                if row != p and col != q:
                    cof[i][j] = mat[row][col]
                    j += 1
                    if j == n - 1:
                        j = 0
                        i += 1

    # Recursive function for finding determinant
    # of matrix mat of dimension n
    def get_det(mat, n):
        if n == 1:
            return mat[0][0]
        det = 0
        cof = [[0] * n for _ in range(n)]  # To store cofactors
        sign = 1
        for f in range(n):
            get_cof(mat, cof, 0, f, n)
            det += sign * mat[0][f] * get_det(cof, n - 1)
            sign = -sign
        return det

    # Function to get adjoint of mat in adj
    def adjoint(mat, adj):
        n = len(mat)
        if n == 1:
            adj[0][0] = 1
            return
        sign = 1
        cof = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                get_cof(mat, cof, i, j, n)
                sign = 1 if (i + j) % 2 == 0 else -1
                adj[j][i] = sign * get_det(cof, n - 1)

    # Function to calculate and store inverse, returns
    # false if matrix is singular
    def inverse(mat):
        n = len(mat)
        det = get_det(mat, n)
        if det == 0:
            print("Singular matrix, can\'t find its inverse")
            return None
        adj = [[0] * n for _ in range(n)]
        adjoint(mat, adj)
        inv = [[adj[i][j] / det for j in range(n)] for i in range(n)]
        return inv

    if __name__ == \'__main__\':
        mat = [[5, -2, 2, 7], [1, 0, 0, 3], [-3, 1, 5, 0], [3, -1, -9, 4]]
        n = len(mat)
        adj = [[0] * n for _ in range(n)]  # To store adjoint

        # Print the input matrix
        print("Input matrix is:")
        for row in mat:
            print(row)

        # Print the adjoint matrix
        print("\\nThe Adjoint is:")
        adjoint(mat, adj)
        for row in adj:
            print(row)

        # Print the inverse matrix if it exists
        print("\\nThe Inverse is:")
        inv = inverse(mat)
        if inv:
            for row in inv:
                print(row)

    ````

    C#

    ````
    using System;

    class MatrixOperations {

        // Function to get cofactor of mat[p][q] in cof[][]. n is
        // current dimension of mat[][]
        static void GetCof(int[,] mat, int[,] cof, int p, int q, int n) {
            int i = 0, j = 0;
            for (int row = 0; row < n; row++) {
                for (int col = 0; col < n; col++) {
                    if (row != p && col != q) {
                        cof[i, j++] = mat[row, col];
                        if (j == n - 1) {
                            j = 0;
                            i++;
                        }
                    }
                }
            }
        }

        // Recursive function for finding determinant of matrix mat of dimension n
        static int GetDet(int[,] mat, int n) {
            if (n == 1) return mat[0, 0];
            int det = 0;

            // To store cofactors
            int[,] cof = new int[n, n];

            int sign = 1;
            for (int f = 0; f < n; f++) {
                GetCof(mat, cof, 0, f, n);
                det += sign * mat[0, f] * GetDet(cof, n - 1);
                sign = -sign;
            }
            return det;
        }

        // Function to get adjoint of mat in adj
        static void Adjoint(int[,] mat, double[,] adj) {
            int n = mat.GetLength(0);
            if (n == 1) {
                adj[0, 0] = 1;
                return;
            }

            int sign = 1;
            int[,] cof = new int[n, n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    GetCof(mat, cof, i, j, n);
                    sign = ((i + j) % 2 == 0) ? 1 : -1;
                    adj[j, i] = sign * GetDet(cof, n - 1);
                }
            }
        }

        // Function to calculate and store inverse, returns false if matrix is singular
        static bool Inverse(int[,] mat, double[,] inv) {
            int n = mat.GetLength(0);
            int det = GetDet(mat, n);
            if (det == 0) {
                Console.WriteLine("Singular matrix, can\'t find its inverse");
                return false;
            }

            double[,] adj = new double[n, n];
            Adjoint(mat, adj);

            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    inv[i, j] = adj[i, j] / det;

            return true;
        }

        static void Main() {
            int[,] mat = new int[,] { { 5, -2, 2, 7 },
                                       { 1, 0, 0, 3 },
                                       { -3, 1, 5, 0 },
                                       { 3, -1, -9, 4 } };
            int n = mat.GetLength(0);
            double[,] adj = new double[n, n]; // To store adjoint
            double[,] inv = new double[n, n]; // To store inverse

            // Print the input matrix
            Console.WriteLine("Input matrix is:");
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    Console.Write(mat[i, j] + " ");
                }
                Console.WriteLine();
            }

            // Print the adjoint matrix
            Console.WriteLine("\\nThe Adjoint is:");
            Adjoint(mat, adj);
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    Console.Write(adj[i, j] + " ");
                }
                Console.WriteLine();
            }

            // Print the inverse matrix if it exists
            Console.WriteLine("\\nThe Inverse is:");
            if (Inverse(mat, inv)) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        Console.Write(inv[i, j] + " ");
                    }
                    Console.WriteLine();
                }
            }
        }
    }

    ````

    JavaScript

    ````
    // Function to get cofactor of mat[p][q] in cof[][]. n is
    // current dimension of mat[][]
    function getCof(mat, cof, p, q, n) {
        let i = 0, j = 0;
        for (let row = 0; row < n; row++) {
            for (let col = 0; col < n; col++) {
                if (row !== p && col !== q) {
                    cof[i][j++] = mat[row][col];
                    if (j === n - 1) {
                        j = 0;
                        i++;
                    }
                }
            }
        }
    }

    // Recursive function for finding determinant
    // of matrix mat of dimension n
    function getDet(mat, n) {
        if (n === 1) return mat[0][0];
        let det = 0;

        // To store cofactors
        let cof = Array.from({ length: mat.length }, () => Array(mat.length).fill(0));

        let sign = 1;
        for (let f = 0; f < n; f++) {
            getCof(mat, cof, 0, f, n);
            det += sign * mat[0][f] * getDet(cof, n - 1);
            sign = -sign;
        }
        return det;
    }

    // Function to get adjoint of mat in adj
    function adjoint(mat, adj) {
        let n = mat.length;
        if (n === 1) {
            adj[0][0] = 1;
            return;
        }

        let sign = 1;
        let cof = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                getCof(mat, cof, i, j, n);
                sign = ((i + j) % 2 === 0) ? 1 : -1;
                adj[j][i] = sign * getDet(cof, n - 1);
            }
        }
    }

    // Function to calculate and store inverse, returns
    // false if matrix is singular
    function inverse(mat, inv) {
        let n = mat.length;
        let det = getDet(mat, n);
        if (det === 0) {
            console.log("Singular matrix, can\'t find its inverse");
            return false;
        }

        let adj = Array.from({ length: n }, () => Array(n).fill(0));
        adjoint(mat, adj);

        for (let i = 0; i < n; i++)
            for (let j = 0; j < n; j++)
                inv[i][j] = adj[i][j] / det;

        return true;
    }

    let mat = [ [ 5, -2, 2, 7 ],
                [ 1, 0, 0, 3 ],
                [ -3, 1, 5, 0 ],
                [ 3, -1, -9, 4 ] ];

    let n = mat.length;
    let adj = Array.from({ length: n }, () => Array(n).fill(0)); // To store adjoint
    let inv = Array.from({ length: n }, () => Array(n).fill(0)); // To store inverse

    // Print the input matrix
    console.log("Input matrix is:");
    mat.forEach(row => {
        console.log(row.join(\' \'));
    });

    // Print the adjoint matrix
    console.log("\\nThe Adjoint is:");
    adjoint(mat, adj);
    adj.forEach(row => {
        console.log(row.join(\' \'));
    });

    // Print the inverse matrix if it exists
    console.log("\\nThe Inverse is:");
    if (inverse(mat, inv)) {
        inv.forEach(row => {
            console.log(row.join(\' \'));
        });
    }

    ````




    **Output**
    ```
    Input matrix is:
    5 -2 2 7
    1 0 0 3
    -3 1 5 0
    3 -1 -9 4

    The Adjoint is:
    -12 76 -60 -36
    -56 208 -82 -58
    4 4 -2 -10
    4 4 20 12

    The Inverse is:
    -0.136364 0.863636 -0.681818 -0.409091
    -0.636364 2.36364 -0.931818 -0.659091
    0.0454545 0.0454545 -0.0227273 -0.113636
    0.0454545 0.0454545 0.227273 0.136364

    ```
    ', '', 'Adjoint and Inverse of a Matrix', 11, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('610cd734-a640-4ad0-9ed2-9360a01d068a', e'****Examples:****

    ```
    Input: board[] =  {\'X\', \'X\', \'O\',
    \'O\', \'O\', \'X\',
    \'X\', \'O\', \'X\'};
Output: Valid
Input: board[] =  {\'O\', \'X\', \'X\',
\'O\', \'X\', \'X\',
\'O\', \'O\', \'X\'};
Output: Invalid
(Both X and O cannot win)
Input: board[] =  {\'O\', \'X\', \' \',
\' \', \' \', \' \',
\' \', \' \', \' \'};
Output: Valid
(Valid board with only two moves played)

```
Recommended Practice

[Tic Tac Toe](https://www.geeksforgeeks.org/problems/tic-tac-toe2412/1/)


[Try It!](https://www.geeksforgeeks.org/problems/tic-tac-toe2412/1/)


Basically, to find the validity of an input grid, we can think of the conditions when an input grid is invalid. Let no. of “X”s be countX and no. of “O”s be countO. Since we know that the game starts with X, a given grid of Tic-Tac-Toe game would be definitely invalid if following two conditions meet


1. countX != countO AND
2. countX != countO + 1
   * Since “X” is always the first move, second condition is also required.
   * Now does it mean that all the remaining board positions are valid one? The answer is NO. Think of the cases when input grid is such that both X and O are making straight lines. This is also not
   * valid position because the game ends when one player wins. So we need to check the following condition as well
3. If input grid shows that both the players are in winning situation, it’s an invalid position.
4. If input grid shows that the player with O has put a straight-line (i.e. is in win condition) and countX != countO, it’s an invalid position. The reason is that O plays his move only after X plays his
   * move. Since X has started the game, O would win when both X and O has played equal no. of moves.
5. If input grid shows that X is in winning condition than xCount must be one greater that oCount.
   * Armed with above conditions i.e. a), b), c) and d), we can now easily formulate an algorithm/program to check the validity of a given Tic-Tac-Toe board position.

```
1)  countX == countO or countX == countO + 1
2)  If O is in win condition then check
     a)     If X also wins, not valid
     b)     If xbox != obox , not valid
3)  If X is in win condition then check if xCount is
     one more than oCount or not

```


Another way to find the validity of a given board is using ‘inverse method’ i.e. rule out all the possibilities when a given board is invalid.


C++
---

















```
// C++ program to check whether a given tic tac toe
// board is valid or not
#include <iostream>
using namespace std;

// This matrix is used to find indexes to check all
// possible winning triplets in board[0..8]
int win[8][3] = {{0, 1, 2}, // Check first row.
{3, 4, 5}, // Check second Row
{6, 7, 8}, // Check third Row
{0, 3, 6}, // Check first column
{1, 4, 7}, // Check second Column
{2, 5, 8}, // Check third Column
{0, 4, 8}, // Check first Diagonal
{2, 4, 6}}; // Check second Diagonal

// Returns true if character \'c\' wins. c can be either
// \'X\' or \'O\'
bool isCWin( char *board, char c)
{
// Check all possible winning combinations
for ( int i=0; i<8; i++)
if (board[win[i][0]] == c &&
board[win[i][1]] == c &&
board[win[i][2]] == c )
return true ;
return false ;
}

// Returns true if given board is valid, else returns false
bool isValid( char board[9])
{
// Count number of \'X\' and \'O\' in the given board
int xCount=0, oCount=0;
for ( int i=0; i<9; i++)
{
if (board[i]== \'X\' ) xCount++;
if (board[i]== \'O\' ) oCount++;
}

// Board can be valid only if either xCount and oCount
// is same or count is one more than oCount
if (xCount==oCount || xCount==oCount+1)
{
// Check if \'O\' is winner
if (isCWin(board, \'O\' ))
{
// Check if \'X\' is also winner, then
// return false
if (isCWin(board, \'X\' ))
return false ;

// Else return true xCount and yCount are same
return (xCount == oCount);
}

// If \'X\' wins, then count of X must be greater
if (isCWin(board, \'X\' ) && xCount != oCount + 1)
return false ;

// If \'O\' is not winner, then return true
return true ;
}
return false ;
}

// Driver program
int main()
{
char board[] = { \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' };
(isValid(board))? cout << "Given board is valid" :
cout << "Given board is not valid" ;
return 0;
}
```





Java
----

















```
// Java program to check whether a given tic tac toe
// board is valid or not
import java.io.*;
class GFG {

// This matrix is used to find indexes to check all
// possible winning triplets in board[0..8]
static int win[][] = {{ 0 , 1 , 2 }, // Check first row.
{ 3 , 4 , 5 }, // Check second Row
{ 6 , 7 , 8 }, // Check third Row
{ 0 , 3 , 6 }, // Check first column
{ 1 , 4 , 7 }, // Check second Column
{ 2 , 5 , 8 }, // Check third Column
{ 0 , 4 , 8 }, // Check first Diagonal
{ 2 , 4 , 6 }}; // Check second Diagonal

// Returns true if character \'c\' wins. c can be either
// \'X\' or \'O\'
static boolean isCWin( char [] board, char c) {
// Check all possible winning combinations
for ( int i = 0 ; i < 8 ; i++) {
if (board[win[i][ 0 ]] == c
&& board[win[i][ 1 ]] == c
&& board[win[i][ 2 ]] == c) {
return true ;
}
}
return false ;
}

// Returns true if given board is valid, else returns false
static boolean isValid( char board[]) {
// Count number of \'X\' and \'O\' in the given board
int xCount = 0 , oCount = 0 ;
for ( int i = 0 ; i < 9 ; i++) {
if (board[i] == \'X\' ) {
xCount++;
}
if (board[i] == \'O\' ) {
oCount++;
}
}

// Board can be valid only if either xCount and oCount
// is same or count is one more than oCount
if (xCount == oCount || xCount == oCount + 1 ) {
// Check if \'O\' is winner
if (isCWin(board, \'O\' )) {
// Check if \'X\' is also winner, then
// return false
if (isCWin(board, \'X\' )) {
return false ;
}

// Else return true xCount and yCount are same
return (xCount == oCount);
}

// If \'X\' wins, then count of X must be greater
if (isCWin(board, \'X\' ) && xCount != oCount + 1 ) {
return false ;
}

// If \'O\' is not winner, then return true
return true ;
}
return false ;
}

// Driver program
public static void main(String[] args) {
char board[] = { \'X\' , \'X\' , \'O\' , \'O\' , \'O\' , \'X\' , \'X\' , \'O\' , \'X\' };

if ((isValid(board))) {
System.out.println( "Given board is valid" );
} else {
System.out.println( "Given board is not valid" );
}
}
}
//this code contributed by PrinciRaj1992
```





Python3
-------

















```
# Python3 program to check whether a given tic tac toe
# board is valid or not

# Returns true if char wins. Char can be either
# \'X\' or \'O\'
def win_check(arr, char):
# Check all possible winning combinations
matches = [[ 0 , 1 , 2 ], [ 3 , 4 , 5 ],
[ 6 , 7 , 8 ], [ 0 , 3 , 6 ],
[ 1 , 4 , 7 ], [ 2 , 5 , 8 ],
[ 0 , 4 , 8 ], [ 2 , 4 , 6 ]]

for i in range ( 8 ):
if (arr[(matches[i][ 0 ])] = = char and
arr[(matches[i][ 1 ])] = = char and
arr[(matches[i][ 2 ])] = = char):
return True
return False

def is_valid(arr):
# Count number of \'X\' and \'O\' in the given board
xcount = arr.count( \'X\' )
ocount = arr.count( \'O\' )

# Board can be valid only if either xcount and ocount
# is same or count is one more than oCount
if (xcount = = ocount + 1 or xcount = = ocount):
# Check if O wins
if win_check(arr, \'O\' ):
# Check if X wins, At a given point only one can win,
# if X also wins then return Invalid
if win_check(arr, \'X\' ):
return "Invalid"

# O can only win if xcount == ocount in case where whole
# board has values in each position.
if xcount = = ocount:
return "Valid"

# If X wins then it should be xc == oc + 1,
# If not return Invalid
if win_check(arr, \'X\' ) and xcount ! = ocount + 1 :
return "Invalid"

# if O is not the winner return Valid
if not win_check(arr, \'O\' ):
return "valid"

# If nothing above matches return invalid
return "Invalid"


# Driver Code
arr = [ \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' ]
print ( "Given board is " + is_valid(arr))
```





C#
--

















```
// C# program to check whether a given
// tic tac toe board is valid or not
using System;

class GFG
{

// This matrix is used to find indexes
// to check all possible winning triplets
// in board[0..8]
public static int [][] win = new int [][]
{
new int [] {0, 1, 2},
new int [] {3, 4, 5},
new int [] {6, 7, 8},
new int [] {0, 3, 6},
new int [] {1, 4, 7},
new int [] {2, 5, 8},
new int [] {0, 4, 8},
new int [] {2, 4, 6}
};

// Returns true if character \'c\'
// wins. c can be either \'X\' or \'O\'
public static bool isCWin( char [] board,
char c)
{
// Check all possible winning
// combinations
for ( int i = 0; i < 8; i++)
{
if (board[win[i][0]] == c &&
board[win[i][1]] == c &&
board[win[i][2]] == c)
{
return true ;
}
}
return false ;
}

// Returns true if given board
// is valid, else returns false
public static bool isValid( char [] board)
{
// Count number of \'X\' and
// \'O\' in the given board
int xCount = 0, oCount = 0;
for ( int i = 0; i < 9; i++)
{
if (board[i] == \'X\' )
{
xCount++;
}
if (board[i] == \'O\' )
{
oCount++;
}
}

// Board can be valid only if either
// xCount and oCount is same or count
// is one more than oCount
if (xCount == oCount ||
xCount == oCount + 1)
{
// Check if \'O\' is winner
if (isCWin(board, \'O\' ))
{
// Check if \'X\' is also winner,
// then return false
if (isCWin(board, \'X\' ))
{
return false ;
}

// Else return true xCount
// and yCount are same
return (xCount == oCount);
}

// If \'X\' wins, then count of
// X must be greater
if (isCWin(board, \'X\' ) &&
xCount != oCount + 1)
{
return false ;
}

// If \'O\' is not winner,
// then return true
return true ;
}
return false ;
}

// Driver Code
public static void Main( string [] args)
{
char [] board = new char [] { \'X\' , \'X\' , \'O\' , \'O\' , \'O\' ,
\'X\' , \'X\' , \'O\' , \'X\' };

if ((isValid(board)))
{
Console.WriteLine( "Given board is valid" );
}
else
{
Console.WriteLine( "Given board is not valid" );
}
}
}

// This code is contributed by Shrikant13
```





Javascript
----------

















```
<script>
// Javascript program to check whether a given
// tic tac toe board is valid or not

// This matrix is used to find indexes
// to check all possible winning triplets
// in board[0..8]

// Returns true if character \'c\' wins.
// c can be either \'X\' or \'O\'
function isCWin(board, c)
{
let win = new Array( new Array(0, 1, 2), // Check first row.
new Array(3, 4, 5), // Check second Row
new Array(6, 7, 8), // Check third Row
new Array(0, 3, 6), // Check first column
new Array(1, 4, 7), // Check second Column
new Array(2, 5, 8), // Check third Column
new Array(0, 4, 8), // Check first Diagonal
new Array(2, 4, 6)); // Check second Diagonal

// Check all possible winning combinations
for (let i = 0; i < 8; i++)
if (board[win[i][0]] == c &&
board[win[i][1]] == c &&
board[win[i][2]] == c )
return true ;
return false ;
}

// Returns true if given board is
// valid, else returns false
function isValid(board)
{
// Count number of \'X\' and \'O\'
// in the given board
let xCount = 0;
let oCount = 0;
for (let i = 0; i < 9; i++)
{
if (board[i] == \'X\' ) xCount++;
if (board[i] == \'O\' ) oCount++;
}

// Board can be valid only if either
// xCount and oCount is same or count
// is one more than oCount
if (xCount == oCount || xCount == oCount + 1)
{
// Check if \'O\' is winner
if (isCWin(board, \'O\' ))
{
// Check if \'X\' is also winner,
// then return false
if (isCWin(board, \'X\' ))
return false ;

// Else return true xCount and
// yCount are same
return (xCount == oCount);
}

// If \'X\' wins, then count of X
// must be greater
if (isCWin(board, \'X\' ) &&
xCount != oCount + 1)
return false ;

// If \'O\' is not winner, then
// return true
return true ;
}
return false ;
}

// Driver Code
let board = new Array( \'X\' , \'X\' , \'O\' , \'O\' ,
\'O\' , \'X\' , \'X\' , \'O\' , \'X\' );
if (isValid(board))
document.write( "Given board is valid" );
else
document.write( "Given board is not valid" );

// This code is contributed
// by Saurabh Jaiswal
</script>
```





PHP
---

















```
<?php
// PHP program to check whether a given
// tic tac toe board is valid or not

// This matrix is used to find indexes
// to check all possible winning triplets
// in board[0..8]

// Returns true if character \'c\' wins.
// c can be either \'X\' or \'O\'
function isCWin( $board , $c )
{
$win = array ( array (0, 1, 2), // Check first row.
array (3, 4, 5), // Check second Row
array (6, 7, 8), // Check third Row
array (0, 3, 6), // Check first column
array (1, 4, 7), // Check second Column
array (2, 5, 8), // Check third Column
array (0, 4, 8), // Check first Diagonal
array (2, 4, 6)); // Check second Diagonal

// Check all possible winning combinations
for ( $i = 0; $i < 8; $i ++)
if ( $board [ $win [ $i ][0]] == $c &&
$board [ $win [ $i ][1]] == $c &&
$board [ $win [ $i ][2]] == $c )
return true;
return false;
}

// Returns true if given board is
// valid, else returns false
function isValid(& $board )
{
// Count number of \'X\' and \'O\'
// in the given board
$xCount = 0;
$oCount = 0;
for ( $i = 0; $i < 9; $i ++)
{
if ( $board [ $i ] == \'X\' ) $xCount ++;
if ( $board [ $i ] == \'O\' ) $oCount ++;
}

// Board can be valid only if either
// xCount and oCount is same or count
// is one more than oCount
if ( $xCount == $oCount || $xCount == $oCount + 1)
{
// Check if \'O\' is winner
if (isCWin( $board , \'O\' ))
{
// Check if \'X\' is also winner,
// then return false
if (isCWin( $board , \'X\' ))
return false;

// Else return true xCount and
// yCount are same
return ( $xCount == $oCount );
}

// If \'X\' wins, then count of X
// must be greater
if (isCWin( $board , \'X\' ) &&
$xCount != $oCount + 1)
return false;

// If \'O\' is not winner, then
// return true
return true;
}
return false;
}

// Driver Code
$board = array ( \'X\' , \'X\' , \'O\' , \'O\' ,
\'O\' , \'X\' , \'X\' , \'O\' , \'X\' );
if (isValid( $board ))
echo ( "Given board is valid" );
else
echo ( "Given board is not valid" );

// This code is contributed
// by Shivi_Aggarwal
?>
```







**Output**

```
Given board is valid







```

****Time complexity:****
O(1)



****Auxiliary Space:****
O(1), since no extra space has been taken.


****Approach 2:****


The algorithm to check if a Tic-Tac-Toe board is valid or not is as follows:


* Initialize a 2D array win of size 8×3, which contains all possible winning combinations in Tic-Tac-Toe. Each row of the win array represents a winning combination, and each element in a row represents a cell index on the board.
* Define a function isCWin(board, c) which takes a board configuration board and a character c (‘X’ or ‘O’) as inputs, and returns true if character c has won on the board.
* Inside the isCWin function, iterate over each row of the win array. Check if the board has the same character c at all three cell indices of the current row. If yes, return true, as the character c has won.
* Define a function isValid(board) which takes a board configuration board as input, and returns true if the board is valid, else returns false.
* Inside the isValid function, count the number of ‘X’ and ‘O’ characters on the board, and store them in xCount and oCount variables, respectively.
* The board can be valid only if either xCount and oCount are the same, or xCount is one more than oCount.
* If ‘O’ is a winner on the board, check if ‘X’ is also a winner. If yes, return false as both ‘X’ and ‘O’ cannot win at the same time. If not, return true if xCount and oCount are the same, else return false.
* If ‘X’ is a winner on the board, then xCount must be one more than oCount. If not, return false.
* If ‘O’ is not a winner, return true as the board is valid.


Here is the code of the above approach:


C++
---

















```
// Returns true if character \'c\' wins. c can be either
// \'X\' or \'O\'
#include<bits/stdc++.h>
using namespace std;
bool isWinner( char *board, char c)
{
// Check all possible winning combinations
if ((board[0] == c && board[1] == c && board[2] == c) ||
(board[3] == c && board[4] == c && board[5] == c) ||
(board[6] == c && board[7] == c && board[8] == c) ||
(board[0] == c && board[3] == c && board[6] == c) ||
(board[1] == c && board[4] == c && board[7] == c) ||
(board[2] == c && board[5] == c && board[8] == c) ||
(board[0] == c && board[4] == c && board[8] == c) ||
(board[2] == c && board[4] == c && board[6] == c))
return true ;

return false ;
}

// Returns true if given board is valid, else returns false
bool isValid( char board[9])
{
// Count number of \'X\' and \'O\' in the given board
int xCount=0, oCount=0;
for ( int i=0; i<9; i++)
{
if (board[i]== \'X\' ) xCount++;
if (board[i]== \'O\' ) oCount++;
}

// Board can be valid only if either xCount and oCount
// is same or count is one more than oCount
if (xCount==oCount || xCount==oCount+1)
{
// Check if there is only one winner
if (isWinner(board, \'X\' ) && isWinner(board, \'O\' ))
return false ;

// If \'X\' wins, then count of X must be greater
if (isWinner(board, \'X\' ) && xCount != oCount + 1)
return false ;

// If \'O\' wins, then count of X must be same as oCount
if (isWinner(board, \'O\' ) && xCount != oCount)
return false ;

return true ;
}
return false ;
}

// Driver program
int main()
{
char board[] = { \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' };
(isValid(board))? cout << "Given board is valid" :
cout << "Given board is not valid" ;
return 0;
}
```





Java
----

















```
import java.util.Arrays;

public class TicTacToe {

// Returns true if character \'c\' wins. c can be either \'X\' or \'O\'
public static boolean isWinner( char [] board, char c) {
// Check all possible winning combinations
if ((board[ 0 ] == c && board[ 1 ] == c && board[ 2 ] == c) ||
(board[ 3 ] == c && board[ 4 ] == c && board[ 5 ] == c) ||
(board[ 6 ] == c && board[ 7 ] == c && board[ 8 ] == c) ||
(board[ 0 ] == c && board[ 3 ] == c && board[ 6 ] == c) ||
(board[ 1 ] == c && board[ 4 ] == c && board[ 7 ] == c) ||
(board[ 2 ] == c && board[ 5 ] == c && board[ 8 ] == c) ||
(board[ 0 ] == c && board[ 4 ] == c && board[ 8 ] == c) ||
(board[ 2 ] == c && board[ 4 ] == c && board[ 6 ] == c))
return true ;

return false ;
}

// Returns true if given board is valid, else returns false
public static boolean isValid( char [] board) {
// Count number of \'X\' and \'O\' in the given board
int xCount = 0 , oCount = 0 ;
for ( int i = 0 ; i < 9 ; i++) {
if (board[i] == \'X\' )
xCount++;
if (board[i] == \'O\' )
oCount++;
}

// Board can be valid only if either xCount and oCount is same or count is one more than oCount
if (xCount == oCount || xCount == oCount + 1 ) {
// Check if there is only one winner
if (isWinner(board, \'X\' ) && isWinner(board, \'O\' ))
return false ;

// If \'X\' wins, then count of X must be greater
if (isWinner(board, \'X\' ) && xCount != oCount + 1 )
return false ;

// If \'O\' wins, then count of X must be same as oCount
if (isWinner(board, \'O\' ) && xCount != oCount)
return false ;

return true ;
}
return false ;
}

// Driver program
public static void main(String[] args) {
char [] board = { \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' };

if (isValid(board))
System.out.println( "Given board is valid" );
else
System.out.println( "Given board is not valid" );
}
}
```





Python3
-------

















```
# Python Program for the above approach
def isWinner(board, c):
# Check all possible winning combinations
if (board[ 0 ] = = c and board[ 1 ] = = c and board[ 2 ] = = c) or \\
(board[ 3 ] = = c and board[ 4 ] = = c and board[ 5 ] = = c) or \\
(board[ 6 ] = = c and board[ 7 ] = = c and board[ 8 ] = = c) or \\
(board[ 0 ] = = c and board[ 3 ] = = c and board[ 6 ] = = c) or \\
(board[ 1 ] = = c and board[ 4 ] = = c and board[ 7 ] = = c) or \\
(board[ 2 ] = = c and board[ 5 ] = = c and board[ 8 ] = = c) or \\
(board[ 0 ] = = c and board[ 4 ] = = c and board[ 8 ] = = c) or \\
(board[ 2 ] = = c and board[ 4 ] = = c and board[ 6 ] = = c):
return True

return False


def isValid(board):
# Count number of \'X\' and \'O\' in the given board
xCount = 0
oCount = 0
for i in range ( 9 ):
if board[i] = = \'X\' :
xCount + = 1
if board[i] = = \'O\' :
oCount + = 1

# Board can be valid only if either xCount and oCount
# is same or count is one more than oCount
if xCount = = oCount or xCount = = oCount + 1 :
# Check if there is only one winner
if isWinner(board, \'X\' ) and isWinner(board, \'O\' ):
return False

# If \'X\' wins, then count of X must be greater
if isWinner(board, \'X\' ) and xCount ! = oCount + 1 :
return False

# If \'O\' wins, then count of X must be same as oCount
if isWinner(board, \'O\' ) and xCount ! = oCount:
return False

return True

return False


# Driver program
board = [ \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' ]

if isValid(board):
print ( "Given board is valid" )
else :
print ( "Given board is not valid" )
# THIS CODE IS CONTRIBUTED BY KIRTI AGARWAL
```





C#
--

















```
using System;

public class TicTacToe {

// Returns true if character \'c\' wins. c can be either \'X\' or \'O\'
public static bool IsWinner( char [] board, char c) {
// Check all possible winning combinations
if ((board[0] == c && board[1] == c && board[2] == c) ||
(board[3] == c && board[4] == c && board[5] == c) ||
(board[6] == c && board[7] == c && board[8] == c) ||
(board[0] == c && board[3] == c && board[6] == c) ||
(board[1] == c && board[4] == c && board[7] == c) ||
(board[2] == c && board[5] == c && board[8] == c) ||
(board[0] == c && board[4] == c && board[8] == c) ||
(board[2] == c && board[4] == c && board[6] == c))
return true ;

return false ;
}

// Returns true if given board is valid, else returns false
public static bool IsValid( char [] board) {
// Count number of \'X\' and \'O\' in the given board
int xCount = 0, oCount = 0;
for ( int i = 0; i < 9; i++) {
if (board[i] == \'X\' )
xCount++;
if (board[i] == \'O\' )
oCount++;
}

// Board can be valid only if either xCount and oCount is same or count is one more than oCount
if (xCount == oCount || xCount == oCount + 1) {
// Check if there is only one winner
if (IsWinner(board, \'X\' ) && IsWinner(board, \'O\' ))
return false ;

// If \'X\' wins, then count of X must be greater
if (IsWinner(board, \'X\' ) && xCount != oCount + 1)
return false ;

// If \'O\' wins, then count of X must be same as oCount
if (IsWinner(board, \'O\' ) && xCount != oCount)
return false ;

return true ;
}
return false ;
}

// Driver program
public static void Main( string [] args) {
char [] board = { \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' };

if (IsValid(board))
Console.WriteLine( "Given board is valid" );
else
Console.WriteLine( "Given board is not valid" );
}
}
```





Javascript
----------

















```
// Returns true if character \'c\' wins. c can be either \'X\' or \'O\'
function isWinner(board, c) {
// Check all possible winning combinations
if (
(board[0] === c && board[1] === c && board[2] === c) ||
(board[3] === c && board[4] === c && board[5] === c) ||
(board[6] === c && board[7] === c && board[8] === c) ||
(board[0] === c && board[3] === c && board[6] === c) ||
(board[1] === c && board[4] === c && board[7] === c) ||
(board[2] === c && board[5] === c && board[8] === c) ||
(board[0] === c && board[4] === c && board[8] === c) ||
(board[2] === c && board[4] === c && board[6] === c)
) {
return true ;
}

return false ;
}

// Returns true if given board is valid, else returns false
function isValid(board) {
// Count number of \'X\' and \'O\' in the given board
let xCount = 0;
let oCount = 0;
for (let i = 0; i < 9; i++) {
if (board[i] === \'X\' ) xCount++;
if (board[i] === \'O\' ) oCount++;
}

// Board can be valid only if either xCount and oCount
// is same or count is one more than oCount
if (xCount == oCount || xCount == oCount + 1) {
// Check if there is only one winner
if (isWinner(board, \'X\' ) && isWinner(board, \'O\' )) {
return false ;
}

// If \'X\' wins, then count of X must be greater
if (isWinner(board, \'X\' ) && xCount !== oCount + 1) {
return false ;
}

// If \'O\' wins, then count of X must be same as oCount
if (isWinner(board, \'O\' ) && xCount !== oCount) {
return false ;
}

return true ;
}

return false ;
}

// Driver program
const board = [ \'X\' , \'X\' , \'O\' , \'O\' , \'O\' , \'X\' , \'X\' , \'O\' , \'X\' ];
isValid(board) ? console.log( \'Given board is valid\' ) : console.log( \'Given board is not valid\' );
```







**Output**
```
Given board is valid







```

****Time complexity: O(N^2)****


****Auxiliary Space: O(N)****
', e'A Tic-Tac-Toe board is given after some moves are played. Find out if the given board is valid, i.e., is it possible to reach this board position after some moves or not.
', 'Validity of a given Tic-Tac-Toe board configuration', 12, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('0f01db32-ffc7-4834-9e6c-2ac158bdbac3', e'
****Enqueue**** and when an element is deleted from the queue, then the operation is known as ****Dequeue.**** It is important to know that we cannot insert an element if the size of the queue is full and cannot delete an element when the queue itself is empty. If we try to insert an element even after the queue is full, then such a condition is known as overflow whereas, if we try to delete an element even after the queue is empty then such a condition is known as underflow.

****Primary Queue Operations:****

* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue
  at the end i.e. at the rear end. (Where T is Generic i.e we can define
  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****
* ****int dequeue():****
  When this operation is performed, an element is removed from the front
  end and is returned. This operation take ****constant time i.e O(1).****

****Auxiliary Queue Operations:****

* ****int front():**** This operation will return the element at the front without removing
  it and it take O(1) time.
* ****int rear():**** This operation will return the element at the rear without removing
  it, Its Time Complexity is O(1).
* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This
  Operation also done in O(1).
* ****int size():**** This operation will return the size of the queue i.e. the total
  number of elements present in the queue and it’s time complexity is
  O(1).

****Types of Queues:****

* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version
  of a queue. Here, insertion of an element i.e. the Enqueue operation
  takes place at the rear end and removal of an element i.e. the Dequeue
  operation takes place at the front end.
* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In
  a circular queue, the element of the queue act as a circular ring. The
  working of a circular queue is similar to the linear queue except for
  the fact that the last element is connected to the first element. Its
  advantage is that the memory is utilized in a better way. This is
  because if there is an empty space i.e. if no element is present at a
  certain position in the queue, then an element can be easily added at
  that position.
* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it
  arranges the elements in a queue based on some priority. The priority
  can be something where the element with the highest value has the
  priority so it creates a queue with decreasing order of values. The
  priority can also be such that the element with the lowest value gets
  the highest priority so in turn it creates a queue with increasing
  order of values.
* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests
  double ended, it means that an element can be inserted or removed from
  both the ends of the queue unlike the other queues in which it can be
  done only from one end. Because of this property it may not obey the
  First In First Out property.

****Implementation of Queue:****

* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited
  number of elements.
* ****Linked list allocation:****
  A queue can be implemented using a linked list. It can organize an
  unlimited number of elements.

****Applications of Queue:****

* ****Multi programming:**** Multi programming means when multiple programs are running in the
  main memory. It is essential to organize these multiple programs and
  these multiple programs are organized as queues.
* ****Network:**** In a network, a queue is used in devices such as a router or a
  switch. another application of a queue is a mail queue which is a
  directory that stores data and controls files for mail messages.
* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that
  are scheduled to be executed one after another. These jobs are
  assigned to the processor one by one which is organized using a
  queue.
* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.

****Real-time application of Queue:****

* Working as a buffer between a slow and a fast device. For example
  keyboard and CPU, and two devices on network.
* ATM Booth Line
* Ticket Counter Line
* CPU task scheduling
* Waiting time of each customer at call centers.

****Advantages of Queue:****

* A large amount of data can be managed efficiently with ease.
* Operations such as insertion and deletion can be performed with ease
  as it follows the first in first out rule.
* Queues are useful when a particular service is used by multiple
  consumers.
* Queues are fast in speed for data inter-process communication.
* Queues can be used in the implementation of other data
  structures.

****Disadvantages of Queue:****

* The operations such as insertion and deletion of elements from the
  middle are time consuming.
* In a classical queue, a new element can only be inserted when the
  existing elements are deleted from the queue.
* Searching an element takes O(N) time.
* Maximum size of a queue must be defined prior in case of array
  implementation.

', e'A Queue
is a linear data structure. This data structure follows a particular
order in which the operations are performed. The order is First In First Out (FIFO). It means that the element that is inserted first in the queue will
come out first and the element that is inserted last will come out last.', 'Applications, Advantages and Disadvantages of Queue', 5, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('4cd8171b-fbfb-4ac2-bd58-4d59d056750d', e'What is a Circular Linked List?
-------------------------------


A

****circular linked list****
is a special type of linked list where all the nodes are connected to form a circle. Unlike a regular linked list, which ends with a node pointing to

****NULL****
, the last node in a circular linked list points back to the first node. This means that you can keep traversing the list without ever reaching a

****NULL****
value.


Types of Circular Linked Lists
------------------------------


We can create a circular linked list from both

[singly linked lists](https://www.geeksforgeeks.org/introduction-to-singly-linked-list/)
and

[doubly linked lists](https://www.geeksforgeeks.org/doubly-linked-list-tutorial-2/)
. So, circular linked list are basically of two types:


### 1. Circular Singly Linked List


In

****Circular Singly Linked List****
, each node has just one pointer called the “

****next****
” pointer. The next pointer of

****last node****
points back to the

****first node****
and this results in forming a circle. In this type of Linked list we can only move through the list in one direction.


![Representation-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806130914/Representation-of-circular-linked-list.webp)

Representation of Circular Singly Linked List

### 2. Circular Doubly Linked List:


In

****circular doubly linked****

****list,****
each node has two pointers

****prev****
and

****next,****
similar to doubly linked list. The

****prev****
pointer points to the previous node and the

****next****
points to the next node. Here, in addition to the

****last****
node storing the address of the first node, the

****first node****
will also store the address of the

****last node****
.


![Representation-of-circular-doubly-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145223/Representation-of-circular-doubly-linked-list.webp)

Representation of Circular Doubly Linked List

****Note:****
In this article, we will use the circular singly linked list to explain the working of circular linked lists.


Representation of a Circular Singly Linked List
-----------------------------------------------


Let’s take a look on the structure of a circular linked list.




![Node-structure-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145414/Node-structure-of-circular-linked-list.webp)

Representation of a Circular Singly Linked List

### Create/Declare a Node of Circular Linked List


Syntax to Declare a Circular Linked List in Different Languages:



C++

````
// Node structure
struct Node {
    int data;
    Node* next;

    Node(int value){
        data = value;
        next = nullptr;
    }
};

````

C

````
// Node structure
struct Node
{
    int data;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value){

    // Allocate memory
    struct Node *newNode =
      (struct Node *)malloc(sizeof(struct Node));

    // Set the data
    newNode->data = value;

    // Initialize next to NULL
    newNode->next = NULL;

    // Return the new node
    return newNode;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int data)
    {
        this.data = data;
        this.next = null;
    }
}

````

Python

````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

````

C#

````
public class Node {
    public int data;
    public Node next;

    public Node(int data){
        this.data = data;
        this.next = null;
    }
}

````

JavaScript

````
class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
    }
}

````


In the code above, each node has

****data****
and a

****pointer****
to the next node. When we create multiple nodes for a circular linked list, we only need to connect the last node back to the first one.


Example of Creating a Circular Linked List
------------------------------------------


Here’s an example of creating a circular linked list with three nodes (2, 3, 4):


![Circular-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240806111438/Circular-Linked-List.png)

Created a circular linked list with 3 nodes


C++

````
// Initilize and allocate memory for nodes
first = new Node(2);
second = new Node(3);
last = new Node(4);

// Connect nodes
first->next = second;
second->next = last;

// Connect last node to first node
last->next = first;

````

C

````
// Allocate memory for nodes
struct Node *first =
  (struct Node *)malloc(sizeof(struct Node));
struct Node *second =
  (struct Node *)malloc(sizeof(struct Node));
struct Node *last =
  (struct Node *)malloc(sizeof(struct Node));

// Initilize nodes
first->data = 2;
second->data = 3;
last->data = 4;

// Connect nodes
first->next = second;
second->next = last;
last->next = first;

````

Java

````
// Initilize and allocate memory for nodes
Node first = new Node(2);
Node second = new Node(3);
Node last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

````

Python

````
# Initilize and allocate memory for nodes
first = Node(2)
second = Node(3)
last = Node(4)

# Connect nodes
first.next = second
second.next = last
last.next = first

````

C#

````
// Initilize and allocate memory for nodes
Node first = new Node(2);
Node second = new Node(3);
Node last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

````

JavaScript

````
// Initilize and allocate memory for nodes
let first = new Node(2);
let second = new Node(3);
let last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

````



In the above code, we have created three nodes

****first, second,****
and

****last****
having values

****2, 3,****
and

****4****
respectively.


* After creating three nodes, we have connected these node in a series.
* Connect the first node “

  ****first”****
  to “

  ****second”****
  node by

  ****s****
  toring the address of “

  ****second”****
  node


  into

  ****first’s****
  next
* Connect the second node “

  ****second”****
  to “

  ****second”****
  node by

  ****s****
  toring the address of “

  ****third****
  ” node into

  ****second’s****
  next
* After connecting all the nodes, we reach the key characteristic of a circular linked list:

  linking the last node back to the first node


  . Therefore, we store the address of the “

  ****first****
  ” node in the “

  ****last****
  ” node.

### Why have we taken a pointer that points to the last node instead of the first node?


For the insertion of a node at the beginning, we need to traverse the whole list. Also, for insertion at the end, the whole list has to be traversed. If instead of the start pointer, we take a pointer to the last node, then in both cases there won’t be any need to traverse the whole list. So insertion at the beginning or at the end takes constant time, irrespective of the length of the list.


Operations on the Circular Linked list:
---------------------------------------


We can do some operations on the circular linked list similar to the singly and doubly linked list which are:


* ****Insertion****
  + Insertion at the empty list
  + Insertion at the beginning
  + Insertion at the end
  + Insertion at the given position
* ****Deletion****
  + Delete the first node
  + Delete the last node
  + Delete the node from any position
* ****Searching****

****Note:****
We will be using the circular singly linked list to represent the working of the circular linked list.


[Insertion in the circular linked list:](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/)
--------------------------------------------------------------------------------------------------------------


Insertion is a fundamental operation in linked lists that involves adding a new node to the list. The only extra step is connecting the last node to the first one. In the circular linked list mentioned below, we can insert nodes in four ways:


### 1. Insertion in an empty List in the circular linked list

> To insert a node in empty circular linked list, creates a
>
> ****new node****
> with the given data, sets its next pointer to point to itself, and updates the
>
> ****last****
> pointer to reference this
>
> ****new node****
> .

![Insertion-in-an-empty-list-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806193408/Insertion-in-an-empty-list-in-circular-linked-list.webp)

Insertion in an empty List


C++

````
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *next;
    Node(int value){
        data = value;
        next = nullptr;
    }
};

// Function to insert a node into an empty circular singly linked list
Node *insertInEmptyList(Node *last, int data){
    if (last != nullptr) return last;

    // Create a new node
    Node *newNode = new Node(data);

    // Point newNode to itself
    newNode->next = newNode;

    // Update last to point to the new node
    last = newNode;
    return last;
}

void printList(Node* last){
    if(last == NULL) return;

    // Start from the head node
    Node* head = last->next;
    while (true) {
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main(){
    Node *last = nullptr;

    // Insert a node into the empty list
    last = insertInEmptyList(last, 1);

    // Print the list
    cout << "List after insertion: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* createNode(int value);

// Function to insert a node into an empty
// circular singly linked list
struct Node* insertInEmptyList(struct Node* last, int data) {
    if (last != NULL) return last;

    // Create a new node
    struct Node* newNode = createNode(data);

    // Update last to point to the new node
    last = newNode;
    return last;
}

void printList(struct Node* last) {
    if (last == NULL) return;

    // Start from the head node
    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = newNode;
    return newNode;
}

int main() {
    struct Node* last = NULL;

    // Insert a node into the empty list
    last = insertInEmptyList(last, 1);

    // Print the list
    printf("List after insertion: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value) {
        data = value;
        next = null;
    }
}

public class Main {
    // Function to insert a node into an empty
    // circular singly linked list
    static Node insertInEmptyList(Node last, int data) {
        if (last != null) return last;

        // Create a new node
        Node newNode = new Node(data);

        // Point newNode to itself
        newNode.next = newNode;

        // Update last to point to the new node
        last = newNode;
        return last;
    }

    // Function to print the list
    static void printList(Node last) {
        if (last == null) return;

        // Start from the head node
        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Node last = null;

        // Insert a node into the empty list
        last = insertInEmptyList(last, 1);

        // Print the list
        System.out.print("List after insertion: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = self  # Point to itself

def insertInEmptyList(last, data):
    if last is not None:
        return last

    # Create a new node
    new_node = Node(data)

    # Update last to point to the new node
    last = new_node
    return last

def printList(last):
    if last is None:
        return

    # Start from the head node
    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

if __name__ == "__main__":
    last = None

    # Insert a node into the empty list
    last = insertInEmptyList(last, 1)

    # Print the list
    print("List after insertion: ", end="")
    printList(last)

````

JavaScript

````
class Node {
    constructor(value)
    {
        this.data = value;
        this.next = null;
    }
}

function insertInEmptyList(last, data)
{
    if (last !== null)
        return last;

    // Create a new node
    let newNode = new Node(data);

    // Point newNode to itself
    newNode.next = newNode;

    // Update last to point to the new node
    last = newNode;
    return last;
}

function printList(last)
{
    if (last === null)
        return;

    // Start from the head node
    let head = last.next;
    while (true) {
        console.log(head.data);
        head = head.next;
        if (head === last.next)
            break;
    }
}

// Main function

let last = null;

// Insert a node into the empty list
last = insertInEmptyList(last, 1);

// Print the list
console.log("List after insertion:");
printList(last);

````




**Output**
```
List after insertion: 1

```
### 2. Insertion at the beginning in circular linked list

> To insert a new node at the beginning of a circular linked list, we first create the
>
> ****new node****
> and allocate memory for it. If the list is empty (indicated by the last pointer being
>
> ****NULL****
> ), we make the
>
> ****new node****
> point to itself. If the list already contains nodes then we set the
>
> ****new node’s****
> next pointer to point to the
>
> ****current head****
> of the list (which is
>
> ****last->next****
> ), and then update the last node’s next pointer to point to the
>
> ****new node****
> . This maintains the circular structure of the list.

![Insertion-at-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150314/Insertion-at-the-beginning-of-circular-linked-list.webp)

Insertion at the beginning in circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;

    Node(int value)
    {
        data = value;
        next = nullptr;
    }
};

// Function to insert a node at the beginning of the
// circular linked list
Node* insertAtBeginning(Node* last, int value){
    // Allocate memory for the new node and set its data
    Node* newNode = new Node(value);

    // If the list is empty, make the new node point to
    // itself and set it as last
    if (last == nullptr) {
        newNode->next = newNode;
        return newNode;
    }

    // Insert the new node at the beginning
    newNode->next = last->next;
    last->next = newNode;

    return last;
}

void printList(Node* last){
  if(last == NULL) return;

    // Start from the head node
    Node* head = last->next;
    while (true) {
        cout << head->data << " ";
        head = head->next;
        if (head == last->next)
            break;
    }
    cout << endl;
}

int main(){

    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Insert 5 at the beginning
    last = insertAtBeginning(last, 5);

    cout << "List after inserting 5 at the beginning: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node
{
    int data;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value)
{
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the beginning
// of the circular linked list
struct Node *insertAtBeginning(struct Node *last, int value)
{
    struct Node *newNode = createNode(value);

    // If the list is empty, make the new node point to itself
    // and set it as last
    if (last == NULL)
    {
        newNode->next = newNode;
        return newNode;
    }

    // Insert the new node at the beginning
    newNode->next = last->next;
    last->next = newNode;

    return last;
}

void printList(struct Node *last)
{
    if (last == NULL) return;

    struct Node *head = last->next;
    while (1){
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next)
            break;
    }
    printf("\\n");
}

int main()
{
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);
    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Insert 5 at the beginning
    last = insertAtBeginning(last, 5);

    printf("List after inserting 5 at the beginning: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {

    // Function to insert a node at the beginning of the
    // circular linked list
    public static Node insertAtBeginning(Node last,
                                         int value){
        Node newNode = new Node(value);

        // If the list is empty, make the new node point to
        // itself and set it as last
        if (last == null) {
            newNode.next = newNode;
            return newNode;
        }

        // Insert the new node at the beginning
        newNode.next = last.next;
        last.next = newNode;

        return last;
    }

    // Function to print the circular linked list
    public static void printList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);
        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Insert 5 at the beginning
        last = insertAtBeginning(last, 5);

        System.out.print(
            "List after inserting 5 at the beginning: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Function to insert a node at the beginning of the circular linked list
def insert_at_beginning(last, value):
    new_node = Node(value)

    # If the list is empty, make the new node point to itself and set it as last
    if last is None:
        new_node.next = new_node
        return new_node

    # Insert the new node at the beginning
    new_node.next = last.next
    last.next = new_node

    return last

# Function to print the circular linked list
def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)
last = first.next.next
last.next = first

print("Original list: ", end="")
print_list(last)

# Insert 5 at the beginning
last = insert_at_beginning(last, 5)

print("List after inserting 5 at the beginning: ", end="")
print_list(last)

````

C#

````
using System;

public class Node
{
    public int data;
    public Node next;

    public Node(int value)
    {
        data = value;
        next = null;
    }
}

public class CircularLinkedList
{
    // Function to insert a node at the beginning of the circular linked list
    public static Node InsertAtBeginning(Node last, int value)
    {
        Node newNode = new Node(value);

        // If the list is empty, make the new node point to itself and set it as last
        if (last == null)
        {
            newNode.next = newNode;
            return newNode;
        }

        // Insert the new node at the beginning
        newNode.next = last.next;
        last.next = newNode;

        return last;
    }

    // Function to print the circular linked list
    public static void PrintList(Node last)
    {
        if (last == null)
            return;

        Node head = last.next;
        while (true)
        {
            Console.Write(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        Console.WriteLine();
    }

    public static void Main(string[] args)
    {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);
        Node last = first.next.next;
        last.next = first;

        Console.Write("Original list: ");
        PrintList(last);

        // Insert 5 at the beginning
        last = InsertAtBeginning(last, 5);

        Console.Write("List after inserting 5 at the beginning: ");
        PrintList(last);
    }
}

````

JavaScript

````
class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
    }
}

// Function to insert a node at the beginning of the
// circular linked list
function insertAtBeginning(last, value)
{
    const newNode = new Node(value);

    // If the list is empty, make the new node point to
    // itself and set it as last
    if (last === null) {
        newNode.next = newNode;
        return newNode;
    }

    // Insert the new node at the beginning
    newNode.next = last.next;
    last.next = newNode;

    return last;
}

// Function to print the circular linked list
function printList(last)
{
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
const first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);
let last
    = first.next.next; // Using let to allow reassignment
last.next = first;

console.log("Original list: ");
printList(last);

// Insert 5 at the beginning
last = insertAtBeginning(last, 5);

console.log("List after inserting 5 at the beginning: ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after inserting 5 at the beginning: 5 2 3 4

```
### 3. Insertion at the end in circular linked list

> To insert a new node at the end of a circular linked list, we first create the new node and allocate memory for it. If the list is empty (mean,
>
> ****last****
> or
>
> ****tail****
> pointer being
>
> ****NULL****
> ), we initialize the list with the
>
> ****new node****
> and making it point to itself to form a circular structure. If the list already contains nodes then we set the
>
> ****new node’s****
> next pointer to point to the
>
> ****current head****
> (which is
>
> ****tail->next****
> ), then update the
>
> ****current tail’s****
> next pointer to point to the
>
> ****new node****
> . Finally, we update the
>
> ****tail pointer****
> to the
>
> ****new node.****
> This will ensure that the
>
> ****new node****
> is now the
>
> ****last node****
> in the list while maintaining the circular linkage.

![Insertion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150353/Insertion-at-the-end-of-circular-linked-list.webp)

Insertion at the end in circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *next;
    Node(int value)
    {
        data = value;
        next = nullptr;
    }
};

// Function to insert a node at the end of a circular linked list
Node *insertEnd(Node *tail, int value)
{
    Node *newNode = new Node(value);
    if (tail == nullptr){
        // If the list is empty, initialize it with the new node
        tail = newNode;

        // Point to itself to form a circular structure
        newNode->next = newNode;
    }
    else{
        // Insert new node after the current tail
        // and update the tail pointer.
        // New node points to the head node
        newNode->next = tail->next;

        // Tail node points to the new node
        tail->next = newNode;

        // Update tail to be the new node
        tail = newNode;
    }
    return tail;
}

void printList(Node *last){
  if(last == NULL) return;

    // Start from the head node
    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next)
            break;
    }
    cout << endl;
}

int main(){
    // Create circular linked list: 2, 3, 4
    Node *first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node *last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Insert elements at the end of the circular linked list
    last = insertEnd(last, 5);
    last = insertEnd(last, 6);

    cout << "List after inserting 5 and 6: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node
{
    int data;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value);

// Function to insert a node at the end of a circular linked list
struct Node *insertEnd(struct Node *tail, int value)
{
    struct Node *newNode = createNode(value);
    if (tail == NULL)
    {
        // If the list is empty, initialize it with the new node
        tail = newNode;
        newNode->next = newNode;
    }
    else
    {
        // Insert new node after the current tail and update the tail pointer
        newNode->next = tail->next;
        tail->next = newNode;
        tail = newNode;
    }
    return tail;
}

// Function to print the circular linked list
void printList(struct Node *last)
{
    if (last == NULL)
        return;

    struct Node *head = last->next;
    while (1)
    {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next)
            break;
    }
    printf("\\n");
}

struct Node *createNode(int value)
{
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main()
{
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Insert elements at the end of the circular linked list
    last = insertEnd(last, 5);
    last = insertEnd(last, 6);

    printf("List after inserting 5 and 6: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {

    // Function to insert a node at the end of a circular
    // linked list
    static Node insertEnd(Node tail, int value){
        Node newNode = new Node(value);
        if (tail == null) {
            // If the list is empty, initialize it with the
            // new node
            tail = newNode;
            newNode.next = newNode;
        }
        else {
            // Insert new node after the current tail and
            // update the tail pointer
            newNode.next = tail.next;
            tail.next = newNode;
            tail = newNode;
        }
        return tail;
    }

    // Function to print the circular linked list
    static void printList(Node last){
        if (last == null) return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Insert elements at the end of the circular linked
        // list
        last = insertEnd(last, 5);
        last = insertEnd(last, 6);

        System.out.print("List after inserting 5 and 6: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Function to insert a node at the end of a circular linked list


def insert_end(tail, value):
    new_node = Node(value)
    if tail is None:
        # If the list is empty, initialize
        # it with the new node
        tail = new_node
        new_node.next = new_node
    else:
        # Insert new node after the current tail
        # and update the tail pointer
        new_node.next = tail.next
        tail.next = new_node
        tail = new_node
    return tail

# Function to print the circular linked list


def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()


if __name__ == "__main__":
    # Create circular linked list: 2, 3, 4
    first = Node(2)
    first.next = Node(3)
    first.next.next = Node(4)

    last = first.next.next
    last.next = first

    print("Original list: ", end="")
    print_list(last)

    # Insert elements at the end of the circular linked list
    last = insert_end(last, 5)
    last = insert_end(last, 6)

    print("List after inserting 5 and 6: ", end="")
    print_list(last)

````

JavaScript

````
class Node {
    constructor(value){
        this.data = value;
        this.next = null;
    }
}

// Function to insert a node at the end of a circular linked
// list
function insertEnd(tail, value){
    let newNode = new Node(value);
    if (tail === null) {
        // If the list is empty, initialize it with the new
        // node
        tail = newNode;
        newNode.next = newNode;
    }
    else {
        // Insert new node after the current tail and update
        // the tail pointer
        newNode.next = tail.next;
        tail.next = newNode;
        tail = newNode;
    }
    return tail;
}

// Function to print the circular linked list
function printList(last)
{
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Insert elements at the end of the circular linked
// list
last = insertEnd(last, 5);
last = insertEnd(last, 6);

console.log("List after inserting 5 and 6: ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after inserting 5 and 6: 2 3 4 5 6

```
### 4. Insertion at specific position in circular linked list

> To insert a new node at a specific position in a circular linked list, we first check if the list is empty. If it is and the
>
> ****position****
> is not
>
> ****1****
> then we print an error message because the position doesn’t exist in the list. If the
>
> ****position****
> is
>
> ****1****
> then we create the
>
> ****new node****
> and make it point to itself. If the list is not empty, we create the
>
> ****new node****
> and traverse the list to find the correct insertion point. If the
>
> ****position****
> is
>
> ****1****
> , we insert the
>
> ****new node****
> at the beginning by adjusting the pointers accordingly. For other positions, we traverse through the list until we reach the desired position and inserting the
>
> ****new node****
> by updating the pointers. If the new node is inserted at the end, we also update the
>
> ****last****
> pointer to reference the new node, maintaining the circular structure of the list.

![Insertion-at-specific-position-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150431/Insertion-at-specific-position-of-circular-linked-list.webp)

Insertion at specific position in circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *next;
    Node(int value){
        data = value;
        next = nullptr;
    }
};

// Function to insert a node at a specific position in a circular linked list
Node *insertAtPosition(Node *last, int data, int pos){
    if (last == nullptr){
        // If the list is empty
        if (pos != 1){
            cout << "Invalid position!" << endl;
            return last;
        }
        // Create a new node and make it point to itself
        Node *newNode = new Node(data);
        last = newNode;
        last->next = last;
        return last;
    }

    // Create a new node with the given data
    Node *newNode = new Node(data);

    // curr will point to head initially
    Node *curr = last->next;

    if (pos == 1){
        // Insert at the beginning
        newNode->next = curr;
        last->next = newNode;
        return last;
    }

    // Traverse the list to find the insertion point
    for (int i = 1; i < pos - 1; ++i) {
        curr = curr->next;

        // If position is out of bounds
        if (curr == last->next){
            cout << "Invalid position!" << endl;
            return last;
        }
    }
    // Insert the new node at the desired position
    newNode->next = curr->next;
    curr->next = newNode;

    // Update last if the new node is inserted at the end
    if (curr == last) last = newNode;

    return last;
}

void printList(Node *last){
    if (last == NULL) return;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main(){
    // Create circular linked list: 2, 3, 4
    Node *first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node *last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Insert elements at specific positions
    int data = 5, pos = 2;
    last = insertAtPosition(last, data, pos);
    cout << "List after insertions: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data;
    struct Node *next;
};

struct Node* createNode(int value);

// Function to insert a node at a specific position in a circular linked list
struct Node* insertAtPosition(struct Node *last, int data, int pos) {
    if (last == NULL) {
        // If the list is empty
        if (pos != 1) {
            printf("Invalid position!\\n");
            return last;
        }
        // Create a new node and make it point to itself
        struct Node *newNode = createNode(data);
        last = newNode;
        last->next = last;
        return last;
    }

    // Create a new node with the given data
    struct Node *newNode = createNode(data);

    // curr will point to head initially
    struct Node *curr = last->next;

    if (pos == 1) {
        // Insert at the beginning
        newNode->next = curr;
        last->next = newNode;
        return last;
    }

    // Traverse the list to find the insertion point
    for (int i = 1; i < pos - 1; ++i) {
        curr = curr->next;

        // If position is out of bounds
        if (curr == last->next) {
            printf("Invalid position!\\n");
            return last;
        }
    }

    // Insert the new node at the desired position
    newNode->next = curr->next;
    curr->next = newNode;

    // Update last if the new node is inserted at the end
    if (curr == last) last = newNode;

    return last;
}

// Function to print the circular linked list
void printList(struct Node *last) {
    if (last == NULL) return;

    struct Node *head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Insert elements at specific positions
    int data = 5, pos = 2;
    last = insertAtPosition(last, data, pos);
    printf("List after insertions: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {

    // Function to insert a node at a specific position in a
    // circular linked list
    static Node insertAtPosition(Node last, int data,
                                 int pos){
        if (last == null) {
            // If the list is empty
            if (pos != 1) {
                System.out.println("Invalid position!");
                return last;
            }
            // Create a new node and make it point to itself
            Node newNode = new Node(data);
            last = newNode;
            last.next = last;
            return last;
        }

        // Create a new node with the given data
        Node newNode = new Node(data);

        // curr will point to head initially
        Node curr = last.next;

        if (pos == 1) {
            // Insert at the beginning
            newNode.next = curr;
            last.next = newNode;
            return last;
        }

        // Traverse the list to find the insertion point
        for (int i = 1; i < pos - 1; ++i) {
            curr = curr.next;

            // If position is out of bounds
            if (curr == last.next) {
                System.out.println("Invalid position!");
                return last;
            }
        }

        // Insert the new node at the desired position
        newNode.next = curr.next;
        curr.next = newNode;

        // Update last if the new node is inserted at the
        // end
        if (curr == last)
            last = newNode;

        return last;
    }

    static void printList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        System.out.println();
    }

    public static void main(String[] args)
    {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Insert elements at specific positions
        int data = 5, pos = 2;
        last = insertAtPosition(last, data, pos);
        System.out.print("List after insertions: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Function to insert a node at a specific position in a circular linked list
def insertAtPosition(last, data, pos):
    if last is None:
        # If the list is empty
        if pos != 1:
            print("Invalid position!")
            return last
        # Create a new node and make it point to itself
        new_node = Node(data)
        last = new_node
        last.next = last
        return last

    # Create a new node with the given data
    new_node = Node(data)

    # curr will point to head initially
    curr = last.next

    if pos == 1:
        # Insert at the beginning
        new_node.next = curr
        last.next = new_node
        return last

    # Traverse the list to find the insertion point
    for i in range(1, pos - 1):
        curr = curr.next

        # If position is out of bounds
        if curr == last.next:
            print("Invalid position!")
            return last

    # Insert the new node at the desired position
    new_node.next = curr.next
    curr.next = new_node

    # Update last if the new node is inserted at the end
    if curr == last:
        last = new_node

    return last

# Function to print the circular linked list
def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

if __name__ == "__main__":
    # Create circular linked list: 2, 3, 4
    first = Node(2)
    first.next = Node(3)
    first.next.next = Node(4)

    last = first.next.next
    last.next = first

    print("Original list: ", end="")
    print_list(last)

    # Insert elements at specific positions
    data = 5
    pos = 2
    last = insertAtPosition(last, data, pos)
    print("List after insertions: ", end="")
    print_list(last)

````

JavaScript

````
class Node {
    constructor(value){
        this.data = value;
        this.next = null;
    }
}

// Function to insert a node at a specific position in a
// circular linked list
function insertAtPosition(last, data, pos)
{
    if (last === null) {
        // If the list is empty
        if (pos !== 1) {
            console.log("Invalid position!");
            return last;
        }
        // Create a new node and make it point to itself
        let newNode = new Node(data);
        last = newNode;
        last.next = last;
        return last;
    }

    // Create a new node with the given data
    let newNode = new Node(data);

    // curr will point to head initially
    let curr = last.next;

    if (pos === 1) {
        // Insert at the beginning
        newNode.next = curr;
        last.next = newNode;
        return last;
    }

    // Traverse the list to find the insertion point
    for (let i = 1; i < pos - 1; ++i) {
        curr = curr.next;

        // If position is out of bounds
        if (curr === last.next) {
            console.log("Invalid position!");
            return last;
        }
    }

    // Insert the new node at the desired position
    newNode.next = curr.next;
    curr.next = newNode;

    // Update last if the new node is inserted at the end
    if (curr === last)
        last = newNode;

    return last;
}

// Function to print the circular linked list
function printList(last){
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Insert elements at specific positions
let data = 5;
let pos = 2;
last = insertAtPosition(last, data, pos);
console.log("List after insertions: ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after insertions: 2 5 3 4

```

[Deletion from a Circular Linked List](https://www.geeksforgeeks.org/deletion-circular-linked-list/?ref=ml_lbp)
---------------------------------------------------------------------------------------------------------------


Deletion involves removing a node from the linked list. The main difference is that we need to ensure the list remains circular after the deletion. We can delete a node in a circular linked list in three ways:


### 1. Delete the first node in circular linked list

> To delete the first node of a circular linked list, we first check if the list is empty. If it is then we print a message and return
>
> ****NULL****
> . If the list contains only one node (the
>
> ****head****
> is the same as the
>
> ****last****
> ) then we delete that node and set the
>
> ****last****
> pointer to
>
> ****NULL****
> . If there are multiple nodes then we update the
>
> ****last->next****
> pointer to skip the
>
> ****head****
> node and effectively removing it from the list. We then delete the
>
> ****head****
> node to free the allocated memory. Finally, we return the updated
>
> ****last****
> pointer, which still points to the
>
> ****last****
> node in the list.

![Deletion-from-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150500/Deletion-from-the-beginning-of-circular-linked-list.webp)

Delete the first node in circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to delete the first node of the circular linked list
Node* deleteFirstNode(Node* last) {
    if (last == nullptr) {
        // If the list is empty
        cout << "List is empty" << endl;
        return nullptr;
    }

    Node* head = last->next;

    if (head == last) {
        // If there is only one node in the list
        delete head;
        last = nullptr;
    } else {
        // More than one node in the list
        last->next = head->next;
        delete head;
    }

    return last;
}

void printList(Node* last) {
    if(last == NULL) return ;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Delete the first node
    last = deleteFirstNode(last);

    cout << "List after deleting first node: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

struct Node* deleteFirstNode(struct Node* last) {
    if (last == NULL) {
        // If the list is empty
        printf("List is empty\\n");
        return NULL;
    }

    struct Node* head = last->next;

    if (head == last) {
        // If there is only one node in the list
        free(head);
        last = NULL;
    } else {
        // More than one node in the list
        last->next = head->next;
        free(head);
    }

    return last;
}

void printList(struct Node* last) {
    if (last == NULL) return;

    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    struct Node* first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node* last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    last = deleteFirstNode(last);

    printf("List after deleting first node: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value) {
        data = value;
        next = null;
    }
}

public class GFG {
    public static Node deleteFirstNode(Node last) {
        if (last == null) {
            // If the list is empty
            System.out.println("List is empty");
            return null;
        }

        Node head = last.next;

        if (head == last) {
            // If there is only one node in the list
            last = null;
        } else {
            // More than one node in the list
            last.next = head.next;
        }

        return last;
    }

    public static void printList(Node last) {
        if (last == null) return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Delete the first node
        last = deleteFirstNode(last);

        System.out.print("List after deleting first node: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def deleteFirstNode(last):
    if last is None:
        # If the list is empty
        print("List is empty")
        return None

    head = last.next

    if head == last:
        # If there is only one node in the list
        last = None
    else:
        # More than one node in the list
        last.next = head.next

    return last

def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)

last = first.next.next
last.next = first

print("Original list: ", end="")
print_list(last)

# Delete the first node
last = deleteFirstNode(last)

print("List after deleting first node: ", end="")
print_list(last)

````

JavaScript

````
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function deleteFirstNode(last) {
    if (last === null) {
        // If the list is empty
        console.log("List is empty");
        return null;
    }

    let head = last.next;

    if (head === last) {
        // If there is only one node in the list
        last = null;
    } else {
        // More than one node in the list
        last.next = head.next;
    }

    return last;
}

function printList(last) {
    if (last === null) return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next) break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete the first node
last = deleteFirstNode(last);

console.log("List after deleting first node: ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after deleting first node: 3 4

```
### 2. Delete a specific node in circular linked list

> To delete a specific node from a circular linked list, we first check if the list is empty. If it is then we print a message and return
>
> ****nullptr****
> . If the list contains only one node and it matches the
>
> ****key****
> then we delete that node and set
>
> ****last****
> to
>
> ****nullptr****
> . If the node to be deleted is the first node then we update the
>
> ****next****
> pointer of the
>
> ****last****
> node to skip the
>
> ****head****
> node and delete the
>
> ****head****
> . For other nodes, we traverse the list using two pointers:
>
> ****curr****
> (to find the node) and
>
> ****prev****
> (to keep track of the previous node). If we find the node with the matching key then we update the next pointer of
>
> ****prev****
> to skip the
>
> ****curr****
> node and delete it. If the node is found and it is the last node, we update the
>
> ****last****
> pointer accordingly. If the node is not found then do nothing and
>
> ****tail****
> or
>
> ****last****
> as it is. Finally, we return the updated
>
> ****last****
> pointer.

![Delete-a-specific-node-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150531/Delete-a-specific-node-in-circular-linked-list.webp)

Delete a specific node in circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to delete a specific node in the circular linked list
Node* deleteSpecificNode(Node* last, int key) {
    if (last == nullptr) {
        // If the list is empty
        cout << "List is empty, nothing to delete." << endl;
        return nullptr;
    }

    Node* curr = last->next;
    Node* prev = last;

    // If the node to be deleted is the only node in the list
    if (curr == last && curr->data == key) {
        delete curr;
        last = nullptr;
        return last;
    }

    // If the node to be deleted is the first node
    if (curr->data == key) {
        last->next = curr->next;
        delete curr;
        return last;
    }

    // Traverse the list to find the node to be deleted
    while (curr != last && curr->data != key) {
        prev = curr;
        curr = curr->next;
    }

    // If the node to be deleted is found
    if (curr->data == key) {
        prev->next = curr->next;
        if (curr == last) {
            last = prev;
        }
        delete curr;
    } else {
        // If the node to be deleted is not found
        cout << "Node with data " << key
          << " not found." << endl;
    }

    return last;
}

// Function to print the circular linked list
void printList(Node* last) {
     if (last == NULL){
        cout << "List is Empty";
        return;
    }

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Delete a specific node
    int key = 3;
    last = deleteSpecificNode(last, key);

    cout << "List after deleting node " << key << ": ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node in the circular linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to delete a specific node in the circular linked list
struct Node* deleteSpecificNode(struct Node* last, int key) {
    if (last == NULL) {
        // If the list is empty
        printf("List is empty, nothing to delete.\\n");
        return NULL;
    }

    struct Node* curr = last->next;
    struct Node* prev = last;

    // If the node to be deleted is the only node in the list
    if (curr == last && curr->data == key) {
        free(curr);
        last = NULL;
        return last;
    }

    // If the node to be deleted is the first node
    if (curr->data == key) {
        last->next = curr->next;
        free(curr);
        return last;
    }

    // Traverse the list to find the node to be deleted
    while (curr != last && curr->data != key) {
        prev = curr;
        curr = curr->next;
    }

    // If the node to be deleted is found
    if (curr->data == key) {
        prev->next = curr->next;
        if (curr == last) {
            last = prev;
        }
        free(curr);
    } else {
        // If the node to be deleted is not found
        printf("Node with data %d not found.\\n", key);
    }

    return last;
}

void printList(struct Node* last) {
    if (last == NULL) {
        printf("List is Empty");
        return;
    }

    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    // Create circular linked list: 2, 3, 4
    struct Node* first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node* last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Delete a specific node
    int key = 3;
    last = deleteSpecificNode(last, key);

    printf("List after deleting node %d: ", key);
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;
    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {
    public static Node deleteSpecificNode(Node last,
                                          int key){
        if (last == null) {
            // If the list is empty
            System.out.println(
                "List is empty, nothing to delete.");
            return null;
        }
        Node curr = last.next;
        Node prev = last;

        // If the node to be deleted is the only node in the
        // list
        if (curr == last && curr.data == key) {
            last = null;
            return last;
        }

        // If the node to be deleted is the first node
        if (curr.data == key) {
            last.next = curr.next;
            return last;
        }

        // Traverse the list to find the node to be deleted
        while (curr != last && curr.data != key) {
            prev = curr;
            curr = curr.next;
        }

        // If the node to be deleted is found
        if (curr.data == key) {
            prev.next = curr.next;
            if (curr == last) {
                last = prev;
            }
        }
        else {
            // If the node to be deleted is not found
            System.out.println("Node with data " + key
                               + " not found.");
        }
        return last;
    }

    public static void printList(Node last){
        if (last == null) {
            System.out.println("List is Empty");
            return;
        }

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Delete a specific node
        int key = 3;
        last = deleteSpecificNode(last, key);

        System.out.print("List after deleting node " + key
                         + ": ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def deleteSpecificNode(last, key):
    if last is None:
        # If the list is empty
        print("List is empty, nothing to delete.")
        return None

    curr = last.next
    prev = last

    # If the node to be deleted is the only node in the list
    if curr == last and curr.data == key:
        last = None
        return last

    # If the node to be deleted is the first node
    if curr.data == key:
        last.next = curr.next
        return last

    # Traverse the list to find the node to be deleted
    while curr != last and curr.data != key:
        prev = curr
        curr = curr.next

    # If the node to be deleted is found
    if curr.data == key:
        prev.next = curr.next
        if curr == last:
            last = prev
    else:
        # If the node to be deleted is not found
        print(f"Node with data {key} not found.")

    return last

def printList(last):
    if last is None:
        print("List is Empty")
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)

last = first.next.next
last.next = first

print("Original list: ", end="")
printList(last)

# Delete a specific node
key = 3
last = deleteSpecificNode(last, key)

print(f"List after deleting node {key}: ", end="")
printList(last)

````

JavaScript

````
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function deleteSpecificNode(last, key) {
    if (last === null) {
        // If the list is empty
        console.log("List is empty, nothing to delete.");
        return null;
    }

    let curr = last.next;
    let prev = last;

    // If the node to be deleted is the only node in the list
    if (curr === last && curr.data === key) {
        last = null;
        return last;
    }

    // If the node to be deleted is the first node
    if (curr.data === key) {
        last.next = curr.next;
        return last;
    }

    // Traverse the list to find the node to be deleted
    while (curr !== last && curr.data !== key) {
        prev = curr;
        curr = curr.next;
    }

    // If the node to be deleted is found
    if (curr.data === key) {
        prev.next = curr.next;
        if (curr === last) {
            last = prev;
        }
    } else {
        // If the node to be deleted is not found
        console.log("Node with data " + key + " not found.");
    }

    return last;
}

function printList(last) {
    if (last === null) {
        console.log("List is Empty");
        return;
    }

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next) break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete a specific node
let key = 3;
last = deleteSpecificNode(last, key);

console.log("List after deleting node " + key + ": ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after deleting node 3: 2 4

```
### 3. Deletion at the end of Circular linked list

> To delete the last node in a circular linked list, we first check if the list is empty. If it is, we print a message and return
>
> ****nullptr****
> . If the list contains only one node (where the
>
> ****head****
> is the same as the
>
> ****last****
> ), we delete that node and set
>
> ****last****
> to
>
> ****nullptr****
> . For lists with multiple nodes, we need to traverse the list to find the
>
> ****second last node****
> . We do this by starting from the
>
> ****head****
> and moving through the list until we reach the node whose next pointer points to
>
> ****last****
> . Once we find the
>
> ****second last****
> node then we update its next pointer to point back to the
>
> ****head,****
> this effectively removing the last node from the list. We then delete the last node to free up memory and return the updated
>
> ****last****
> pointer, which now points to the last node.

![Deletion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150601/Deletion-at-the-end-of-circular-linked-list.webp)

Deletion at the end of Circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to delete the last node in the circular linked list
Node* deleteLastNode(Node* last) {
    if (last == nullptr) {
        // If the list is empty
        cout << "List is empty, nothing to delete." << endl;
        return nullptr;
    }
    Node* head = last->next;

    // If there is only one node in the list
    if (head == last) {
        delete last;
        last = nullptr;
        return last;
    }
    // Traverse the list to find the second last node
    Node* curr = head;
    while (curr->next != last) {
        curr = curr->next;
    }
    // Update the second last node\'s next pointer
    // to point to head
    curr->next = head;
    delete last;
    last = curr;

    return last;
}

void printList(Node* last) {
   if(last == NULL) return;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Delete the last node
    last = deleteLastNode(last);

    cout << "List after deleting last node: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node in the circular linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to delete the last node in the circular linked list
struct Node* deleteLastNode(struct Node* last) {
    if (last == NULL) {
        // If the list is empty
        printf("List is empty, nothing to delete.\\n");
        return NULL;
    }
    struct Node* head = last->next;

    // If there is only one node in the list
    if (head == last) {
        free(last);
        last = NULL;
        return last;
    }
    // Traverse the list to find the second last node
    struct Node* curr = head;
    while (curr->next != last) {
        curr = curr->next;
    }
    // Update the second last node\'s next pointer to point to head
    curr->next = head;
    free(last);
    last = curr;

    return last;
}

void printList(struct Node* last) {
    if (last == NULL) return;

    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    // Create circular linked list: 2, 3, 4
    struct Node* first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node* last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Delete the last node
    last = deleteLastNode(last);

    printf("List after deleting last node: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {
    public static Node deleteLastNode(Node last){
        if (last == null) {
            // If the list is empty
            System.out.println(
                "List is empty, nothing to delete.");
            return null;
        }
        Node head = last.next;

        // If there is only one node in the list
        if (head == last) {
            last = null;
            return last;
        }
        // Traverse the list to find the second last node
        Node curr = head;
        while (curr.next != last) {
            curr = curr.next;
        }
        // Update the second last node\'s next pointer to
        // point to head
        curr.next = head;
        last = curr;

        return last;
    }

    public static void printList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Delete the last node
        last = deleteLastNode(last);

        System.out.print("List after deleting last node: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def deleteLastNode(last):
    if last is None:
        # If the list is empty
        print("List is empty, nothing to delete.")
        return None

    head = last.next

    # If there is only one node in the list
    if head == last:
        last = None
        return last

    # Traverse the list to find the second last node
    curr = head
    while curr.next != last:
        curr = curr.next

    # Update the second last node\'s next pointer to point to head
    curr.next = head
    last = curr

    return last

def printList(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)

last = first.next.next
last.next = first

print("Original list: ", end="")
printList(last)

# Delete the last node
last = deleteLastNode(last)

print("List after deleting last node: ", end="")
printList(last)

````

C#

````
using System;

public class Node {
    public int data;
    public Node next;

    public Node(int value)
    {
        data = value;
        next = null;
    }
}

public class GFG {
    // Function to delete the last node in the circular
    // linked list
    public static Node deleteLastNode(Node last)
    {
        if (last == null) {
            // If the list is empty
            Console.WriteLine(
                "List is empty, nothing to delete.");
            return null;
        }
        Node head = last.next;

        // If there is only one node in the list
        if (head == last) {
            last = null;
            return last;
        }
        // Traverse the list to find the second last node
        Node curr = head;
        while (curr.next != last) {
            curr = curr.next;
        }
        // Update the second last node\'s next pointer
        // to point to head
        curr.next = head;
        last = curr;

        return last;
    }

    // Function to print the circular linked list
    public static void printList(Node last)
    {
        if (last == null) {
            Console.WriteLine("List is Empty");
            return;
        }

        Node head = last.next;
        while (true) {
            Console.Write(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        Console.WriteLine();
    }

    public static void Main(string[] args)
    {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        Console.Write("Original list: ");
        printList(last);

        // Delete the last node
        last = deleteLastNode(last);

        Console.Write("List after deleting last node: ");
        printList(last);
    }
}

````

JavaScript

````
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function deleteLastNode(last) {
    if (last === null) {
        // If the list is empty
        console.log("List is empty, nothing to delete.");
        return null;
    }
    let head = last.next;

    // If there is only one node in the list
    if (head === last) {
        last = null;
        return last;
    }
    // Traverse the list to find the second last node
    let curr = head;
    while (curr.next !== last) {
        curr = curr.next;
    }
    // Update the second last node\'s next pointer to point to head
    curr.next = head;
    last = curr;

    return last;
}

function printList(last) {
    if (last === null) return;

    let head = last.next;
    while (true) {
        process.stdout.write(head.data + " ");
        head = head.next;
        if (head === last.next) break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete the last node
last = deleteLastNode(last);

console.log("List after deleting last node: ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after deleting last node: 2 3

```

[Searching in Circular Linked list](https://www.geeksforgeeks.org/searching-in-circular-linked-list/?ref=ml_lbp)
----------------------------------------------------------------------------------------------------------------


Searching in a circular linked list is similar to searching in a regular linked list. We start at a given node and traverse the list until you either find the target value or return to the starting node. Since the list is circular, make sure to keep track of where you started to avoid an infinite loop.


> To search for a specific value in a circular linked list, we first check if the list is empty. If it is then we return
>
> ****false****
> . If the list contains nodes then we start from the
>
> ****head****
> node (which is the
>
> ****last->next****
> ) and traverse the list. We use a pointer
>
> ****curr****
> to iterate through the nodes until we reach back to the
>
> ****head****
> . During traversal, if we find a node whose
>
> ****data****
> matches the given
>
> ****key****
> then we return
>
> ****true****
> to indicating that the value was found. After the loop, we also check the last node to ensure we don’t miss it. If the
>
> ****key****
> is not found after traversing the entire list then we return
>
> ****false****
> .

C++

````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to search for a specific value in the
// circular linked list
bool search(Node* last, int key) {
    if (last == nullptr) {
        // If the list is empty
        return false;
    }

    Node* head = last->next;
    Node* curr = head;

    // Traverse the list to find the key
    while (curr != last) {
        if (curr->data == key) {
          // Key found
            return true;
        }
        curr = curr->next;
    }

    // Check the last node
    if (last->data == key) {
      // Key found
        return true;
    }
    // Key not found
    return false;
}

void printList(Node* last) {
   if(last == NULL) return;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Search for a specific value
    int key = 3;
    bool found = search(last, key);
    if (found) {
        cout << "Value " << key << " found in the list." << endl;
    } else {
        cout << "Value " << key << " not found in the list." << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Definition of the Node structure
struct Node{
    int data;
    struct Node *next;
};

// Function to search for a specific value in the circular linked list
int search(struct Node *last, int key){
    if (last == NULL){
        // If the list is empty
        return 0;
    }

    struct Node *head = last->next;
    struct Node *curr = head;

    // Traverse the list to find the key
    while (curr != last){
        if (curr->data == key){
            // Key found
            return 1;
        }
        curr = curr->next;
    }

    // Check the last node
    if (last->data == key){
        // Key found
        return 1;
    }
    // Key not found
    return 0;
}

// Function to print the circular linked list
void printList(struct Node *last){
    if (last == NULL) return;

    struct Node *head = last->next;
    while (1){
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next)
            break;
    }
    printf("\\n");
}
// Function to create a new node
struct Node *createNode(int value){
    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));
    temp->data = value;
    temp->next = NULL;
    return temp;
}

int main(){
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Search for a specific value
    int key = 3;
    int found = search(last, key);
    if (found){
        printf("Value %d found in the list.\\n", key);
    }
    else{
        printf("Value %d not found in the list.\\n", key);
    }

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;
    Node(int value) {
        data = value;
        next = null;
    }
}

public class CircularLinkedList {
    // Function to search for a specific value
    // in the circular linked list
    static boolean search(Node last, int key) {
        if (last == null) {
            // If the list is empty
            return false;
        }

        Node head = last.next;
        Node curr = head;

        // Traverse the list to find the key
        while (curr != last) {
            if (curr.data == key) {
                // Key found
                return true;
            }
            curr = curr.next;
        }

        // Check the last node
        if (last.data == key) {
            // Key found
            return true;
        }
        // Key not found
        return false;
    }

    static void printList(Node last) {
        if (last == null) return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Search for a specific value
        int key = 3;
        boolean found = search(last, key);
        if (found) {
            System.out.println("Value " + key
                               + " found in the list.");
        } else {
            System.out.println("Value " + key +
                               " not found in the list.");
        }
    }
}

````

Python

````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

def search(last, key):
    if last is None:
        # If the list is empty
        return False

    head = last.next
    curr = head

    # Traverse the list to find the key
    while curr != last:
        if curr.data == key:
            # Key found
            return True
        curr = curr.next

    # Check the last node
    if last.data == key:
        # Key found
        return True
    # Key not found
    return False

def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

if __name__ == "__main__":
    # Create circular linked list: 2, 3, 4
    first = Node(2)
    first.next = Node(3)
    first.next.next = Node(4)

    last = first.next.next
    last.next = first

    print("Original list:", end=" ")
    print_list(last)

    # Search for a specific value
    key = 3
    found = search(last, key)
    if found:
        print(f"Value {key} found in the list.")
    else:
        print(f"Value {key} not found in the list.")

````

C#

````
using System;

public class Node {
    public int data;
    public Node next;
    public Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {
    // Function to search for a specific value in the
    // circular linked list
    public static bool Search(Node last, int key){
        if (last == null) {
            // If the list is empty
            return false;
        }

        Node head = last.next;
        Node curr = head;

        // Traverse the list to find the key
        while (curr != last) {
            if (curr.data == key) {
                // Key found
                return true;
            }
            curr = curr.next;
        }

        // Check the last node
        if (last.data == key) {
            // Key found
            return true;
        }
        // Key not found
        return false;
    }

    public static void PrintList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            Console.Write(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        Console.WriteLine();
    }

    public static void Main(string[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        Console.Write("Original list: ");
        PrintList(last);

        // Search for a specific value
        int key = 3;
        bool found = Search(last, key);
        if (found) {
            Console.WriteLine("Value " + key
                              + " found in the list.");
        }
        else {
            Console.WriteLine("Value " + key
                              + " not found in the list.");
        }
    }
}

````

JavaScript

````
class Node {
    constructor(value){
        this.data = value;
        this.next = null;
    }
}

function search(last, key){
    if (last === null) {
        // If the list is empty
        return false;
    }

    let head = last.next;
    let curr = head;

    // Traverse the list to find the key
    while (curr !== last) {
        if (curr.data === key) {
            // Key found
            return true;
        }
        curr = curr.next;
    }

    // Check the last node
    if (last.data === key) {
        // Key found
        return true;
    }
    // Key not found
    return false;
}

function printList(last){
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        process.stdout.write(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list:");
printList(last);

// Search for a specific value
let key = 3;
let found = search(last, key);
if (found) {
    console.log(`Value ${key} found in the list.`);
}
else {
    console.log(`Value ${key} not found in the list.`);
}

````




**Output**
```
Original list: 2 3 4
Value 3 found in the list.

```

Advantages of Circular Linked Lists
-----------------------------------

* In circular linked list, the last node points to the first node. There are no null references, making traversal easier and reducing the chances of encountering null pointer exceptions.
* We can traverse the list from any node and return to it without needing to restart from the head, which is useful in applications requiring a circular iteration.
* Circular linked lists can easily implement circular queues, where the last element connects back to the first, allowing for efficient resource management.
* In a circular linked list, each node has a reference to the next node in the sequence. Although it doesn’t have a direct reference to the previous node like a doubly linked list, we can still find the previous node by traversing the list.

Disadvantages of Circular Linked Lists
--------------------------------------

* Circular linked lists are more complex to implement than singly linked lists.
* Traversing a circular linked list without a clear stopping condition can lead to infinite loops if not handled carefully.
* Debugging can be more challenging due to the circular nature, as traditional methods of traversing linked lists may not apply.

Applications of Circular Linked Lists
-------------------------------------

* It is used for time-sharing among different users, typically through a

  ****Round-Robin scheduling mechanism.****
* In multiplayer games, a circular linked list can be used to switch between players. After the last player’s turn, the list cycles back to the first player.
* Circular linked lists are often used in buffering applications, such as streaming data, where data is continuously produced and consumed.
* In media players, circular linked lists can manage playlists, this allowing users to loop through songs continuously.
* Browsers use circular linked lists to manage the cache. This allows you to navigate back through your browsing history efficiently by pressing the BACK button.
', 'A circular linked list is a data structure where the last node connects back to the first, forming a loop. This structure allows for continuous traversal without any interruptions. Circular linked lists are especially helpful for tasks like scheduling and managing playlists, this allowing for smooth navigation. In this tutorial, we’ll cover the basics of circular linked lists, how to work with them, their advantages and disadvantages, and their applications.', 'Introduction to Circular Linked List', 3, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('184c2a73-cbb4-45dd-9892-6ee6acc78a7b', e'Advantages of Linked Lists (or Most Common Use Cases):
------------------------------------------------------

* Linked Lists are mostly used because of their effective insertion and deletion.  We only need to change few pointers (or references) to insert (or delete) an item in the middle
* [Insertion and deletion](https://www.geeksforgeeks.org/insertion-deletion-stl-set-c/)
  at any point in a linked list take O(1) time. Whereas in an

  [array](https://www.geeksforgeeks.org/array-data-structure/)
  data structure, insertion / deletion in the middle takes O(n) time.
* This data structure is simple and can be also used to implement

  [a stack](https://www.geeksforgeeks.org/stack-data-structure/)
  ,

  [queues,](https://www.geeksforgeeks.org/queue-data-structure/)
  and other

  [abstract data structures](https://www.geeksforgeeks.org/abstract-data-types/)
  .
* Implementation of Queue and Deque data structures : Simple array implementation is not efficient at all. We must use circular array to efficiently implement which is complex. But with linked list, it is easy and straightforward. That is why most of the language libraries use Linked List internally to implement these data structures..
* Linked List might turn out to be more space efficient compare to arrays in cases where we cannot guess the number of elements in advance. In case of arrays, the whole memory for items is allocated together. Even with dynamic sized arrays like vector in C++ or list in Python or ArrayList in Java. the internal working involves de-allocation of whole memory and allocation of a bigger chunk when insertions happen beyond the current capacity.

Applications of Linked Lists:
-----------------------------

* Linked Lists can be used to implement stacks, queue, deque,

  [sparse matrices](https://www.geeksforgeeks.org/sparse-matrix-representation/)
  and adjacency list representation of graphs.
* [Dynamic memory allocation](https://www.geeksforgeeks.org/what-is-dynamic-memory-allocation/)
  in operating systems and compilers (linked list of free blocks).
* Manipulation of polynomials
* Arithmetic operations on long integers.
* In operating systems, they can be used in Memory management, process scheduling (for example circular linked list for round robin scheduling) and file system.
* Algorithms that need to frequently insert or delete items from large collections of data.
* LRU cache, which uses a doubly linked list to keep track of the most recently used items in a cache.

Applications of Linked Lists in real world:
-------------------------------------------

* The list of songs in the music player are linked to the previous and next songs.
* In a web browser, previous and next web page URLs can be linked through the previous and next buttons (Doubly Linked List)
* In image viewer, the previous and next images can be linked with the help of the previous and next buttons (Doubly Linked List)
* Circular Linked Lists can be used to implement things in round manner where we go to every element one by one.
* Linked List are preferred over arrays for implementations of Queue and Deque data structures because of fast deletions (or insertions) from the front of the linked lists.

Disadvantages of Linked Lists:
------------------------------


Linked lists are a popular data structure in computer science, but like any other data structure, they have certain disadvantages as well. Some of the key disadvantages of linked lists are:


* ****Slow Access Time:****
  Accessing elements in a linked list can be slow, as you need to traverse the linked list to find the element you are looking for, which is an O(n) operation. This makes linked lists a poor choice for situations where you need to access elements quickly.
* ****Pointers or References:****
  Linked lists use pointers or references to access the next node, which can make them more complex to understand and use compared to arrays. This complexity can make linked lists more difficult to debug and maintain.
* ****Higher overhead:****
  Linked lists have a higher overhead compared to arrays, as each node in a linked list requires extra memory to store the reference to the next node.
* ****Cache Inefficiency:****
  Linked lists are cache-inefficient because the memory is not contiguous. This means that when you traverse a linked list, you are not likely to get the data you need in the cache, leading to cache misses and slow performance.


In conclusion, linked lists are a powerful and flexible data structure, but they have certain disadvantages that need to be taken into consideration when deciding whether to use them or not. For example, if you need fast access time, arrays might be a better choice, but if you need to insert or delete elements frequently, linked lists might be the better choice.
', 'A Linked List is a linear data structure that is used to store a collection of data with the help of nodes. Please remember the following points before moving forward.', 'Applications, Advantages and Disadvantages of Linked List', 4, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('e6b3784f-3ef1-4b59-896b-06430bafe574', e'Given a Singly Linked List, the task is to find the Length of the Linked List.


****Examples:****


> ****Input:****
> LinkedList = 1->3->1->2->1
>
>
>
> ****Output:****
> 5
>
>
> ****Input:****
> LinkedList = 2->4->1->9->5->3->6
>
>
>
> ****Output:****
> 7

Iterative Approach to Find the Length of a Linked List:
-------------------------------------------------------

> The idea is similar to
>
> [traversal of Linked List](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)
> with an additional variable
>
>
> to count the number of nodes in the Linked List.


Following is the approach to find the length of the Linked List:


* Initialize count as 0.
* Initialize a node pointer, curr = head.
* Do following while curr is not NULL
  + curr = curr -> next
  + Increment count by 1.
* Return count.


Below is the implementation of the above approach:


C++

````
// Iterative C++ program to find length
// or count of nodes in a linked list

#include <bits/stdc++.h>
using namespace std;

// Link list node
class Node {
public:
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// Counts number of nodes in linked list
int countNodes(Node* head) {

    // Initialize count with 0
    int count = 0;

    // Initialize curr with head of Linked List
    Node* curr = head;

    // Traverse till we reach nullptr
    while (curr != nullptr) {

          // Increment count by 1
        count++;

          // Move pointer to next node
        curr = curr->next;
    }

      // Return the count of nodes
    return count;
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 1 -> 3 -> 1 -> 2 -> 1
    Node* head = new Node(1);
    head->next = new Node(3);
    head->next->next = new Node(1);
    head->next->next->next = new Node(2);
    head->next->next->next->next = new Node(1);

    // Function call to count the number of nodes
    cout << "Count of nodes is " << countNodes(head);
    return 0;
}

````

C

````
// Iterative C program to find length or count of nodes in a
// linked list

#include <stdio.h>
#include <stdlib.h>

// Link list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node =
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Counts number of nodes in linked list
int countNodes(struct Node* head) {
    // Initialize count with 0
    int count = 0;

    // Initialize curr with head of Linked List
    struct Node* curr = head;

    // Traverse till we reach NULL
    while (curr != NULL) {

        // Increment count by 1
        count++;

          // Move pointer to next node
        curr = curr->next;
    }

    // Return the count of nodes
    return count;
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 1 -> 3 -> 1 -> 2 -> 1
    struct Node* head = createNode(1);
    head->next = createNode(3);
    head->next->next = createNode(1);
    head->next->next->next = createNode(2);
    head->next->next->next->next = createNode(1);

    // Function call
    printf("Count of nodes is %d", countNodes(head));
    return 0;
}

````

Java

````
// Iterative Java program to count the number of
// nodes in a linked list

// Node class to define a linked list node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int newData) {
        data = newData;
        next = null;
    }
}

// Class to define methods related to the linked list
public class GFG {

    // Counts number of nodes in linked list
    public static int countNodes(Node head) {

        // Initialize count with 0
        int count = 0;

        // Initialize curr with head of Linked List
        Node curr = head;

        // Traverse till we reach null
        while (curr != null) {

            // Increment count by 1
            count++;

            // Move pointer to next node
            curr = curr.next;
        }
        // Return the count of nodes
        return count;
    }

    // Driver code
    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 3 -> 1 -> 2 -> 1
        Node head = new Node(1);
        head.next = new Node(3);
        head.next.next = new Node(1);
        head.next.next.next = new Node(2);
        head.next.next.next.next = new Node(1);

        // Function call to count the number of nodes
        System.out.println("Count of nodes is "
                           + countNodes(head));
    }
}

````

Python

````
# Iterative Python program to count the number of nodes
# in a linked list


class Node:
    def __init__(self, new_data):

        # Constructor to initialize a new node with data
        self.data = new_data
        self.next = None


def count_nodes(head):

    # Counts number of nodes in linked list
    # Initialize count with 0
    count = 0

    # Initialize curr with head of Linked List
    curr = head

    # Traverse till we reach None
    while curr is not None:
        # Increment count by 1
        count += 1

        # Move pointer to next node
        curr = curr.next

    # Return the count of nodes
    return count


# Driver code
if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 3 -> 1 -> 2 -> 1
    head = Node(1)
    head.next = Node(3)
    head.next.next = Node(1)
    head.next.next.next = Node(2)
    head.next.next.next.next = Node(1)

    # Function call to count the number of nodes
    print("Count of nodes is", count_nodes(head))

````

C#

````
// Iterative C# program to find length or count of nodes
// in a linked list

using System;

// Link list node
class Node {
    public int Data;
    public Node Next;

    // Constructor to initialize a new node with data
    public Node(int newData) {
        Data = newData;
        Next = null;
    }
}

class GFG {

    // Counts number of nodes in linked list
    static int CountNodes(Node head) {

          // Initialize count with 0
        int count = 0;

        // Initialize curr with head of Linked List
        Node curr = head;

        // Traverse till we reach null
        while (curr != null) {
            // Increment count by 1
            count++;

            // Move pointer to next node
            curr = curr.Next;
        }

        // Return the count of nodes
        return count;
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 3 -> 1 -> 2 -> 1
        Node head = new Node(1);
        head.Next = new Node(3);
        head.Next.Next = new Node(1);
        head.Next.Next.Next = new Node(2);
        head.Next.Next.Next.Next = new Node(1);

        // Function call to count the number of nodes
        Console.WriteLine("Count of nodes is "
                          + CountNodes(head));
    }
}

````

JavaScript

````
// Iterative JavaScript program to find length
// or count of nodes in a linked list

// Linked List Node
class Node {

    // Constructor to initialize a new node
    // with data
    constructor(newData) {
        this.data = newData;
        this.next = null;
    }
}

// Counts number of nodes in linked list
function countNodes(head) {
    // Initialize count with 0
    let count = 0;

    // Initialize curr with head of Linked List
    let curr = head;

    // Traverse till we reach null
    while (curr !== null) {

        // Increment count by 1
        count++;

        // Move pointer to next node
        curr = curr.next;
    }

    // Return the count of nodes
    return count;
}

// Driver code

// Create a hard-coded linked list:
// 1 -> 3 -> 1 -> 2 -> 1
let head = new Node(1);
head.next = new Node(3);
head.next.next = new Node(1);
head.next.next.next = new Node(2);
head.next.next.next.next = new Node(1);

// Function call to count the number of nodes
console.log("Count of nodes is " + countNodes(head));

````




**Output**
```
Count of nodes is 5
```

****Time complexity:****
O(N), Where

****N****
is the size of the linked list



****Auxiliary Space:****
O(1), As constant extra space is used.


Recursive Approach to Find the Length of a Linked List:
-------------------------------------------------------

> The idea is to use
>
> [recursion](https://www.geeksforgeeks.org/introduction-to-recursion-data-structure-and-algorithm-tutorials/)
> by maintaining a function, say
>
> ****countNodes(node)****
> which takes a node as an argument and calls itself with the next node until we reach the end of the Linked List. Each of the recursive call returns
>
> ****1 + count of remaining nodes****
> .


Below is the implementation of the above approach:


C++

````
// Recursive C++ program to find length
// or count of nodes in a linked list

#include <bits/stdc++.h>
using namespace std;

// Link list node
class Node {
public:
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// Recursively count number of nodes in linked list
int countNodes(Node* head) {

    // Base Case
    if (head == NULL) {
        return 0;
    }

    // Count this node plus the rest of the list
    return 1 + countNodes(head->next);
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 1 -> 3 -> 1 -> 2 -> 1
    Node* head = new Node(1);
    head->next = new Node(3);
    head->next->next = new Node(1);
    head->next->next->next = new Node(2);
    head->next->next->next->next = new Node(1);

    // Function call to count the number of nodes
    cout << "Count of nodes is " << countNodes(head);
    return 0;
}

````

C

````
// Recursive C program to find length
// or count of nodes in a linked list

#include <stdio.h>
#include <stdlib.h>

// Link list node
struct Node {
    int data;
    struct Node* next;
};

// Constructor to initialize a new node with data
struct Node* createNode(int new_data) {
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Recursively count number of nodes in linked list
int countNodes(struct Node* head) {

    // Base Case
    if (head == NULL) {
        return 0;
    }

    // Count this node plus the rest of the list
    return 1 + countNodes(head->next);
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 1 -> 3 -> 1 -> 2 -> 1
    struct Node* head = createNode(1);
    head->next = createNode(3);
    head->next->next = createNode(1);
    head->next->next->next = createNode(2);
    head->next->next->next->next = createNode(1);

    // Function call to count the number of nodes
    printf("Count of nodes is %d\\n", countNodes(head));
    return 0;
}

````

Java

````
// Recursive Java program to find length
// or count of nodes in a linked list

// Link list node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

// Recursively count number of nodes in linked list
public class GFG {
    public static int countNodes(Node head) {

        // Base Case
        if (head == null) {
            return 0;
        }

        // Count this node plus the rest of the list
        return 1 + countNodes(head.next);
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 3 -> 1 -> 2 -> 1
        Node head = new Node(1);
        head.next = new Node(3);
        head.next.next = new Node(1);
        head.next.next.next = new Node(2);
        head.next.next.next.next = new Node(1);

        // Function call to count the number of nodes
        System.out.println("Count of nodes is "
                           + countNodes(head));
    }
}

````

Python

````
# Recursive Python program to find length
# or count of nodes in a linked list

# Linked List Node
class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Recursively count number of nodes in linked list
def count_nodes(head):
    # Base Case
    if head is None:
        return 0

    # Count this node plus the rest of the list
    return 1 + count_nodes(head.next)


# Driver code
if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 3 -> 1 -> 2 -> 1
    head = Node(1)
    head.next = Node(3)
    head.next.next = Node(1)
    head.next.next.next = Node(2)
    head.next.next.next.next = Node(1)

    # Function call to count the number of nodes
    print("Count of nodes is", count_nodes(head))

````

C#

````
// Recursive C# program to find length
// or count of nodes in a linked list

using System;

// Link list node
public class Node {
    public int Data;
    public Node Next;

    // Constructor to initialize a new node with data
    public Node(int new_data) {
        Data = new_data;
        Next = null;
    }
}

// Recursively count number of nodes in linked list
public class GFG {
    public static int CountNodes(Node head) {

        // Base Case
        if (head == null) {
            return 0;
        }

        // Count this node plus the rest of the list
        return 1 + CountNodes(head.Next);
    }

    // Driver code
    public static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 3 -> 1 -> 2 -> 1
        Node head = new Node(1);
        head.Next = new Node(3);
        head.Next.Next = new Node(1);
        head.Next.Next.Next = new Node(2);
        head.Next.Next.Next.Next = new Node(1);

        // Function call to count the number of nodes
        Console.WriteLine("Count of nodes is " + CountNodes(head));
    }
}

````

JavaScript

````
// Recursive Javascript program to find length
// or count of nodes in a linked list

// Link list node
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// Recursively count number of nodes in linked list
function countNodes(head) {

    // Base Case
    if (head === null) {
        return 0;
    }

    // Count this node plus the rest of the list
    return 1 + countNodes(head.next);
}

// Driver code
// Create a hard-coded linked list:
// 1 -> 3 -> 1 -> 2 -> 1
let head = new Node(1);
head.next = new Node(3);
head.next.next = new Node(1);
head.next.next.next = new Node(2);
head.next.next.next.next = new Node(1);

// Function call to count the number of nodes
console.log("Count of nodes is " + countNodes(head));

````




**Output**
```
Count of nodes is 5
```

****Time Complexity:****
O(N), where

****N****
is the length of Linked List.



****Auxiliary Space:****
O(N), Extra space is used in the recursion call stack.', '', 'Find Length of a Linked List (Iterative and Recursive)', 5, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('522fe91a-61af-4a65-9b20-bb62618061e5', e'Given a Singly Linked List, the task is to print all the elements in the list.


****Examples:****

> ****Input:****
> 1->2->3->4->5->null
>
>
>
> ****Output:****
> 1 2 3 4 5
>
>
>
> ****Explanation:****
> Every element of each node from head node to last node is printed.
>
>
> ****Input:****
> 10->20->30->40->50->null
>
>
>
> ****Output:****
> 10 20 30 40 50
>
>
>
> ****Explanation:****
> Every element of each node from head node to last node is printed.

Table of Content

* [Iterative Approach - O(n) Time and O(1) Space](#iterative-approach-on-time-and-o1-space)
* [Recursive Approach - O(n) Time and O(n) Memory Space](#recursive-approach-on-time-and-on-memory-space)
### Iterative Approach - O(n) Time and O(1) Space


The process of printing a

****singly linked list****
involves printing the value of each node and then going on to the next node and print that node\'s value also and so on, till we reach the last node in the singly linked list, whose next node points towards the null.


****Step-by-Step Algorithm****

> * We will initialize a temporary pointer to the head node of the singly linked list.
> * After that, we will check if that pointer is null or not null, if it is null, then return.
> * While the pointer is not null, we will access and print the data of the current node, then we move the pointer to next node.


Program to Print the Singly Linked List using Iteration.


C++

````
//Driver Code Starts{
#include <iostream>

using namespace std;

//Driver Code Ends }

// A linked list node
class Node {
public:
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        this->data = new_data;
        this->next = nullptr;
    }
};

// Function to print the singly linked list
void printList(Node* head) {

    // A loop that runs till head is nullptr
    while (head != nullptr) {

        // Printing data of current node
        cout << head->data << " ";

        // Moving to the next node
        head = head->next;
    }
}

//Driver Code Starts{

int main() {

    // Create a linked list: 10 -> 20 -> 30 -> 40
    Node* head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);
    head->next->next->next = new Node(40);

    printList(head);

    return 0;
}

//Driver Code Ends }

````

C

````
//Driver Code Starts{
#include <stdio.h>
#include <stdlib.h>

//Driver Code Ends }

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node->data = new_data;
    node->next = NULL;
    return node;
}

// Function to print the singly linked list
void printList(struct Node* head) {

    // A loop that runs till head is NULL
    while (head != NULL) {

        // Printing data of current node
        printf("%d ", head->data);

        // Moving to the next node
        head = head->next;
    }
}

//Driver Code Starts{

int main() {

    // Create a linked list: 10 -> 20 -> 30 -> 40
    struct Node* head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    printList(head);

    return 0;
}

//Driver Code Ends }

````

Java

````
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int newData) {
        this.data = newData;
        this.next = null;
    }
}

class GfG {

    // Function to print the singly linked list
    static void printList(Node head) {

        // A loop that runs till head is null
        while (head != null) {

            // Printing data of current node
            System.out.print(head.data + " ");

            // Moving to the next node
            head = head.next;
        }
    }

//Driver Code Starts{
    public static void main(String[] args) {

        // Create a linked list: 10 -> 20 -> 30 -> 40
        Node head = new Node(10);
        head.next = new Node(20);
        head.next.next = new Node(30);
        head.next.next.next = new Node(40);

        printList(head);
    }
}

//Driver Code Ends }

````

Python

````
# A linked list node
class Node:
    def __init__(self, newData):
        # Constructor to initialize a new node with data
        self.data = newData
        self.next = None

# Function to print the singly linked list
def printList(head):

    # A loop that runs till head is None
    while head is not None:

        # Printing data of current node
        print(head.data, end=" ")

        # Moving to the next node
        head = head.next

if __name__ == "__main__":

#Driver Code Starts{
    # Create a linked list: 10 -> 20 -> 30 -> 40
    head = Node(10)
    head.next = Node(20)
    head.next.next = Node(30)
    head.next.next.next = Node(40)

    printList(head)

#Driver Code Ends }

````

C#

````
//Driver Code Starts{
using System;

//Driver Code Ends }

class Node {
    public int data;
    public Node next;

    // Constructor to initialize a new node with data
    public Node(int new_data) {
        this.data = new_data;
        this.next = null;
    }
}

class GfG {

    // Function to print the singly linked list
    static void printList(Node head) {

        // A loop that runs till head is null
        while (head != null) {

            // Printing data of current node
            Console.Write(head.data + " ");

            // Moving to the next node
            head = head.next;
        }
    }

//Driver Code Starts{

    static void Main(string[] args) {

        // Create a linked list: 10 -> 20 -> 30 -> 40
        Node head = new Node(10);
        head.next = new Node(20);
        head.next.next = new Node(30);
        head.next.next.next = new Node(40);

        printList(head);
    }
}

//Driver Code Ends }

````

JavaScript

````
class Node {
    constructor(newData) {
        // Constructor to initialize a new node with data
        this.data = newData;
        this.next = null;
    }
}

// Function to print the singly linked list
function printList(head) {

	let result = \'\';

    // A loop that runs till head is null
    while (head !== null) {

        // Printing data of current node
        result += head.data + \' \';

        // Moving to the next node
        head = head.next;
    }

    console.log(result.trim());
}

//Driver Code Starts{
// Driver Code

// Create a linked list: 10 -> 20 -> 30 -> 40
const head = new Node(10);
head.next = new Node(20);
head.next.next = new Node(30);
head.next.next.next = new Node(40);

printList(head);


//Driver Code Ends }

````




**Output**
```
10 20 30 40

```

****Time Complexity:****
O(n), where

****n****
is the number of nodes in the linked list.



****Auxiliary Space:****
O(1)


### Recursive Approach - O(n) Time and O(n) Memory Space


We can also traverse the singly linked list using recursion. We start at the head node of the singly linked list, check if it is null or not and print its value. We then call the traversal function again with the next node passed as pointer.


****Step-by-Step Algorithm****

> * Firstly, we define a recursive method to traverse the singly linked list, which takes a node as a parameter.
> * In this function, the base case is that if the node is null then we will return from the recursive method.
> * We then pass the head node as the parameter to this function.
> * After that, we access and print the data of the current node.
> * At last, we will make a recursive call to this function with the next node as the parameter.


Program to Print the Singly Linked List using Recursion.


C++

````
#include <iostream>
using namespace std;

// A linked list node
class Node {
public:
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        this->data = new_data;
        this->next = nullptr;
    }
};

// Function to print the singly linked list
void printList(Node* head) {

    // Base condition is when the head is nullptr
    if (head == nullptr) {
        return;
    }

    // Printing the current node data
    cout << head->data << " ";

    // Moving to the next node
    printList(head->next);
}

int main() {

    // Create a linked list: 10 -> 20 -> 30 -> 40
    Node* head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);
    head->next->next->next = new Node(40);

    printList(head);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node with given data
struct Node* createNode(int new_data) {
    struct Node* new_node
        = (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Function to print the singly linked list
void printList(struct Node* head) {

    // Base condition is when the head is nullptr
    if (head == NULL) {
        return;
    }

    // Printing the current node data
    printf("%d ", head->data);

    // Moving to the next node
    printList(head->next);
}

int main() {

    // Create a linked list: 10 -> 20 -> 30 -> 40
    struct Node* head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    printList(head);

    return 0;
}

````

Java

````
// A linked list node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

class GfG {

    // Function to print the singly linked list
    static void printList(Node head) {

        // Base condition is when the head is nullptr
        if (head == null) {
            return;
        }

        // Printing the current node data
        System.out.print(head.data + " ");

        // Moving to the next node
        printList(head.next);
    }

    public static void main(String[] args) {

        // Create a linked list: 10 -> 20 -> 30 -> 40
        Node head = new Node(10);
        head.next = new Node(20);
        head.next.next = new Node(30);
        head.next.next.next = new Node(40);

        printList(head);
    }
}

````

Python

````
# A linked list node
class Node:
    def __init__(self, data):

        # Constructor to initialize a new node with data
        self.data = data
        self.next = None

# Function to print the singly linked list
def printList(head):

    # Base condition is when the head is nullptr
    if head is None:
        return

    # Printing the current node data
    print(head.data, end=" ")

    # Moving to the next node
    printList(head.next)

if __name__ == "__main__":

    # Create a linked list: 10 -> 20 -> 30 -> 40
    head = Node(10)
    head.next = Node(20)
    head.next.next = Node(30)
    head.next.next.next = Node(40)

    printList(head)

````

C#

````
using System;

// A linked list node
class Node {
    public int Data { get;set; }
    public Node Next { get;set; }

    // Constructor to initialize a new node with data
    public Node(int newData) {
        Data = newData;
        Next = null;
    }
}

class GfG {

    // Function to print the singly linked list
    static void printList(Node head) {

        // Base condition is when the head is nullptr
        if (head == null) {
            return;
        }

        // Printing the current node data
        Console.Write(head.Data + " ");

        // Moving to the next node
        printList(head.Next);
    }

    static void Main() {

        // Create a linked list: 10 -> 20 -> 30 -> 40
        Node head = new Node(10);
        head.Next = new Node(20);
        head.Next.Next = new Node(30);
        head.Next.Next.Next = new Node(40);

        printList(head);
    }
}

````




**Output**
```
10 20 30 40

```

****Time Complexity:****
O(n), where

****n****
is number of nodes in the linked list.



****Space complexity:****
O(n) because of recursive stack space.', '', 'Print Linked List', 6, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('52d5e2e5-8598-413c-be15-d5c2a0db1948', e'Given a linked list and a

****key****
, the task is to check if

****key****
is present in the linked list or not.


****Examples:****

> ****Input:****
> 14 -> 21 -> 11 -> 30 -> 10, key = 14
>
>
>
> ****Output:****
> Yes
>
>
>
> ****Explanation:****
> 14 is present in the linked list.
>
>
> ****Input:****
> 6 -> 21 -> 17 -> 30 -> 10 -> 8, key = 13
>
>
>
> ****Output:****
> No
>
>
>
> ****Explanation:****
> No node in the linked list has value = 13.

Table of Content

* [Search an element in a Linked List (Iterative Approach) – O(N) Time and O(1) Space](#search-an-element-in-a-linked-list-iterative-approach)
* [Search an element in a Linked List (Recursive Approach) – O(N) Time and O(N) Space](#search-an-element-in-a-linked-list-recursive-approach)

Search an element in a Linked List (Iterative Approach) – O(N) Time and O(1) Space:
-----------------------------------------------------------------------------------

> The idea is to traverse all the nodes of the linked list, starting from the
>
> ****head****
> . While traversing, if we find a node whose value is equal to
>
> ****key****
> then print “Yes”, otherwise print “No”.


Follow the below steps to solve the problem:



* Initialize a node pointer,

  ****curr = head****
  .
* Do following while current is not NULL
  + If the current value (i.e.,

    ****curr->key****
    ) is equal to the key being searched return true.
  + Otherwise, move to the next node (

    ****curr = curr->next****
    ).
* If the key is not found, return false


Below is the implementation of the above approach.



C++

````
// Iterative C++ program to search
// an element in linked list

#include <iostream>
using namespace std;

// A linked list node
class Node {
public:
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data)
    {
        data = new_data;
        next = nullptr;
    }
};

// Checks whether key is present in linked list
bool searchKey(Node* head, int key) {

    // Initialize curr with the head of linked list
    Node* curr = head;

    // Iterate over all the nodes
    while (curr != NULL) {

        // If the current node\'s value is equal to key,
        // return true
        if (curr->data == key)
            return true;

        // Move to the next node
        curr = curr->next;
    }

    // If there is no node with value as key, return false
    return false;
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 14 -> 21 -> 13 -> 30 -> 10
    Node* head = new Node(14);
    head->next = new Node(21);
    head->next->next = new Node(13);
    head->next->next->next = new Node(30);
    head->next->next->next->next = new Node(10);

      // Key to search in the linked list
      int key = 14;

    if (searchKey(head, key))
        cout << "Yes";
    else
        cout << "No";

    return 0;
}

````

C

````
// Iterative C program to search
// an element in linked list

#include <stdio.h>
#include <stdbool.h>

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node =
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Checks whether key is present in linked list
bool searchKey(struct Node* head, int key) {

    // Initialize curr with the head of linked list
    struct Node* curr = head;

    // Iterate over all the nodes
    while (curr != NULL) {

        // If the current node\'s value is equal to key,
        // return true
        if (curr->data == key)
            return true;

        // Move to the next node
        curr = curr->next;
    }

    // If there is no node with value as key, return false
    return false;
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 14 -> 21 -> 13 -> 30 -> 10
    struct Node* head = createNode(14);
    head->next = createNode(21);
    head->next->next = createNode(13);
    head->next->next->next = createNode(30);
    head->next->next->next->next = createNode(10);

      // Key to search in the linked list
      int key = 14;

    if (searchKey(head, key))
        printf("Yes");
    else
        printf("No");

    return 0;
}

````

Java

````
// Iterative Java program to search
// an element in linked list

// A Linked List Node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

public class GFG {

    // Checks whether key is present in linked list
    static boolean searchKey(Node head, int key) {

        // Initialize curr with the head of linked list
        Node curr = head;

        // Iterate over all the nodes
        while (curr != null) {

            // If the current node\'s value is equal to key,
            // return true
            if (curr.data == key)
                return true;

            // Move to the next node
            curr = curr.next;
        }

        // If there is no node with value as key, return
        // false
        return false;
    }

      // Driver code
    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 14 -> 21 -> 13 -> 30 -> 10
        Node head = new Node(14);
        head.next = new Node(21);
        head.next.next = new Node(13);
        head.next.next.next = new Node(30);
        head.next.next.next.next = new Node(10);

        // Key to search in the linked list
        int key = 14;

        if (searchKey(head, key))
            System.out.println("Yes");
        else
            System.out.println("No");
    }
}

````

Python

````
# Iterative Python program to search
# an element in linked list

# A Linked List Node
class Node:

      # Constructor to intialize a node with data
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Checks whether key is present in linked list
def search_key(head, key):

    # Initialize curr with the head of linked list
    curr = head

    # Iterate over all the nodes
    while curr is not None:

        # If the current node\'s value is equal to key,
        # return true
        if curr.data == key:
            return True

        # Move to the next node
        curr = curr.next

    # If there is no node with value as key, return false
    return False

# Driver code
if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 14 -> 21 -> 13 -> 30 -> 10
    head = Node(14)
    head.next = Node(21)
    head.next.next = Node(13)
    head.next.next.next = Node(30)
    head.next.next.next.next = Node(10)

    # Key to search in the linked list
    key = 14

    if search_key(head, key):
        print("Yes")
    else:
        print("No")

````

C#

````
// Iterative C# program to search
// an element in linked list

using System;

// A Linked List Node
class Node {
    public int Data;
    public Node Next;

    // Constructor to initialize a new node with data
    public Node(int new_data) {
        Data = new_data;
        Next = null;
    }
}

// Driver code
class GFG {

    // Checks whether key is present in linked list
    static bool SearchKey(Node head, int key) {

        // Initialize curr with the head of linked list
        Node curr = head;

        // Iterate over all the nodes
        while (curr != null) {

            // If the current node\'s value is equal to key,
            // return true
            if (curr.Data == key)
                return true;

            // Move to the next node
            curr = curr.Next;
        }

        // If there is no node with value as key, return
        // false
        return false;
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 14 -> 21 -> 13 -> 30 -> 10
        Node head = new Node(14);
        head.Next = new Node(21);
        head.Next.Next = new Node(13);
        head.Next.Next.Next = new Node(30);
        head.Next.Next.Next.Next = new Node(10);

        // Key to search in the linked list
        int key = 14;

        if (SearchKey(head, key))
            Console.WriteLine("Yes");
        else
            Console.WriteLine("No");
    }
}

````

JavaScript

````
// Iterative JavaScript program to search
// an element in linked list

// A Linked List Node
class Node {

    // Constructor to initialize a new node with data
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Checks whether key is present in linked list
function searchKey(head, key) {

    // Initialize curr with the head of linked list
    let curr = head;

    // Iterate over all the nodes
    while (curr !== null) {

        // If the current node\'s value is equal to key,
        // return true
        if (curr.data === key)
            return true;

        // Move to the next node
        curr = curr.next;
    }

    // If there is no node with value as key, return false
    return false;
}

// Driver code

// Create a hard-coded linked list:
// 14 -> 21 -> 13 -> 30 -> 10
let head = new Node(14);
head.next = new Node(21);
head.next.next = new Node(13);
head.next.next.next = new Node(30);
head.next.next.next.next = new Node(10);

// Key to search in the linked list
let key = 14;

if (searchKey(head, key))
console.log("Yes");
else
console.log("No");

````




**Output**
```
Yes
```

****Time Complexity:****
O(N), Where

****N****
is the number of nodes in the Linked List.



****Auxiliary Space:****
O(1)


Search an element in a Linked List (Recursive Approach) – O(N) Time and O(N) Space:
-----------------------------------------------------------------------------------

> The idea is to recursively traverse all the nodes starting from the
>
> ****head****
> of linked list. For any node, if the value is equal to
>
> ****key****
> , then return true. Otherwise, recursively search the next node. If at any point the head reaches
>
> ****NULL****
> , it means that we have reached the end of linked list so return
>
> ****false****
> .


Follow the below steps to solve the problem:


* If the head is NULL, return false.
* If the head’s key is the same as

  ****X****
  , return true;
* Else recursively search in the next node.


Below is the recursive implementation of the above algorithm.


C++

````
// Recursive C++ program to search
// an element in linked list

#include <iostream>
using namespace std;

// A Linked List Node
struct Node {
    int data;
    Node* next;

      // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// Checks whether the key is present in linked list
bool searchKey(struct Node* head, int key) {

    // Base case
    if (head == NULL)
        return false;

    // If key is present in current node, return true
    if (head->data == key)
        return true;

    // Recur for remaining list
    return searchKey(head->next, key);
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 14 -> 21 -> 13 -> 30 -> 10
    struct Node* head = new Node(14);
    head->next = new Node(21);
    head->next->next = new Node(13);
    head->next->next->next = new Node(30);
    head->next->next->next->next = new Node(10);

      // Key to search in the linked list
      int key = 14;

    if (searchKey(head, key))
        printf("Yes");
    else
        printf("No");

    return 0;
}

````

C

````
// Recursive C program to search
// an element in linked list

#include <stdio.h>
#include <stdbool.h>

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node =
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Checks whether the key is present in linked list
bool searchKey(struct Node* head, int key) {

    // Base case
    if (head == NULL)
        return 0;

    // If key is present in current node, return true
    if (head->data == key)
        return 1;

    // Recur for remaining list
    return searchKey(head->next, key);
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 14 -> 21 -> 13 -> 30 -> 10
    struct Node* head = createNode(14);
    head->next = createNode(21);
    head->next->next = createNode(13);
    head->next->next->next = createNode(30);
    head->next->next->next->next = createNode(10);

      // Key to search in the linked list
      int key = 14;

    if (searchKey(head, key))
        printf("Yes");
    else
        printf("No");

    return 0;
}

````

Java

````
// Recursive Java program to search
// an element in linked list

// A Linked List Node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

// Driver code
public class GFG {

    // Checks whether the key is present in linked list
    static boolean searchKey(Node head, int key) {

        // Base case
        if (head == null)
            return false;

        // If key is present in current node, return true
        if (head.data == key)
            return true;

        // Recur for remaining list
        return searchKey(head.next, key);
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 14 -> 21 -> 13 -> 30 -> 10
        Node head = new Node(14);
        head.next = new Node(21);
        head.next.next = new Node(13);
        head.next.next.next = new Node(30);
        head.next.next.next.next = new Node(10);

        // Key to search in the linked list
        int key = 14;

        if (searchKey(head, key))
            System.out.println("Yes");
        else
            System.out.println("No");
    }
}

````

Python

````
# Recursive Python program to search
# an element in linked list

# A Linked List Node
class Node:

      # Constructor to initialize a new node with data
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Checks whether the key is present in linked list
def searchKey(head, key):

    # Base case
    if head is None:
        return False

    # If key is present in current node, return true
    if head.data == key:
        return True

    # Recur for remaining list
    return searchKey(head.next, key)

# Driver code
if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 14 -> 21 -> 13 -> 30 -> 10
    head = Node(14)
    head.next = Node(21)
    head.next.next = Node(13)
    head.next.next.next = Node(30)
    head.next.next.next.next = Node(10)

    # Key to search in the linked list
    key = 14

    if searchKey(head, key):
        print("Yes")
    else:
        print("No")

````

C#

````
// Recursive C# program to search
// an element in linked list

using System;

// A Linked List Node
class Node {
    public int data;
    public Node next;

    // Constructor to initialize a new node with data
    public Node(int new_data) {
        data = new_data;
        next = null;
    }
}

// Checks whether the key is present in linked list
class GFG {

      // Checks whether the key is present in linked list
    static bool SearchKey(Node head, int key) {

        // Base case
        if (head == null)
            return false;

        // If key is present in current node, return true
        if (head.data == key)
            return true;

        // Recur for remaining list
        return SearchKey(head.next, key);
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 14 -> 21 -> 13 -> 30 -> 10
        Node head = new Node(14);
        head.next = new Node(21);
        head.next.next = new Node(13);
        head.next.next.next = new Node(30);
        head.next.next.next.next = new Node(10);

        // Key to search in the linked list
        int key = 14;

        if (SearchKey(head, key))
            Console.WriteLine("Yes");
        else
            Console.WriteLine("No");
    }
}

````

JavaScript

````
// Recursive Javascript program to search
// an element in linked list


// A Linked List Node
class Node {

    // Constructor to initialize a new node with data
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Checks whether the key is present in linked list
function searchKey(head, key) {

    // Base case
    if (head === null)
        return false;

    // If key is present in current node, return true
    if (head.data === key)
        return true;

    // Recur for remaining list
    return searchKey(head.next, key);
}

// Create a hard-coded linked list:
// 14 -> 21 -> 13 -> 30 -> 10
let head = new Node(14);
head.next = new Node(21);
head.next.next = new Node(13);
head.next.next.next = new Node(30);
head.next.next.next.next = new Node(10);

// Key to search in the linked list
let key = 14;

if (searchKey(head, key))
console.log("Yes");
else
console.log("No");

````




**Output**
```
Yes
```

****Time Complexity:****
O(N), where

****N****
is the number of nodes in the linked list.



****Auxiliary Space:****
O(N), Stack space used by recursive calls', '', 'Search an element in a Linked List (Iterative and Recursive)', 7, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('cf626aff-7b6c-4197-a2cb-c8365f512ec8', e'Given a singly linked list and a position (1-based indexing), the task is to delete a linked list node at the given position.


****Note:****
Position will be valid (i.e, 1 <= position <= linked list length)


****Example:****


> ****Input:****
> position = 2, Linked List = 8->2->3->1->7
>
>
>
> ****Output:****
> Linked List =  8->3->1->7
>
>
> ****Input:****
> position = 1, Linked List = 8->2->3->1->7
>
>
>
> ****Output:****
> Linked List = 2->3->1->7

****Approach:****


Deletion at a specified position in a linked list involves removing a node from a specific index/position, which can be the first, middle, or last node.


> To perform the deletion, If the position is 1, we update the
>
> ****head****
> to point to the
>
> ****next node****
> and delete the current head. For other positions, we traverse the list to reach the node just before the specified
>
> ****position****
> . If the target node exists, we adjust the next of this previous node to point to next of
>
> ****next nodes****
> , which will result in skipping the target node.

![Deletion-specific-At-End--](https://media.geeksforgeeks.org/wp-content/uploads/20240729185435/Deletion-specific-At-End--.webp)

Delete a Linked List node at a given position


Step-by-step approach:


* If list is empty (

  ****head****
  ==

  ****NULL)****
  , returns the

  ****head****
  .
* If the

  ****position****
  to delete is

  ****1****
  (the head node):
  + Update

    ****head = temp->next****
* Traverse the list until reaching the desired position:
  + Initialize

    ****prev****
    to keep track of the previous node.
  + Move

    ****temp****
    through the list until the position is reached.
* Check for Valid Position:
  + If

    ****temp****
    becomes

    ****NULL****
    , it means the position exceeds the number of nodes in the list. Print a message and return the

    ****head****
    .
* If the node to delete is found:
  + Set

    ****prev->next****
    to

    ****temp->next****
    , effectively skipping over the node to be deleted.

****Code Implementation:****

C++14

````
// C++ program to delete a linked list node at a given
// position
#include <iostream>
using namespace std;

// Node structure for the linked list
struct Node {
    int data;
    Node* next;
    Node(int data)
        : data(data)
        , next(nullptr)
    {
    }
};

// Function to delete a node at a given position
Node* deleteNode(Node* head, int position)
{
    // previous of node to be deleted
    Node* prev;
    Node* temp = head;

    // Base case if linked list is empty
    if (temp == NULL)
        return head;

    // Case 1: Head is to be deleted
    if (position == 1) {
        // make next node as head and free old head
        head = temp->next;
        free(temp);
        return head;
    }

    // Case 2: Node to be deleted is in middle
    // Traverse till given position
    for (int i = 1; i != position; i++) {
        prev = temp;
        temp = temp->next;
    }

    // If given position is found, delete node
    if (temp != NULL) {
        prev->next = temp->next;
        free(temp);
    }
    // If given position is not present
    else {
        cout << "Data not present\\n";
    }

    return head;
}

void printList(Node* head)
{
    while (head != nullptr) {
        cout << head->data << " -> ";
        head = head->next;
    }
    cout << "nullptr" << endl;
}

// Driver code
int main()
{
    // Creating a static linked list
    // 1 -> 2 -> 3 -> 4 -> 5 -> nullptr
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Original list: ";
    printList(head);

    // Deleting node at position 2
    int position = 2;
    head = deleteNode(head, position);

    cout << "List after deletion : ";
    printList(head);

    // Cleanup remaining nodes
    while (head != nullptr) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }

    return 0;
}

````

C

````
// C program to delete a linked list node at a given
// position

#include <stdio.h>
#include <stdlib.h>

// Node structure for the linked list
struct Node {
    int data;
    struct Node* next;
};

struct Node* newNode(int data)
{
    struct Node* node
        = (struct Node*)malloc(sizeof(struct Node));
    node->data = data;
    node->next = NULL;
    return node;
}

// Function to delete a node at a given position
struct Node* deleteNode(struct Node* head, int position)
{
    struct Node* temp = head;
    struct Node* prev = NULL;

    // Base case if linked list is empty
    if (temp == NULL)
        return head;

    // Case 1: Head is to be deleted
    if (position == 1) {
        head = temp->next;
        free(temp);
        return head;
    }

    // Case 2: Node to be deleted is in middle
    // Traverse till given position
    for (int i = 1; temp != NULL && i < position; i++) {
        prev = temp;
        temp = temp->next;
    }

    // If given position is found, delete node
    if (temp != NULL) {
        prev->next = temp->next;
        free(temp);
    }
    else {
        printf("Data not present\\n");
    }

    return head;
}

void printList(struct Node* head)
{
    while (head != NULL) {
        printf("%d -> ", head->data);
        head = head->next;
    }
    printf("NULL\\n");
}

// Driver code
int main()
{
    struct Node* head = newNode(1);
    head->next = newNode(2);
    head->next->next = newNode(3);
    head->next->next->next = newNode(4);
    head->next->next->next->next = newNode(5);

    printf("Original list: ");
    printList(head);

    int position = 2;
    head = deleteNode(head, position);

    printf("List after deletion: ");
    printList(head);

    // Cleanup remaining nodes
    while (head != NULL) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
    }

    return 0;
}

````

Java

````
// Java program to delete a linked list node at a given
// position

// Node class to define a linked list node
class Node {
    int data;
    Node next;

    Node(int data)
    {
        this.data = data;
        this.next = null;
    }
}

public class LinkedList {
    // Function to delete a node at a given position
    public static Node deleteNode(Node head, int position)
    {
        Node temp = head;
        Node prev = null;

        // Base case if linked list is empty
        if (temp == null)
            return head;

        // Case 1: Head is to be deleted
        if (position == 1) {
            head = temp.next;
            return head;
        }

        // Case 2: Node to be deleted is in middle
        // Traverse till given position
        for (int i = 1; temp != null && i < position; i++) {
            prev = temp;
            temp = temp.next;
        }

        // If given position is found, delete node
        if (temp != null) {
            prev.next = temp.next;
        }
        else {
            System.out.println("Data not present");
        }

        return head;
    }

    // Function to print the linked list
    public static void printList(Node head)
    {
        while (head != null) {
            System.out.print(head.data + " -> ");
            head = head.next;
        }
        System.out.println("null");
    }

    // Driver code
    public static void main(String[] args)
    {
        // Creating a static linked list
        // 1 -> 2 -> 3 -> 4 -> 5 -> null
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

        // Print original list
        System.out.print("Original list: ");
        printList(head);

        // Deleting node at position 2
        int position = 2;
        head = deleteNode(head, position);

        // Print list after deletion
        System.out.print("List after deletion: ");
        printList(head);
    }
}

````

Python

````
# Python program to delete a linked list node at
# a given position


class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Function to delete a node at a given position


def deleteNode(head, position):
    temp = head
    prev = None

    # Base case if linked list is empty
    if temp is None:
        return head

    # Case 1: Head is to be deleted
    if position == 1:
        head = temp.next
        return head

    # Case 2: Node to be deleted is in middle
    # Traverse till given position
    for i in range(1, position):
        prev = temp
        temp = temp.next
        if temp is None:
            print("Data not present")
            return head

    # If given position is found, delete node
    if temp is not None:
        prev.next = temp.next

    return head

# Function to print the linked list


def printList(head):
    while head:
        print(f"{head.data} -> ", end="")
        head = head.next
    print("None")


# Driver code
if __name__ == "__main__":
    # Creating a static linked list
    # 1 -> 2 -> 3 -> 4 -> 5 -> None
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)

    # Print original list
    print("Original list: ", end="")
    printList(head)

    # Deleting node at position 2
    position = 2
    head = deleteNode(head, position)

    # Print list after deletion
    print("List after deletion: ", end="")
    printList(head)

````

JavaScript

````
// Javascript program to delete a linked list node at a
// given position
class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
    }
}

// Function to delete a node at a given position
function deleteNode(head, position)
{
    let temp = head;
    let prev = null;

    // Base case if linked list is empty
    if (temp === null)
        return head;

    // Case 1: Head is to be deleted
    if (position === 1) {
        head = temp.next;
        return head;
    }

    // Case 2: Node to be deleted is in middle
    // Traverse till given position
    for (let i = 1; temp !== null && i < position; i++) {
        prev = temp;
        temp = temp.next;
    }

    // If given position is found, delete node
    if (temp !== null) {
        prev.next = temp.next;
    }
    else {
        console.log("Data not present");
    }

    return head;
}

// Function to print the linked list
function printList(head)
{
    while (head !== null) {
        process.stdout.write(head.data + " -> ");
        head = head.next;
    }
    console.log("null");
}

// Driver code
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);

// Print original list
console.log("Original list: ");
printList(head);

// Deleting node at position 2
let position = 2;
head = deleteNode(head, position);

// Print list after deletion
console.log("List after deletion: ");
printList(head);

````




**Output**
```
Original list: 1 -> 2 -> 3 -> 4 -> 5 -> nullptr
List after deletion : 1 -> 3 -> 4 -> 5 -> nullptr

```

****Time Complexity****
: O(n), where n is the number of nodes in the list



****Auxiliary Space:****
O(1)
', '', 'Delete a Linked List node at a given position', 8, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('21a97134-4f54-443f-870a-71183556f602', e'Given a

****linked list****
, the task is to

****delete****
the linked list completely.


****Examples:****

> ****Input:****
> head: 1 -> 2 -> 3 -> 4 -> 5 -> NULL
>
>
>
> ****Output:****
> NULL
>
>
>
> ****Explanation:****
> Linked List is Deleted.
>
>
>
>
>
> ****Input:****
> head: 1 -> 12 -> 1 -> 4 -> 1 -> NULL
>
>
>
> ****Output:****
> NULL
>
>
>
> ****Explanation:****
> Linked List is Deleted.

Table of Content

* [[Expected Approach – 1] Using Recursion – O(n) Time and O(n) Space](#expected-approach-1-using-recursion-on-time-and-on-space)
* [[Expected Approach – 2] Using Iteration – O(n) Time and O(1) Space](#expected-approach-2-using-iteration-on-time-and-o1-space)
### [Expected Approach – 1] Using Recursion – O(n) Time and O(n) Space:

> The idea is to use
>
> [****recursion****](https://www.geeksforgeeks.org/introduction-to-recursion-2/)
> to delete the entire linked list. Traverse from the
>
> ****head****
> to the
>
> ****end****
> of the list recursively. While backtracking, delete the
>
> ****currrent****
> node. This ensures that each node is processed after its subsequent nodes.


Below is the implementation of the above approach:


C++

````
// C++ program to delete a linked list
// using recursion
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int x) {
        data = x;
        next = nullptr;
    }
};

// Given the head of a list, delete the list
// using recursion
void deleteList(Node* curr) {

    // Base case: If the list is empty, return
    if (curr == nullptr) {
        return;
    }

    // Recursively delete the next node
    deleteList(curr->next);

    // Delete the current node
    delete curr;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    deleteList(head);
    cout << "NULL";

    return 0;
}

````

C

````
// C program to delete a linked list
// using recursion
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

// Given the head of a list, delete the list
// using recursion
void deleteList(struct Node* curr) {

    // Base case: If the list is empty, return
    if (curr == NULL) {
        return;
    }

    // Recursively delete the next node
    deleteList(curr->next);

    // Delete the current node
    free(curr);
}

struct Node* createNode(int new_data) {
    struct Node* new_node =
        (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    struct Node* head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);

    deleteList(head);
    printf("NULL");

    return 0;
}

````

Java

````
// Java program to delete a linked list
class Node {
    int data;
    Node next;

    Node(int x) {
        data = x;
        next = null;
    }
}


public class GfG {

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

           // Set head to null to remove the reference to the linked list.
        // This allows Java\'s garbage collector to automatically clean up
        // the memory used by the nodes, as there are no more references
        // to the nodes in the linked list.
          head = null;
          System.out.print("NULL");
    }

}

````

Python

````
# Python program to delete a linked list

class Node:
    def __init__(self, x):
        self.data = x
        self.next = None


if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 2 -> 3 -> 4 -> 5
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)

    # Set head to None to remove the reference to the linked list.
    # This allows Python\'s garbage collector to automatically reclaim
    # the memory used by the nodes, as there are no more references
    # to the nodes in the linked list.
    head = None
    print("NULL")

````

C#

````
// C# program to delete a linked list

using System;

class Node {
    public int Data;
    public Node next;

    public Node(int x) {
        Data = x;
        next = null;
    }
}

class GfG {

    static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

           // Set head to null to remove the reference to the linked list.
        // This allows C#\'s garbage collector to automatically reclaim
        // the memory used by the nodes, as there are no more references
        // to the nodes in the linked list.
        head = null;
        Console.WriteLine("NULL");
    }
}

````

JavaScript

````
// JavaScript program to delete a linked list

class Node {
    constructor(x) {
        this.data = x;
        this.next = null;
    }
}

// Create a hard-coded linked list:
// 1 -> 2 -> 3 -> 4 -> 5
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);

// Set head to null to remove the reference to the linked list.
// This allows JavaScript\'s garbage collector to automatically reclaim
// the memory used by the nodes, as there are no more references
// to the nodes in the linked list.
head = null;
console.log("NULL");

````




**Output**
```
NULL
```

****Time Complexity:****
O(n), where

****n****
is the number of nodes in the given linked list.



****Auxiliary Space:****
O(n)


### [Expected Approach – 2] Using Iteration – O(n) Time and O(1) Space:

> The idea is to
>
> ****iteratively****
> delete the list by starting from the
>
> ****head****
> and moving towards the
>
> ****end****
> . At each step, the function stores a
>
> ****reference****
> to the
>
> ****next****
> node, deletes the
>
> ****current****
> node, and
>
> ****moves****
> to the next node. This continues until all nodes are deleted.


Below is the implementation of the above approach:


C++

````
// C++ program to delete a linked list
// using iteration
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int x) {
        data = x;
        next = nullptr;
    }
};

// Given the head of a list, delete the list
// using iteration
void deleteList(Node* curr) {

    // Iterate through the list until it becomes empty
    while (curr != nullptr) {

        // Store the next node before deleting current
        Node* temp = curr->next;

        // Delete the current node
        delete curr;

        // Move to the next node
        curr = temp;
    }
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    deleteList(head);
    head = nullptr;

    cout << "NULL";

    return 0;
}

````

C

````
// C program to delete a linked list
// using iteration
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

// Given the head of a list, delete the list
// using iteration
void deleteList(struct Node* curr) {

    // Iterate through the list until it becomes empty
    while (curr != NULL) {

        // Store the next node before deleting current
        struct Node* temp = curr->next;

        // Delete the current node
        free(curr);

        // Move to the next node
        curr = temp;
    }
}

struct Node* createNode(int new_data) {
    struct Node* new_node =
        (struct Node*)malloc(sizeof(struct Node));

    new_node->data = new_data;
    new_node->next = NULL;

    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    struct Node* head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);

    deleteList(head);
    head = NULL;

    printf("NULL");

    return 0;
}

````

Java

````
// Java program to delete a linked list
class Node {
    int data;
    Node next;

    Node(int x) {
        data = x;
        next = null;
    }
}

public class GfG {

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

           // Set head to null to remove the reference to the linked list.
        // This allows Java\'s garbage collector to automatically clean up
        // the memory used by the nodes, as there are no more references
        // to the nodes in the linked list.
          head = null;
          System.out.print("NULL");
    }

}

````

Python

````
# Python program to delete a linked list

class Node:
    def __init__(self, x):
        self.data = x
        self.next = None


if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 2 -> 3 -> 4 -> 5
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)

    # Set head to None to remove the reference to the linked list.
    # This allows Python\'s garbage collector to automatically reclaim
    # the memory used by the nodes, as there are no more references
    # to the nodes in the linked list.
    head = None
    print("NULL")

````

C#

````
// C# program to delete a linked list

using System;

class Node {
    public int Data;
    public Node next;

    public Node(int x) {
        Data = x;
        next = null;
    }
}


class GfG {

    static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

           // Set head to null to remove the reference to the linked list.
        // This allows C#\'s garbage collector to automatically reclaim
        // the memory used by the nodes, as there are no more references
        // to the nodes in the linked list.
        head = null;
        Console.WriteLine("NULL");
    }
}

````

JavaScript

````
// JavaScript program to delete a linked list

class Node {
    constructor(x) {
        this.data = x;
        this.next = null;
    }
}

// Create a hard-coded linked list:
// 1 -> 2 -> 3 -> 4 -> 5
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);

// Set head to null to remove the reference to the linked list.
// This allows JavaScript\'s garbage collector to automatically reclaim
// the memory used by the nodes, as there are no more references
// to the nodes in the linked list.
head = null;
console.log("NULL");

````




**Output**
```
NULL
```

****Time Complexity:****
O(n), where

****n****
is the number of nodes in the given linked list.



****Auxiliary Space:****
O(1)', '', 'Write a function to delete a Linked List', 9, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('a904febf-06a7-4308-ad85-436b2ed04ba7', e'Given a

****LinkedList****
and an

****index****
(1-based). The task is to find the

****data value****
stored in the node at that

****kth****
position. If no such node exists whose index is

****k****
then

****return -1.****

****Example:****


> ****Input****
> : 1->10->30->14, index = 2
>
>
>
> ****Output****
> : 10
>
>
>
> ****Explanation****
> : The node value at index 2 is 10
>
>
> ![Maximum-of-all-subarrays-of-size-K](https://media.geeksforgeeks.org/wp-content/uploads/20240822110836/Maximum-of-all-subarrays-of-size-K.webp)
>
>
>
> ****Input****
> : 1->32->12->10->30->14->100, index = 8
>
>
>
> ****Output****
> : -1
>
>
>
> ****Explanation****
> : No such node exists at index = 8.

Table of Content

* [[Naive Approach] Recursive Method – O(n) Time and O(n) Space](#approach-1-using-recursion-on-time-and-on-space)
* [[Expected Approach-2] Iterative Method – O(n) Time and O(1) Space](#approach-2-using-iterative-method-on-time-and-o1-space)
### ****[Naive Approach] Recursive Method – O(n) Time and O(n) Space****

> The idea is to use the
>
> [****recursive****](https://www.geeksforgeeks.org/introduction-to-recursion-2/)
> ****method****
> to find the value of
>
> ****index****
> node
>
> ****(1- based)****
> . Call the function
>
> ****GetNth(head,index)****
> recusively, where
>
> ****head****
> will represent the
>
> ****current head****
> node . Decrement the index
>
> ****value by 1****
> on every recursion call. When the
>
> ****n reaches 1****
> ,we will return the
>
> ****data****
> of current node.


Below is the implementation of above approach:


C++

````
//C++ program to find the data at nth node
//recursively

#include <bits/stdc++.h>
using namespace std;
struct Node {
    int data;
    Node* next;
    Node(int x) {
      data = x;
      next = NULL;
    }
};

// Takes head pointer of the linked list and index
// as arguments and returns data at index.
int GetNth(Node* head, int index) {

    // If the list is empty or index is out of bounds
    if (head == NULL)
        return -1;

    // If index equals 1, return node\'s data
    if (index == 1)
        return head->data;

    // Recursively move to the next node
    return GetNth(head->next, index - 1);
}


int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Element at index 3 is " << GetNth(head, 3) << endl;

    return 0;
}

````

C

````
// C program to find the data at nth node
// recursively

#include <stdio.h>
struct Node {
    int data;
    struct Node *next;
};

// Takes head pointer of the linked list and index
// as arguments and returns data at index.
int GetNth(struct Node *head, int index) {

    // If the list is empty or index is out of bounds
    if (head == NULL)
        return -1;

    // If index equals 1, return node\'s data
    if (index == 1)
        return head->data;

    // Recursively move to the next node
    return GetNth(head->next, index - 1);
}

struct Node *createNode(int new_data) {
    struct Node *new_node =
      (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);
    printf("Element at index 3 is %d\\n", GetNth(head, 3));

    return 0;
}

````

Java

````
// Java program to find n\'th node in linked list
// using recursion

import java.io.*;
class Node {
    int data;
    Node next;

    Node(int x){
        data = x;
        next = null;
    }
}

class GfG {

    // Takes head pointer of the linked list and index
    // as arguments and return data at index*/
    static int GetNth(Node head, int index) {

        if (head == null)
            return -1;

        // if index equal to 1 return node.data
        if (index == 1)
            return head.data;

        // recursively decrease n and increase
        // head to next pointer
        return GetNth(head.next, index - 1);
    }

    public static void main(String args[]) {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

        System.out.printf("Element at index 3 is %d",
                          GetNth(head, 3));
    }
}

````

Python

````
# Python program to find the Nth node in
# linked list using recursion

class Node:
    def __init__(self, x):
        self.data = x
        self.next = None

# Recursive method to find the Nth node
def get_nth_node(head, index):

    # Helper function to handle recursion
    #and count tracking
        if head is None:
            print(-1)

        if index == 1:
            print(head.data)
        else:
            get_nth_node(head.next, index-1)

if __name__ == "__main__":

    # Create a linked list: 1 -> 2 -> 3 -> 4 -> 5
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)
    print("Element at index 3 is", end=" ")
    get_nth_node(head, 3)

````

C#

````
// C# program to find the Nth node in
// linked list using recursion

using System;

class Node {
    public int Data;
    public Node Next;

    public Node(int x) {
        Data = x;
        Next = null;
    }
}

class GfG {

    // Takes head pointer of the linked list and index
    // as arguments and returns data at index
    static int GetNth(Node head, int index) {

        // Base Condition
        if (head == null)
            return -1;

        // If n equals 0, return the node\'s data
        if (index == 1)
            return head.Data;

        // Recursively move to the next node
        return GetNth(head.Next, index - 1);
    }

    public static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Next = new Node(3);
        head.Next.Next.Next = new Node(4);
        head.Next.Next.Next.Next = new Node(5);

        Console.WriteLine("Element at index 3 is {0}", GetNth(head, 3));
    }
}

````

JavaScript

````
// JavaScript program to find the n\'th node in
// a linked list using recursion

class Node {
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

function GetNth(head, index) {

    // Base case: if the list is empty or index is out of
    // bounds
    if (head === null) {
        return -1;
    }

    // Base case: if count equals n, return node\'s data
    if (index === 1) {
        return head.data;
    }

    // Recursive case: move to the next node and decrease
    // index
    return GetNth(head.next, index - 1);
}

// Create a hard-coded linked list:
// 1 -> 2 -> 3 -> 4 -> 5
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);
console.log("Element at index 3 is", GetNth(head, 3));

````




**Output**
```
Element at index 3 is 3

```

****Time Complexity :****
O(n)

****,****
where n is the nth node of linked list.



****Auxiliary Space:****
O(n), for recursive call stack


### ****[Expected Approach-2] Iterative Method – O(n) Time and O(1) Space****

> The idea is similar to recursive
>
> ****approach to find****
> the value at
>
> ****index****
> node
>
> ****(1- based)****
> .We will use a variable say,
>
> ****count = 1****
> to track the node
>
> ****s.****
> Traverse the list until
>
> ****curr != NULL****
> . Increment the
>
>
> count
>
>
> if count is
>
> ****not equal****
> to
>
> ****index****
> node
>
> ****(1- based) ,****
> else if count equals to the
>
> ****index****
> node, return data at
>
> ****current****
> node.


Below is the implementation of above approach :


C++

````
// C++ program to find n\'th
// node in linked list (iteratively)

#include <iostream>
using namespace std;

class Node {
  public:
    int data;
    Node *next;
    Node(int x) {
        data = x;
        next = nullptr;
    }
};

// Function to find the nth node in the list
int GetNth(Node *head, int index) {
    Node *curr = head;
    int count = 1;

    while (curr != nullptr) {
        if (count == index)
            return curr->data;
        count++;
        curr = curr->next;
    }

    return -1;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    Node *head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Element at index 3 is " << GetNth(head, 3) << endl;

    return 0;
}

````

C

````
// C program to find n\'th
// node in linked list (iteratively)

#include <stdio.h>
struct Node {
    int data;
    struct Node *next;
};

// Function to find the nth node in the list
int GetNth(struct Node *head, int index)
{
    struct Node *curr = head;
    int count = 1;
    while (curr != NULL) {
        if (count == index)
            return curr->data;
        count++;
        curr = curr->next;
    }

    return -1;
}

struct Node *createNode(int new_data) {
    struct Node *new_node =
      (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);
    printf("Element at index 3 is %d\\n", GetNth(head, 3));
}

````

Java

````
// Java program to find the Nth node in
// a linked list iteratively

class Node {
    int data;
    Node next;
    Node(int x) {
        data = x;
        next = null;
    }
}

class GfG {

    // Function to find the nth node in the list iteratively
    static int getNthNodeIterative(Node head, int index) {
        Node current = head;
        int count = 1;

        // Traverse the list until the end or until the nth
        // node is reached
        while (current != null) {
            if (count == index) {
                return current.data;
            }
            count++;
            current = current.next;
        }

        // Return -1 if the index is out of bounds
        return -1;
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

        int index = 3;
        int result = getNthNodeIterative(head, index);
        if (result != -1) {
            System.out.println("Element at index " + index
                               + " is " + result);
        }
        else {
            System.out.println("Index " + index
                               + " is out of bounds");
        }
    }
}

````

Python

````
# Python program to find the Nth node in
# a linked list iteratively

class Node:
    def __init__(self, x):
        self.data = x
        self.next = None

# Function to find the nth node in the list iteratively
def get_nth_node_iterative(head, n):
    current = head
    count = 1

    # Traverse the list until the end or until the nth node is reached
    while current is not None:
        if count == n:
            return current.data
        count += 1
        current = current.next

    # Return -1 if the index is out of bounds
    return -1

if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 2 -> 3 -> 4 -> 5
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)
    index = 3
    result = get_nth_node_iterative(head, index)
    if result != -1:
        print(f"Element at index {index} is {result}")
    else:
        print(f"Index {index} is out of bounds")

````

C#

````
// Iterative C# program to find the nth node in
// a linked list

using System;

class Node {
    public int Data;
    public Node Next;
    public Node(int x) {
        Data = x;
        Next = null;
    }
}

class GfG {

    // Given the head of a list and index, find the nth node
    // and return its data
    static int GetNthNode(Node head, int n) {
        Node current = head;
        int count = 1;

        // Traverse the list until the nth node is found or
        // end of the list is reached
        while (current != null) {
            if (count == n) {
                return current.Data;
            }
            count++;
            current = current.Next;
        }

        // Return -1 if the index is out of bounds
        return -1;
    }

   public static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Next = new Node(3);
        head.Next.Next.Next = new Node(4);
        head.Next.Next.Next.Next = new Node(5);
        int index = 3;
        int result = GetNthNode(head, index);
        if (result != -1) {
            Console.WriteLine($"Element at index {index} is {result}");
        }
        else {
            Console.WriteLine($"Index {index} is out of bounds");
        }
    }
}

````

JavaScript

````
// Iterative JavaScript program to find the Nth node in a
// linked list

class Node {
    constructor(x) {
        this.data = x;
        this.next = null;
    }
}

// Given the head of a list and an index, return the data at
// the index
function getNth(head, index) {
    let current = head;
    let count = 1;

    // Traverse the linked list
    while (current !== null) {
        if (count === index) {
            // Return data at the current
            // node if index matches
            return current.data;
        }
        count++;
        current = current.next;
    }

    // Return -1 if index is out of bounds
    return -1;
}

// Create a hard-coded linked list:
// 1 -> 2 -> 3 -> 4 -> 5
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);
let index = 3;
let result = getNth(head, index);
if (result !== -1) {
    console.log(`Element at index ${index} is ${result}`);
}
else {
    console.log(`Index ${index} is out of bounds`);
}

````




**Output**
```
Element at index 3 is 3

```

****Time Complexity :****
O(n)

****,****
where n is the nth node of linked list.



****Auxiliary Space:****
O(1)', '', 'Write a function to get Nth node in a Linked List', 10, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('c4109005-926f-4553-bb7a-e8751a632d01', e'Given a Linked List of

****M****
nodes and a number

****N****
, find the value at the Nth node from the end of the Linked List. If there is no Nth node from the end, print -1.


****Examples:****

> ****Input:****
> 1 -> 2 -> 3 -> 4, N = 3
>
>
>
> ****Output:****
> 2
>
>
>
> ****Explanation:****
> Node 2 is the third node from the end of the linked list.
>
>
> ****Input:****
> 35 -> 15 -> 4 -> 20, N = 4
>
>
>
> ****Output:****
> 35
>
>
>
> ****Explanation:****
> Node 35 is the fourth node from the end of the linked list.

Table of Content

* [[Naive Approach] By Finding the length of list – Two Pass – O(M) Time and O(1) Space](#naive-approach-finding-the-length-of-list-and-return-the-node-two-pass-om-time-and-o1-space)
* [[Expected Approach] Using Two Pointers – One Pass – O(M) Time and O(1) Space](#expected-approach-using-two-pointers-one-pass-om-time-and-o1-space)
### ****[Naive Approach]**** Finding the length of list – Two Pass – O(M) Time and O(1) Space

> The idea is to count the number of nodes in linked list in the first pass, say
>
> ****len****
> . In the second pass, return the
>
> ****(len – n + 1)th****
> nodes from beginning of the Linked List.

C++14

````
// C++ program to find Nth node from end of linked list

#include <bits/stdc++.h>
using namespace std;

// Link list node
struct Node {
    int data;
    Node* next;

      // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// Function to find the Nth node from the last of a linked list
int findNthFromLast(Node* head, int N) {
    int len = 0, i;

      // Pointer to store the copy of head
    Node* temp = head;

    // Count the number of nodes in Linked List
    while (temp != NULL) {
        temp = temp->next;
        len++;
    }

    // Check if value of N is not
    // more than length of the linked list
    if (len < N)
        return -1;

    temp = head;

    // Get the (len - N + 1)th node from the beginning
    for (i = 1; i < len - N + 1; i++)
        temp = temp->next;

    return temp->data;
}

int main() {

    // Create a hard-coded linked list:
    // 35 -> 15 -> 4 -> 20
    Node* head = new Node(35);
    head->next = new Node(15);
    head->next->next = new Node(4);
    head->next->next->next = new Node(20);

    // Function Call to find the 4th node from end
    cout << findNthFromLast(head, 4);
    return 0;
}

````

C

````
// C program to find Nth node from end of linked list

#include <stdio.h>

// Link list node
struct Node {
    int data;
    struct Node* next;
};

// Function to find the Nth node from the last of a linked list
int findNthFromLast(struct Node* head, int N) {
    int len = 0, i;

    // Pointer to store the copy of head
    struct Node* temp = head;

    // Count the number of nodes in Linked List
    while (temp != NULL) {
        temp = temp->next;
        len++;
    }

    // Check if value of N is not more than length of the linked list
    if (len < N)
        return -1;

    temp = head;

    // Get the (len - N + 1)th node from the beginning
    for (i = 1; i < len - N + 1; i++)
        temp = temp->next;

    return temp->data;
}

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node =
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 35 -> 15 -> 4 -> 20
    struct Node* head = createNode(35);
    head->next = createNode(15);
    head->next->next = createNode(4);
    head->next->next->next = createNode(20);

    // Function Call to find the 4th node from end
    printf("%d\\n", findNthFromLast(head, 4));

    return 0;
}

````

Java

````
// Java program to find Nth node from
// end of linked list

// Link list node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

public class GFG {
      // Function to find the Nth node from the last of a linked list
    static int findNthFromLast(Node head, int N) {
        int len = 0, i;

        // Pointer to store the copy of head
        Node temp = head;

        // Count the number of nodes in Linked List
        while (temp != null) {
            temp = temp.next;
            len++;
        }

        // Check if value of N is not more than length of the linked list
        if (len < N)
            return -1;

        temp = head;

        // Get the (len - N + 1)th node from the beginning
        for (i = 1; i < len - N + 1; i++)
            temp = temp.next;

        return temp.data;
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 35 -> 15 -> 4 -> 20
        Node head = new Node(35);
        head.next = new Node(15);
        head.next.next = new Node(4);
        head.next.next.next = new Node(20);

        // Function Call to find the 4th node from end
        System.out.println(findNthFromLast(head, 4));
    }
}

````

Python

````
# Python3 program to find Nth node from end of linked list

# Link list node
class Node:

   # Constructor to initialize a new node with data
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Function to find the Nth node from the last of a linked list
def findNthFromLast(head, N):
    length = 0
    temp = head

    # Count the number of nodes in Linked List
    while temp is not None:
        temp = temp.next
        length += 1

    # Check if value of N is not more than length of the linked list
    if length < N:
        return -1

    temp = head

    # Get the (length - N + 1)th node from the beginning
    for _ in range(1, length - N + 1):
        temp = temp.next

    return temp.data

if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 35 -> 15 -> 4 -> 20
    head = Node(35)
    head.next = Node(15)
    head.next.next = Node(4)
    head.next.next.next = Node(20)

    # Function Call to find the 4th node from end
    print(findNthFromLast(head, 4))

````

C#

````
// C# program to find N\'th node from end of linked list
using System;

// Link list node
class Node {
    public int data;
    public Node next;

    // Constructor to initialize a new node with data
    public Node(int new_data) {
        data = new_data;
        next = null;
    }
}

// Function to find the Nth node from the last of a linked list
class GFG {
    static int FindNthFromLast(Node head, int N) {
        int len = 0;
        Node temp = head;

        // Count the number of nodes in Linked List
        while (temp != null) {
            temp = temp.next;
            len++;
        }

        // Check if value of N is not more than length of the linked list
        if (len < N)
            return -1;

        temp = head;

        // Get the (len - N + 1)th node from the beginning
        for (int i = 1; i < len - N + 1; i++)
            temp = temp.next;

        return temp.data;
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 35 -> 15 -> 4 -> 20
        Node head = new Node(35);
        head.next = new Node(15);
        head.next.next = new Node(4);
        head.next.next.next = new Node(20);

        // Function Call to find the 4th node from end
        Console.WriteLine(FindNthFromLast(head, 4));
    }
}

````

JavaScript

````
// Javascript program to find N\'th node from end of linked list

// Link list node
class Node {

    // Constructor to initialize a new node with data
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Function to find the Nth node from the last of a linked list
function findNthFromLast(head, N) {
    let len = 0;
    let temp = head;

    // Count the number of nodes in Linked List
    while (temp !== null) {
        temp = temp.next;
        len++;
    }

    // Check if value of N is not more than length of the linked list
    if (len < N) {
        return -1;
    }

    temp = head;

    // Get the (len - N + 1)th node from the beginning
    for (let i = 1; i < len - N + 1; i++) {
        temp = temp.next;
    }

    return temp.data;
}

// Create a hard-coded linked list:
// 35 -> 15 -> 4 -> 20
let head = new Node(35);
head.next = new Node(15);
head.next.next = new Node(4);
head.next.next.next = new Node(20);

// Function Call to find the 4th node from end
console.log(findNthFromLast(head, 4));

````




**Output**
```
35
```

****Time complexity:****
O(M) where

****M****
is the size of the linked list



****Auxiliary Space:****
O(1)


### [Expected Approach] Using Two Pointers – One Pass – O(M) Time and O(1) Space

> The idea is to maintain two pointers, say
>
> ****main\\_ptr****
> and
>
> ****ref\\_ptr****
> point to the head of Linked List and move
>
> ****ref\\_ptr****
> to the Nth node from the head to ensure that the distance between main\\_ptr and ref\\_ptr is
>
> ****(N – 1)****
> . Now, move both the pointers simultaneously until ref\\_ptr reaches the last node. Since the distance between main\\_ptr and ref\\_ptr is (N – 1), so when ref\\_ptr will reach the
>
> ****last node****
> , main\\_ptr will reach
>
> ****Nth****
> node from the end of Linked List. Return the value of node pointed by main\\_ptr.


Below image is a dry run of the above approach:








Follow the given steps to solve the problem:


* Maintain two pointers

  ****main\\_ptr****
  and

  ****ref\\_ptr****
* Move ref\\_ptr to the Nth node from the start
* Now move both main\\_ptr and ref\\_ptr, until the ref\\_ptr reaches the last node
* Now return the data of the main\\_ptr, as it is at the Nth node from the end

C++

````
// C++ program to find Nth node from end of linked list

#include <bits/stdc++.h>
using namespace std;

// Link list node
struct Node {
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// function to find Nth node from the end of linked list
int nthFromEnd(Node *head, int N) {

    // create two pointers main_ptr and ref_ptr
    // initially pointing to head.
    Node* main_ptr = head;
    Node* ref_ptr = head;

    // move ref_ptr to the n-th node from beginning.
    for (int i = 1; i < N; i++) {
        ref_ptr = ref_ptr->next;

          // If the ref_ptr reaches NULL, then it means
          // N > length of linked list
        if (ref_ptr == NULL) {
            return -1;
        }
    }

    // move ref_ptr and main_ptr by one node until
    // ref_ptr reaches last node of the list.
    while (ref_ptr->next != NULL) {
        ref_ptr = ref_ptr->next;
        main_ptr = main_ptr->next;
    }

    return main_ptr->data;
}

int main() {

    // Create a hard-coded linked list:
    // 35 -> 15 -> 4 -> 20
    Node* head = new Node(35);
    head->next = new Node(15);
    head->next->next = new Node(4);
    head->next->next->next = new Node(20);

    // Function Call to find the 4th node from end
    cout << nthFromEnd(head, 4);
    return 0;
}

````

C

````
// C program to find Nth node from end of linked list

#include <stdio.h>

// Link list node
struct Node {
    int data;
    struct Node* next;
};

// Function to find the Nth node from the last of a linked
// list
int findNthFromLast(struct Node* head, int N) {

    // Create two pointers main_ptr and ref_ptr initially
    // pointing to head
    struct Node* main_ptr = head;
    struct Node* ref_ptr = head;

    // Move ref_ptr to the N-th node from the beginning
    for (int i = 1; i < N; i++) {
        ref_ptr = ref_ptr->next;

        // If the ref_ptr reaches NULL, then it means
        // N > length of linked list
        if (ref_ptr == NULL) {
            return -1;
        }
    }

    // Move ref_ptr and main_ptr by one node until ref_ptr
    // reaches the last node of the list
    while (ref_ptr->next != NULL) {
        ref_ptr = ref_ptr->next;
        main_ptr = main_ptr->next;
    }

    return main_ptr->data;
}

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node
        = (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 35 -> 15 -> 4 -> 20
    struct Node* head = createNode(35);
    head->next = createNode(15);
    head->next->next = createNode(4);
    head->next->next->next = createNode(20);

    // Function Call to find the 4th node from end
    printf("%d\\n", findNthFromLast(head, 4));

    return 0;
}

````

Java

````
// Java program to find Nth node from end of linked list

// Link list node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

public class GFG {

    // Function to find Nth node from the end of linked list
    static int nthFromEnd(Node head, int N) {

        // Create two pointers main_ptr and ref_ptr
        // initially pointing to head.
        Node main_ptr = head;
        Node ref_ptr = head;

        // Move ref_ptr to the N-th node from beginning.
        for (int i = 1; i < N; i++) {
            ref_ptr = ref_ptr.next;

            // If the ref_ptr reaches NULL, then it means
            // N > length of linked list
            if (ref_ptr == null) {
                return -1;
            }
        }

        // Move ref_ptr and main_ptr by one node until
        // ref_ptr reaches last node of the list.
        while (ref_ptr.next != null) {
            ref_ptr = ref_ptr.next;
            main_ptr = main_ptr.next;
        }

        return main_ptr.data;
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 35 -> 15 -> 4 -> 20
        Node head = new Node(35);
        head.next = new Node(15);
        head.next.next = new Node(4);
        head.next.next.next = new Node(20);

        // Function Call to find the 4th node from end
        System.out.println(nthFromEnd(head, 4));
    }
}

````

Python

````
# Python3 program to find Nth node from end of linked list

# Link list node
class Node:

      # Constructor to initialize a new node with data
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Function to find Nth node from the end of linked list
def nth_from_end(head, N):

    # Create two pointers main_ptr and ref_ptr
    # initially pointing to head.
    main_ptr = head
    ref_ptr = head

    # Move ref_ptr to the N-th node from beginning.
    for _ in range(1, N):
        ref_ptr = ref_ptr.next

        # If the ref_ptr reaches None, then it means
        # N > length of linked list
        if ref_ptr is None:
            return -1

    # Move ref_ptr and main_ptr by one node until
    # ref_ptr reaches last node of the list.
    while ref_ptr.next is not None:
        ref_ptr = ref_ptr.next
        main_ptr = main_ptr.next

    return main_ptr.data

if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 35 -> 15 -> 4 -> 20
    head = Node(35)
    head.next = Node(15)
    head.next.next = Node(4)
    head.next.next.next = Node(20)

    # Function Call to find the 4th node from end
    print(nth_from_end(head, 4))

````

C#

````
// C# program to find Nth node from end of linked list
using System;

class GFG {

    // Node class for the linked list
    class Node {
        public int Data;
        public Node Next;

          // Constructor to initialize a new node with data
        public Node(int newData) {
            Data = newData;
            Next = null;
        }
    }

    // Function to find the Nth node from the end of the
    // linked list
    static int NthFromEnd(Node head, int N) {
        Node mainPtr = head;
        Node refPtr = head;

        // Move refPtr to the N-th node from the beginning
        for (int i = 1; i < N; i++) {
            refPtr = refPtr ?.Next;

            // If the refPtr reaches null, then N > length
            // of linked list
            if (refPtr == null) {
                return -1;
            }
        }

        // Move refPtr and mainPtr by one node until refPtr
        // reaches the last node
        while (refPtr?.Next != null) {
            refPtr = refPtr.Next;
            mainPtr = mainPtr.Next;
        }

        return mainPtr.Data;
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 35 -> 15 -> 4 -> 20
        Node head = new Node(35);
        head.Next = new Node(15);
        head.Next.Next = new Node(4);
        head.Next.Next.Next = new Node(20);

        // Function call to find the 4th node from the end
        Console.WriteLine(NthFromEnd(head, 4));
    }
}

````

JavaScript

````
// javascript program to find n\'th
// node from end of linked list

// Linked List Node
class Node {

    // Constructor to initialize a new node with data
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// Function to find Nth node from the end of linked list
function nthFromEnd(head, N) {
    let mainPtr = head;
    let refPtr = head;

    // Move refPtr to the N-th node from the beginning
    for (let i = 1; i < N; i++) {
        refPtr = refPtr.next;

        if (refPtr === null) {

            // If N is greater than the length of the linked list
            return -1;
        }
    }

    // Move refPtr and mainPtr by one node until refPtr reaches the last node
    while (refPtr.next !== null) {
        refPtr = refPtr.next;
        mainPtr = mainPtr.next;
    }

    return mainPtr.data;
}

// Create a hard-coded linked list:
// 35 -> 15 -> 4 -> 20
const head = new Node(35);
head.next = new Node(15);
head.next.next = new Node(4);
head.next.next.next = new Node(20);

// Function call to find the 4th node from end
console.log(nthFromEnd(head, 4));

````




**Output**
```
Node no. 4 from end is: 35

```

****Time Complexity:****
O(M) where

****M****
is the length of the linked list



****Auxiliary Space:****
O(1)', '', 'Program for Nth node from the end of a Linked List', 11, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('0f29c6e9-3edb-43c1-b60d-41e4c65c90e0', e'Given a

[doubly linked list](https://www.geeksforgeeks.org/doubly-linked-list/)
, The task is to find the

****number of nodes in****
the given doubly linked list.


Example:


> ****Input****
> : 1<->2<->3<->4
>
>
>
> ****output****
> : 4
>
>
> ****Input****
> : 1<->2
>
>
>
> ****output****
> : 2

### By Traversing the Doubly linked list – O(n) Time and O(1) Space

> The idea is to traverse the doubly linked list starting from the
>
> ****head****
> node. Increment the
>
> ****size****
> variable until we reaches end.


Algorithm :


* Initialize a variable

  ****size****
  to 0
* Initialize a

  ****curr****
  node to

  ****head****
* Do the following while the

  ****curr node****
  is not NULL
  + ****curr = curr -> next****
  + ****size++;****
* Return

  ****size****
  .


Below is the implementation of above approach:


C++

````
// C++ program to
// find size of doubly linked list.
#include <bits/stdc++.h>
using namespace std;

class Node {
  public:
    int data;
    Node *next;
    Node *prev;
    Node(int val) {
        data = val;
        next = nullptr;
        prev = nullptr;
    }
};

// This function returns size of linked list
int findSize(Node *curr) {
    int size = 0;
    while (curr != NULL) {
        size++;
        curr = curr->next;
    }
    return size;
}

int main() {

    // Create a hard-coded doubly linked list:
    // 1 <-> 2 <-> 3 <-> 4
    Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;
    head->next->next->next = new Node(4);
    head->next->next->next->prev = head->next->next;

    cout << findSize(head);
    return 0;
}

````

C

````
// C program to find size of doubly linked list.
#include <stdio.h>

struct Node {
  int data;
  struct Node* prev;
  struct Node* next;
};


int findSize(struct Node* curr) {
  int size = 0;
  while (curr != NULL) {
    size++;
    curr = curr->next;
  }
  return size;
}

struct Node *createNode(int new_data) {
    struct Node *new_node =
      (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded doubly linked list:
    // 1 <-> 2 <-> 3 <-> 4
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;
    head->next->next->next = createNode(4);
    head->next->next->next->prev = head->next->next;
      printf("%d", findSize(head));

  return 0;
}

````

Java

````
// A complete working Java program to
// find the size of a doubly linked list.
class Node {
    int data;
    Node next;
    Node prev;

    Node(int val) {
        data = val;
        next = null;
        prev = null;
    }
}

public class GfG {

    // This function returns the size of
      // the linked list
    static int findSize(Node curr) {
        int size = 0;
        while (curr != null) {
            size++;
            curr = curr.next;
        }
        return size;
    }

    public static void main(String[] args) {

        // Create a hard-coded doubly linked list:
        // 1 <-> 2 <-> 3 <-> 4
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;
        head.next.next.next = new Node(4);
        head.next.next.next.prev = head.next.next;

        System.out.println(findSize(head));
    }
}

````

Python

````
# A complete working Python program to
# find the size of a doubly linked list.

class Node:
    def __init__(self, val):
        self.data = val
        self.next = None
        self.prev = None

# This function returns the size of
# the linked list
def find_size(curr):
    size = 0
    while curr:
        size += 1
        curr = curr.next
    return size

if __name__ == "__main__":

    # Create a hard-coded doubly linked list:
    # 1 <-> 2 <-> 3 <-> 4
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next
    head.next.next.next = Node(4)
    head.next.next.next.prev = head.next.next

    print(find_size(head))

````

C#

````
// A complete working C# program to
// find the size of a doubly linked list.
using System;

class Node {
    public int data;
    public Node next;
    public Node prev;

    public Node(int val) {
        data = val;
        next = null;
        prev = null;
    }
}

class GfG {

    // This function returns the size of
      // the linked list
    static int FindSize(Node curr) {
        int size = 0;
        while (curr != null) {
            size++;
            curr = curr.next;
        }
        return size;
    }

    static void Main() {

        // Create a hard-coded doubly linked list:
        // 1 <-> 2 <-> 3 <-> 4
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;
        head.next.next.next = new Node(4);
        head.next.next.next.prev = head.next.next;

        Console.WriteLine(FindSize(head));
    }
}

````

JavaScript

````
// A complete working JavaScript program to
// find the size of a doubly linked list.

class Node {
    constructor(val) {
        this.data = val;
        this.next = null;
        this.prev = null;
    }
}

// This function returns the size
// of the linked list
function findSize(curr) {
    let size = 0;
    while (curr !== null) {
        size++;
        curr = curr.next;
    }
    return size;
}

// Create a hard-coded doubly linked list:
// 1 <-> 2 <-> 3 <-> 4
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;
head.next.next.next = new Node(4);
head.next.next.next.prev = head.next.next;

console.log(findSize(head));

````




**Output**
```
4
```

****Time Complexity: O(n),****
where n is the number of nodes in the linked list.



****Auxiliary Space:****

****O(1)****', '', 'Program to find size of Doubly Linked List', 12, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('0c68fc2c-a6d9-4306-a996-07fbf5dccb2e', e'Given a

****singly linked list,****
the task is to remove every k

th
node of the linked list. Assume that k is always less than or equal to the length of the Linked List.


****Examples :****


> ****Input:****
> LinkedList: 1 -> 2 -> 3 -> 4 -> 5 -> 6, k = 2
>
>
>
> ****Output:****
> 1 -> 3 -> 5
>
>
>
> ****Explanation:****
> After removing every 2nd node of the linked list, the resultant linked list will be: 1 -> 3 -> 5 .
>
>
> ****Input:****
> LinkedList: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10, k = 3
>
>
>
> ****Output:****
> 1 -> 2 -> 4 -> 5 -> 7 -> 8 -> 10
>
>
>
> ****Explanation:****
> After removing every 3rd node of the linked list, the resultant linked list will be: 1 -> 2 -> 4 -> 5 -> 7 -> 8 -> 10.

### [Expected Approach – 1] Iterative Approach – O(n) Time and O(1) Space

> The idea is to traverse the linked list while maintaining a
>
> ****counter****
> to track node positions. Every time the counter reaches
>
> ****k,****
> update the next pointer of the
>
> ****previous****
> node to
>
> ****skip****
> the current k
>
> th
> node, effectively removing it from the list. Continue this process until reaching the
>
> ****end****
> of the list. This method ensures that the
>
> ****k****
> ****th****
>
> nodes are removed as required while
>
> ****preserving****
> the rest of the list structure.


Below is the implementation of the above approach:


C++

````
// C++ program to delete every k-th Node of
// a singly linked list.
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int x) {
        data = x;
        next = nullptr;
    }
};

// Function to remove every kth node in the linked list
Node* deleteK(Node* head, int k) {

    // If list is empty or k is 0, return the head
    if (head == nullptr || k <= 0)
        return head;

    Node* curr = head;
    Node* prev = nullptr;

    // Initialize counter to track node positions
    int count = 0;

    // Traverse the linked list
    while (curr != nullptr) {
        count++;

        // If count is a multiple of k, remove current node
        if (count % k == 0) {

            // skip the current node
            if (prev != nullptr) {
                prev->next = curr->next;
            }
            else {

                head = curr->next;
            }
        }
        else {

            // Update previous node pointer only if
            // we do not remove the node
            prev = curr;
        }
        curr = curr->next;
    }

    return head;
}

void printList(Node* head) {

    Node* curr = head;
    while (curr != nullptr) {
        cout << curr->data << " ";
        curr = curr->next;
    }
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5 -> 6
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);
    head->next->next->next->next->next = new Node(6);
    int k = 2;
    head = deleteK(head, k);
    printList(head);

    return 0;
}

````

C

````
// C program to delete every k-th Node of
// a singly linked list.
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

// Function to remove every kth node in the linked list
struct Node* deleteK(struct Node* head, int k) {

    // If list is empty or k is 0, return the head
    if (head == NULL || k <= 0)
        return head;

    struct Node* curr = head;
    struct Node* prev = NULL;

    int count = 0;

    while (curr != NULL) {
        count++;

        // If count is a multiple of k, remove
        // current node
        if (count % k == 0) {

            // skip the current node
            if (prev != NULL) {
                prev->next = curr->next;
            }
            else {

                head = curr->next;
            }
            free(curr);
            curr = prev != NULL ? prev->next : head;
        }
        else {

            // Update previous node pointer only if
            // we do not remove the node
            prev = curr;
            curr = curr->next;
        }
    }
    return head;
}

void printList(struct Node* node) {
   struct Node* curr = node;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }
    printf("\\n");
}

struct Node* createNode(int new_data) {
    struct Node* new_node =
        (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}


int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5 -> 6
    struct Node* head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);
    head->next->next->next->next->next = createNode(6);

    int k = 2;
    head = deleteK(head, k);

    printList(head);

    return 0;
}

````

Java

````
// Java program to delete every k-th Node of
// a singly linked list.
class Node {
    int data;
    Node next;

    Node(int newData) {
        data = newData;
        next = null;
    }
}

public class GfG {

    // Function to remove every kth node in the
    // linked list
    static Node deleteK(Node head, int k) {

        // If list is empty or k is 0, return the head
        if (head == null || k <= 0)
            return head;

        Node curr = head;

        Node prev = null;

        int count = 0;

        // Traverse the linked list
        while (curr != null) {

            // Increment the counter for each node
            count++;

            // If count is a multiple of k, remove
            // current node
            if (count % k == 0) {

                // skip the current node
                if (prev != null) {
                    prev.next = curr.next;
                }
               else {

                    // If removing the head node
                    head = curr.next;
                }
            }
           else {

                // Update previous node pointer only if
                // we do not remove the node
                prev = curr;
            }
            curr = curr.next;
        }

        return head;
    }

    static void printList(Node head) {

        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5 -> 6
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);
        head.next.next.next.next.next = new Node(6);
        int k = 2;

        head = deleteK(head, k);

        printList(head);
    }
}

````

Python

````
# Python program to delete every k-th Node of
# a singly linked list.
class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Function to remove every kth node in the linked list
def delete_k(head, k):

    # If list is empty or k is 0, return the head
    if head is None or k <= 0:
        return head

    curr = head
    prev = None

    count = 0

    while curr is not None:
        count += 1

        # If count is a multiple of k, remove current node
        if count % k == 0:

            # Bypass the current node
            if prev is not None:
                prev.next = curr.next
            else:

                # If removing the head node
                head = curr.next
        else:

            # Update previous node pointer only if
            # we do not remove the node
            prev = curr

        curr = curr.next

    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 2 -> 3 -> 4 -> 5 -> 6
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)
    head.next.next.next.next.next = Node(6)
    k = 2
    head = delete_k(head, k)
    print_list(head)

````

C#

````
// C# program to delete every k-th Node of
// a singly linked list.
using System;

class Node {
    public int Data;
    public Node next;

    public Node(int newData) {
        Data = newData;
        next = null;
    }
}

class GfG {

    // Function to remove every kth node in the linked list
    static Node DeleteK(Node head, int k) {

        // If list is empty or k is 0, return the head
        if (head == null || k <= 0)
            return head;

        Node curr = head;
        Node prev = null;

        int count = 0;

        while (curr != null) {
            count++;

            // If count is a multiple of k, remove
            // current node
            if (count % k == 0) {

                // Bypass the current node
                if (prev != null) {
                    prev.next = curr.next;
                }
                else {

                    // If removing the head node
                    head = curr.next;
                }
            }
            else {

                // Update previous node pointer only if
                // we do not remove the node
                prev = curr;
            }
            curr = curr.next;
        }
        return head;
    }

    static void PrintList(Node curr) {
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.next;
        }
        Console.WriteLine();
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5 -> 6
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);
        head.next.next.next.next.next = new Node(6);

        int k = 2;
        head = DeleteK(head, k);

        PrintList(head);
    }
}

````

JavaScript

````
// Javascript program to delete every k-th Node of
// a singly linked list.
class Node {
    constructor(newData) {
        this.data = newData;
        this.next = null;
    }
}

// Function to remove every kth node in the linked list
function deleteK(head, k) {

    // If list is empty or k is 0, return the head
    if (head === null || k <= 0) {
        return head;
    }

    let curr = head;
    let prev = null;
    let count = 0;

    // Traverse the linked list
    while (curr !== null) {
        count++;

        // If count is a multiple of k, remove
        // current node
        if (count % k === 0) {

            // skip the current node
            if (prev !== null) {
                prev.next = curr.next;
            }
            else {

                // If removing the head node
                head = curr.next;
            }
        }
        else {

            // Update previous node pointer only if
            // we do not remove the node
            prev = curr;
        }
        curr = curr.next;
    }
    return head;
}

function printList(curr) {
    let output = "";
    while (curr !== null) {
        output += curr.data + " ";
        curr = curr.next;
    }
    console.log(output.trim());
}

// Create a hard-coded linked list:
// 1 -> 2 -> 3 -> 4 -> 5 -> 6
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);
head.next.next.next.next.next = new Node(6);

let k = 2;
head = deleteK(head, k);

printList(head);

````




**Output**
```
1 3 5
```

****Time Complexity :****
O(n),


where

****n****
is the number of nodes.



****Auxiliary Space :****
O(1)', '', 'Remove every k-th node of the linked list', 13, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('237c88d5-987b-4fc0-8bd1-d27a07cd1aa9', e'Understanding Node Structure
----------------------------

In a singly linked list, each node consists of two parts: data and a
pointer to the next node. This structure allows nodes to be dynamically
linked together, forming a chain-like sequence.


![Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240917161540/Singly-Linked-List.webp)

Singly Linked List



C++
````
// Definition of a Node in a singly linked list
struct Node {

    // Data part of the node
    int data;

    // Pointer to the next node in the list
    Node* next;

    // Constructor to initialize the node with data
    Node(int data)
    {
        this->data = data;
        this->next = nullptr;
    }
};

````

C
````
// Definition of a Node in a singly linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new Node
struct Node* newNode(int data) {
    struct Node* temp =
      (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

````

Java
````
// Definition of a Node in a singly linked list
public class Node {
    int data;
    Node next;

    // Constructor to initialize the node with data
    public Node(int data)
    {
        this.data = data;
        this.next = null;
    }
}

````

Python
````
# Definition of a Node in a singly linked list
class Node:
    def __init__(self, data):
       # Data part of the node
        self.data = data
        self.next = None

````

JavaScript
````
// Definition of a Node in a singly linked list
class Node {
    constructor(data) {
    // Data part of the node
        this.data = data;
        this.next = null;
    }
}

````



In this example, the Node class contains an integer data field (****data****) to store the information and a pointer to another Node (****next****) to establish the link to the next node in the list.

Operations on Singly Linked List
--------------------------------

* ****Traversal****
* ****Searching****
* ****Length****
* ****Insertion:****
  + Insert at the beginning
  + Insert at the end
  + Insert at a specific position
* ****Deletion:****
  + Delete from the beginning
  + Delete from the end
  + Delete a specific node

Let\'s go through each of the operations mentioned above, one by
one.

[****Traversal**** of Singly Linked List](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)
---------------------------------------------------------------------------------------------------------

Traversal involves visiting each node in the linked list and performing
some operation on the data. A simple traversal function would print or
process the data of each node.

Step-by-step approach:

* Initialize a pointer current to the head of the list.
* Use a while loop to iterate through the list until the current
  pointer reaches NULL.
* Inside the loop, print the data of the current node and move the
  current pointer to the next node.

Below is the function for traversal in singly Linked List:

C++
````
// C++ Function to traverse and print the elements of the linked
// list
void traverseLinkedList(Node* head)
{
    // Start from the head of the linked list
    Node* current = head;

    // Traverse the linked list until reaching the end
    // (nullptr)
    while (current != nullptr) {

        // Print the data of the current node
        cout << current->data << " ";

        // Move to the next node
        current = current->next;
    }

    cout << std::endl;
}

````

C
````
// Function to traverse and print the elements
// of the linked list
void traverseLinkedList(struct Node* head)
{
    // Start from the head of the linked list
    struct Node* current = head;

    // Traverse the linked list until reaching the end (NULL)
    while (current != NULL) {

        // Print the data of the current node
        printf("%d ", current->data);

        // Move to the next node
        current = current->next;
    }

    printf("\\n");
}

````

Java
````
// Java Function to traverse and print the elements of the
// linked list
public static void traverseLinkedList(Node head)
{
    // Start from the head of the linked list
    Node current = head;

    // Traverse the linked list until reaching the end
    // (null)
    while (current != null) {

        // Print the data of the current node
        System.out.print(current.data + " ");

        // Move to the next node
        current = current.next;
    }

    System.out.println();
}

````

Python
````
# Python Function to traverse and print the elements of the linked list
def traverse_linked_list(head):
    # Start from the head of the linked list
    current = head

    # Traverse the linked list until reaching the end (None)
    while current is not None:

        # Print the data of the current node followed by a space
        print(current.data),

        # Move to the next node
        current = current.next

    print()  # Print a new line after traversing the linked list

````

JavaScript
````
// Javascript Function to traverse and print the elements
// of the linked list
function traverseLinkedList(head) {

    // Start from the head of the linked list
    let current = head;

    // Traverse the linked list until reaching the
    // end (null)
    while (current !== null) {

        // Print the data of the current node
        console.log(current.data + " ");

        // Move to the next node
        current = current.next;
    }

    console.log();
}

````

**Output**
```

1 2 3

```

[Searching in Singly Linked List](https://www.geeksforgeeks.org/search-an-element-in-a-linked-list-iterative-and-recursive/)
----------------------------------------------------------------------------------------------------------------------------

Searching in a Singly Linked List refers to the process of looking for
a specific element or value within the elements of the linked list.


Step-by-step approach:

1. Traverse the Linked List starting from the head.
2. Check if the current node\'s data matches the target value.
   * If a match is found, return ****true****.
3. Otherwise, Move to the next node and repeat steps 2.
4. If the end of the list is reached without finding a match, return ****false****.

Below is the function for searching in singly linked list:

C++
````
// Function to search for a value in the Linked List
bool searchLinkedList(struct Node* head, int target)
{
    // Traverse the Linked List
    while (head != nullptr) {

        // Check if the current node\'s
        // data matches the target value
        if (head->data == target) {
            return true; // Value found
        }

        // Move to the next node
        head = head->next;
    }

    return false; // Value not found
}

````

C
````
// Function to search for a value in the Linked List
bool searchLinkedList(struct Node* head, int target)
{
    // Traverse the Linked List
    while (head != NULL) {

        // Check if the current node\'s
        // data matches the target value
        if (head->data == target) {
            return true; // Value found
        }

        // Move to the next node
        head = head->next;
    }

    return false; // Value not found
}

````

Java
````
// Java function to search for a value in the Linked List
public boolean searchLinkedList(Node head, int target)
{
    // Traverse the Linked List
    while (head != null) {

        // Check if the current node\'s data matches the
        // target value
        if (head.data == target) {

            // Value found
            return true;
        }

        // Move to the next node
        head = head.next;
    }

    // Value not found
    return false;
}

````

Python
````
# Python function to search for a value in the Linked List
def search_linked_list(head, target):

    # Traverse the Linked List
    while head is not None:

        # Check if the current node\'s data matches the target value
        if head.data == target:

            return True  # Value found
        # Move to the next node
        head = head.next

    return False  # Value not found

````

JavaScript
````
// Javascript function to search for a value in the Linked List
function searchLinkedList(head, target) {

    // Traverse the Linked List
    while (head !== null) {

        // Check if the current node\'s data matches the target value
        if (head.data === target) {
            return true;  // Value found
        }

        // Move to the next node
        head = head.next;
    }

    return false;  // Value not found
}

````



[Length of Singly Linked List](https://www.geeksforgeeks.org/find-length-of-a-linked-list-iterative-and-recursive)
------------------------------------------------------------------------------------------------------------------

Finding Length in Singly Linked List refers to the process of
determining the total number of nodes in a singly linked list.

Step-by-step approach:

* Initialize a counter ****length**** to 0.
* Start from the head of the list, assign it to current.
* Traverse the list:
  + Increment ****length**** for each node.
  + Move to the next node (****current = current->next****).
* Return the final value of ****length****.

Below is the function for finding length in Singly Linked List:

C++
````
// C++ function to find the length of the linked list
int findLength(Node* head)
{
    // Initialize a counter for the length
    int length = 0;

    // Start from the head of the list
    Node* current = head;

    // Traverse the list and increment the length for each
    // node
    while (current != nullptr) {
        length++;
        current = current->next;
    }

    // Return the final length of the linked list
    return length;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Definition of a Node in a singly linked list
struct Node {
    int data;          // Data part of the node
    struct Node* next; // Pointer to the next node in the list
};

// Function to find the length of the linked list
int findLength(struct Node* head)
{
    // Initialize a counter for the length
    int length = 0;

    // Start from the head of the list
    struct Node* curr = head;

    // Traverse the list and increment
    // the length for each node
    while (curr != NULL) {
        length++;
        curr = curr->next;
    }

    // Return the final length of the linked list
    return length;
}

````

Java
````
// Java function to find the length of the linked list
public int findLength(Node head) {

    // Initialize a counter for the length
    int length = 0;

    // Start from the head of the list
    Node current = head;

    // Traverse the list and increment the length for each
    // node
    while (current != null) {
        length++;
        current = current.next;
    }

    // Return the final length of the linked list
    return length;
}

````

Python
````
# Python function to find the length of the linked list
def find_length(head):

    # Initialize a counter for the length
    length = 0

    # Start from the head of the list
    current = head

    # Traverse the list and increment the length for each
    # node
    while current is not None:
        length += 1
        current = current.next

    # Return the final length of the linked list
    return length

````

JavaScript
````
// Javascript function to find the length of the linked list
function findLength(head) {

    // Initialize a counter for the length
    let length = 0;

    // Start from the head of the list
    let current = head;

    // Traverse the list and increment the length for each
    // node
    while (current !== null) {
        length++;
        current = current.next;
    }

    // Return the final length of the linked list
    return length;
}

````




[Insertion in Singly Linked List](https://www.geeksforgeeks.org/insertion-in-linked-list)
-----------------------------------------------------------------------------------------

Insertion is a fundamental operation in linked lists that involves
adding a new node to the list. There are several scenarios for
insertion:

### a. [Insertion at the Beginning of Singly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-front-beginning-of-a-linked-list):

![Insertion-at-the-Beginning-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163445386036/Insertion-at-the-Beginning-of-Singly-Linked-List.webp)


Insert a Node at the Front/Beginning of Linked List



Step-by-step approach:

* Create a new node with the given value.
* Set the ****next**** pointer of the new node to the current head.
* Move the head to point to the new node.
* Return the new head of the linked list.

Below is the function for insertion at the beginning of singly linked
list:

C++
````
// C++ function to insert a new node at the beginning of the
// linked list
Node* insertAtBeginning(Node* head, int value)
{
    // Create a new node with the given value
    Node* newNode = new Node(value);

    // Set the next pointer of the new node to the current
    // head
    newNode->next = head;

    // Move the head to point to the new node
    head = newNode;

    // Return the new head of the linked list
    return head;
}

````

C
````
// Function to insert a new node at the beginning of the linked list
struct Node* insertAtBeginning(struct Node* head, int value)
{
    // Create a new node with the given value
    struct Node* new_node = newNode(value);

    // Set the next pointer of the new node to the current head
    new_node->next = head;

    // Move the head to point to the new node
    head = new_node;

    // Return the new head of the linked list
    return head;
}

````

Java
````
// Java function to insert a new node at the beginning of the
// linked list
public Node insertAtBeginning(Node head, int value) {
    // Create a new node with the given value
    Node newNode = new Node(value);

    // Set the next pointer of the new node to the current
    // head
    newNode.next = head;

    // Move the head to point to the new node
    head = newNode;

    // Return the new head of the linked list
    return head;
}

````

Python
````
# Python function to insert a new node at the beginning of the
# linked list
def insert_at_beginning(head, value):

    # Create a new node with the given value
    new_node = Node(value)

    # Set the next pointer of the new node to the current
    # head
    new_node.next = head

    # Move the head to point to the new node
    head = new_node

    # Return the new head of the linked list
    return head

````

JavaScript
````
// Javascript function to insert a new node at the beginning of the
// linked list
function insertAtBeginning(head, value) {

    // Create a new node with the given value
    let newNode = new Node(value);

    // Set the next pointer of the new node to the current
    // head
    newNode.next = head;

    // Move the head to point to the new node
    head = newNode;

    // Return the new head of the linked list
    return head;
}

````


### b. [Insertion at the End of Singly Linked List:](https://www.geeksforgeeks.org/insert-node-at-the-end-of-a-linked-list)

To insert a node at the end of the list, traverse the list until the
last node is reached, and then link the new node to the current last
node-

![Insertion-at-the-End-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163601409037/Insertion-at-the-End-of-Singly-Linked-List.webp)

Insertion at end of Linked List


Step-by-step approach:

* Create a new node with the given value.
* Check if the list is empty:
  + If it is, make the new node the head and return.
* Traverse the list until the last node is reached.
* Link the new node to the current last node by setting the last node\'s
  next pointer to the new node.

Below is the function for insertion at the end of singly linked
list:

C++
````
// C++ Function to insert a node at the end of the linked
// list
Node* insertAtEnd(Node* head, int value)
{
    // Create a new node with the given value
    Node* newNode = new Node(value);

    // If the list is empty, make the new node the head
    if (head == nullptr)
        return newNode;

    // Traverse the list until the last node is reached
    Node* curr = head;
    while (curr->next != nullptr) {
        curr = curr->next;
    }

    // Link the new node to the current last node
    curr->next = newNode;
    return head;
}

````

C
````
// Function to insert a node at the end of the linked list
struct Node* insertAtEnd(struct Node* head, int value)
{
    // Create a new node with the given value
    struct Node* new_node = newNode(value);

    // If the list is empty, make the new node the head
    if (head == NULL)
        return new_node;

    // Traverse the list until the last node is reached
    struct Node* curr = head;
    while (curr->next != NULL) {
        curr = curr->next;
    }

    // Link the new node to the current last node
    curr->next = new_node;

    return head;
}

````

Java
````
// Function to insert a node at the end of the linked list
public static Node insertAtEnd(Node head, int value)
{
    // Create a new node with the given value
    Node newNode = new Node(value);

    // If the list is empty, make the new node the head
    if (head == null)
        return newNode;

    // Traverse the list until the last node is reached
    Node curr = head;
    while (curr.next != null) {
        curr = curr.next;
    }

    // Link the new node to the current last node
    curr.next = newNode;

    return head;
}

````

Python
````
# Python function to insert a node at the end of the linked
# list
def insert_at_end(head, value):

    # Create a new node with the given value
    new_node = Node(value)

    # If the list is empty, make the new node the head
    if head is None:
        return new_node

    # Traverse the list until the last node is reached
    current = head
    while current.next is not None:
        current = current.next

    # Link the new node to the current last node
    current.next = new_node

    return head

````

JavaScript
````
// Javascript function to insert a node at the end of the linked
// list
function insertAtEnd(head, value) {

    // Create a new node with the given value
    let newNode = new Node(value);

    // If the list is empty, make the new node the head
    if (head === null) {
        return newNode;
    }

    // Traverse the list until the last node is reached
    let current = head;
    while (current.next !== null) {
        current = current.next;
    }

    // Link the new node to the current last node
    current.next = newNode;

    return head;
}

````





### c. [Insertion at a Specific Position of the Singly Linked List:](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-a-linked-list)

To insert a node at a specific position, traverse the list to the
desired position, link the new node to the next node, and update the
links accordingly.

![Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20241022163649252002/Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy.webp)




We mainly find the node after which we need to insert the new node. If
we encounter a NULL before reaching that node, it means that the given
position is invalid.

Below is the function for insertion at a specific position of the
singly linked list:

C++
````
// Function to insert a Node at a specified position
// without using a double pointer
Node* insertPos(Node* head, int pos, int data)
{
    if (pos < 1) {
        cout << "Invalid position!" << endl;
        return head;
    }

    // Special case for inserting at the head
    if (pos == 1) {
        Node* temp = new Node(data);
        temp->next = head;
        return temp;
    }

    // Traverse the list to find the node
    // before the insertion point
    Node* prev = head;
    int count = 1;
    while (count < pos - 1 && prev != nullptr) {
        prev = prev->next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev == nullptr) {
        cout << "Invalid position!" << endl;
        return head;
    }

    // Insert the new node at the specified position
    Node* temp = new Node(data);
    temp->next = prev->next;
    prev->next = temp;

    return head;
}

````

C
````
// Function to insert a node at a specified position
struct Node* insertPos(struct Node* head, int pos, int data) {
    if (pos < 1) {
        printf("Invalid position!\\n");
        return head;
    }

    // Special case for inserting at the head
    if (pos == 1) {
        struct Node* temp = getNode(data);
        temp->next = head;
        return temp;
    }

    // Traverse the list to find the node
    // before the insertion point
    struct Node* prev = head;
    int count = 1;
    while (count < pos - 1 && prev != NULL) {
        prev = prev->next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev == NULL) {
        printf("Invalid position!\\n");
        return head;
    }

    // Insert the new node at the specified position
    struct Node* temp = getNode(data);
    temp->next = prev->next;
    prev->next = temp;

    return head;
}

````

Java
````
public static Node insertPos(Node head, int pos, int data)
{
    if (pos < 1) {
        System.out.println("Invalid position!");
        return head;
    }

    // Special case for inserting at the head
    if (pos == 1) {
        Node temp = new Node(data);
        temp.next = head;
        return temp;
    }

    // Traverse the list to find the node before the
    // insertion point
    Node prev = head;
    int count = 1;
    while (count < pos - 1 && prev != null) {
        prev = prev.next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev == null) {
        System.out.println("Invalid position!");
        return head;
    }

    // Insert the new node at the specified position
    Node temp = new Node(data);
    temp.next = prev.next;
    prev.next = temp;

    return head;
}

````

Python
````
# Function to insert a node at a specified position
def insertPos(head, pos, data):
    if pos < 1:
        print("Invalid position!")
        return head

    # Special case for inserting at the head
    if pos == 1:
        new_node = Node(data)
        new_node.next = head
        return new_node

    # Traverse the list to find the node before
    # the insertion point
    prev = head
    count = 1
    while count < pos - 1 and prev is not None:
        prev = prev.next
        count += 1

    # If position is greater than the number of nodes
    if prev is None:
        print("Invalid position!")
        return head

    # Insert the new node at the specified position
    new_node = Node(data)
    new_node.next = prev.next
    prev.next = new_node

    return head

````

JavaScript
````
// Function to insert a node at a specified position
function insertPos(head, pos, data) {
    if (pos < 1) {
        console.log("Invalid position!");
        return head;
    }

    // Special case for inserting at the head
    if (pos === 1) {
        const newNode = new Node(data);
        newNode.next = head;
        return newNode;
    }

    // Traverse the list to find the node
    // before the insertion point
    let prev = head;
    let count = 1;
    while (count < pos - 1 && prev !== null) {
        prev = prev.next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev === null) {
        console.log("Invalid position!");
        return head;
    }

    // Insert the new node at the specified position
    const newNode = new Node(data);
    newNode.next = prev.next;
    prev.next = newNode;

    return head;
}

````








[Deletion in Singly Linked List](https://www.geeksforgeeks.org/deletion-in-linked-list)
---------------------------------------------------------------------------------------

Deletion involves removing a node from the linked list. Similar to
insertion, there are different scenarios for deletion:

### a. [****Deletion at the Beginning of**** Singly Linked List****:****](https://www.geeksforgeeks.org/remove-first-node-of-the-linked-list)

To delete the first node, update the head to point to the second node
in the list.

![Deletion-at-beginning-](https://media.geeksforgeeks.org/wp-content/uploads/20241022163937663413/Deletion-at-beginning-.webp)

Deletion at beginning in a Linked List


Steps-by-step approach:

* Check if the head is ****NULL****.
  + If it is, return ****NULL**** (the list is empty).
* Store the current head node in a temporary variable ****temp****.
* Move the head pointer to the next node.
* Delete the temporary node.
* Return the new head of the linked list.

Below is the function for deletion at the beginning of singly linked
list:

C++
````
// C++ Function to remove the first node of the linked
// list
Node* removeFirstNode(Node* head)
{
    if (head == nullptr)
        return nullptr;

    // Move the head pointer to the next node
    Node* temp = head;
    head = head->next;

    delete temp;

    return head;
}

````

C
````
// Function to remove the first node of the linked list
struct Node* removeFirstNode(struct Node* head)
{
    if (head == NULL)
        return NULL;

    // Move the head pointer to the next node
    struct Node* temp = head;
    head = head->next;

    // Free the memory of the old head
    free(temp);

    return head;
}

````

Java
````
// Java Function to remove the first node
// of the linked list
static Node removeFirstNode(Node head)
{
    if (head == null)
        return null;

    // Move the head pointer to the next node
    Node temp = head;
    head = head.next;

    return head;
}

````

Python
````
# Python Function to remove the first node
# of the linked list
def removeFirstNode(head):
    if not head:
        return None
    temp = head

    # Move the head pointer to the next node
    head = head.next
    temp = None
    return head

````

JavaScript
````
// Javascript Function to remove the first node
// of the linked list /
function removeFirstNode(head) {
  if (head == null) return null;

  // Move the head pointer to the next node
  temp = head;
  head = head.next;

  return head;
}

````


### b. [Deletion at the End of Singly Linked List:](https://www.geeksforgeeks.org/remove-last-node-of-the-linked-list)

To delete the last node, traverse the list until the second-to-last
node and update its next field to None.

![Deletion-At-End](https://media.geeksforgeeks.org/wp-content/uploads/20241022164030481275/Deletion-At-End.webp)

Deletion at the end of linked list


Step-by-step approach:

* Check if the head is ****NULL****.
  + If it is, return NULL (the list is empty).
* Check if the head\'s ****next**** is ****NULL**** (only one node in the list).
  + If true, delete the head and return ****NULL****.
* Traverse the list to find the second last node (****second\\_last****).
* Delete the last node (the node after ****second\\_last****).
* Set the ****next**** pointer of the second last node to ****NULL****.
* Return the head of the linked list.

Below is the function for deletion at the end of singly linked
list:

C++
````
// C++ Function to remove the last node of the linked list
Node* removeLastNode(Node* head)
{
    if (head == nullptr)
        return nullptr;

    if (head->next == nullptr) {
        delete head;
        return nullptr;
    }

    // Find the second last node
    Node* second_last = head;
    while (second_last->next->next != nullptr)
        second_last = second_last->next;

    // Delete last node
    delete (second_last->next);

    // Change next of second last
    second_last->next = nullptr;

    return head;
}

````

C
````
// Function to remove the last node of the linked list
struct Node* removeLastNode(struct Node* head)
{
    if (head == NULL)
        return NULL;

    if (head->next == NULL) {
        free(head);
        return NULL;
    }

    // Find the second last node
    struct Node* second_last = head;
    while (second_last->next->next != NULL)
        second_last = second_last->next;

    // Delete last node
    free(second_last->next);

    // Change next of second last
    second_last->next = NULL;

    return head;
}

````

Java
````
// Java Function to remove the last node of the linked list
Node removeLastNode(Node head)
{
    // If the list is empty, return null
    if (head == null)
        return null;

    // If the list has only one node, delete it and return
    // null
    if (head.next == null) {
        head = null;
        return null;
    }

    // Find the second last node
    Node second_last = head;
    while (second_last.next.next != null)
        second_last = second_last.next;

    // Remove the last node
    second_last.next = null;

    // Return the modified list
    return head;
}

````

Python
````
# Python Function to remove the last node of the linked list
def removeLastNode(head):
    # If the list is empty, return None
    if head is None:
        return None

    # If the list has only one node, delete it and return None
    if head.next is None:
        head = None
        return None

    # Find the second last node
    second_last = head
    while second_last.next.next is not None:
        second_last = second_last.next

    # Remove the last node
    second_last.next = None

    # Return the modified list
    return head

````

JavaScript
````
// Javascript Function to remove the last node of the linked list
function removeLastNode(head) {
    // If the list is empty, return null
    if (head === null)
        return null;

    // If the list has only one node, delete it
    // and return null
    if (head.next === null) {
        head = null;
        return null;
    }

    // Find the second last node
    let second_last = head;
    while (second_last.next.next !== null)
        second_last = second_last.next;

    // Remove the last node
    second_last.next = null;

    // Return the modified list
    return head;
}

````




### c. [Deletion at a Specific Position of Singly Linked List:](https://www.geeksforgeeks.org/delete-a-linked-list-node-at-a-given-position)

To delete a node at a specific position, traverse the list to the
desired position, update the links to bypass the node to be
deleted.

![Deletion-specific-At-End--](https://media.geeksforgeeks.org/wp-content/uploads/20241022164248836160/Deletion-specific-At-End--.webp)

Delete a Linked List node at a given position


Step-by-step approach:

* Check if the list is empty or the position is invalid, return if
  so.
* If the head needs to be deleted, update the head and delete the
  node.
* Traverse to the node before the position to be deleted.
* If the position is out of range, return.
* Store the node to be deleted.
* Update the links to bypass the node.
* Delete the stored node.

Below is the function for deletion at a specific position of singly
linked list:

C++
````
// C++ function to delete a node at a specific position
Node* deleteAtPosition(Node* head, int position)
{
    // If the list is empty or the position is invalid
    if (head == nullptr || position < 1) {
        return head;
    }

    // If the head needs to be deleted
    if (position == 1) {
        Node* temp = head;
        head = head->next;
        delete temp;
        return head;
    }

    // Traverse to the node before the position to be
    // deleted
    Node* current = head;
    for (int i = 1; i < position - 1 && current != nullptr;
         i++) {
        current = current->next;
    }

    // If the position is out of range
    if (current == NULL || current->next == nullptr) {
        return;
    }

    // Store the node to be deleted
    Node* temp = current->next;

    // Update the links to bypass the node to be deleted
    current->next = current->next->next;

    // Delete the node
    delete temp;

    return head;
}

````

C
````
// Function to delete a node at a specific position
struct Node* deleteAtPosition(struct Node* head, int position)
{
    // If the list is empty or the position is invalid
    if (head == NULL || position < 1) {
        return head;
    }

    // If the head needs to be deleted
    if (position == 1) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return head;
    }

    // Traverse to the node before the position to be deleted
    struct Node* curr = head;
    for (int i = 1; i < position - 1 && curr != NULL; i++) {
        curr = curr->next;
    }

    // If the position is out of range
    if (curr == NULL || curr->next == NULL) {
        return head;
    }

    // Store the node to be deleted
    struct Node* temp = curr->next;

    // Update the links to bypass the node to be deleted
    curr->next = curr->next->next;

    // Delete the node
    free(temp);

    return head;
}

````

Java
````
// Java function to delete a node at a specific position
public void deleteAtPosition(Node head, int position)
{
    // If the list is empty or the position is invalid
    if (head == null || position < 1) {
        return;
    }

    // If the head needs to be deleted
    if (position == 1) {
        Node temp = head;
        head = head.next;
        temp = null;
        return;
    }

    // Traverse to the node before the position to be
    // deleted
    Node current = head;
    for (int i = 1; i < position - 1 && current != null;
         i++) {
        current = current.next;
    }

    // If the position is out of range
    if (current == null || current.next == null) {
        return;
    }

    // Store the node to be deleted
    Node temp = current.next;

    // Update the links to bypass the node to be deleted
    current.next = current.next.next;

    // Delete the node
    temp = null;
}

````

Python
````
# Python function to delete a node at a specific position
def delete_at_position(head, position):
    # If the list is empty or the position is invalid
    if head is None or position < 1:
        return head

    # If the head needs to be deleted
    if position == 1:
        temp = head
        head = head.next
        temp = None
        return head

    # Traverse to the node before the position to be deleted
    current = head
    for i in range(1, position - 1):
        if current is not None:
            current = current.next

    # If the position is out of range
    if current is None or current.next is None:
        return head

    # Store the node to be deleted
    temp = current.next

    # Update the links to bypass the node to be deleted
    current.next = current.next.next

    # Delete the node
    temp = None
    return head

````

JavaScript
````
// Javascript function to delete a node at a specific position
function deleteAtPosition(head, position) {
    // If the list is empty or the position is invalid
    if (head === null || position < 1) {
        return head;
    }

    // If the head needs to be deleted
    if (position === 1) {
        let temp = head;
        head = head.next;
        temp = null;
        return head;
    }

    // Traverse to the node before the position to be deleted
    let current = head;
    for (let i = 1; i < position - 1 && current !== null; i++) {
        current = current.next;
    }

    // If the position is out of range
    if (current === null || current.next === null) {
        return head;
    }

    // Store the node to be deleted
    let temp = current.next;

    // Update the links to bypass the node to be deleted
    current.next = current.next.next;

    // Delete the node
    temp = null;
    return head;
}

````


', 'A singly linked list is a fundamental data structure, it consists of nodes where each node contains a data field and a reference to the next node in the linked list. The next of the last node is null, indicating the end of the list. Linked Lists support efficient insertion and deletion operations.', 'Singly Linked List Tutorial', 1, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', 'e73a74e2-29d5-4617-aa46-84c970dbba55');
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('e9c94003-0430-44e0-ac55-fda3101baf00', e'Given two integers ****a**** and ****b**** (b != 0), the task is to return the fraction ****a/b**** in string format. If the fractional part is repeating, enclose the repeating part in parentheses.****Examples:****


> ****Input****
> : a = 1, b = 2
>
>
>
> ****Output****
> : “0.5”
>
>
>
> ****Explanation:****
> 1/2 = 0.5 with no repeating part.
>
>
>
>
>
> ****Input****
> : a = 50, b = 22
>
>
>
> ****Output****
> : “2.(27)”
>
>
>
> ****Explanation:****
> 50/22 = 2.27272727… Since fractional part (27) is repeating, it is enclosed in parentheses.

****Approach****
:


> The idea is to first calculate the integral quotient (absolute part before decimal point) and then calculate the fractional part. To check if the fractional part is repeating, insert the remainder (a % b) in a
>
> [hash map](https://www.geeksforgeeks.org/hashing-data-structure/)
> with key as remainder and value as the index position at which this remainder occurs. If at any point of time, the remainder becomes zero, then there doesn’t exist a repeating fraction otherwise if the remainder is already found in the map, then there exists a repeating fraction.

C++

````
// C++ Program to convert fraction to string

#include <iostream>
#include <unordered_map>
using namespace std;

string calculateFraction(int a, int b) {

    // If the numerator is zero, answer is 0
    if (a == 0)
        return "0";

    // If exactly one of the numerator or denominator
    // is negative, then result will be negative
    string res = (a < 0) ^ (b < 0) ? "-" : "";

    a = abs(a);
    b = abs(b);

    // Calculate and Append the part before decimal point
    res += to_string(a / b);

    int rem = a % b;

    // If completely divisible, return res
    if (rem == 0)
        return res;

    res.append(".");
    unordered_map<int, int> mp;

    while (rem > 0) {

        // If this remainder is already seen,
        // then there exists a repeating fraction.
        if (mp.find(rem) != mp.end()) {

            res.insert(mp[rem], "(");
            res.append(")");
            break;
        }

        // If the remainder is seen for the first time,
        // store its index
        mp[rem] = res.size();

        rem = rem * 10;

        // Calculate quotient, append it to result and
        // calculate next remainder
        res += to_string(rem / b);
        rem = rem % b;
    }

    return res;
}

int main() {
    int a = 50, b = 22;
    cout << calculateFraction(a, b) << endl;
    return 0;
}

````

Java

````
// Java Program to convert fraction to string

import java.util.HashMap;

class GfG {
    static String calculateFraction(int a, int b) {

        // If the numerator is zero, answer is "0"
        if (a == 0)
            return "0";

        // If exactly one of the numerator or denominator
        // is negative, then result will be negative
        String res = (a < 0) ^ (b < 0) ? "-" : "";

        a = Math.abs(a);
        b = Math.abs(b);

        // Calculate and Append the part before decimal point
        res += Integer.toString(a / b);

        int rem = a % b;

        // If completely divisible, return res
        if (rem == 0)
            return res;

        res += ".";
        HashMap<Integer, Integer> mp = new HashMap<>();

        while (rem > 0) {

            // If this remainder is already seen,
            // then there exists a repeating fraction.
            if (mp.containsKey(rem)) {
                res = res.substring(0, mp.get(rem)) + "(" + res.substring(mp.get(rem)) + ")";
                break;
            }

            // If the remainder is seen for the first time,
            // store its index
            mp.put(rem, res.length());

            rem = rem * 10;

            // Calculate quotient, append it to result and
            // calculate next remainder
            res += Integer.toString(rem / b);
            rem = rem % b;
        }

        return res;
    }

    public static void main(String[] args) {
        int a = 50, b = 22;
        System.out.println(calculateFraction(a, b));
    }
}

````

Python

````
# Python Program to convert fraction to string

def calculateFraction(a, b):

    # If the numerator is zero, answer is "0"
    if a == 0:
        return "0"

    # If exactly one of the numerator or denominator
    # is negative, then result will be negative
    res = "-" if (a < 0) ^ (b < 0) else ""

    a = abs(a)
    b = abs(b)

    # Calculate and Append the part before decimal point
    res += str(a // b)

    rem = a % b

    # If completely divisible, return res
    if rem == 0:
        return res

    res += "."
    mp = {}

    while rem > 0:

        # If this remainder is already seen,
        # then there exists a repeating fraction.
        if rem in mp:
            res = res[:mp[rem]] + "(" + res[mp[rem]:] + ")"
            break

        # If the remainder is seen for the first time,
        # store its index
        mp[rem] = len(res)

        rem = rem * 10

        # Calculate quotient, append it to result and
        # calculate next remainder
        res += str(rem // b)
        rem = rem % b

    return res

if __name__ == "__main__":
    a = 50
    b = 22
    print(calculateFraction(a, b))

````

C#

````
// C# Program to convert fraction to string

using System;
using System.Collections.Generic;

class GfG {
    static string calculateFraction(int a, int b) {

        // If the numerator is zero, answer is "0"
        if (a == 0)
            return "0";

        // If exactly one of the numerator or denominator
        // is negative, then result will be negative
        string res = (a < 0) ^ (b < 0) ? "-" : "";

        a = Math.Abs(a);
        b = Math.Abs(b);

        // Calculate and Append the part before decimal point
        res += a / b;

        int rem = a % b;

        // If completely divisible, return res
        if (rem == 0)
            return res;

        res += ".";
        Dictionary<int, int> mp = new Dictionary<int, int>();

        while (rem > 0) {

            // If this remainder is already seen,
            // then there exists a repeating fraction.
            if (mp.ContainsKey(rem)) {
                res = res.Insert(mp[rem], "(");
                res += ")";
                break;
            }

            // If the remainder is seen for the first time,
            // store its index
            mp[rem] = res.Length;

            rem = rem * 10;

            // Calculate quotient, append it to result and
            // calculate next remainder
            res += rem / b;
            rem = rem % b;
        }

        return res;
    }

    static void Main() {
        int a = 50, b = 22;
        Console.WriteLine(calculateFraction(a, b));
    }
}

````

JavaScript

````
// JavaScript Program to convert fraction to string

function calculateFraction(a, b) {

    // If the numerator is zero, answer is "0"
    if (a === 0) {
        return "0";
    }

    // If exactly one of the numerator or denominator
    // is negative, then result will be negative
    let res = (a < 0) ^ (b < 0) ? "-" : "";

    a = Math.abs(a);
    b = Math.abs(b);

    // Calculate and Append the part before decimal point
    res += Math.floor(a / b);

    let rem = a % b;

    // If completely divisible, return res
    if (rem === 0) {
        return res;
    }

    res += ".";
    let mp = new Map();

    while (rem > 0) {
        // If this remainder is already seen,
        // then there exists a repeating fraction.
        if (mp.has(rem)) {
            let repeatIndex = mp.get(rem);
            res = res.substring(0, repeatIndex) + "("
                        + res.substring(repeatIndex) + ")";
            break;
        }

        // If the remainder is seen for the first time,
        // store its index
        mp.set(rem, res.length);

        rem = rem * 10;

        // Calculate quotient, append it to result and
        // calculate next remainder
        res += Math.floor(rem / b);
        rem = rem % b;
    }

    return res;
}

// Driver Code
let a = 50, b = 22;
console.log(calculateFraction(a, b));

````
**Output**
```
2.(27)

```

****Time Complexity****
: O(max(log10(a), log10(b))), we can make any number of recurring digits in the fraction. For example:


* 2/9 = 0.22222..
* 21/99 = 0.212121…
* 213/999 = 0.213213…
* 2134/9999 = 0.21342134…
* 21345/99999 = 0.2134521345… and so on.

****Auxiliary Space****
: O(max(log10(a), log10(b))), to store the result.

', '', 'Fraction to Recurring Decimal', 1, null, '598d78e5-c34f-437f-88fb-31557168c07b', 'fa41a74d-5590-49a6-84f7-ad1ceed83eaf');
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('864de22e-8f8d-4d5d-93ff-2bb5714cc2f5', e'Let’s take a look a simple example to demonstrate the use of vector
container:


C++
````
#include <bits/stdc++.h>
using namespace std;

int main() {

      // Creating a vector of 5 elements
      vector<int> v = {1, 4, 2, 3, 5};

      for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
      return 0;
}

````

**Output**
```
1 4 2 3 5
```

Table of Content

* [Syntax of Vector](#create-a-vector)
* [Declaration and Initialization](#initialize-a-vector)
* [Basic Vector Operations](#basic-vector-operations)

+ [Accessing Elements](#accessing-elements)
+ [Updating Elements](#updating-elements)
+ [Traversing Vector](#traversal)
+ [Inserting Elements](#insert)
+ [Deleting Elements](#delete)

* [Other Common Operations on Vector](#common-examples-of-vector-in-c)
* [Passing Vector to Functions](#passing-vector-to-functions)
* [Internal Working of Vector](#internal-working-of-vector)
* [2D Vectors](#2d-vectors)
* [All Member Functions of Vector](#all-member-functions-of-stdvector)

Syntax of Vector
----------------

Vector is defined as the ****std::vector****
class template which contains its implementation and some useful member
functions. It is defined inside the ****<vector>**** header file.

> ****vector****<**T**> vec\\_name;

where,

* ****T:**** Type of elements in the vector.
* ****vec\\_name:**** Name assigned to the vector.

To master vectors and other STL components, check out our [****Complete C++ Course****](https://gfgcdn.com/tu/T5Y/), which covers the ins and outs of C++ STL with real-world examples and
hands-on projects.


Declaration and Initialization
------------------------------

Declaration and initialization are the process of creating an instance
of std::vector class and assigning it some initial value. In C++,
vectors can be declared and initialized in multiple ways as shown
below:

****1. Default Initialization****

An empty vector can be created using the below declaration. This vector
can be filled later on in the program.

> ****vector****<T> vec\\_name;

****2. Initialization with Size and Default Value****

A vector of a specific size can also be declared and initialized to the
given value as default value.

> ****vector****<T> vec\\_name(size, value);

****3. Initialization Using Initializer List****

Vector can also be initialized using a list of values enclosed in ****{} braces**** separated by comma.

> ****vector****<T> vec\\_name = { v1, v2, v3….};
> ****vector****<T> vec\\_name ({ v1, v2, v3….});

Let’s take a look at an example that shows implements the above
methods:

C++
````
#include <bits/stdc++.h>
using namespace std;

void printV(vector<int> &v) {
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
    cout << endl;
}

int main() {

    // Creating an empty vector
    vector<int> v1;

    // Creating a vector of 5 elements from
    // initializer list
    vector<int> v2 = {1, 4, 2, 3, 5};

    // Creating a vector of 5 elements with
    // default value
    vector<int> v3(5, 9);

    printV(v1);
    printV(v2);
    printV(v3);

    return 0;
}

````





**Output**
```

1 4 2 3 5
9 9 9 9 9

```

More ways to declare and initialize vectors are discussed in this
article – [8 Ways to Initialize Vector in C++](https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/)

Basic Vector Operations
-----------------------

The basic operations of vector are shown below:

### 1. Accessing Elements

Just like arrays, vector elements can be accessed using their index
inside the [****[] subscript operator****](https://www.geeksforgeeks.org/vectoroperator-vectoroperator-c-stl/). This method is fast but doesn’t check whether the given index exists
in the vector or not. So, there is another member method [****vector at()****](https://www.geeksforgeeks.org/vector-at-in-cpp-stl/) for safely accessing elements:

The below example illustrates how to access the vector elements:

C++
````
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {\'a\', \'c\', \'f\', \'d\', \'z\'};

    // Accessing and printing values using indexes
      cout << v[3] << endl;
      cout << v.at(2);

    return 0;
}

````

**Output**
```
d
f
```

To know more about accessing vector elements, refer to the article – [How to Access an Element in a Vector in C++?](https://www.geeksforgeeks.org/how-to-access-element-in-vector-using-index-in-cpp/)

### 2. Updating Elements

Updating elements is very similar to the accessing except that we use
an additional assignment operator to assign a new value to a particular
element. It uses the same methods: [] subscript operator and vector
at().

The below example illustrates how to update vector elements:

C++
````
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {\'a\', \'c\', \'f\', \'d\', \'z\'};

    // Updating values using indexes 3 and 2
      v[3] = \'D\';
      v.at(2) = \'F\';

      cout << v[3] << endl;
      cout << v.at(2);

    return 0;
}

````

**Output**
```

D
F
```

More methods to update vector elements are discussed in this article – [How to Update Vector Elements in C++?](https://www.geeksforgeeks.org/change-an-element-by-index-in-vector-in-cpp/)

### 3. Traversing Vector

Vector in C++ can be traversed using indexes in a loop. The indexes
start from 0 and go up to vector size – 1. To iterate through this
range, we can use a loop and determine the size of the vector using the [vector size()](https://www.geeksforgeeks.org/vectorempty-vectorsize-c-stl/) method.

C++
````
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {\'a\', \'c\', \'f\', \'d\', \'z\'};

    // Traversing vector using vector size()
      for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
    return 0;
}

````

**Output**
```

a c f d z
a c f d z
```

More ways to traverse vectors are discussed in this article – [How to Iterate Through a Vector in C++?](https://www.geeksforgeeks.org/how-to-iterate-through-a-vector-in-cpp/)

### 4. Inserting Elements

An element can be inserted into a vector using [****vector insert()****](https://www.geeksforgeeks.org/vector-insert-function-in-cpp-stl)
method which takes linear time. But for the insertion at the end, the [****vector push\\_back()****](https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/)
method can be used. It is much faster, taking only constant time.

The below example illustrates how to insert elements in the
vector:

C++
````
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {\'a\', \'f\', \'d\'};

      // Inserting \'z\' at the back
      v.push_back(\'z\');

      // Inserting \'c\' at index 1
      v.insert(v.begin() + 1, \'c\');

      for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
    return 0;
}

````

More ways to insert an element in the vector are discussed in this
article – [How to Add Elements in a Vector in C++?](https://www.geeksforgeeks.org/how-to-add-elements-in-a-vector-in-cpp/)

### 5. Deleting Elements

An element can be deleted from a vector using [****vector erase()****](https://www.geeksforgeeks.org/vector-erase-and-clear-in-cpp/)
but this method needs iterator to the element to be deleted. If only the
value of the element is known, then find() function is used to find the
position of this element.

For the deletion at the end, the [****vector pop\\_back()****](https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/)
method can be used, and it is much faster, taking only constant
time.

The below example demonstrates how to delete an element from the
vector:

C++
````
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {\'a\', \'c\', \'f\', \'d\', \'z\'};

    // Deleting last element \'z\'
      v.pop_back();
      for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
    cout << endl;

      // Deleting element \'f\'
      v.erase(find(v.begin(), v.end(), \'f\'));
      for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
    return 0;
}

````

**Output**
```

a c f d
a c d
```

To know more about the deletion of an element in the vector, refer to
this article – [How to Remove an Element from Vector in C++?](https://www.geeksforgeeks.org/how-to-remove-an-element-from-vector-in-cpp/)

Other Common Operations on Vector
---------------------------------

Vector is one of the most frequently used containers in C++. It is used
in many situations for different purposes. The following examples aim to
help you master vector operations beyond the basics.', e'Array in C is one of the most used data structures in C programming. It is a
simple and fast way of storing multiple values under a single name. In
this article, we will study the different aspects of array in C language
such as array declaration, definition, initialization, types of arrays,
array syntax, advantages and disadvantages, and many more.', 'C Arrays', 3, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('ff4db851-5e60-40f5-9ff9-ab98645fc05c', e'**Types of Queues:**

There are **five different types of queues** that are used in
different scenarios. They are:

1. Input Restricted Queue (this is a Simple Queue)
2. Output Restricted Queue (this is also a Simple Queue)
3. Circular Queue
4. Double Ended Queue (Deque)
5. Priority Queue
   * Ascending Priority Queue
   * Descending Priority Queue

![Types of Queues](https://media.geeksforgeeks.org/wp-content/uploads/20220623134709/typesofqueues.jpg)

Types of Queues

**1.** [**Circular Queue**](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/)**:** Circular Queue is a linear data structure in which the
operations are performed based on FIFO (First In First Out) principle and
the last position is connected back to the first position to make a
circle. It is also called **‘Ring Buffer’**. This queue is
primarily used in the following cases:

1. **Memory Management:** The unused memory locations in the
   case of ordinary queues can be utilized in circular queues.
2. **Traffic system:** In a computer-controlled traffic
   system, circular queues are used to switch on the traffic lights one by
   one repeatedly as per the time set.
3. **CPU Scheduling:** Operating systems often maintain a
   queue of processes that are ready to execute or that are waiting for a
   particular event to occur.

The time complexity for the circular Queue is O(1).

**2. Input restricted Queue:** In this type of Queue, the
input can be taken from one side only(rear) and deletion of elements can
be done from both sides(front and rear). This kind of Queue does not
follow FIFO(first in first out).  This queue is used in cases where
the consumption of the data needs to be in FIFO order but if there is a
need to remove the recently inserted data for some reason and one such
case can be irrelevant data, performance issue, etc.



![Input Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131417/inputrestrictedqueue.jpg)

Input Restricted Queue

**Advantages of Input restricted Queue:**

* Prevents overflow and overloading of the queue by limiting the number of
  items added
* Helps maintain stability and predictable performance of the system

**Disadvantages of Input restricted Queue:**

* May lead to resource wastage if the restriction is set too low and items
  are frequently discarded
* May lead to waiting or blocking if the restriction is set too high and
  the queue is full, preventing new items from being added.

**3. Output restricted Queue:** In this type of Queue, the
input can be taken from both sides(rear and front) and the deletion of the
element can be done from only one side(front).  This queue is used in
the case where the inputs have some priority order to be executed and the
input can be placed even in the first place so that it is executed
first.

![Output Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131455/outputrestrictedqueue.jpg)

Output Restricted Queue

**4.** [**Double ended Queue**](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/)**:** Double Ended Queue is also a Queue data structure in
which the insertion and deletion operations are performed at both the ends
(front and rear). That means, we can insert at both front and rear
positions and can delete from both front and rear positions.  Since
Deque supports both stack and queue operations, it can be used as both.
The Deque data structure supports clockwise and anticlockwise rotations in
O(1) time which can be useful in certain applications. Also, the problems
where elements need to be removed and or added both ends can be
efficiently solved using Deque.

![Double Ended Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131811/doubleended.jpg)

Double Ended Queue

**5.** [**Priority Queue**](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)**:** A priority queue is a special type of queue in which
each element is associated with a priority and is served according to its
priority. There are two types of Priority Queues. They are:

1. **Ascending Priority Queue:** Element can be inserted
   arbitrarily but only smallest element can be removed. For example,
   suppose there is an array having elements 4, 2, 8 in the same order. So,
   while inserting the elements, the insertion will be in the same sequence
   but while deleting, the order will be 2, 4, 8.
2. **Descending priority Queue:** Element can be inserted
   arbitrarily but only the largest element can be removed first from the
   given Queue. For example, suppose there is an array having elements 4,
   2, 8 in the same order. So, while inserting the elements, the insertion
   will be in the same sequence but while deleting, the order will be 8, 4, 2.

The time complexity of the Priority Queue is O(logn).

[**Applications of a Queue:**](https://www.geeksforgeeks.org/applications-of-queue-data-structure/)

The [queue](https://www.geeksforgeeks.org/queue-set-1introduction-and-array-implementation is used when things don’t have to be processed immediately, but have to be processed in First In First Out order like [Breadth First Search](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/). This property of Queue makes it also useful in the following kind of scenarios.

1. When a resource is shared among multiple consumers. Examples include   [CPU scheduling](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/),   [Disk Scheduling](https://www.geeksforgeeks.org/disk-scheduling-algorithms/).
2. When data is transferred asynchronously (data not necessarily received
   at the same rate as sent) between two processes. Examples include IO
   Buffers, [pipes](https://www.geeksforgeeks.org/piping-in-unix-or-linux/), file IO, etc.
3. Linear Queue: A linear queue is a type of queue where data elements are
   added to the end of the queue and removed from the front of the queue.
   Linear queues are used in applications where data elements need to be
   processed in the order in which they are received. Examples include
   printer queues and message queues.
4. Circular Queue: A circular queue is similar to a linear queue, but the
   end of the queue is connected to the front of the queue. This allows for
   efficient use of space in memory and can improve performance. Circular
   queues are used in applications where the data elements need to be
   processed in a circular fashion. Examples include CPU scheduling and
   memory management.
5. Priority Queue: A priority queue is a type of queue where each element
   is assigned a priority level. Elements with higher priority levels are
   processed before elements with lower priority levels. Priority queues
   are used in applications where certain tasks or data elements need to be
   processed with higher priority. Examples include operating system task
   scheduling and network packet scheduling.
6. Double-ended Queue: A double-ended queue, also known as a deque, is a
   type of queue where elements can be added or removed from either end of
   the queue. This allows for more flexibility in data processing and can
   be used in applications where elements need to be processed in multiple
   directions. Examples include job scheduling and searching algorithms.
7. Concurrent Queue: A concurrent queue is a type of queue that is designed
   to handle multiple threads accessing the queue simultaneously.
   Concurrent queues are used in multi-threaded applications where data
   needs to be shared between threads in a thread-safe manner. Examples
   include database transactions and web server requests.

**Issues of Queue :**

Some common issues that can arise when using queues:

1. Queue overflow: Queue overflow occurs when the queue reaches its maximum
   capacity and is unable to accept any more elements. This can cause data
   loss and can lead to application crashes.
2. Queue underflow: Queue underflow occurs when an attempt is made to
   remove an element from an empty queue. This can cause errors and
   application crashes.
3. Priority inversion: Priority inversion occurs in priority queues when a
   low-priority task holds a resource that a high-priority task needs. This
   can cause delays in processing and can impact system performance.
4. Deadlocks: Deadlocks occur when multiple threads or processes are
   waiting for each other to release resources, resulting in a situation
   where none of the threads can proceed. This can happen when using
   concurrent queues and can lead to system crashes.
5. Performance issues: Queue performance can be impacted by various
   factors, such as the size of the queue, the frequency of access, and the
   type of operations performed on the queue. Poor queue performance can
   lead to slower system performance and reduced user experience.
6. Synchronization issues: Synchronization issues can arise when multiple
   threads are accessing the same queue simultaneously. This can result in
   data corruption, race conditions, and other errors.
7. Memory management issues: Queues can use up significant amounts of
   memory, especially when processing large data sets. Memory leaks and
   other memory management issues can occur, leading to system crashes and
   other errors.

**Reference :**

Some references for further reading on queues:

1. “Data Structures and Algorithms in Java” by Robert Lafore – This book
   provides an in-depth explanation of different types of queues and their
   implementations in Java.
2. “Introduction to Algorithms” by Thomas H. Cormen et al. – This textbook
   covers the basic concepts of data structures and algorithms, including
   queues and their various applications.
3. “Concurrency in C# Cookbook” by Stephen Cleary – This book provides
   practical examples of how to use concurrent queues in C# programming.
4. “Queue (abstract data type)” on Wikipedia – This article provides an
   overview of queues and their properties, as well as examples of their
   applications.
5. “The Art of Computer Programming, Volume 1: Fundamental Algorithms” by
   Donald E. Knuth – This book includes a detailed analysis of different
   queue algorithms and their performance.
6. “Queues and the Producer-Consumer Problem” by Douglas C. Schmidt – This
   paper discusses how queues can be used to solve the producer-consumer
   problem in concurrent programming.', e'Queue is a linear structure that follows a particular order in which the
operations are performed. The order is First In First Out (FIFO). A good
example of a queue is any queue of consumers for a resource where the
consumer that came first is served first. In this article, the different
types of queues are discussed.', 'Different Types of Queues and its Applications', 6, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('d6d953c0-ff47-4998-ae93-b22677a0fd02', e'**Basic Operations on Queue:**
------------------------------

Some of the basic operations for Queue in Data Structure are:

* **enqueue() –** Insertion of elements to the queue.
* **dequeue() –** Removal of elements from the queue.
* **peek() or front()-** Acquires the data element available
  at the front node of the queue without deleting it.
* **rear() –** This operation returns the element at the rear
  end without removing it.
* **isFull() –** Validates if the queue is full.
* **isEmpty() –** Checks if the queue is empty.
* **size():** This operation returns the size of the queue
  i.e. the total number of elements it contains.

![](https://media.geeksforgeeks.org/wp-content/uploads/20221209094646/Queue-768.png)

Queue Data Structure

### **Operation 1: enqueue()**

Inserts an element at the end of the queue i.e. at the rear end.

The following steps should be taken to enqueue (insert) data into a queue:

* Check if the queue is full.
* If the queue is full, return overflow error and exit.
* If the queue is not full, increment the rear pointer to point to the
  next empty space.
* Add the data element to the queue location, where the rear is pointing.
* return success.

![Enqueue representation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122158/fifo1-660x371.png)

Enqueue representation

Below is the Implementation of the above approach:

* C++


C++
```
void queueEnqueue(int data)
{  // Check queue is full or not
    if (capacity == rear) {
        printf("\\nQueue is full\\n");
        return;  }
    // Insert element at the rear
    else {  queue[rear] = data;  rear++;  }
        return;  }
```








**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

### **Operation 2: dequeue()**

This operation removes and returns an element that is at the front end of
the queue.

The following steps are taken to perform the dequeue operation:

* Check if the queue is empty.
* If the queue is empty, return the underflow error and exit.
* If the queue is not empty, access the data where the front is pointing.
* Increment the front pointer to point to the next available data element.
* The Return success.

![Dequeue operation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122625/fifo2-660x371.png)

Dequeue operation

Below is the Implementation of above approach:

* C++
C++
```
 void queueDequeue()  {
     // If queue is empty
     if (front == rear) {
        printf("\\nQueue is empty\\n");
         return;  }
     // Shift all the elements from index 2
    // till rear to the left by one
    else {
        for (int i = 0; i < rear - 1; i++)
            {
                queue[i] = queue[i + 1];
}
        // decrement rear  rear--;
    }
        return;
}
```

**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

### Operation 4 : rear()

This operation returns the element at the rear end without removing it.

The following steps are taken to perform the rear operation:

* If the queue is empty return the most minimum value.
* otherwise, return the rear value.

Below is the Implementation of the above approach:

* C++

C++
```
//Function to get rear of queue
int rear(Queue* queue)  {
    if (isEmpty(queue))
        return INT_MIN;
return queue->arr[queue->rear];

}

```



**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

### **Operation 5: isEmpty():**

This operation returns a boolean value that indicates whether the queue is
empty or not.

The following steps are taken to perform the Empty operation:

* check if front value is equal to -1 or not, if yes then return true
  means queue is empty.
* Otherwise return false, means queue is not empty

Below is the implementation of the above approach:

* C++


C++
```
// This function will check whether
//the queue is empty or not:
    bool isEmpty() {
    if (front == -1)
        return true;
else return false;
}
```



**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

### **Operation 6 : isFull()**

This operation returns a boolean value that indicates whether the queue is
full or not.

The following steps are taken to perform the isFull() operation:

* Check if front value is equal to zero and rear is equal to the capacity
  of queue if yes then return true.
* otherwise return false

Below is the Implementation of the above approach:

* C++


C++
```
// This function will check
// whether the queue is full or not.
bool isFull()  {
    if (front == 0 && rear == MAX_SIZE - 1) {
        return true;
}
    return false;
}
```

**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

### Operation 7: size()

This operation returns the size of the queue i.e. the total number of
elements it contains.

```
queuename.size()
Parameters :
No parameters are passed
Returns :
Number of elements in the container
```

* C++


C++
```
// CPP program to illustrate
// Implementation of size() function
#include <iostream>
#include <queue>
using namespace std;
int main()  {
    int sum = 0;
    queue<int> myqueue;
    myqueue.push(1);
    myqueue.push(8);
    myqueue.push(3);
    myqueue.push(6);
    myqueue.push(2);
// Queue becomes 1, 8, 3, 6, 2
    cout << myqueue.size();
return 0;

}
```

**Complexity Analysis:**
**Time Complexity:** O(1)
**Space Complexity:** O(N)

', '', 'Basic Operations for Queue in Data Structure', 7, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('dfada5ab-a189-4507-8c06-78c269c52440', e'Basic Terminologies of Queue
----------------------------

* ****Front:**** Position of the entry in a queue ready to be served, that is, the
  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.
* ****Rear:****
  Position of the last entry in the queue, that is, the one most
  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.
* ****Size:**** Size refers to the ****current**** number of elements in the queue.
* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.

****Representation of Queue****
-------------------------------

![Representation-of-Queue-Data-Structure](https://media.geeksforgeeks.org/wp-content/uploads/20241212130245410876/Representation-of-Queue-Data-Structure-768.webp)

Operations on Queue
-------------------

### ****1. Enqueue:****

Enqueue operation ****adds (or stores) an element to the end of the queue****.

****Steps:****

1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.
2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.
3. Insert the element at the rear.


![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)


![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)


![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)


![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)


![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)


![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)



Previous





Pause

Next





3 / 6



### ****2. Dequeue:****

Dequeue operation removes the element at the front of the queue. The
following steps are taken to perform the dequeue operation:


1. Check if the ****queue is empty****. If so, return an ****underflow**** error.
2. Remove the element at the ****front****.
3. ****Increment**** the ****front**** pointer to the next element.


![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)



Previous





Play

Next





1 / 6



### ****3. Peek or Front Operation:****

This operation returns the element at the front end without removing
it.

### 4. Size Operation:

This operation returns the numbers of elements present in the
queue.

### ****5. isEmpty Operation:****

This operation returns a boolean value that indicates whether the queue
is empty or not.

### ****6. isFull Operation:****

This operation returns a boolean value that indicates whether the queue
is full or not.

Implementation of Queue Data Structure
--------------------------------------

Queue can be implemented using following data structures:

* [Implementation of Queue using Arrays](https://www.geeksforgeeks.org/introduction-and-array-implementation-of-queue)
* [Implementation of Queue using Linked List](https://www.geeksforgeeks.org/queue-linked-list-implementation)

Complexity Analysis of Operations on Queue
------------------------------------------

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****enqueue**** | O(1) | O(1) |
| ****dequeue**** | O(1) | O(1) |
| front | O(1) | O(1) |
| size | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| isFull | O(1) | O(1) |

****Types of Queues****
-----------------------

Queue data structure can be classified into 4 types:

1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the
   element from the front of the queue.
2. [****Double-Ended Queue (Deque)****](https://www.geeksforgeeks.org/deque-set-1-introduction-applications)****:****
   In a double-ended queue the insertion and deletion operations, both
   can be performed from both ends. They are of two types:
   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be
     taken from only one end but deletion can be done from any of the
     ends.
   * ****Output Restricted Queue:****
     This is also a simple queue. In this type of queue, the input can
     be taken from both ends but deletion can be done from only one
     end.
3. [****Circular Queue:****](https://www.geeksforgeeks.org/introduction-to-circular-queue) This is a special type of queue where the last position is connected
   back to the first position. Here also the operations are performed in
   FIFO order.
4. [****Priority Queue****](https://www.geeksforgeeks.org/priority-queue-set-1-introduction)****:****
   A priority queue is a special queue where the elements are accessed
   based on the priority assigned to them. They are of two types:
   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in
     increasing order of their priority values. Element with smallest
     priority value is popped first.
   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in
     decreasing order of their priority values. Element with largest
     priority is popped first.

![Types-of-Queue](https://media.geeksforgeeks.org/wp-content/uploads/20241212125924381216/Types-of-Queue-660.webp)

****Applications of Queue Data Structure****
--------------------------------------------

Application of queue is common. In a computer system, there may be
queues of tasks waiting for the printer, for access to disk storage, or
even in a time-sharing system, for use of the CPU. Within a single
program, there may be multiple requests to be kept in a queue, or one
task may create other tasks, which must be done in turn by keeping them
in a queue.

* A Queue is always used as a buffer when we have a speed mismatch
  between a producer and consumer. For example keyboard and CPU.
* Queue can be used where we have a single resource and multiple
  consumers like a single CPU and multiple processes.
* In a network, a queue is used in devices such as a router/switch and
  mail queue.
* Queue can be used in various algorithm techniques like Breadth First
  Search, Topological Sort, etc.', e'Queue is a linear data structure that follows FIFO (First In First Out) Principle, so the first element inserted is the first to be popped out.
', 'Introduction to Queue Data Structure', 4, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('ba83bbd2-32b7-445a-9895-7a9502446497', e'Advantages of Linked Lists (or Most Common Use Cases):
------------------------------------------------------

* Linked Lists are mostly used because of their effective insertion and
  deletion.  We only need to change few pointers (or references) to
  insert (or delete) an item in the middle
* [Insertion and deletion](https://www.geeksforgeeks.org/insertion-deletion-stl-set-c/) at any point in a linked list take O(1) time. Whereas in an [array](https://www.geeksforgeeks.org/array-data-structure/)
  data structure, insertion / deletion in the middle takes O(n)
  time.
* This data structure is simple and can be also used to implement [a stack](https://www.geeksforgeeks.org/stack-data-structure/), [queues,](https://www.geeksforgeeks.org/queue-data-structure/) and other [abstract data structures](https://www.geeksforgeeks.org/abstract-data-types/).
* Implementation of Queue and Deque data structures : Simple array
  implementation is not efficient at all. We must use circular array to
  efficiently implement which is complex. But with linked list, it is
  easy and straightforward. That is why most of the language libraries
  use Linked List internally to implement these data structures..
* Linked List might turn out to be more space efficient compare to
  arrays in cases where we cannot guess the number of elements in
  advance. In case of arrays, the whole memory for items is allocated
  together. Even with dynamic sized arrays like vector in C++ or list in
  Python or ArrayList in Java. the internal working involves
  de-allocation of whole memory and allocation of a bigger chunk when
  insertions happen beyond the current capacity.

Applications of Linked Lists:
-----------------------------

* Linked Lists can be used to implement stacks, queue, deque, [sparse matrices](https://www.geeksforgeeks.org/sparse-matrix-representation/) and adjacency list representation of graphs.
* [Dynamic memory allocation](https://www.geeksforgeeks.org/what-is-dynamic-memory-allocation/)
  in operating systems and compilers (linked list of free blocks).
* Manipulation of polynomials
* Arithmetic operations on long integers.
* In operating systems, they can be used in Memory management, process
  scheduling (for example circular linked list for round robin
  scheduling) and file system.
* Algorithms that need to frequently insert or delete items from large
  collections of data.
* LRU cache, which uses a doubly linked list to keep track of the most
  recently used items in a cache.

Applications of Linked Lists in real world:
-------------------------------------------

* The list of songs in the music player are linked to the previous and
  next songs.
* In a web browser, previous and next web page URLs can be linked
  through the previous and next buttons (Doubly Linked List)
* In image viewer, the previous and next images can be linked with the
  help of the previous and next buttons (Doubly Linked List)
* Circular Linked Lists can be used to implement things in round manner
  where we go to every element one by one.
* Linked List are preferred over arrays for implementations of Queue
  and Deque data structures because of fast deletions (or insertions)
  from the front of the linked lists.

Disadvantages of Linked Lists:
------------------------------

Linked lists are a popular data structure in computer science, but like
any other data structure, they have certain disadvantages as well. Some
of the key disadvantages of linked lists are:

* ****Slow Access Time:**** Accessing elements in a linked list can be slow, as you need to
  traverse the linked list to find the element you are looking for,
  which is an O(n) operation. This makes linked lists a poor choice for
  situations where you need to access elements quickly.
* ****Pointers or References:****
  Linked lists use pointers or references to access the next node, which
  can make them more complex to understand and use compared to arrays.
  This complexity can make linked lists more difficult to debug and
  maintain.
* ****Higher overhead:**** Linked lists have a higher overhead compared to arrays, as each node
  in a linked list requires extra memory to store the reference to the
  next node.
* ****Cache Inefficiency:**** Linked lists are cache-inefficient because the memory is not
  contiguous. This means that when you traverse a linked list, you are
  not likely to get the data you need in the cache, leading to cache
  misses and slow performance.

In conclusion, linked lists are a powerful and flexible data structure,
but they have certain disadvantages that need to be taken into
consideration when deciding whether to use them or not. For example, if
you need fast access time, arrays might be a better choice, but if you
need to insert or delete elements frequently, linked lists might be the
better choice.
', e'A Linked List is a linear data structure
that is used to store a collection of data with the help of nodes.
Please remember the following points before moving forward.
', 'Applications, Advantages and Disadvantages of Linked List', 15, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('fe47d547-098c-4d93-a52b-09f5533ea97c', e'Understanding Node Structure
----------------------------

In a singly linked list, each node consists of two parts: data and a
pointer to the next node. This structure allows nodes to be dynamically
linked together, forming a chain-like sequence.


![Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240917161540/Singly-Linked-List.webp)

Singly Linked List



C++
````
// Definition of a Node in a singly linked list
struct Node {

    // Data part of the node
    int data;

    // Pointer to the next node in the list
    Node* next;

    // Constructor to initialize the node with data
    Node(int data)
    {
        this->data = data;
        this->next = nullptr;
    }
};

````

C
````
// Definition of a Node in a singly linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new Node
struct Node* newNode(int data) {
    struct Node* temp =
      (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

````

Java
````
// Definition of a Node in a singly linked list
public class Node {
    int data;
    Node next;

    // Constructor to initialize the node with data
    public Node(int data)
    {
        this.data = data;
        this.next = null;
    }
}

````

Python
````
# Definition of a Node in a singly linked list
class Node:
    def __init__(self, data):
       # Data part of the node
        self.data = data
        self.next = None

````

JavaScript
````
// Definition of a Node in a singly linked list
class Node {
    constructor(data) {
    // Data part of the node
        this.data = data;
        this.next = null;
    }
}

````



In this example, the Node class contains an integer data field (****data****) to store the information and a pointer to another Node (****next****) to establish the link to the next node in the list.

Operations on Singly Linked List
--------------------------------

* ****Traversal****
* ****Searching****
* ****Length****
* ****Insertion:****
  + Insert at the beginning
  + Insert at the end
  + Insert at a specific position
* ****Deletion:****
  + Delete from the beginning
  + Delete from the end
  + Delete a specific node

Let\'s go through each of the operations mentioned above, one by
one.

[****Traversal**** of Singly Linked List](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)
---------------------------------------------------------------------------------------------------------

Traversal involves visiting each node in the linked list and performing
some operation on the data. A simple traversal function would print or
process the data of each node.

Step-by-step approach:

* Initialize a pointer current to the head of the list.
* Use a while loop to iterate through the list until the current
  pointer reaches NULL.
* Inside the loop, print the data of the current node and move the
  current pointer to the next node.

Below is the function for traversal in singly Linked List:

C++
````
// C++ Function to traverse and print the elements of the linked
// list
void traverseLinkedList(Node* head)
{
    // Start from the head of the linked list
    Node* current = head;

    // Traverse the linked list until reaching the end
    // (nullptr)
    while (current != nullptr) {

        // Print the data of the current node
        cout << current->data << " ";

        // Move to the next node
        current = current->next;
    }

    cout << std::endl;
}

````

C
````
// Function to traverse and print the elements
// of the linked list
void traverseLinkedList(struct Node* head)
{
    // Start from the head of the linked list
    struct Node* current = head;

    // Traverse the linked list until reaching the end (NULL)
    while (current != NULL) {

        // Print the data of the current node
        printf("%d ", current->data);

        // Move to the next node
        current = current->next;
    }

    printf("\\n");
}

````

Java
````
// Java Function to traverse and print the elements of the
// linked list
public static void traverseLinkedList(Node head)
{
    // Start from the head of the linked list
    Node current = head;

    // Traverse the linked list until reaching the end
    // (null)
    while (current != null) {

        // Print the data of the current node
        System.out.print(current.data + " ");

        // Move to the next node
        current = current.next;
    }

    System.out.println();
}

````

Python
````
# Python Function to traverse and print the elements of the linked list
def traverse_linked_list(head):
    # Start from the head of the linked list
    current = head

    # Traverse the linked list until reaching the end (None)
    while current is not None:

        # Print the data of the current node followed by a space
        print(current.data),

        # Move to the next node
        current = current.next

    print()  # Print a new line after traversing the linked list

````

JavaScript
````
// Javascript Function to traverse and print the elements
// of the linked list
function traverseLinkedList(head) {

    // Start from the head of the linked list
    let current = head;

    // Traverse the linked list until reaching the
    // end (null)
    while (current !== null) {

        // Print the data of the current node
        console.log(current.data + " ");

        // Move to the next node
        current = current.next;
    }

    console.log();
}

````

**Output**
```

1 2 3

```

[Searching in Singly Linked List](https://www.geeksforgeeks.org/search-an-element-in-a-linked-list-iterative-and-recursive/)
----------------------------------------------------------------------------------------------------------------------------

Searching in a Singly Linked List refers to the process of looking for
a specific element or value within the elements of the linked list.


Step-by-step approach:

1. Traverse the Linked List starting from the head.
2. Check if the current node\'s data matches the target value.
   * If a match is found, return ****true****.
3. Otherwise, Move to the next node and repeat steps 2.
4. If the end of the list is reached without finding a match, return ****false****.

Below is the function for searching in singly linked list:

C++
````
// Function to search for a value in the Linked List
bool searchLinkedList(struct Node* head, int target)
{
    // Traverse the Linked List
    while (head != nullptr) {

        // Check if the current node\'s
        // data matches the target value
        if (head->data == target) {
            return true; // Value found
        }

        // Move to the next node
        head = head->next;
    }

    return false; // Value not found
}

````

C
````
// Function to search for a value in the Linked List
bool searchLinkedList(struct Node* head, int target)
{
    // Traverse the Linked List
    while (head != NULL) {

        // Check if the current node\'s
        // data matches the target value
        if (head->data == target) {
            return true; // Value found
        }

        // Move to the next node
        head = head->next;
    }

    return false; // Value not found
}

````

Java
````
// Java function to search for a value in the Linked List
public boolean searchLinkedList(Node head, int target)
{
    // Traverse the Linked List
    while (head != null) {

        // Check if the current node\'s data matches the
        // target value
        if (head.data == target) {

            // Value found
            return true;
        }

        // Move to the next node
        head = head.next;
    }

    // Value not found
    return false;
}

````

Python
````
# Python function to search for a value in the Linked List
def search_linked_list(head, target):

    # Traverse the Linked List
    while head is not None:

        # Check if the current node\'s data matches the target value
        if head.data == target:

            return True  # Value found
        # Move to the next node
        head = head.next

    return False  # Value not found

````

JavaScript
````
// Javascript function to search for a value in the Linked List
function searchLinkedList(head, target) {

    // Traverse the Linked List
    while (head !== null) {

        // Check if the current node\'s data matches the target value
        if (head.data === target) {
            return true;  // Value found
        }

        // Move to the next node
        head = head.next;
    }

    return false;  // Value not found
}

````



[Length of Singly Linked List](https://www.geeksforgeeks.org/find-length-of-a-linked-list-iterative-and-recursive)
------------------------------------------------------------------------------------------------------------------

Finding Length in Singly Linked List refers to the process of
determining the total number of nodes in a singly linked list.

Step-by-step approach:

* Initialize a counter ****length**** to 0.
* Start from the head of the list, assign it to current.
* Traverse the list:
  + Increment ****length**** for each node.
  + Move to the next node (****current = current->next****).
* Return the final value of ****length****.

Below is the function for finding length in Singly Linked List:

C++
````
// C++ function to find the length of the linked list
int findLength(Node* head)
{
    // Initialize a counter for the length
    int length = 0;

    // Start from the head of the list
    Node* current = head;

    // Traverse the list and increment the length for each
    // node
    while (current != nullptr) {
        length++;
        current = current->next;
    }

    // Return the final length of the linked list
    return length;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Definition of a Node in a singly linked list
struct Node {
    int data;          // Data part of the node
    struct Node* next; // Pointer to the next node in the list
};

// Function to find the length of the linked list
int findLength(struct Node* head)
{
    // Initialize a counter for the length
    int length = 0;

    // Start from the head of the list
    struct Node* curr = head;

    // Traverse the list and increment
    // the length for each node
    while (curr != NULL) {
        length++;
        curr = curr->next;
    }

    // Return the final length of the linked list
    return length;
}

````

Java
````
// Java function to find the length of the linked list
public int findLength(Node head) {

    // Initialize a counter for the length
    int length = 0;

    // Start from the head of the list
    Node current = head;

    // Traverse the list and increment the length for each
    // node
    while (current != null) {
        length++;
        current = current.next;
    }

    // Return the final length of the linked list
    return length;
}

````

Python
````
# Python function to find the length of the linked list
def find_length(head):

    # Initialize a counter for the length
    length = 0

    # Start from the head of the list
    current = head

    # Traverse the list and increment the length for each
    # node
    while current is not None:
        length += 1
        current = current.next

    # Return the final length of the linked list
    return length

````

JavaScript
````
// Javascript function to find the length of the linked list
function findLength(head) {

    // Initialize a counter for the length
    let length = 0;

    // Start from the head of the list
    let current = head;

    // Traverse the list and increment the length for each
    // node
    while (current !== null) {
        length++;
        current = current.next;
    }

    // Return the final length of the linked list
    return length;
}

````




[Insertion in Singly Linked List](https://www.geeksforgeeks.org/insertion-in-linked-list)
-----------------------------------------------------------------------------------------

Insertion is a fundamental operation in linked lists that involves
adding a new node to the list. There are several scenarios for
insertion:

### a. [Insertion at the Beginning of Singly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-front-beginning-of-a-linked-list):

![Insertion-at-the-Beginning-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163445386036/Insertion-at-the-Beginning-of-Singly-Linked-List.webp)


Insert a Node at the Front/Beginning of Linked List



Step-by-step approach:

* Create a new node with the given value.
* Set the ****next**** pointer of the new node to the current head.
* Move the head to point to the new node.
* Return the new head of the linked list.

Below is the function for insertion at the beginning of singly linked
list:

C++
````
// C++ function to insert a new node at the beginning of the
// linked list
Node* insertAtBeginning(Node* head, int value)
{
    // Create a new node with the given value
    Node* newNode = new Node(value);

    // Set the next pointer of the new node to the current
    // head
    newNode->next = head;

    // Move the head to point to the new node
    head = newNode;

    // Return the new head of the linked list
    return head;
}

````

C
````
// Function to insert a new node at the beginning of the linked list
struct Node* insertAtBeginning(struct Node* head, int value)
{
    // Create a new node with the given value
    struct Node* new_node = newNode(value);

    // Set the next pointer of the new node to the current head
    new_node->next = head;

    // Move the head to point to the new node
    head = new_node;

    // Return the new head of the linked list
    return head;
}

````

Java
````
// Java function to insert a new node at the beginning of the
// linked list
public Node insertAtBeginning(Node head, int value) {
    // Create a new node with the given value
    Node newNode = new Node(value);

    // Set the next pointer of the new node to the current
    // head
    newNode.next = head;

    // Move the head to point to the new node
    head = newNode;

    // Return the new head of the linked list
    return head;
}

````

Python
````
# Python function to insert a new node at the beginning of the
# linked list
def insert_at_beginning(head, value):

    # Create a new node with the given value
    new_node = Node(value)

    # Set the next pointer of the new node to the current
    # head
    new_node.next = head

    # Move the head to point to the new node
    head = new_node

    # Return the new head of the linked list
    return head

````

JavaScript
````
// Javascript function to insert a new node at the beginning of the
// linked list
function insertAtBeginning(head, value) {

    // Create a new node with the given value
    let newNode = new Node(value);

    // Set the next pointer of the new node to the current
    // head
    newNode.next = head;

    // Move the head to point to the new node
    head = newNode;

    // Return the new head of the linked list
    return head;
}

````


### b. [Insertion at the End of Singly Linked List:](https://www.geeksforgeeks.org/insert-node-at-the-end-of-a-linked-list)

To insert a node at the end of the list, traverse the list until the
last node is reached, and then link the new node to the current last
node-

![Insertion-at-the-End-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163601409037/Insertion-at-the-End-of-Singly-Linked-List.webp)

Insertion at end of Linked List


Step-by-step approach:

* Create a new node with the given value.
* Check if the list is empty:
  + If it is, make the new node the head and return.
* Traverse the list until the last node is reached.
* Link the new node to the current last node by setting the last node\'s
  next pointer to the new node.

Below is the function for insertion at the end of singly linked
list:

C++
````
// C++ Function to insert a node at the end of the linked
// list
Node* insertAtEnd(Node* head, int value)
{
    // Create a new node with the given value
    Node* newNode = new Node(value);

    // If the list is empty, make the new node the head
    if (head == nullptr)
        return newNode;

    // Traverse the list until the last node is reached
    Node* curr = head;
    while (curr->next != nullptr) {
        curr = curr->next;
    }

    // Link the new node to the current last node
    curr->next = newNode;
    return head;
}

````

C
````
// Function to insert a node at the end of the linked list
struct Node* insertAtEnd(struct Node* head, int value)
{
    // Create a new node with the given value
    struct Node* new_node = newNode(value);

    // If the list is empty, make the new node the head
    if (head == NULL)
        return new_node;

    // Traverse the list until the last node is reached
    struct Node* curr = head;
    while (curr->next != NULL) {
        curr = curr->next;
    }

    // Link the new node to the current last node
    curr->next = new_node;

    return head;
}

````

Java
````
// Function to insert a node at the end of the linked list
public static Node insertAtEnd(Node head, int value)
{
    // Create a new node with the given value
    Node newNode = new Node(value);

    // If the list is empty, make the new node the head
    if (head == null)
        return newNode;

    // Traverse the list until the last node is reached
    Node curr = head;
    while (curr.next != null) {
        curr = curr.next;
    }

    // Link the new node to the current last node
    curr.next = newNode;

    return head;
}

````

Python
````
# Python function to insert a node at the end of the linked
# list
def insert_at_end(head, value):

    # Create a new node with the given value
    new_node = Node(value)

    # If the list is empty, make the new node the head
    if head is None:
        return new_node

    # Traverse the list until the last node is reached
    current = head
    while current.next is not None:
        current = current.next

    # Link the new node to the current last node
    current.next = new_node

    return head

````

JavaScript
````
// Javascript function to insert a node at the end of the linked
// list
function insertAtEnd(head, value) {

    // Create a new node with the given value
    let newNode = new Node(value);

    // If the list is empty, make the new node the head
    if (head === null) {
        return newNode;
    }

    // Traverse the list until the last node is reached
    let current = head;
    while (current.next !== null) {
        current = current.next;
    }

    // Link the new node to the current last node
    current.next = newNode;

    return head;
}

````





### c. [Insertion at a Specific Position of the Singly Linked List:](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-a-linked-list)

To insert a node at a specific position, traverse the list to the
desired position, link the new node to the next node, and update the
links accordingly.

![Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20241022163649252002/Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy.webp)




We mainly find the node after which we need to insert the new node. If
we encounter a NULL before reaching that node, it means that the given
position is invalid.

Below is the function for insertion at a specific position of the
singly linked list:

C++
````
// Function to insert a Node at a specified position
// without using a double pointer
Node* insertPos(Node* head, int pos, int data)
{
    if (pos < 1) {
        cout << "Invalid position!" << endl;
        return head;
    }

    // Special case for inserting at the head
    if (pos == 1) {
        Node* temp = new Node(data);
        temp->next = head;
        return temp;
    }

    // Traverse the list to find the node
    // before the insertion point
    Node* prev = head;
    int count = 1;
    while (count < pos - 1 && prev != nullptr) {
        prev = prev->next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev == nullptr) {
        cout << "Invalid position!" << endl;
        return head;
    }

    // Insert the new node at the specified position
    Node* temp = new Node(data);
    temp->next = prev->next;
    prev->next = temp;

    return head;
}

````

C
````
// Function to insert a node at a specified position
struct Node* insertPos(struct Node* head, int pos, int data) {
    if (pos < 1) {
        printf("Invalid position!\\n");
        return head;
    }

    // Special case for inserting at the head
    if (pos == 1) {
        struct Node* temp = getNode(data);
        temp->next = head;
        return temp;
    }

    // Traverse the list to find the node
    // before the insertion point
    struct Node* prev = head;
    int count = 1;
    while (count < pos - 1 && prev != NULL) {
        prev = prev->next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev == NULL) {
        printf("Invalid position!\\n");
        return head;
    }

    // Insert the new node at the specified position
    struct Node* temp = getNode(data);
    temp->next = prev->next;
    prev->next = temp;

    return head;
}

````

Java
````
public static Node insertPos(Node head, int pos, int data)
{
    if (pos < 1) {
        System.out.println("Invalid position!");
        return head;
    }

    // Special case for inserting at the head
    if (pos == 1) {
        Node temp = new Node(data);
        temp.next = head;
        return temp;
    }

    // Traverse the list to find the node before the
    // insertion point
    Node prev = head;
    int count = 1;
    while (count < pos - 1 && prev != null) {
        prev = prev.next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev == null) {
        System.out.println("Invalid position!");
        return head;
    }

    // Insert the new node at the specified position
    Node temp = new Node(data);
    temp.next = prev.next;
    prev.next = temp;

    return head;
}

````

Python
````
# Function to insert a node at a specified position
def insertPos(head, pos, data):
    if pos < 1:
        print("Invalid position!")
        return head

    # Special case for inserting at the head
    if pos == 1:
        new_node = Node(data)
        new_node.next = head
        return new_node

    # Traverse the list to find the node before
    # the insertion point
    prev = head
    count = 1
    while count < pos - 1 and prev is not None:
        prev = prev.next
        count += 1

    # If position is greater than the number of nodes
    if prev is None:
        print("Invalid position!")
        return head

    # Insert the new node at the specified position
    new_node = Node(data)
    new_node.next = prev.next
    prev.next = new_node

    return head

````

JavaScript
````
// Function to insert a node at a specified position
function insertPos(head, pos, data) {
    if (pos < 1) {
        console.log("Invalid position!");
        return head;
    }

    // Special case for inserting at the head
    if (pos === 1) {
        const newNode = new Node(data);
        newNode.next = head;
        return newNode;
    }

    // Traverse the list to find the node
    // before the insertion point
    let prev = head;
    let count = 1;
    while (count < pos - 1 && prev !== null) {
        prev = prev.next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev === null) {
        console.log("Invalid position!");
        return head;
    }

    // Insert the new node at the specified position
    const newNode = new Node(data);
    newNode.next = prev.next;
    prev.next = newNode;

    return head;
}

````








[Deletion in Singly Linked List](https://www.geeksforgeeks.org/deletion-in-linked-list)
---------------------------------------------------------------------------------------

Deletion involves removing a node from the linked list. Similar to
insertion, there are different scenarios for deletion:

### a. [****Deletion at the Beginning of**** Singly Linked List****:****](https://www.geeksforgeeks.org/remove-first-node-of-the-linked-list)

To delete the first node, update the head to point to the second node
in the list.

![Deletion-at-beginning-](https://media.geeksforgeeks.org/wp-content/uploads/20241022163937663413/Deletion-at-beginning-.webp)

Deletion at beginning in a Linked List


Steps-by-step approach:

* Check if the head is ****NULL****.
  + If it is, return ****NULL**** (the list is empty).
* Store the current head node in a temporary variable ****temp****.
* Move the head pointer to the next node.
* Delete the temporary node.
* Return the new head of the linked list.

Below is the function for deletion at the beginning of singly linked
list:

C++
````
// C++ Function to remove the first node of the linked
// list
Node* removeFirstNode(Node* head)
{
    if (head == nullptr)
        return nullptr;

    // Move the head pointer to the next node
    Node* temp = head;
    head = head->next;

    delete temp;

    return head;
}

````

C
````
// Function to remove the first node of the linked list
struct Node* removeFirstNode(struct Node* head)
{
    if (head == NULL)
        return NULL;

    // Move the head pointer to the next node
    struct Node* temp = head;
    head = head->next;

    // Free the memory of the old head
    free(temp);

    return head;
}

````

Java
````
// Java Function to remove the first node
// of the linked list
static Node removeFirstNode(Node head)
{
    if (head == null)
        return null;

    // Move the head pointer to the next node
    Node temp = head;
    head = head.next;

    return head;
}

````

Python
````
# Python Function to remove the first node
# of the linked list
def removeFirstNode(head):
    if not head:
        return None
    temp = head

    # Move the head pointer to the next node
    head = head.next
    temp = None
    return head

````

JavaScript
````
// Javascript Function to remove the first node
// of the linked list /
function removeFirstNode(head) {
  if (head == null) return null;

  // Move the head pointer to the next node
  temp = head;
  head = head.next;

  return head;
}

````


### b. [Deletion at the End of Singly Linked List:](https://www.geeksforgeeks.org/remove-last-node-of-the-linked-list)

To delete the last node, traverse the list until the second-to-last
node and update its next field to None.

![Deletion-At-End](https://media.geeksforgeeks.org/wp-content/uploads/20241022164030481275/Deletion-At-End.webp)

Deletion at the end of linked list


Step-by-step approach:

* Check if the head is ****NULL****.
  + If it is, return NULL (the list is empty).
* Check if the head\'s ****next**** is ****NULL**** (only one node in the list).
  + If true, delete the head and return ****NULL****.
* Traverse the list to find the second last node (****second\\_last****).
* Delete the last node (the node after ****second\\_last****).
* Set the ****next**** pointer of the second last node to ****NULL****.
* Return the head of the linked list.

Below is the function for deletion at the end of singly linked
list:

C++
````
// C++ Function to remove the last node of the linked list
Node* removeLastNode(Node* head)
{
    if (head == nullptr)
        return nullptr;

    if (head->next == nullptr) {
        delete head;
        return nullptr;
    }

    // Find the second last node
    Node* second_last = head;
    while (second_last->next->next != nullptr)
        second_last = second_last->next;

    // Delete last node
    delete (second_last->next);

    // Change next of second last
    second_last->next = nullptr;

    return head;
}

````

C
````
// Function to remove the last node of the linked list
struct Node* removeLastNode(struct Node* head)
{
    if (head == NULL)
        return NULL;

    if (head->next == NULL) {
        free(head);
        return NULL;
    }

    // Find the second last node
    struct Node* second_last = head;
    while (second_last->next->next != NULL)
        second_last = second_last->next;

    // Delete last node
    free(second_last->next);

    // Change next of second last
    second_last->next = NULL;

    return head;
}

````

Java
````
// Java Function to remove the last node of the linked list
Node removeLastNode(Node head)
{
    // If the list is empty, return null
    if (head == null)
        return null;

    // If the list has only one node, delete it and return
    // null
    if (head.next == null) {
        head = null;
        return null;
    }

    // Find the second last node
    Node second_last = head;
    while (second_last.next.next != null)
        second_last = second_last.next;

    // Remove the last node
    second_last.next = null;

    // Return the modified list
    return head;
}

````

Python
````
# Python Function to remove the last node of the linked list
def removeLastNode(head):
    # If the list is empty, return None
    if head is None:
        return None

    # If the list has only one node, delete it and return None
    if head.next is None:
        head = None
        return None

    # Find the second last node
    second_last = head
    while second_last.next.next is not None:
        second_last = second_last.next

    # Remove the last node
    second_last.next = None

    # Return the modified list
    return head

````

JavaScript
````
// Javascript Function to remove the last node of the linked list
function removeLastNode(head) {
    // If the list is empty, return null
    if (head === null)
        return null;

    // If the list has only one node, delete it
    // and return null
    if (head.next === null) {
        head = null;
        return null;
    }

    // Find the second last node
    let second_last = head;
    while (second_last.next.next !== null)
        second_last = second_last.next;

    // Remove the last node
    second_last.next = null;

    // Return the modified list
    return head;
}

````




### c. [Deletion at a Specific Position of Singly Linked List:](https://www.geeksforgeeks.org/delete-a-linked-list-node-at-a-given-position)

To delete a node at a specific position, traverse the list to the
desired position, update the links to bypass the node to be
deleted.

![Deletion-specific-At-End--](https://media.geeksforgeeks.org/wp-content/uploads/20241022164248836160/Deletion-specific-At-End--.webp)

Delete a Linked List node at a given position


Step-by-step approach:

* Check if the list is empty or the position is invalid, return if
  so.
* If the head needs to be deleted, update the head and delete the
  node.
* Traverse to the node before the position to be deleted.
* If the position is out of range, return.
* Store the node to be deleted.
* Update the links to bypass the node.
* Delete the stored node.

Below is the function for deletion at a specific position of singly
linked list:

C++
````
// C++ function to delete a node at a specific position
Node* deleteAtPosition(Node* head, int position)
{
    // If the list is empty or the position is invalid
    if (head == nullptr || position < 1) {
        return head;
    }

    // If the head needs to be deleted
    if (position == 1) {
        Node* temp = head;
        head = head->next;
        delete temp;
        return head;
    }

    // Traverse to the node before the position to be
    // deleted
    Node* current = head;
    for (int i = 1; i < position - 1 && current != nullptr;
         i++) {
        current = current->next;
    }

    // If the position is out of range
    if (current == NULL || current->next == nullptr) {
        return;
    }

    // Store the node to be deleted
    Node* temp = current->next;

    // Update the links to bypass the node to be deleted
    current->next = current->next->next;

    // Delete the node
    delete temp;

    return head;
}

````

C
````
// Function to delete a node at a specific position
struct Node* deleteAtPosition(struct Node* head, int position)
{
    // If the list is empty or the position is invalid
    if (head == NULL || position < 1) {
        return head;
    }

    // If the head needs to be deleted
    if (position == 1) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return head;
    }

    // Traverse to the node before the position to be deleted
    struct Node* curr = head;
    for (int i = 1; i < position - 1 && curr != NULL; i++) {
        curr = curr->next;
    }

    // If the position is out of range
    if (curr == NULL || curr->next == NULL) {
        return head;
    }

    // Store the node to be deleted
    struct Node* temp = curr->next;

    // Update the links to bypass the node to be deleted
    curr->next = curr->next->next;

    // Delete the node
    free(temp);

    return head;
}

````

Java
````
// Java function to delete a node at a specific position
public void deleteAtPosition(Node head, int position)
{
    // If the list is empty or the position is invalid
    if (head == null || position < 1) {
        return;
    }

    // If the head needs to be deleted
    if (position == 1) {
        Node temp = head;
        head = head.next;
        temp = null;
        return;
    }

    // Traverse to the node before the position to be
    // deleted
    Node current = head;
    for (int i = 1; i < position - 1 && current != null;
         i++) {
        current = current.next;
    }

    // If the position is out of range
    if (current == null || current.next == null) {
        return;
    }

    // Store the node to be deleted
    Node temp = current.next;

    // Update the links to bypass the node to be deleted
    current.next = current.next.next;

    // Delete the node
    temp = null;
}

````

Python
````
# Python function to delete a node at a specific position
def delete_at_position(head, position):
    # If the list is empty or the position is invalid
    if head is None or position < 1:
        return head

    # If the head needs to be deleted
    if position == 1:
        temp = head
        head = head.next
        temp = None
        return head

    # Traverse to the node before the position to be deleted
    current = head
    for i in range(1, position - 1):
        if current is not None:
            current = current.next

    # If the position is out of range
    if current is None or current.next is None:
        return head

    # Store the node to be deleted
    temp = current.next

    # Update the links to bypass the node to be deleted
    current.next = current.next.next

    # Delete the node
    temp = None
    return head

````

JavaScript
````
// Javascript function to delete a node at a specific position
function deleteAtPosition(head, position) {
    // If the list is empty or the position is invalid
    if (head === null || position < 1) {
        return head;
    }

    // If the head needs to be deleted
    if (position === 1) {
        let temp = head;
        head = head.next;
        temp = null;
        return head;
    }

    // Traverse to the node before the position to be deleted
    let current = head;
    for (let i = 1; i < position - 1 && current !== null; i++) {
        current = current.next;
    }

    // If the position is out of range
    if (current === null || current.next === null) {
        return head;
    }

    // Store the node to be deleted
    let temp = current.next;

    // Update the links to bypass the node to be deleted
    current.next = current.next.next;

    // Delete the node
    temp = null;
    return head;
}

````


', e'A singly linked list is a fundamental data structure, it consists of nodes where each node contains a data field and a reference to the next node in the linked list. The next of the last node is null, indicating the end of the list. Linked Lists support efficient
insertion and deletion operations.', 'Singly Linked List Tutorial', 12, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', '853e7ebc-48f7-4f47-aa0f-7cd103b4e503');
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('2220549e-2da8-4f0c-9d38-2495ce6b234e', e'What is a Circular Linked List?
-------------------------------

A ****circular linked list****
is a special type of linked list where all the nodes are connected to
form a circle. Unlike a regular linked list, which ends with a node
pointing to ****NULL****, the last node in a circular linked list points back to the first
node. This means that you can keep traversing the list without ever
reaching a ****NULL**** value.

Types of Circular Linked Lists
------------------------------

We can create a circular linked list from both [singly linked lists](https://www.geeksforgeeks.org/introduction-to-singly-linked-list/) and [doubly linked lists](https://www.geeksforgeeks.org/doubly-linked-list-tutorial-2/). So, circular linked list are basically of two types:

### 1. Circular Singly Linked List

In ****Circular Singly Linked List****, each node has just one pointer called the “****next****” pointer. The next pointer of ****last node**** points back to the ****first node**** and this results in forming a circle. In this type of Linked list we
can only move through the list in one direction.

![Representation-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806130914/Representation-of-circular-linked-list.webp)

Representation of Circular Singly Linked List

### 2. Circular Doubly Linked List:

In ****circular doubly linked**** ****list,**** each node has two pointers ****prev**** and ****next,**** similar to doubly linked list. The ****prev**** pointer points to the previous node and the ****next**** points to the next node. Here, in addition to the ****last**** node storing the address of the first node, the ****first node**** will also store the address of the ****last node****.

![Representation-of-circular-doubly-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145223/Representation-of-circular-doubly-linked-list.webp)

Representation of Circular Doubly Linked List

****Note:**** In this article, we will use the circular singly linked list to explain
the working of circular linked lists.

Representation of a Circular Singly Linked List
-----------------------------------------------

Let’s take a look on the structure of a circular linked list.



![Node-structure-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145414/Node-structure-of-circular-linked-list.webp)

Representation of a Circular Singly Linked List

### Create/Declare a Node of Circular Linked List

Syntax to Declare a Circular Linked List in Different Languages:


C++
````
// Node structure
struct Node {
    int data;
    Node* next;

    Node(int value){
        data = value;
        next = nullptr;
    }
};

````

C
````
// Node structure
struct Node
{
    int data;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value){

    // Allocate memory
    struct Node *newNode =
      (struct Node *)malloc(sizeof(struct Node));

    // Set the data
    newNode->data = value;

    // Initialize next to NULL
    newNode->next = NULL;

    // Return the new node
    return newNode;
}

````

Java
````
class Node {
    int data;
    Node next;

    Node(int data)
    {
        this.data = data;
        this.next = null;
    }
}

````

Python
````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

````

C#
````
public class Node {
    public int data;
    public Node next;

    public Node(int data){
        this.data = data;
        this.next = null;
    }
}

````

JavaScript
````
class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
    }
}

````







In the code above, each node has ****data**** and a ****pointer**** to the next node. When we create multiple nodes for a circular linked
list, we only need to connect the last node back to the first one.

Example of Creating a Circular Linked List
------------------------------------------

Here’s an example of creating a circular linked list with three nodes
(2, 3, 4):

![Circular-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240806111438/Circular-Linked-List.png)

Created a circular linked list with 3 nodes


C++
````
// Initilize and allocate memory for nodes
first = new Node(2);
second = new Node(3);
last = new Node(4);

// Connect nodes
first->next = second;
second->next = last;

// Connect last node to first node
last->next = first;

````

C
````
// Allocate memory for nodes
struct Node *first =
  (struct Node *)malloc(sizeof(struct Node));
struct Node *second =
  (struct Node *)malloc(sizeof(struct Node));
struct Node *last =
  (struct Node *)malloc(sizeof(struct Node));

// Initilize nodes
first->data = 2;
second->data = 3;
last->data = 4;

// Connect nodes
first->next = second;
second->next = last;
last->next = first;

````

Java
````
// Initilize and allocate memory for nodes
Node first = new Node(2);
Node second = new Node(3);
Node last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

````

Python
````
# Initilize and allocate memory for nodes
first = Node(2)
second = Node(3)
last = Node(4)

# Connect nodes
first.next = second
second.next = last
last.next = first

````

C#
````
// Initilize and allocate memory for nodes
Node first = new Node(2);
Node second = new Node(3);
Node last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

````

JavaScript
````
// Initilize and allocate memory for nodes
let first = new Node(2);
let second = new Node(3);
let last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

````





In the above code, we have created three nodes ****first, second,**** and ****last**** having values ****2, 3,**** and ****4**** respectively.

* After creating three nodes, we have connected these node in a
  series.
* Connect the first node “****first”**** to “****second”**** node by ****s****toring the address of “****second”**** nodeinto ****first’s**** next
* Connect the second node “****second”**** to “****second”**** node by ****s****toring the address of “****third****” node into ****second’s**** next
* After connecting all the nodes, we reach the key characteristic of a
  circular linked list: linking the last node back to the first node. Therefore, we store the address of the “****first****” node in the “****last****” node.

### Why have we taken a pointer that points to the last node instead of the first node?

For the insertion of a node at the beginning, we need to traverse the
whole list. Also, for insertion at the end, the whole list has to be
traversed. If instead of the start pointer, we take a pointer to the
last node, then in both cases there won’t be any need to traverse the
whole list. So insertion at the beginning or at the end takes constant
time, irrespective of the length of the list.

Operations on the Circular Linked list:
---------------------------------------

We can do some operations on the circular linked list similar to the
singly and doubly linked list which are:

* ****Insertion****
  + Insertion at the empty list
  + Insertion at the beginning
  + Insertion at the end
  + Insertion at the given position
* ****Deletion****
  + Delete the first node
  + Delete the last node
  + Delete the node from any position
* ****Searching****

****Note:**** We will be using the circular singly linked list to represent the
working of the circular linked list.

[Insertion in the circular linked list:](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/)
--------------------------------------------------------------------------------------------------------------

Insertion is a fundamental operation in linked lists that involves
adding a new node to the list. The only extra step is connecting the
last node to the first one. In the circular linked list mentioned below,
we can insert nodes in four ways:

### 1. Insertion in an empty List in the circular linked list

> To insert a node in empty circular linked list, creates a ****new node**** with the given data, sets its next pointer to point to itself, and
> updates the ****last**** pointer to reference this ****new node****.

![Insertion-in-an-empty-list-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806193408/Insertion-in-an-empty-list-in-circular-linked-list.webp)

Insertion in an empty List


C++
````
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *next;
    Node(int value){
        data = value;
        next = nullptr;
    }
};

// Function to insert a node into an empty circular singly linked list
Node *insertInEmptyList(Node *last, int data){
    if (last != nullptr) return last;

    // Create a new node
    Node *newNode = new Node(data);

    // Point newNode to itself
    newNode->next = newNode;

    // Update last to point to the new node
    last = newNode;
    return last;
}

void printList(Node* last){
    if(last == NULL) return;

    // Start from the head node
    Node* head = last->next;
    while (true) {
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main(){
    Node *last = nullptr;

    // Insert a node into the empty list
    last = insertInEmptyList(last, 1);

    // Print the list
    cout << "List after insertion: ";
    printList(last);

    return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* createNode(int value);

// Function to insert a node into an empty
// circular singly linked list
struct Node* insertInEmptyList(struct Node* last, int data) {
    if (last != NULL) return last;

    // Create a new node
    struct Node* newNode = createNode(data);

    // Update last to point to the new node
    last = newNode;
    return last;
}

void printList(struct Node* last) {
    if (last == NULL) return;

    // Start from the head node
    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = newNode;
    return newNode;
}

int main() {
    struct Node* last = NULL;

    // Insert a node into the empty list
    last = insertInEmptyList(last, 1);

    // Print the list
    printf("List after insertion: ");
    printList(last);

    return 0;
}

````

Java
````
class Node {
    int data;
    Node next;

    Node(int value) {
        data = value;
        next = null;
    }
}

public class Main {
    // Function to insert a node into an empty
    // circular singly linked list
    static Node insertInEmptyList(Node last, int data) {
        if (last != null) return last;

        // Create a new node
        Node newNode = new Node(data);

        // Point newNode to itself
        newNode.next = newNode;

        // Update last to point to the new node
        last = newNode;
        return last;
    }

    // Function to print the list
    static void printList(Node last) {
        if (last == null) return;

        // Start from the head node
        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Node last = null;

        // Insert a node into the empty list
        last = insertInEmptyList(last, 1);

        // Print the list
        System.out.print("List after insertion: ");
        printList(last);
    }
}

````

Python
````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = self  # Point to itself

def insertInEmptyList(last, data):
    if last is not None:
        return last

    # Create a new node
    new_node = Node(data)

    # Update last to point to the new node
    last = new_node
    return last

def printList(last):
    if last is None:
        return

    # Start from the head node
    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

if __name__ == "__main__":
    last = None

    # Insert a node into the empty list
    last = insertInEmptyList(last, 1)

    # Print the list
    print("List after insertion: ", end="")
    printList(last)

````

JavaScript
````
class Node {
    constructor(value)
    {
        this.data = value;
        this.next = null;
    }
}

function insertInEmptyList(last, data)
{
    if (last !== null)
        return last;

    // Create a new node
    let newNode = new Node(data);

    // Point newNode to itself
    newNode.next = newNode;

    // Update last to point to the new node
    last = newNode;
    return last;
}

function printList(last)
{
    if (last === null)
        return;

    // Start from the head node
    let head = last.next;
    while (true) {
        console.log(head.data);
        head = head.next;
        if (head === last.next)
            break;
    }
}

// Main function

let last = null;

// Insert a node into the empty list
last = insertInEmptyList(last, 1);

// Print the list
console.log("List after insertion:");
printList(last);

````




**Output**
```

List after insertion: 1

```
### 2. Insertion at the beginning in circular linked list

> To insert a new node at the beginning of a circular linked list, we
> first create the ****new node****
> and allocate memory for it. If the list is empty (indicated by the
> last pointer being ****NULL****), we make the ****new node****
> point to itself. If the list already contains nodes then we set the ****new node’s**** next pointer to point to the ****current head**** of the list (which is ****last->next****), and then update the last node’s next pointer to point to the ****new node****. This maintains the circular structure of the list.

![Insertion-at-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150314/Insertion-at-the-beginning-of-circular-linked-list.webp)

Insertion at the beginning in circular linked list


C++
````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;

    Node(int value)
    {
        data = value;
        next = nullptr;
    }
};

// Function to insert a node at the beginning of the
// circular linked list
Node* insertAtBeginning(Node* last, int value){
    // Allocate memory for the new node and set its data
    Node* newNode = new Node(value);

    // If the list is empty, make the new node point to
    // itself and set it as last
    if (last == nullptr) {
        newNode->next = newNode;
        return newNode;
    }

    // Insert the new node at the beginning
    newNode->next = last->next;
    last->next = newNode;

    return last;
}

void printList(Node* last){
  if(last == NULL) return;

    // Start from the head node
    Node* head = last->next;
    while (true) {
        cout << head->data << " ";
        head = head->next;
        if (head == last->next)
            break;
    }
    cout << endl;
}

int main(){

    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Insert 5 at the beginning
    last = insertAtBeginning(last, 5);

    cout << "List after inserting 5 at the beginning: ";
    printList(last);

    return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node
{
    int data;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value)
{
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the beginning
// of the circular linked list
struct Node *insertAtBeginning(struct Node *last, int value)
{
    struct Node *newNode = createNode(value);

    // If the list is empty, make the new node point to itself
    // and set it as last
    if (last == NULL)
    {
        newNode->next = newNode;
        return newNode;
    }

    // Insert the new node at the beginning
    newNode->next = last->next;
    last->next = newNode;

    return last;
}

void printList(struct Node *last)
{
    if (last == NULL) return;

    struct Node *head = last->next;
    while (1){
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next)
            break;
    }
    printf("\\n");
}

int main()
{
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);
    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Insert 5 at the beginning
    last = insertAtBeginning(last, 5);

    printf("List after inserting 5 at the beginning: ");
    printList(last);

    return 0;
}

````

Java
````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {

    // Function to insert a node at the beginning of the
    // circular linked list
    public static Node insertAtBeginning(Node last,
                                         int value){
        Node newNode = new Node(value);

        // If the list is empty, make the new node point to
        // itself and set it as last
        if (last == null) {
            newNode.next = newNode;
            return newNode;
        }

        // Insert the new node at the beginning
        newNode.next = last.next;
        last.next = newNode;

        return last;
    }

    // Function to print the circular linked list
    public static void printList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);
        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Insert 5 at the beginning
        last = insertAtBeginning(last, 5);

        System.out.print(
            "List after inserting 5 at the beginning: ");
        printList(last);
    }
}

````

Python
````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Function to insert a node at the beginning of the circular linked list
def insert_at_beginning(last, value):
    new_node = Node(value)

    # If the list is empty, make the new node point to itself and set it as last
    if last is None:
        new_node.next = new_node
        return new_node

    # Insert the new node at the beginning
    new_node.next = last.next
    last.next = new_node

    return last

# Function to print the circular linked list
def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)
last = first.next.next
last.next = first

print("Original list: ", end="")
print_list(last)

# Insert 5 at the beginning
last = insert_at_beginning(last, 5)

print("List after inserting 5 at the beginning: ", end="")
print_list(last)

````

C#
````
using System;

public class Node
{
    public int data;
    public Node next;

    public Node(int value)
    {
        data = value;
        next = null;
    }
}

public class CircularLinkedList
{
    // Function to insert a node at the beginning of the circular linked list
    public static Node InsertAtBeginning(Node last, int value)
    {
        Node newNode = new Node(value);

        // If the list is empty, make the new node point to itself and set it as last
        if (last == null)
        {
            newNode.next = newNode;
            return newNode;
        }

        // Insert the new node at the beginning
        newNode.next = last.next;
        last.next = newNode;

        return last;
    }

    // Function to print the circular linked list
    public static void PrintList(Node last)
    {
        if (last == null)
            return;

        Node head = last.next;
        while (true)
        {
            Console.Write(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        Console.WriteLine();
    }

    public static void Main(string[] args)
    {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);
        Node last = first.next.next;
        last.next = first;

        Console.Write("Original list: ");
        PrintList(last);

        // Insert 5 at the beginning
        last = InsertAtBeginning(last, 5);

        Console.Write("List after inserting 5 at the beginning: ");
        PrintList(last);
    }
}

````

JavaScript
````
class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
    }
}

// Function to insert a node at the beginning of the
// circular linked list
function insertAtBeginning(last, value)
{
    const newNode = new Node(value);

    // If the list is empty, make the new node point to
    // itself and set it as last
    if (last === null) {
        newNode.next = newNode;
        return newNode;
    }

    // Insert the new node at the beginning
    newNode.next = last.next;
    last.next = newNode;

    return last;
}

// Function to print the circular linked list
function printList(last)
{
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
const first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);
let last
    = first.next.next; // Using let to allow reassignment
last.next = first;

console.log("Original list: ");
printList(last);

// Insert 5 at the beginning
last = insertAtBeginning(last, 5);

console.log("List after inserting 5 at the beginning: ");
printList(last);

````





**Output**
```

Original list: 2 3 4
List after inserting 5 at the beginning: 5 2 3 4

```
### 3. Insertion at the end in circular linked list

> To insert a new node at the end of a circular linked list, we first
> create the new node and allocate memory for it. If the list is empty
> (mean, ****last**** or ****tail**** pointer being ****NULL****), we initialize the list with the ****new node**** and making it point to itself to form a circular structure. If the
> list already contains nodes then we set the ****new node’s**** next pointer to point to the ****current head**** (which is ****tail->next****), then update the ****current tail’s**** next pointer to point to the ****new node****. Finally, we update the ****tail pointer**** to the ****new node.**** This will ensure that the ****new node**** is now the ****last node**** in the list while maintaining the circular linkage.

![Insertion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150353/Insertion-at-the-end-of-circular-linked-list.webp)

Insertion at the end in circular linked list


C++
````
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *next;
    Node(int value)
    {
        data = value;
        next = nullptr;
    }
};

// Function to insert a node at the end of a circular linked list
Node *insertEnd(Node *tail, int value)
{
    Node *newNode = new Node(value);
    if (tail == nullptr){
        // If the list is empty, initialize it with the new node
        tail = newNode;

        // Point to itself to form a circular structure
        newNode->next = newNode;
    }
    else{
        // Insert new node after the current tail
        // and update the tail pointer.
        // New node points to the head node
        newNode->next = tail->next;

        // Tail node points to the new node
        tail->next = newNode;

        // Update tail to be the new node
        tail = newNode;
    }
    return tail;
}

void printList(Node *last){
  if(last == NULL) return;

    // Start from the head node
    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next)
            break;
    }
    cout << endl;
}

int main(){
    // Create circular linked list: 2, 3, 4
    Node *first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node *last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Insert elements at the end of the circular linked list
    last = insertEnd(last, 5);
    last = insertEnd(last, 6);

    cout << "List after inserting 5 and 6: ";
    printList(last);

    return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node
{
    int data;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value);

// Function to insert a node at the end of a circular linked list
struct Node *insertEnd(struct Node *tail, int value)
{
    struct Node *newNode = createNode(value);
    if (tail == NULL)
    {
        // If the list is empty, initialize it with the new node
        tail = newNode;
        newNode->next = newNode;
    }
    else
    {
        // Insert new node after the current tail and update the tail pointer
        newNode->next = tail->next;
        tail->next = newNode;
        tail = newNode;
    }
    return tail;
}

// Function to print the circular linked list
void printList(struct Node *last)
{
    if (last == NULL)
        return;

    struct Node *head = last->next;
    while (1)
    {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next)
            break;
    }
    printf("\\n");
}

struct Node *createNode(int value)
{
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main()
{
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Insert elements at the end of the circular linked list
    last = insertEnd(last, 5);
    last = insertEnd(last, 6);

    printf("List after inserting 5 and 6: ");
    printList(last);

    return 0;
}

````

Java
````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {

    // Function to insert a node at the end of a circular
    // linked list
    static Node insertEnd(Node tail, int value){
        Node newNode = new Node(value);
        if (tail == null) {
            // If the list is empty, initialize it with the
            // new node
            tail = newNode;
            newNode.next = newNode;
        }
        else {
            // Insert new node after the current tail and
            // update the tail pointer
            newNode.next = tail.next;
            tail.next = newNode;
            tail = newNode;
        }
        return tail;
    }

    // Function to print the circular linked list
    static void printList(Node last){
        if (last == null) return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Insert elements at the end of the circular linked
        // list
        last = insertEnd(last, 5);
        last = insertEnd(last, 6);

        System.out.print("List after inserting 5 and 6: ");
        printList(last);
    }
}

````

Python
````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Function to insert a node at the end of a circular linked list


def insert_end(tail, value):
    new_node = Node(value)
    if tail is None:
        # If the list is empty, initialize
        # it with the new node
        tail = new_node
        new_node.next = new_node
    else:
        # Insert new node after the current tail
        # and update the tail pointer
        new_node.next = tail.next
        tail.next = new_node
        tail = new_node
    return tail

# Function to print the circular linked list


def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()


if __name__ == "__main__":
    # Create circular linked list: 2, 3, 4
    first = Node(2)
    first.next = Node(3)
    first.next.next = Node(4)

    last = first.next.next
    last.next = first

    print("Original list: ", end="")
    print_list(last)

    # Insert elements at the end of the circular linked list
    last = insert_end(last, 5)
    last = insert_end(last, 6)

    print("List after inserting 5 and 6: ", end="")
    print_list(last)

````

JavaScript
````
class Node {
    constructor(value){
        this.data = value;
        this.next = null;
    }
}

// Function to insert a node at the end of a circular linked
// list
function insertEnd(tail, value){
    let newNode = new Node(value);
    if (tail === null) {
        // If the list is empty, initialize it with the new
        // node
        tail = newNode;
        newNode.next = newNode;
    }
    else {
        // Insert new node after the current tail and update
        // the tail pointer
        newNode.next = tail.next;
        tail.next = newNode;
        tail = newNode;
    }
    return tail;
}

// Function to print the circular linked list
function printList(last)
{
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Insert elements at the end of the circular linked
// list
last = insertEnd(last, 5);
last = insertEnd(last, 6);

console.log("List after inserting 5 and 6: ");
printList(last);

````

**Output**
```

Original list: 2 3 4
List after inserting 5 and 6: 2 3 4 5 6

```
### 4. Insertion at specific position in circular linked list

> To insert a new node at a specific position in a circular linked
> list, we first check if the list is empty. If it is and the ****position**** is not ****1****
> then we print an error message because the position doesn’t exist in
> the list. If the ****position**** is ****1**** then we create the ****new node**** and make it point to itself. If the list is not empty, we create the ****new node**** and traverse the list to find the correct insertion point. If the ****position**** is ****1****, we insert the ****new node****
> at the beginning by adjusting the pointers accordingly. For other
> positions, we traverse through the list until we reach the desired
> position and inserting the ****new node****
> by updating the pointers. If the new node is inserted at the end, we
> also update the ****last****
> pointer to reference the new node, maintaining the circular structure
> of the list.

![Insertion-at-specific-position-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150431/Insertion-at-specific-position-of-circular-linked-list.webp)

Insertion at specific position in circular linked list


C++
````
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *next;
    Node(int value){
        data = value;
        next = nullptr;
    }
};

// Function to insert a node at a specific position in a circular linked list
Node *insertAtPosition(Node *last, int data, int pos){
    if (last == nullptr){
        // If the list is empty
        if (pos != 1){
            cout << "Invalid position!" << endl;
            return last;
        }
        // Create a new node and make it point to itself
        Node *newNode = new Node(data);
        last = newNode;
        last->next = last;
        return last;
    }

    // Create a new node with the given data
    Node *newNode = new Node(data);

    // curr will point to head initially
    Node *curr = last->next;

    if (pos == 1){
        // Insert at the beginning
        newNode->next = curr;
        last->next = newNode;
        return last;
    }

    // Traverse the list to find the insertion point
    for (int i = 1; i < pos - 1; ++i) {
        curr = curr->next;

        // If position is out of bounds
        if (curr == last->next){
            cout << "Invalid position!" << endl;
            return last;
        }
    }
    // Insert the new node at the desired position
    newNode->next = curr->next;
    curr->next = newNode;

    // Update last if the new node is inserted at the end
    if (curr == last) last = newNode;

    return last;
}

void printList(Node *last){
    if (last == NULL) return;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main(){
    // Create circular linked list: 2, 3, 4
    Node *first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node *last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Insert elements at specific positions
    int data = 5, pos = 2;
    last = insertAtPosition(last, data, pos);
    cout << "List after insertions: ";
    printList(last);

    return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data;
    struct Node *next;
};

struct Node* createNode(int value);

// Function to insert a node at a specific position in a circular linked list
struct Node* insertAtPosition(struct Node *last, int data, int pos) {
    if (last == NULL) {
        // If the list is empty
        if (pos != 1) {
            printf("Invalid position!\\n");
            return last;
        }
        // Create a new node and make it point to itself
        struct Node *newNode = createNode(data);
        last = newNode;
        last->next = last;
        return last;
    }

    // Create a new node with the given data
    struct Node *newNode = createNode(data);

    // curr will point to head initially
    struct Node *curr = last->next;

    if (pos == 1) {
        // Insert at the beginning
        newNode->next = curr;
        last->next = newNode;
        return last;
    }

    // Traverse the list to find the insertion point
    for (int i = 1; i < pos - 1; ++i) {
        curr = curr->next;

        // If position is out of bounds
        if (curr == last->next) {
            printf("Invalid position!\\n");
            return last;
        }
    }

    // Insert the new node at the desired position
    newNode->next = curr->next;
    curr->next = newNode;

    // Update last if the new node is inserted at the end
    if (curr == last) last = newNode;

    return last;
}

// Function to print the circular linked list
void printList(struct Node *last) {
    if (last == NULL) return;

    struct Node *head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Insert elements at specific positions
    int data = 5, pos = 2;
    last = insertAtPosition(last, data, pos);
    printf("List after insertions: ");
    printList(last);

    return 0;
}

````

Java
````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {

    // Function to insert a node at a specific position in a
    // circular linked list
    static Node insertAtPosition(Node last, int data,
                                 int pos){
        if (last == null) {
            // If the list is empty
            if (pos != 1) {
                System.out.println("Invalid position!");
                return last;
            }
            // Create a new node and make it point to itself
            Node newNode = new Node(data);
            last = newNode;
            last.next = last;
            return last;
        }

        // Create a new node with the given data
        Node newNode = new Node(data);

        // curr will point to head initially
        Node curr = last.next;

        if (pos == 1) {
            // Insert at the beginning
            newNode.next = curr;
            last.next = newNode;
            return last;
        }

        // Traverse the list to find the insertion point
        for (int i = 1; i < pos - 1; ++i) {
            curr = curr.next;

            // If position is out of bounds
            if (curr == last.next) {
                System.out.println("Invalid position!");
                return last;
            }
        }

        // Insert the new node at the desired position
        newNode.next = curr.next;
        curr.next = newNode;

        // Update last if the new node is inserted at the
        // end
        if (curr == last)
            last = newNode;

        return last;
    }

    static void printList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        System.out.println();
    }

    public static void main(String[] args)
    {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Insert elements at specific positions
        int data = 5, pos = 2;
        last = insertAtPosition(last, data, pos);
        System.out.print("List after insertions: ");
        printList(last);
    }
}

````

Python
````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Function to insert a node at a specific position in a circular linked list
def insertAtPosition(last, data, pos):
    if last is None:
        # If the list is empty
        if pos != 1:
            print("Invalid position!")
            return last
        # Create a new node and make it point to itself
        new_node = Node(data)
        last = new_node
        last.next = last
        return last

    # Create a new node with the given data
    new_node = Node(data)

    # curr will point to head initially
    curr = last.next

    if pos == 1:
        # Insert at the beginning
        new_node.next = curr
        last.next = new_node
        return last

    # Traverse the list to find the insertion point
    for i in range(1, pos - 1):
        curr = curr.next

        # If position is out of bounds
        if curr == last.next:
            print("Invalid position!")
            return last

    # Insert the new node at the desired position
    new_node.next = curr.next
    curr.next = new_node

    # Update last if the new node is inserted at the end
    if curr == last:
        last = new_node

    return last

# Function to print the circular linked list
def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

if __name__ == "__main__":
    # Create circular linked list: 2, 3, 4
    first = Node(2)
    first.next = Node(3)
    first.next.next = Node(4)

    last = first.next.next
    last.next = first

    print("Original list: ", end="")
    print_list(last)

    # Insert elements at specific positions
    data = 5
    pos = 2
    last = insertAtPosition(last, data, pos)
    print("List after insertions: ", end="")
    print_list(last)

````

JavaScript
````
class Node {
    constructor(value){
        this.data = value;
        this.next = null;
    }
}

// Function to insert a node at a specific position in a
// circular linked list
function insertAtPosition(last, data, pos)
{
    if (last === null) {
        // If the list is empty
        if (pos !== 1) {
            console.log("Invalid position!");
            return last;
        }
        // Create a new node and make it point to itself
        let newNode = new Node(data);
        last = newNode;
        last.next = last;
        return last;
    }

    // Create a new node with the given data
    let newNode = new Node(data);

    // curr will point to head initially
    let curr = last.next;

    if (pos === 1) {
        // Insert at the beginning
        newNode.next = curr;
        last.next = newNode;
        return last;
    }

    // Traverse the list to find the insertion point
    for (let i = 1; i < pos - 1; ++i) {
        curr = curr.next;

        // If position is out of bounds
        if (curr === last.next) {
            console.log("Invalid position!");
            return last;
        }
    }

    // Insert the new node at the desired position
    newNode.next = curr.next;
    curr.next = newNode;

    // Update last if the new node is inserted at the end
    if (curr === last)
        last = newNode;

    return last;
}

// Function to print the circular linked list
function printList(last){
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Insert elements at specific positions
let data = 5;
let pos = 2;
last = insertAtPosition(last, data, pos);
console.log("List after insertions: ");
printList(last);

````


**Output**
```

Original list: 2 3 4
List after insertions: 2 5 3 4

```

[Deletion from a Circular Linked List](https://www.geeksforgeeks.org/deletion-circular-linked-list/?ref=ml_lbp)
---------------------------------------------------------------------------------------------------------------

Deletion involves removing a node from the linked list. The main
difference is that we need to ensure the list remains circular after the
deletion. We can delete a node in a circular linked list in three
ways:

### 1. Delete the first node in circular linked list

> To delete the first node of a circular linked list, we first check if
> the list is empty. If it is then we print a message and return ****NULL****. If the list contains only one node (the ****head**** is the same as the ****last****) then we delete that node and set the ****last**** pointer to ****NULL****. If there are multiple nodes then we update the ****last->next**** pointer to skip the ****head**** node and effectively removing it from the list. We then delete the ****head**** node to free the allocated memory. Finally, we return the updated ****last**** pointer, which still points to the ****last**** node in the list.

![Deletion-from-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150500/Deletion-from-the-beginning-of-circular-linked-list.webp)

Delete the first node in circular linked list


C++
````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to delete the first node of the circular linked list
Node* deleteFirstNode(Node* last) {
    if (last == nullptr) {
        // If the list is empty
        cout << "List is empty" << endl;
        return nullptr;
    }

    Node* head = last->next;

    if (head == last) {
        // If there is only one node in the list
        delete head;
        last = nullptr;
    } else {
        // More than one node in the list
        last->next = head->next;
        delete head;
    }

    return last;
}

void printList(Node* last) {
    if(last == NULL) return ;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Delete the first node
    last = deleteFirstNode(last);

    cout << "List after deleting first node: ";
    printList(last);

    return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

struct Node* deleteFirstNode(struct Node* last) {
    if (last == NULL) {
        // If the list is empty
        printf("List is empty\\n");
        return NULL;
    }

    struct Node* head = last->next;

    if (head == last) {
        // If there is only one node in the list
        free(head);
        last = NULL;
    } else {
        // More than one node in the list
        last->next = head->next;
        free(head);
    }

    return last;
}

void printList(struct Node* last) {
    if (last == NULL) return;

    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    struct Node* first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node* last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    last = deleteFirstNode(last);

    printf("List after deleting first node: ");
    printList(last);

    return 0;
}

````

Java
````
class Node {
    int data;
    Node next;

    Node(int value) {
        data = value;
        next = null;
    }
}

public class GFG {
    public static Node deleteFirstNode(Node last) {
        if (last == null) {
            // If the list is empty
            System.out.println("List is empty");
            return null;
        }

        Node head = last.next;

        if (head == last) {
            // If there is only one node in the list
            last = null;
        } else {
            // More than one node in the list
            last.next = head.next;
        }

        return last;
    }

    public static void printList(Node last) {
        if (last == null) return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Delete the first node
        last = deleteFirstNode(last);

        System.out.print("List after deleting first node: ");
        printList(last);
    }
}

````

Python
````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def deleteFirstNode(last):
    if last is None:
        # If the list is empty
        print("List is empty")
        return None

    head = last.next

    if head == last:
        # If there is only one node in the list
        last = None
    else:
        # More than one node in the list
        last.next = head.next

    return last

def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)

last = first.next.next
last.next = first

print("Original list: ", end="")
print_list(last)

# Delete the first node
last = deleteFirstNode(last)

print("List after deleting first node: ", end="")
print_list(last)

````

JavaScript
````
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function deleteFirstNode(last) {
    if (last === null) {
        // If the list is empty
        console.log("List is empty");
        return null;
    }

    let head = last.next;

    if (head === last) {
        // If there is only one node in the list
        last = null;
    } else {
        // More than one node in the list
        last.next = head.next;
    }

    return last;
}

function printList(last) {
    if (last === null) return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next) break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete the first node
last = deleteFirstNode(last);

console.log("List after deleting first node: ");
printList(last);

````




**Output**
```

Original list: 2 3 4
List after deleting first node: 3 4

```
### 2. Delete a specific node in circular linked list

> To delete a specific node from a circular linked list, we first check
> if the list is empty. If it is then we print a message and return ****nullptr****. If the list contains only one node and it matches the ****key**** then we delete that node and set ****last**** to ****nullptr****. If the node to be deleted is the first node then we update
> the ****next**** pointer of the ****last**** node to skip the ****head**** node and delete the ****head****. For other nodes, we traverse the list using two pointers: ****curr**** (to find the node) and ****prev****
> (to keep track of the previous node). If we find the node with the
> matching key then we update the next pointer of ****prev**** to skip the ****curr****
> node and delete it. If the node is found and it is the last node, we
> update the ****last****
> pointer accordingly. If the node is not found then do nothing and ****tail**** or ****last**** as it is. Finally, we return the updated ****last**** pointer.

![Delete-a-specific-node-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150531/Delete-a-specific-node-in-circular-linked-list.webp)

Delete a specific node in circular linked list


C++
````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to delete a specific node in the circular linked list
Node* deleteSpecificNode(Node* last, int key) {
    if (last == nullptr) {
        // If the list is empty
        cout << "List is empty, nothing to delete." << endl;
        return nullptr;
    }

    Node* curr = last->next;
    Node* prev = last;

    // If the node to be deleted is the only node in the list
    if (curr == last && curr->data == key) {
        delete curr;
        last = nullptr;
        return last;
    }

    // If the node to be deleted is the first node
    if (curr->data == key) {
        last->next = curr->next;
        delete curr;
        return last;
    }

    // Traverse the list to find the node to be deleted
    while (curr != last && curr->data != key) {
        prev = curr;
        curr = curr->next;
    }

    // If the node to be deleted is found
    if (curr->data == key) {
        prev->next = curr->next;
        if (curr == last) {
            last = prev;
        }
        delete curr;
    } else {
        // If the node to be deleted is not found
        cout << "Node with data " << key
          << " not found." << endl;
    }

    return last;
}

// Function to print the circular linked list
void printList(Node* last) {
     if (last == NULL){
        cout << "List is Empty";
        return;
    }

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Delete a specific node
    int key = 3;
    last = deleteSpecificNode(last, key);

    cout << "List after deleting node " << key << ": ";
    printList(last);

    return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node in the circular linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to delete a specific node in the circular linked list
struct Node* deleteSpecificNode(struct Node* last, int key) {
    if (last == NULL) {
        // If the list is empty
        printf("List is empty, nothing to delete.\\n");
        return NULL;
    }

    struct Node* curr = last->next;
    struct Node* prev = last;

    // If the node to be deleted is the only node in the list
    if (curr == last && curr->data == key) {
        free(curr);
        last = NULL;
        return last;
    }

    // If the node to be deleted is the first node
    if (curr->data == key) {
        last->next = curr->next;
        free(curr);
        return last;
    }

    // Traverse the list to find the node to be deleted
    while (curr != last && curr->data != key) {
        prev = curr;
        curr = curr->next;
    }

    // If the node to be deleted is found
    if (curr->data == key) {
        prev->next = curr->next;
        if (curr == last) {
            last = prev;
        }
        free(curr);
    } else {
        // If the node to be deleted is not found
        printf("Node with data %d not found.\\n", key);
    }

    return last;
}

void printList(struct Node* last) {
    if (last == NULL) {
        printf("List is Empty");
        return;
    }

    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    // Create circular linked list: 2, 3, 4
    struct Node* first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node* last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Delete a specific node
    int key = 3;
    last = deleteSpecificNode(last, key);

    printf("List after deleting node %d: ", key);
    printList(last);

    return 0;
}

````

Java
````
class Node {
    int data;
    Node next;
    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {
    public static Node deleteSpecificNode(Node last,
                                          int key){
        if (last == null) {
            // If the list is empty
            System.out.println(
                "List is empty, nothing to delete.");
            return null;
        }
        Node curr = last.next;
        Node prev = last;

        // If the node to be deleted is the only node in the
        // list
        if (curr == last && curr.data == key) {
            last = null;
            return last;
        }

        // If the node to be deleted is the first node
        if (curr.data == key) {
            last.next = curr.next;
            return last;
        }

        // Traverse the list to find the node to be deleted
        while (curr != last && curr.data != key) {
            prev = curr;
            curr = curr.next;
        }

        // If the node to be deleted is found
        if (curr.data == key) {
            prev.next = curr.next;
            if (curr == last) {
                last = prev;
            }
        }
        else {
            // If the node to be deleted is not found
            System.out.println("Node with data " + key
                               + " not found.");
        }
        return last;
    }

    public static void printList(Node last){
        if (last == null) {
            System.out.println("List is Empty");
            return;
        }

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Delete a specific node
        int key = 3;
        last = deleteSpecificNode(last, key);

        System.out.print("List after deleting node " + key
                         + ": ");
        printList(last);
    }
}

````

Python
````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def deleteSpecificNode(last, key):
    if last is None:
        # If the list is empty
        print("List is empty, nothing to delete.")
        return None

    curr = last.next
    prev = last

    # If the node to be deleted is the only node in the list
    if curr == last and curr.data == key:
        last = None
        return last

    # If the node to be deleted is the first node
    if curr.data == key:
        last.next = curr.next
        return last

    # Traverse the list to find the node to be deleted
    while curr != last and curr.data != key:
        prev = curr
        curr = curr.next

    # If the node to be deleted is found
    if curr.data == key:
        prev.next = curr.next
        if curr == last:
            last = prev
    else:
        # If the node to be deleted is not found
        print(f"Node with data {key} not found.")

    return last

def printList(last):
    if last is None:
        print("List is Empty")
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)

last = first.next.next
last.next = first

print("Original list: ", end="")
printList(last)

# Delete a specific node
key = 3
last = deleteSpecificNode(last, key)

print(f"List after deleting node {key}: ", end="")
printList(last)

````

JavaScript
````
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function deleteSpecificNode(last, key) {
    if (last === null) {
        // If the list is empty
        console.log("List is empty, nothing to delete.");
        return null;
    }

    let curr = last.next;
    let prev = last;

    // If the node to be deleted is the only node in the list
    if (curr === last && curr.data === key) {
        last = null;
        return last;
    }

    // If the node to be deleted is the first node
    if (curr.data === key) {
        last.next = curr.next;
        return last;
    }

    // Traverse the list to find the node to be deleted
    while (curr !== last && curr.data !== key) {
        prev = curr;
        curr = curr.next;
    }

    // If the node to be deleted is found
    if (curr.data === key) {
        prev.next = curr.next;
        if (curr === last) {
            last = prev;
        }
    } else {
        // If the node to be deleted is not found
        console.log("Node with data " + key + " not found.");
    }

    return last;
}

function printList(last) {
    if (last === null) {
        console.log("List is Empty");
        return;
    }

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next) break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete a specific node
let key = 3;
last = deleteSpecificNode(last, key);

console.log("List after deleting node " + key + ": ");
printList(last);

````



**Output**
```

Original list: 2 3 4
List after deleting node 3: 2 4

```
### 3. Deletion at the end of Circular linked list

> To delete the last node in a circular linked list, we first check if
> the list is empty. If it is, we print a message and return ****nullptr****. If the list contains only one node (where the ****head**** is the same as the ****last****), we delete that node and set ****last**** to ****nullptr****. For lists with multiple nodes, we need to traverse the list to find
> the ****second last node****. We do this by starting from the ****head**** and moving through the list until we reach the node whose next
> pointer points to ****last****. Once we find the ****second last**** node then we update its next pointer to point back to the ****head,****
> this effectively removing the last node from the list. We then delete
> the last node to free up memory and return the updated ****last**** pointer, which now points to the last node.

![Deletion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150601/Deletion-at-the-end-of-circular-linked-list.webp)

Deletion at the end of Circular linked list


C++
````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to delete the last node in the circular linked list
Node* deleteLastNode(Node* last) {
    if (last == nullptr) {
        // If the list is empty
        cout << "List is empty, nothing to delete." << endl;
        return nullptr;
    }
    Node* head = last->next;

    // If there is only one node in the list
    if (head == last) {
        delete last;
        last = nullptr;
        return last;
    }
    // Traverse the list to find the second last node
    Node* curr = head;
    while (curr->next != last) {
        curr = curr->next;
    }
    // Update the second last node\'s next pointer
    // to point to head
    curr->next = head;
delete last;
last = curr;

    return last;
}

void printList(Node* last) {
   if(last == NULL) return;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
}
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
first->next = new Node(3);
first->next->next = new Node(4);

    Node* last = first->next->next;
last->next = first;

    cout << "Original list: ";
    printList(last);

// Delete the last node
    last = deleteLastNode(last);

    cout << "List after deleting last node: ";
    printList(last);

return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node in the circular linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to delete the last node in the circular linked list
struct Node* deleteLastNode(struct Node* last) {
    if (last == NULL) {
        // If the list is empty
        printf("List is empty, nothing to delete.\\n");
return NULL;
}
    struct Node* head = last->next;

// If there is only one node in the list
    if (head == last) {
        free(last);
last = NULL;
        return last;
}
    // Traverse the list to find the second last node
    struct Node* curr = head;
    while (curr->next != last) {
        curr = curr->next;
}
    // Update the second last node\'s next pointer to point to head
    curr->next = head;
    free(last);
    last = curr;

    return last;
}

void printList(struct Node* last) {
    if (last == NULL) return;

    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    // Create circular linked list: 2, 3, 4
    struct Node* first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node* last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Delete the last node
    last = deleteLastNode(last);

    printf("List after deleting last node: ");
    printList(last);

    return 0;
}

````

Java
````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {
    public static Node deleteLastNode(Node last){
        if (last == null) {
            // If the list is empty
            System.out.println(
                "List is empty, nothing to delete.");
            return null;
        }
        Node head = last.next;

        // If there is only one node in the list
        if (head == last) {
            last = null;
            return last;
        }
        // Traverse the list to find the second last node
        Node curr = head;
        while (curr.next != last) {
            curr = curr.next;
        }
        // Update the second last node\'s next pointer to
           // point to head
           curr.next = head;
last = curr;

        return last;
}

    public static void printList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
}
        System.out.println();
}

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

        Node last = first.next.next;
last.next = first;

        System.out.print("Original list: ");
        printList(last);

// Delete the last node
        last = deleteLastNode(last);

        System.out.print("List after deleting last node: ");
        printList(last);
}
}

````

Python
````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def deleteLastNode(last):
    if last is None:
        # If the list is empty
        print("List is empty, nothing to delete.")
        return None

    head = last.next

    # If there is only one node in the list
    if head == last:
        last = None
        return last

    # Traverse the list to find the second last node
    curr = head
    while curr.next != last:
        curr = curr.next

    # Update the second last node\'s next pointer to point to head
    curr.next = head
    last = curr

    return last

def printList(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)

last = first.next.next
last.next = first

print("Original list: ", end="")
printList(last)

# Delete the last node
last = deleteLastNode(last)

print("List after deleting last node: ", end="")
printList(last)

````

C#
````
using System;

public class Node {
    public int data;
    public Node next;

    public Node(int value)
    {
        data = value;
        next = null;
    }
}

public class GFG {
    // Function to delete the last node in the circular
    // linked list
    public static Node deleteLastNode(Node last)
    {
        if (last == null) {
            // If the list is empty
            Console.WriteLine(
                "List is empty, nothing to delete.");
            return null;
        }
        Node head = last.next;

        // If there is only one node in the list
        if (head == last) {
            last = null;
            return last;
        }
        // Traverse the list to find the second last node
        Node curr = head;
        while (curr.next != last) {
            curr = curr.next;
        }
        // Update the second last node\'s next pointer
          // to point to head
          curr.next = head;
last = curr;

        return last;
}

    // Function to print the circular linked list
    public static void printList(Node last)
    {
        if (last == null) {
            Console.WriteLine("List is Empty");
            return;
}

        Node head = last.next;
        while (true) {
            Console.Write(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
}
        Console.WriteLine();
}

    public static void Main(string[] args)
    {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

        Node last = first.next.next;
last.next = first;

        Console.Write("Original list: ");
        printList(last);

// Delete the last node
        last = deleteLastNode(last);

        Console.Write("List after deleting last node: ");
        printList(last);
}
}

````

JavaScript
````
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
}
}

function deleteLastNode(last) {
    if (last === null) {
        // If the list is empty
        console.log("List is empty, nothing to delete.");
return null;
}
    let head = last.next;

// If there is only one node in the list
    if (head === last) {
        last = null;
        return last;
}
    // Traverse the list to find the second last node
    let curr = head;
    while (curr.next !== last) {
        curr = curr.next;
}
    // Update the second last node\'s next pointer to point to head
    curr.next = head;
    last = curr;

    return last;
}

function printList(last) {
    if (last === null) return;

    let head = last.next;
    while (true) {
        process.stdout.write(head.data + " ");
        head = head.next;
        if (head === last.next) break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete the last node
last = deleteLastNode(last);

console.log("List after deleting last node: ");
printList(last);

````

**Output**
```

Original list: 2 3 4
List after deleting last node: 2 3

```

[Searching in Circular Linked list](https://www.geeksforgeeks.org/searching-in-circular-linked-list/?ref=ml_lbp)
----------------------------------------------------------------------------------------------------------------

Searching in a circular linked list is similar to searching in a
regular linked list. We start at a given node and traverse the list
until you either find the target value or return to the starting node.
Since the list is circular, make sure to keep track of where you started
to avoid an infinite loop.

> To search for a specific value in a circular linked list, we first
> check if the list is empty. If it is then we return ****false****. If the list contains nodes then we start from the ****head**** node (which is the ****last->next****) and traverse the list. We use a pointer ****curr**** to iterate through the nodes until we reach back to the ****head****. During traversal, if we find a node whose ****data**** matches the given ****key**** then we return ****true**** to indicating that the value was found. After the loop, we also check
> the last node to ensure we don’t miss it. If the ****key**** is not found after traversing the entire list then we return ****false****.

C++
````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to search for a specific value in the
// circular linked list
bool search(Node* last, int key) {
    if (last == nullptr) {
        // If the list is empty
        return false;
    }

    Node* head = last->next;
    Node* curr = head;

    // Traverse the list to find the key
    while (curr != last) {
        if (curr->data == key) {
          // Key found
            return true;
        }
        curr = curr->next;
    }

    // Check the last node
    if (last->data == key) {
      // Key found
        return true;
    }
    // Key not found
    return false;
}

void printList(Node* last) {
   if(last == NULL) return;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Search for a specific value
    int key = 3;
    bool found = search(last, key);
    if (found) {
        cout << "Value " << key << " found in the list." << endl;
    } else {
        cout << "Value " << key << " not found in the list." << endl;
    }

    return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Definition of the Node structure
struct Node{
    int data;
    struct Node *next;
};

// Function to search for a specific value in the circular linked list
int search(struct Node *last, int key){
    if (last == NULL){
        // If the list is empty
        return 0;
    }

    struct Node *head = last->next;
    struct Node *curr = head;

    // Traverse the list to find the key
    while (curr != last){
        if (curr->data == key){
            // Key found
            return 1;
        }
        curr = curr->next;
    }

    // Check the last node
    if (last->data == key){
        // Key found
        return 1;
    }
    // Key not found
    return 0;
}

// Function to print the circular linked list
void printList(struct Node *last){
    if (last == NULL) return;

    struct Node *head = last->next;
    while (1){
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next)
            break;
    }
    printf("\\n");
}
// Function to create a new node
struct Node *createNode(int value){
    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));
    temp->data = value;
    temp->next = NULL;
    return temp;
}

int main(){
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Search for a specific value
    int key = 3;
    int found = search(last, key);
    if (found){
        printf("Value %d found in the list.\\n", key);
    }
    else{
        printf("Value %d not found in the list.\\n", key);
    }

    return 0;
}

````

Java
````
class Node {
    int data;
    Node next;
    Node(int value) {
        data = value;
        next = null;
    }
}

public class CircularLinkedList {
    // Function to search for a specific value
    // in the circular linked list
    static boolean search(Node last, int key) {
        if (last == null) {
            // If the list is empty
            return false;
        }

        Node head = last.next;
        Node curr = head;

        // Traverse the list to find the key
        while (curr != last) {
            if (curr.data == key) {
                // Key found
                return true;
            }
            curr = curr.next;
        }

        // Check the last node
        if (last.data == key) {
            // Key found
            return true;
        }
        // Key not found
        return false;
    }

    static void printList(Node last) {
        if (last == null) return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Search for a specific value
        int key = 3;
        boolean found = search(last, key);
        if (found) {
            System.out.println("Value " + key
                               + " found in the list.");
        } else {
            System.out.println("Value " + key +
                               " not found in the list.");
        }
    }
}

````

Python
````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

def search(last, key):
    if last is None:
        # If the list is empty
        return False

    head = last.next
    curr = head

    # Traverse the list to find the key
    while curr != last:
        if curr.data == key:
            # Key found
            return True
        curr = curr.next

    # Check the last node
    if last.data == key:
        # Key found
        return True
    # Key not found
    return False

def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

if __name__ == "__main__":
    # Create circular linked list: 2, 3, 4
    first = Node(2)
    first.next = Node(3)
    first.next.next = Node(4)

    last = first.next.next
    last.next = first

    print("Original list:", end=" ")
    print_list(last)

    # Search for a specific value
    key = 3
    found = search(last, key)
    if found:
        print(f"Value {key} found in the list.")
    else:
        print(f"Value {key} not found in the list.")

````

C#
````
using System;

public class Node {
    public int data;
    public Node next;
    public Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {
    // Function to search for a specific value in the
    // circular linked list
    public static bool Search(Node last, int key){
        if (last == null) {
            // If the list is empty
            return false;
        }

        Node head = last.next;
        Node curr = head;

        // Traverse the list to find the key
        while (curr != last) {
            if (curr.data == key) {
                // Key found
                return true;
            }
            curr = curr.next;
        }

        // Check the last node
        if (last.data == key) {
            // Key found
            return true;
        }
        // Key not found
        return false;
    }

    public static void PrintList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            Console.Write(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        Console.WriteLine();
    }

    public static void Main(string[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        Console.Write("Original list: ");
        PrintList(last);

        // Search for a specific value
        int key = 3;
        bool found = Search(last, key);
        if (found) {
            Console.WriteLine("Value " + key
                              + " found in the list.");
        }
        else {
            Console.WriteLine("Value " + key
                              + " not found in the list.");
        }
    }
}

````

JavaScript
````
class Node {
    constructor(value){
        this.data = value;
        this.next = null;
    }
}

function search(last, key){
    if (last === null) {
        // If the list is empty
        return false;
    }

    let head = last.next;
    let curr = head;

    // Traverse the list to find the key
    while (curr !== last) {
        if (curr.data === key) {
            // Key found
            return true;
        }
        curr = curr.next;
    }

    // Check the last node
    if (last.data === key) {
        // Key found
        return true;
    }
    // Key not found
    return false;
}

function printList(last){
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        process.stdout.write(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list:");
printList(last);

// Search for a specific value
let key = 3;
let found = search(last, key);
if (found) {
    console.log(`Value ${key} found in the list.`);
}
else {
    console.log(`Value ${key} not found in the list.`);
}

````




**Output**
```

Original list: 2 3 4
Value 3 found in the list.

```

Advantages of Circular Linked Lists
-----------------------------------

* In circular linked list, the last node points to the first node.
  There are no null references, making traversal easier and reducing the
  chances of encountering null pointer exceptions.
* We can traverse the list from any node and return to it without
  needing to restart from the head, which is useful in applications
  requiring a circular iteration.
* Circular linked lists can easily implement circular queues, where the
  last element connects back to the first, allowing for efficient
  resource management.
* In a circular linked list, each node has a reference to the next node
  in the sequence. Although it doesn’t have a direct reference to the
  previous node like a doubly linked list, we can still find the
  previous node by traversing the list.

Disadvantages of Circular Linked Lists
--------------------------------------

* Circular linked lists are more complex to implement than singly
  linked lists.
* Traversing a circular linked list without a clear stopping condition
  can lead to infinite loops if not handled carefully.
* Debugging can be more challenging due to the circular nature, as
  traditional methods of traversing linked lists may not apply.

Applications of Circular Linked Lists
-------------------------------------

* It is used for time-sharing among different users, typically through
  a ****Round-Robin scheduling mechanism.****
* In multiplayer games, a circular linked list can be used to switch
  between players. After the last player’s turn, the list cycles back to
  the first player.
* Circular linked lists are often used in buffering applications, such
  as streaming data, where data is continuously produced and
  consumed.
* In media players, circular linked lists can manage playlists, this
  allowing users to loop through songs continuously.
* Browsers use circular linked lists to manage the cache. This allows
  you to navigate back through your browsing history efficiently by
  pressing the BACK button.', e'A circular linked list is a data structure where the last node connects back to the first,
forming a loop. This structure allows for continuous traversal without
any interruptions. Circular linked lists are especially helpful for
tasks like scheduling and managing playlists, this allowing for smooth navigation. In this tutorial, we’ll cover the
basics of circular linked lists, how to work with them, their advantages
and disadvantages, and their applications.', 'Introduction to Circular Linked List', 14, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('039efe3e-47d0-410e-b3db-a9e64d9bedd7', e'Representation of Stack Data Structure:
---------------------------------------

Stack follows LIFO (Last In First Out) Principle so the element which
is pushed last is popped first.


![Stack-representation-in-Data-Structures-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp)

****Types of Stack:****
-----------------------

* ****Fixed Size Stack****
  : As the name suggests, a fixed size stack has a fixed size and cannot
  grow or shrink dynamically. If the stack is full and an attempt is
  made to add an element to it, an overflow error occurs. If the stack
  is empty and an attempt is made to remove an element from it, an
  underflow error occurs.
* ****Dynamic Size Stack****
  : A dynamic size stack can grow or shrink dynamically. When the stack
  is full, it automatically increases its size to accommodate the new
  element, and when the stack is empty, it decreases its size. This type
  of stack is implemented using a linked list, as it allows for easy
  resizing of the stack.

Basic Operations on Stack:
--------------------------

In order to make manipulations in a stack, there are certain operations
provided to us.


* ****push()****  to insert an element into the stack
* ****pop()****  to remove an element from the stack
* ****top()****  Returns the top element of the stack.
* ****isEmpty()****  returns true if stack is empty else false.
* ****isFull()****  returns true if the stack is full else false.

To implement stack, we need to maintain reference to the top
item.

### ****Push Operation on Stack****

Adds an item to the stack. If the stack is full, then it is said to be
an  ****Overflow condition.****

 ****Algorithm for Push Operation:****

* Before pushing the element to the stack, we check if the stack is  ****full****  .
* If the stack is full  ****(top == capacity-1)****  , then  ****Stack Overflows****  and we cannot insert the element to the stack.
* Otherwise, we increment the value of top by 1  ****(top = top + 1)****  and the new value is inserted at  ****top position****  .
* The elements can be pushed into the stack till we reach the  ****capacity****  of the stack.

![Push-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180844/Push-Operation-in-Stack-(1).webp)
### ****Pop Operation in Stack****

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an  ****Underflow condition.****

****Algorithm for Pop Operation:****

* Before popping the element from the stack, we check if the stack is  ****empty****  .
* If the stack is empty (top == -1), then  ****Stack Underflows****  and we cannot remove any element from the stack.
* Otherwise, we store the value at top, decrement the value of top by 1  ****(top = top – 1)****  and return the stored top value.

![Pop-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180943/Pop-Operation-in-Stack-(1).webp)
### ****Top or Peek Operation on Stack****

Returns the top element of the stack.

****Algorithm for Top Operation:****

* Before returning the top element from the stack, we check if the
  stack is empty.
* If the stack is empty (top == -1), we simply print “Stack is empty”.
* Otherwise, we return the element stored at  ****index = top****  .

![Top-or-Peek-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181023/Top-or-Peek-Operation-in-Stack-(1).webp)
### ****isEmpty Operation in Stack Data Structure:****

Returns true if the stack is empty, else false.

****Algorithm for isEmpty Operation****:

* Check for the value of  ****top****  in stack.
* If  ****(top == -1)****, then the stack is  ****empty****  so return  ****true****  .
* Otherwise, the stack is not empty so return  ****false****  .

![isEmpty-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181101/isEmpty-Operation-in-Stack-(1).webp)
### isFull ****Operation in Stack**** ****Data Structure****:

Returns true if the stack is full, else false.

****Algorithm for isFull Operation:****

* Check for the value of  ****top****  in stack.
* If  ****(top == capacity-1),****  then the stack is  ****full****  so return  ****true****.
* Otherwise, the stack is not full so return  ****false****.

![isFull-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181147/isFull-Operation-in-Stack-(1).webp)

Implementation of Stack
-----------------------


The basic operations that can be performed on a stack include push, pop,
and peek. There are two ways to implement a stack –


* [****Implementation of Stack using Array****](https://www.geeksforgeeks.org/implement-stack-using-array/)
* [****Implementation of Stack using Linked List****](https://www.geeksforgeeks.org/implement-a-stack-using-singly-linked-list/)

****Complexity Analysis of Operations on Stack Data Structure:****
------------------------------------------------------------------

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****push()**** | O(1) | O(1) |
| ****pop()**** | O(1) | O(1) |
| top() or  ****pee****k() | O(1) | O(1) |
| isEmpty() | O(1) | O(1) |
| isFull() | O(1) | O(1) |', e'Stack is a linear data structure that follows LIFO (Last In First Out) Principle, the last element inserted is the first to be popped out. It means
both insertion and deletion operations happen at one end only.', 'What is Stack Data Structure? A Complete Tutorial', 8, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('2b55a666-302b-4c46-8d3a-3fdaefcca1e7', e'Implement Stack using Array:
----------------------------

> To implement a stack using an array, initialize an array and treat
> its end as the stack’s top. Implement ****push**** (add to end), ****pop**** (remove from end), and ****peek**** (check end) operations, handling cases for an ****empty**** or f****ull stack****.

****Step-by-step approach:****

1. ****Initialize an array**** to represent the stack.
2. Use the ****end of the array**** to represent the ****top of the stack****.
3. Implement ****push**** (add to end), ****pop**** (remove from the end), and ****peek**** (check end) operations, ensuring to handle empty and full stack
   conditions.

Implement Stack Operations using Array:
---------------------------------------


Here are the following operations of implement stack using array:

### ****Push Operation in Stack:****

Adds an item to the stack. If the stack is full, then it is said to be
an ****Overflow condition.****

****Algorithm for Push Operation:****

> * Before pushing the element to the stack, we check if the stack
>   is ****full****.
> * If the stack is full ****(top == capacity-1)**** , then ****Stack Overflows****and we cannot insert the element to the stack.
> * Otherwise, we increment the value of top by 1 ****(top = top + 1)**** and the new value is inserted at ****top position****.
> * The elements can be pushed into the stack till we reach
>   the ****capacity**** of the stack.

![push-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)![push-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)


![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114220/push-operation-in-stack-2.webp)![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114220/push-operation-in-stack-2.webp)


![push-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114221/push-operation-in-stack-3.webp)![push-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114221/push-operation-in-stack-3.webp)


![push-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-4.webp)![push-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-4.webp)


![push-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-5.webp)![push-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-5.webp)


![push-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114223/push-operation-in-stack-6.webp)![push-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114223/push-operation-in-stack-6.webp)



Previous





Pause

Next





5 / 6

### ****Pop Operation in Stack:****

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an ****Underflow condition.****

****Algorithm for Pop Operation:****

> * Before popping the element from the stack, we check if the stack
>   is ****empty****.
> * If the stack is empty (top == -1), then ****Stack Underflows**** and we cannot remove any element from the stack.
> * Otherwise, we store the value at top, decrement the value of top by
>   1 ****(top = top – 1)**** and return the stored top value.

![pop-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)



Previous





Play

Next





1 / 6




### ****Top or Peek Operation in Stack:****

Returns the top element of the stack.

****Algorithm for Top Operation:****

> * Before returning the top element from the stack, we check if the
>   stack is empty.
> * If the stack is empty (top == -1), we simply print “Stack is
>   empty”.
> * Otherwise, we return the element stored at ****index = top****.

### ****isEmpty Operation in Stack:****

Returns true if the stack is empty, else false.

****Algorithm for isEmpty Operation****:

> * Check for the value of ****top**** in stack.
> * If ****(top == -1)**** , then the stack is ****empty****so return ****true****.
> * Otherwise, the stack is not empty so return ****false****.

### isFull ****Operation in Stack****:

Returns true if the stack is full, else false.

****Algorithm for isFull Operation:****

> * Check for the value of ****top**** in stack.
> * If ****(top == capacity-1),**** then the stack is ****full**** so return ****true****.
> * Otherwise, the stack is not full so return ****false.****

Below is the implementation of the above approach:

C++
````
/* C++ program to implement basic stack
operations */
#include <bits/stdc++.h>

using namespace std;

#define MAX 1000

class Stack {
    int top;

public:
    int a[MAX]; // Maximum size of Stack

    Stack() { top = -1; }
    bool push(int x);
    int pop();
    int peek();
    bool isEmpty();
};

bool Stack::push(int x)
{
    if (top >= (MAX - 1)) {
        cout << "Stack Overflow";
        return false;
    }
    else {
        a[++top] = x;
        cout << x << " pushed into stack\\n";
        return true;
    }
}

int Stack::pop()
{
    if (top < 0) {
        cout << "Stack Underflow";
        return 0;
    }
    else {
        int x = a[top--];
        return x;
    }
}
int Stack::peek()
{
    if (top < 0) {
        cout << "Stack is Empty";
        return 0;
    }
    else {
        int x = a[top];
        return x;
    }
}

bool Stack::isEmpty()
{
    return (top < 0);
}

// Driver program to test above functions
int main()
{
    class Stack s;
    s.push(10);
    s.push(20);
    s.push(30);
    cout << s.pop() << " Popped from stack\\n";

    //print top element of stack after popping
    cout << "Top element is : " << s.peek() << endl;

    //print all elements in stack :
    cout <<"Elements present in stack : ";
    while(!s.isEmpty())
    {
        // print top element in stack
        cout << s.peek() <<" ";
        // remove top element in stack
        s.pop();
    }

    return 0;
}

````

C
````
// C program for array implementation of stack
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

// A structure to represent a stack
struct Stack {
    int top;
    unsigned capacity;
    int* array;
};

// function to create a stack of given capacity. It initializes size of
// stack as 0
struct Stack* createStack(unsigned capacity)
{
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->capacity = capacity;
    stack->top = -1;
    stack->array = (int*)malloc(stack->capacity * sizeof(int));
    return stack;
}

// Stack is full when top is equal to the last index
int isFull(struct Stack* stack)
{
    return stack->top == stack->capacity - 1;
}

// Stack is empty when top is equal to -1
int isEmpty(struct Stack* stack)
{
    return stack->top == -1;
}

// Function to add an item to stack. It increases top by 1
void push(struct Stack* stack, int item)
{
    if (isFull(stack))
        return;
    stack->array[++stack->top] = item;
    printf("%d pushed to stack\\n", item);
}

// Function to remove an item from stack. It decreases top by 1
int pop(struct Stack* stack)
{
    if (isEmpty(stack))
        return INT_MIN;
    return stack->array[stack->top--];
}

// Function to return the top from stack without removing it
int peek(struct Stack* stack)
{
    if (isEmpty(stack))
        return INT_MIN;
    return stack->array[stack->top];
}

// Driver program to test above functions
int main()
{
    struct Stack* stack = createStack(100);

    push(stack, 10);
    push(stack, 20);
    push(stack, 30);

    printf("%d popped from stack\\n", pop(stack));

    return 0;
}

````

Java
````
/* Java program to implement basic stack
operations */
class Stack {
    static final int MAX = 1000;
    int top;
    int a[] = new int[MAX]; // Maximum size of Stack

    boolean isEmpty()
    {
        return (top < 0);
    }
    Stack()
    {
        top = -1;
    }

    boolean push(int x)
    {
        if (top >= (MAX - 1)) {
            System.out.println("Stack Overflow");
            return false;
        }
        else {
            a[++top] = x;
            System.out.println(x + " pushed into stack");
            return true;
        }
    }

    int pop()
    {
        if (top < 0) {
            System.out.println("Stack Underflow");
            return 0;
        }
        else {
            int x = a[top--];
            return x;
        }
    }

    int peek()
    {
        if (top < 0) {
            System.out.println("Stack Underflow");
            return 0;
        }
        else {
            int x = a[top];
            return x;
        }
    }

    void print(){
    for(int i = top;i>-1;i--){
    System.out.print(" "+ a[i]);
    }
}
}

// Driver code
class Main {
    public static void main(String args[])
    {
        Stack s = new Stack();
        s.push(10);
        s.push(20);
        s.push(30);
        System.out.println(s.pop() + " Popped from stack");
        System.out.println("Top element is :" + s.peek());
        System.out.print("Elements present in stack :");
        s.print();
    }
}

````

Python3
````
# Python program for implementation of stack

# import maxsize from sys module
# Used to return -infinite when stack is empty
from sys import maxsize

# Function to create a stack. It initializes size of stack as 0
def createStack():
    stack = []
    return stack

# Stack is empty when stack size is 0
def isEmpty(stack):
    return len(stack) == 0

# Function to add an item to stack. It increases size by 1
def push(stack, item):
    stack.append(item)
    print(item + " pushed to stack ")

# Function to remove an item from stack. It decreases size by 1
def pop(stack):
    if (isEmpty(stack)):
        return str(-maxsize -1) # return minus infinite

    return stack.pop()

# Function to return the top from stack without removing it
def peek(stack):
    if (isEmpty(stack)):
        return str(-maxsize -1) # return minus infinite
    return stack[len(stack) - 1]

# Driver program to test above functions
stack = createStack()
push(stack, str(10))
push(stack, str(20))
push(stack, str(30))
print(pop(stack) + " popped from stack")

````

C#
````
// C# program to implement basic stack
// operations
using System;

namespace ImplementStack {
class Stack {
    private int[] ele;
    private int top;
    private int max;
    public Stack(int size)
    {
        ele = new int[size]; // Maximum size of Stack
        top = -1;
        max = size;
    }

    public void push(int item)
    {
        if (top == max - 1) {
            Console.WriteLine("Stack Overflow");
            return;
        }
        else {
            ele[++top] = item;
        }
    }

    public int pop()
    {
        if (top == -1) {
            Console.WriteLine("Stack is Empty");
            return -1;
        }
        else {
            Console.WriteLine("{0} popped from stack ", ele[top]);
            return ele[top--];
        }
    }

    public int peek()
    {
        if (top == -1) {
            Console.WriteLine("Stack is Empty");
            return -1;
        }
        else {
            Console.WriteLine("{0} popped from stack ", ele[top]);
            return ele[top];
        }
    }

    public void printStack()
    {
        if (top == -1) {
            Console.WriteLine("Stack is Empty");
            return;
        }
        else {
            for (int i = 0; i <= top; i++) {
                Console.WriteLine("{0} pushed into stack", ele[i]);
            }
        }
    }
}

// Driver program to test above functions
class Program {
    static void Main()
    {
        Stack p = new Stack(5);

        p.push(10);
        p.push(20);
        p.push(30);
        p.printStack();
        p.pop();
    }
}
}

````

JavaScript
````
/* javascript program to implement basic stack
operations
*/
var t = -1;
    var MAX = 1000;
    var a = Array(MAX).fill(0); // Maximum size of Stack

    function isEmpty() {
        return (t < 0);
    }

    function push(x) {
        if (t >= (MAX - 1)) {
            console.log("Stack Overflow");
            return false;
        } else {
        t+=1;
            a[t] = x;

            console.log(x + " pushed into stack<br/>");
            return true;
        }
    }

    function pop() {
        if (t < 0) {
            console.log("Stack Underflow");
            return 0;
        } else {
            var x = a[t];
            t-=1;
            return x;
        }
    }

    function peek() {
        if (t < 0) {
            console.log("Stack Underflow");
            return 0;
        } else {
            var x = a[t];
            return x;
        }
    }

    function print() {
        for (i = t; i > -1; i--) {
            console.log(" " + a[i]);
        }
    }

        push(10);
        push(20);
        push(30);
        console.log(pop() + " Popped from stack");
        console.log("<br/>Top element is :" + peek());
        console.log("<br/>Elements present in stack : ");
        print();

````

**Output**
```

10 pushed into stack
20 pushed into stack
30 pushed into stack
30 Popped from stack
Top element is : 20
Elements present in stack : 20 10
```
### Complexity Analysis:

* ****Time Complexity****:
  + `push`: O(1)
  + `pop`: O(1)
  + `peek`: O(1)
  + `is_empty`: O(1)
  + is\\_full: O(1)
* ****Auxiliary Space****: O(n), where n is the number of items in the stack.

Advantages of Array Implementation:
-----------------------------------

* Easy to implement.
* Memory is saved as pointers are not involved.

Disadvantages of Array Implementation:
--------------------------------------

* It is not dynamic i.e., it doesn’t grow and shrink depending on needs
  at runtime. [But in case of dynamic sized arrays like vector in C++,
  list in Python, ArrayList in Java, stacks can grow and shrink with
  array implementation as well].
* The total size of the stack must be defined beforehand.
', e'Stack is a linear data structurewhich follows LIFO principle. In this article, we will learn how to implement Stack using
Arrays. In Array-based approach, all stack-related operations are
executed using arrays. Let’s see how we can implement each operation on
the stack utilizing the Array Data Structure.', 'Implement Stack using Array', 9, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('b41b7e34-c749-4217-b0f3-6b496b632261', e'Applications of Stacks:
-----------------------

* ****Function calls:****
  Stacks are used to keep track of the return addresses of function
  calls, allowing the program to return to the correct location after a
  function has finished executing.
* ****Recursion:**** Stacks are used to store the local variables and return addresses of
  recursive function calls, allowing the program to keep track of the
  current state of the recursion.
* ****Expression evaluation:**** Stacks are used to evaluate expressions in postfix notation (Reverse
  Polish Notation).
* ****Syntax parsing:**** Stacks are used to check the validity of syntax in programming
  languages and other formal languages.
* ****Memory management:**** Stacks are used to allocate and manage memory in some operating
  systems and programming languages.
* Used to solve popular problems like [Next Greater](https://www.geeksforgeeks.org/next-greater-element/), [Previous Greater](https://www.geeksforgeeks.org/previous-greater-element/), [Next Smaller](https://www.geeksforgeeks.org/next-smaller-element/), [Previous Smaller](https://www.geeksforgeeks.org/find-the-nearest-smaller-numbers-on-left-side-in-an-array/), [Largest Area in a Histogram](https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-using-stack/) and [Stock Span Problems](https://www.geeksforgeeks.org/the-stock-span-problem/).

Advantages of Stacks:
---------------------

* ****Simplicity:**** Stacks are a simple and easy-to-understand data structure, making
  them suitable for a wide range of applications.
* ****Efficiency:**** Push and pop operations on a stack can be performed in constant time ****(O(1))****, providing efficient access to data.
* ****Last-in, First-out (LIFO):****
  Stacks follow the LIFO principle, ensuring that the last element added
  to the stack is the first one removed. This behavior is useful in many
  scenarios, such as function calls and expression evaluation.
* ****Limited memory usage:**** Stacks only need to store the elements that have been pushed onto
  them, making them memory-efficient compared to other data
  structures.

Disadvantages of Stacks:
------------------------

* ****Limited access:****
  Elements in a stack can only be accessed from the top, making it
  difficult to retrieve or modify elements in the middle of the
  stack.
* ****Potential for overflow:**** If more elements are pushed onto a stack than it can hold, an
  overflow error will occur, resulting in a loss of data.
* ****Not suitable for random access:**** Stacks do not allow for random access to elements, making them
  unsuitable for applications where elements need to be accessed in a
  specific order.
* ****Limited capacity:****
  Stacks have a fixed capacity, which can be a limitation if the number
  of elements that need to be stored is unknown or highly
  variable.
', e'A stack is a linear data structure
in which the insertion of a new element and removal of an existing
element takes place at the same end represented as the top of the stack.', 'Applications, Advantages and Disadvantages of Stack', 11, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('9a7d3527-1c48-4e9d-8aac-990f873ca15d', e'What is a Doubly Linked List?
-----------------------------

A ****doubly linked list****
is a data structure that consists of a set of nodes, each of which
contains a ****value**** and ****two pointers****, one pointing to the ****previous node**** in the list and one pointing to the ****next node****
in the list. This allows for efficient traversal of the list in ****both directions****, making it suitable for applications where frequent ****insertions**** and ****deletions**** are required.

![Insertion-at-the-End-in-Doubly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20240809123741/Insertion-at-the-End-in-Doubly-Linked-List-copy.webp)

Doubly Linked List


Representation of Doubly Linked List in Data Structure
------------------------------------------------------

In a data structure, a doubly linked list is represented using nodes
that have three fields:

1. Data
2. A pointer to the next node (****next****)
3. A pointer to the previous node (****prev****)

![Node-Structure-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124907/Node-Structure-of-Doubly-Linked-List.webp)

Node Structure of Doubly Linked List


Node Definition
---------------

Here is how a node in a Doubly Linked List is typically
represented:

[Try it on GfG Practice
![redirect icon](https://media.geeksforgeeks.org/auth-dashboard-uploads/Group-arrow.svg)](https://www.geeksforgeeks.org/problems/display-doubly-linked-list--154650/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card)
C++
````
struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;

    // Constructor
    Node(int d) {
       data = d;
       prev = next = nullptr;
    }
};

````

C
````
struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;
};

// Function to create a new node
struct Node *createNode(int new_data) {
    struct Node *new_node = (struct Node *)
    malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}

````

Java
````
class Node {

    // To store the Value or data.
    int data;

    // Reference to the Previous Node
    Node prev;

    // Reference to the next Node
    Node next;

    // Constructor
    Node(int d) {
       data = d;
       prev = next = null;
    }
};

````

Python
````
class Node:

    def __init__(self, data):
        # To store the value or data.
        self.data = data

        # Reference to the previous node
        self.prev = None

        # Reference to the next node
        self.next = None

````

C#
````
class Node
{
  	// To store the value or data
    public int Data;

  	// Pointer to the next node
    public Node Next;

  	// Pointer to the previous node
    public Node Prev;

    // Constructor
    public Node(int d)
    {
        Data = d;
        Prev = Next = null;
    }
}

````

JavaScript
````
class Node {
    constructor(data)
    {
        // To store the value or data.
        this.data = data;

        // Reference to the previous node
        this.prev = null;

        // Reference to the next node
        this.next = null;
    }
}

````

Each node in a ****Doubly Linked List**** contains the ****data**** it holds, a pointer to the ****next**** node in the list, and a pointer to the ****previous****
node in the list. By linking these nodes together through the ****next**** and ****prev****
pointers, we can traverse the list in both directions (forward and
backward), which is a key feature of a Doubly Linked List.

[Operations on Doubly Linked List](https://www.geeksforgeeks.org/doubly-linked-list-tutorial)
---------------------------------------------------------------------------------------------

* ****Traversal in Doubly Linked List****
* ****Searching in Doubly Linked List****
* ****Finding Length of Doubly Linked List****
* [****Insertion in Doubly Linked List****:](https://www.geeksforgeeks.org/introduction-and-insertion-in-a-doubly-linked-list)
  + Insertion at the beginning of Doubly Linked List
  + Insertion at the end of the Doubly Linked List
  + Insertion at a specific position in Doubly Linked List
* [****Deletion in Doubly Linked List****:](https://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list)
  + Deletion of a node at the beginning of Doubly Linked List
  + Deletion of a node at the end of Doubly Linked List
  + Deletion of a node at a specific position in Doubly Linked
    List

Let\'s go through each of the operations mentioned above, one by
one.

[Traversal in Doubly Linked List](https://www.geeksforgeeks.org/traversal-in-doubly-linked-list/)
-------------------------------------------------------------------------------------------------

To Traverse the doubly list, we can use the following steps:

****a. Forward Traversal:****

* Initialize a pointer to the head of the linked list.
* While the pointer is not null:
  + Visit the data at the current node.
  + Move the pointer to the next node.

****b. Backward Traversal:****

* Initialize a pointer to the tail of the linked list.
* While the pointer is not null:
  + Visit the data at the current node.
  + Move the pointer to the previous node.

Below are the implementation of the above approach:

C++
````
#include <iostream>
using namespace std;

// Define the Node structure
struct Node {
    int data;
    Node* next;
    Node* prev;

// Constructor to initialize Node with data
    Node(int data) : data(data), next(nullptr),
  	prev(nullptr) {}
};

// Function to traverse the doubly linked list
// in forward direction
void forwardTraversal(Node* head) {

    // Start traversal from the head of the list
    Node* curr = head;

// Continue until current node is not null
    // (end of list)
    while (curr != nullptr) {

        // Output data of the current node
        cout << curr->data << " ";

// Move to the next node
        curr = curr->next;
}

    // Print newline after traversal
    cout << endl;
}

// Function to traverse the doubly linked list
// in backward direction
void backwardTraversal(Node* tail) {

    // Start traversal from the tail of the list
    Node* curr = tail;

// Continue until current node is not null
    // (end of list)
    while (curr != nullptr) {

        // Output data of the current node
        cout << curr->data << " ";

// Move to the previous node
        curr = curr->prev;
}

    // Print newline after traversal
    cout << endl;
}

int main() {

    // Sample usage of the doubly linked list and
    // traversal functions
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    cout << "Forward Traversal:" << endl;
    forwardTraversal(head);

    cout << "Backward Traversal:" << endl;
    backwardTraversal(third);

return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data; // Data stored in the node
    struct Node* next; // Pointer to the next node
    struct Node* prev; // Pointer to the previous node
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode =
      (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
return newNode;
}

// Function to traverse the doubly linked list
// in forward direction
void forwardTraversal(struct Node* head) {

    // Start traversal from the head of the list
    struct Node* curr = head;

// Continue until the current node is not
    // null (end of list)
    while (curr != NULL) {

        // Output data of the current node
        printf("%d ", curr->data);

// Move to the next node
        curr = curr->next;
}

    // Print newline after traversal
    printf("\\n");
}

// Function to traverse the doubly linked list
// in backward direction
void backwardTraversal(struct Node* tail) {

    // Start traversal from the tail of the list
    struct Node* curr = tail;

// Continue until the current node is not
    // null (end of list)
    while (curr != NULL) {

        // Output data of the current node
        printf("%d ", curr->data);

// Move to the previous node
        curr = curr->prev;
}

    // Print newline after traversal
    printf("\\n");
}

int main() {

    // Sample usage of the doubly linked list and
    // traversal functions
    struct Node* head = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    printf("Forward Traversal:\\n");
    forwardTraversal(head);

    printf("Backward Traversal:\\n");
    backwardTraversal(third);

// Free memory allocated for nodes
    free(head);
    free(second);
    free(third);

return 0;
}

````

Java
````
// Define the Node class
class Node {
    int data; // Data stored in the node
    Node next; // Pointer to the next node
    Node prev; // Pointer to the previous node

    // Constructor to initialize the node with data
    public Node(int data) {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

// Class to manage the doubly linked list
class GfG {

    // Function to traverse the doubly linked list
    // in forward direction
    static void forwardTraversal(Node head) {

        // Start traversal from the head of the list
        Node curr = head;

// Continue until the current node is
        // null (end of the list)
        while (curr != null) {

            // Output data of the current node
            System.out.print(curr.data + " ");

// Move to the next node
            curr = curr.next;
}

        // Print newline after traversal
        System.out.println();
}

    // Function to traverse the doubly linked list
  	//in backward direction
    static void backwardTraversal(Node tail) {

        // Start traversal from the tail of the list
        Node curr = tail;

// Continue until the current node is
        // null (end of the list)
        while (curr != null) {

            // Output data of the current node
            System.out.print(curr.data + " ");

// Move to the previous node
            curr = curr.prev;
}

        // Print newline after traversal
        System.out.println();
}

    public static void main(String[] args) {

        // Sample usage of the doubly linked
        // list and traversal functions
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        System.out.println("Forward Traversal:");
        forwardTraversal(head);

        System.out.println("Backward Traversal:");
        backwardTraversal(third);
}
}

````

Python
````
# Define the Node class
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Function to traverse the doubly linked list
# in forward direction
def forward_traversal(head):

    # Start traversal from the head of the list
    curr = head

    # Continue until the current node is
    # null (end of the list)
    while curr is not None:

        # Output data of the current node
        print(curr.data, end=" ")

        # Move to the next node
        curr = curr.next

    # Print newline after traversal
    print()

# Function to traverse the doubly linked
# list in backward direction
def backward_traversal(tail):

    # Start traversal from the tail of the list
    curr = tail

    # Continue until the current node
    # is null (end of the list)
    while curr is not None:

        # Output data of the current node
        print(curr.data, end=" ")

        # Move to the previous node
        curr = curr.prev

    # Print newline after traversal
    print()

# Sample usage of the doubly linked list
# and traversal functions
if __name__ == "__main__":

    # Create a doubly linked list with 3 nodes
    head = Node(1)
    second = Node(2)
    third = Node(3)

    head.next = second
    second.prev = head
    second.next = third
    third.prev = second

    print("Forward Traversal:")
    forward_traversal(head)

    print("Backward Traversal:")
    backward_traversal(third)

````

C#
````
using System;

// Define the Node class
class Node
{
    public int Data; // Data stored in the node
    public Node Next; // Pointer to the next node
    public Node Prev; // Pointer to the previous node

    // Constructor to initialize the node with data
    public Node(int data)
    {
        Data = data;
Next = null;
        Prev = null;
}
}

// Class to manage the doubly linked list
class GfG
{
    // Function to traverse the doubly linked list
  	//in forward direction
    static void ForwardTraversal(Node head)
    {
        // Start traversal from the head of the list
        Node curr = head;

// Continue until the current node is null
      	//(end of the list)
        while (curr != null)
        {
            // Output data of the current node
            Console.Write(curr.Data + " ");

// Move to the next node
            curr = curr.Next;
}

        // Print newline after traversal
        Console.WriteLine();
}

    // Function to traverse the doubly linked list
  	//in backward direction
    static void BackwardTraversal(Node tail)
    {
        // Start traversal from the tail of the list
        Node curr = tail;

// Continue until the current node is null
      	//(end of the list)
        while (curr != null)
        {
            // Output data of the current node
            Console.Write(curr.Data + " ");

// Move to the previous node
            curr = curr.Prev;
}

        // Print newline after traversal
        Console.WriteLine();
}

    public static void Main()
    {
        // Sample usage of the doubly linked list
      	//and traversal functions
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.Next = second;
second.Prev = head;
second.Next = third;
        third.Prev = second;

        Console.WriteLine("Forward Traversal:");
        ForwardTraversal(head);

        Console.WriteLine("Backward Traversal:");
        BackwardTraversal(third);
}
}

````

JavaScript
````
// Define the Node class
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Function to traverse the doubly linked list
// in forward direction
function forwardTraversal(head) {

    // Start traversal from the head of the list
    let curr = head;

// Continue until the current node is null
    // (end of the list)
    while (curr !== null) {

        // Output data of the current node
        console.log(curr.data + " ");

// Move to the next node
        curr = curr.next;
}

    // Print newline after traversal
    console.log();
}

// Function to traverse the doubly linked list
// in backward direction
function backwardTraversal(tail) {

    // Start traversal from the tail of the list
    let curr = tail;

// Continue until the current node is null
    // (end of the list)
    while (curr !== null) {

        // Output data of the current node
        console.log(curr.data + " ");

// Move to the previous node
        curr = curr.prev;
}

    // Print newline after traversal
    console.log();
}

// Sample usage of the doubly linked list
//and traversal functions
// Create a doubly linked list with 3 nodes
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);

head.next = second;
second.prev = head;
second.next = third;
third.prev = second;

console.log("Forward Traversal:");
forwardTraversal(head);

console.log("Backward Traversal:");
backwardTraversal(third);

````



**Output**
```

Forward Traversal:
1 2 3
Backward Traversal:
3 2 1

```

[Finding Length of Doubly Linked List](https://www.geeksforgeeks.org/program-find-size-doubly-linked-list/)
-----------------------------------------------------------------------------------------------------------

To find the length of doubly list, we can use the following
steps:

* Start at the head of the list.
* Traverse through the list, counting each node visited.
* Return the total count of nodes as the length of the list.

Below are the implementation of the above approach:

C++
````
#include <iostream>

using namespace std;

// Node structure for doubly linked list
struct Node {
    int data;
    Node * prev;
    Node * next;

    Node(int val) {
        data = val;
        prev = next = nullptr;
}
};

// Function to find the length of a doubly
//linked list
int findLength(Node * head) {
    int count = 0;
for (Node * cur = head; cur != nullptr; cur = cur -> next)
        count++;
return count;
}

int main() {

    // Create a DLL with 3 nodes
    Node * head = new Node(1);
    Node * second = new Node(2);
    Node * third = new Node(3);
    head -> next = second;
second -> prev = head;
second -> next = third;
    third -> prev = second;

    cout << "Length of the doubly linked list: " <<
        findLength(head) << endl;

return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Node structure for doubly linked list
struct Node {
    int data; // Data stored in the node
    struct Node* prev; // Pointer to the previous node
    struct Node* next; // Pointer to the next node
};

// Constructor function to create a new node
struct Node* createNode(int val) {
    struct Node* newNode =
         (struct Node*)malloc(sizeof(struct Node));
    newNode->data = val;
    newNode->prev = NULL;
    newNode->next = NULL;
return newNode;
}

// Function to find the length of a doubly linked list
int findLength(struct Node* head) {
    int count = 0;
for (struct Node* cur = head; cur != NULL; cur = cur->next)
        count++;
return count;
}

int main() {
    // Create a DLL with 3 nodes
    struct Node* head = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    printf("Length of the doubly linked list: %d\\n",
           findLength(head));

return 0;
}

````

Java
````
class Node {
    int data;
    Node prev;
    Node next;

// Constructor
    public Node(int val) {
        data = val;
        prev = null;
next = null;
}
}

class GfG {

    // Function to find the length of
    // a doubly linked list
    static int FindLength(Node head) {
        int count = 0;
for (Node cur = head; cur != null; cur = cur.next)
            count++;
return count;
}

    // Driver code
    public static void main(String[] args) {

        // Create a doubly linked list
        // with 3 nodes
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        System.out.println("Length of doubly linked list: "
                           + FindLength(head));
}
}

````

Python
````
class Node:
    def __init__(self, val):
        self.data = val
        self.prev = None
        self.next = None

# Function to find the length of
# a doubly linked list
def find_length(head):
    count = 0
    cur = head
    while cur is not None:
        count += 1
        cur = cur.next
    return count

# Driver code
if __name__ == "__main__":

    # Create a doubly linked list
    # with 3 nodes
    head = Node(1)
    second = Node(2)
    third = Node(3)

    head.next = second
    second.prev = head
    second.next = third
    third.prev = second

    print("Length of the doubly linked list: " +
          str(find_length(head)))

````

C#
````
using System;

class Node {
    public int data;
public Node prev;
public Node next;

// Constructor
    public Node(int val) {
        data = val;
        prev = null;
next = null;
}
}

public class GfG {

    // Function to find the length of
    // a doubly linked list
    static int FindLength(Node head) {
        int count = 0;
for (Node cur = head; cur != null; cur = cur.next)
            count++;
return count;
}

    // Driver code
    public static void Main(string[] args) {

        // Create a doubly linked list
        // with 3 nodes
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        Console.WriteLine("Length of doubly linked list: "
                                 + FindLength(head));
}
}

````

JavaScript
````
class Node {
    constructor(val) {
        this.data = val;
        this.prev = null;
        this.next = null;
}
}

// Function to find the length of
// a doubly linked list
function findLength(head) {
    let count = 0;
    let cur = head;
    while (cur !== null) {
        count++;
        cur = cur.next;
}
    return count;
}

// Create a doubly linked list with 3 nodes
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);

head.next = second;
second.prev = head;
second.next = third;
third.prev = second;

console.log("Length of the doubly linked list: " +
            findLength(head));

````





**Output**
```

Length of the doubly linked list: 3

```

[Insertion at the Beginning in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-frontbeginning-of-doubly-linked-list/)
----------------------------------------------------------------------------------------------------------------------------------------

![Insertion-at-the-Beginning-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809123903/Insertion-at-the-Beginning-in-Doubly-Linked-List.webp)

Insertion at the Beginning in Doubly Linked List


To insert a new node at the beginning of the doubly list, we can use
the following steps:

* Create a new node, say ****new\\_node****with the given data and set its previous pointer to null, ****new\\_node->prev =**** ****NULL****.
* Set the next pointer of new\\_node to current head, ****new\\_node->next = head.****
* If the linked list is not empty, update the previous pointer of the
                                                                                                                                                                                                                current head to new\\_node, ****head->prev = new\\_node****.
                                                                                                                                                                                                                * Return new\\_node as the head of the updated linked list.

                                                                                                                                                                                                                Below are the implementation of the above approach:

                                                                                                                                                                                                                C++
                                                                                                                                                                                                                ````
                                                                                                                                                                                                                // C++ Program to insert a new node at the
                                   // beginning of doubly linked list

                                   #include <iostream>
                                   using namespace std;

// Node structure for the doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;

    Node(int d) {
      data = d;
      prev = next = NULL;
}
};

// Insert a node at the beginning
Node* insertBegin(Node* head, int data) {

    // Create a new node
    Node* new_node = new Node(data);

// Make next of it as head
    new_node->next = head;

// Set previous of head as new node
    if (head != NULL) {
        head->prev = new_node;
}

    // Return new node as new head
    return new_node;
}

void printList(Node* head) {
    Node* curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
  	cout << "\\n";
}

int main() {

    // Create a hardcoded linked list:
  	// 2 <-> 3 <-> 4
    Node* head = new Node(2);
    Node* temp1 = new Node(3);
    Node* temp2 = new Node(4);
    head->next = temp1;
    temp1->prev = head;
    temp1->next = temp2;
    temp2->prev = temp1;

// Print the original list
    cout << "Original Linked List: ";
    printList(head);

// Insert a new node at the front of the list
    head = insertBegin(head, 1);

// Print the updated list
  	cout << "After inserting Node 1 at the front: ";
    printList(head);

return 0;
}

````

C
````
// C Program to insert a node at the beginning
//of doubly linked list


#include <stdio.h>

// Node structure for the doubly linked list
struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

// Create a new node
struct Node* createNode(int data) {
    struct Node* new_node =
      (struct Node*)malloc(sizeof(struct Node));
    new_node->data = data;
    new_node->prev = NULL;
    new_node->next = NULL;
return new_node;
}

// Insert a node at the beginning
struct Node* insertBegin(struct Node* head, int data) {

    // Create a new node
    struct Node* new_node = createNode(data);

// Make next of it as head
    new_node->next = head;

// Set previous of head as new node
    if (head != NULL) {
        head->prev = new_node;
}

    // Return new node as new head
    return new_node;
}

// Print the doubly linked list
void printList(struct Node* head) {
    struct Node* curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
}
  	printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 2 <-> 3 <-> 4
    struct Node *head = createNode(2);
    head->next = createNode(3);
    head->next->prev = head;
    head->next->next = createNode(4);
    head->next->next->prev = head->next;

// Print the original list
    printf("Original Linked List: ");
    printList(head);

// Insert a new node at the front of the list
    head = insertBegin(head, 1);

// Print the updated list
  	printf("After inserting Node 1 at the front: ");
    printList(head);

return 0;
}

````

Java
````
// Java Program to insert a node at the beginning of a
// doubly linked list

class Node {
    int data;
    Node prev, next;

// Node structure for the doubly linked list
    Node(int d) {
        data = d;
        prev = null;
next = null;
}
}

class GfG {

    // Insert a node at the beginning
    static Node insertBegin(Node head, int data) {

        // Create a new node
        Node new_node = new Node(data);

// Make next of it as head
        new_node.next = head;

// Set previous of head as new node
        if (head != null) {
            head.prev = new_node;
}

        // Return new node as new head
        return new_node;
}

    // Print the doubly linked list
    static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
      	System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 2 <-> 3 <-> 4
        Node head = new Node(2);
        head.next = new Node(3);
        head.next.prev = head;
        head.next.next = new Node(4);
        head.next.next.prev = head.next;

// Print the original list
        System.out.print("Original Linked List: ");
        printList(head);

// Insert a new node at the front of the list
        head = insertBegin(head, 1);

// Print the updated list
      	System.out.print(
            "After inserting Node 1 at the front: ");
        printList(head);
}
}

````

Python
````
# Python Program to insert a node at the beginning
#of doubly linked list

# Node structure for the doubly linked list
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Insert a node at the beginning
def insertBegin(head, data):

    # Create a new node
    new_node = Node(data)

    # Make next of it as head
    new_node.next = head

    # Set previous of head as new node
    if head is not None:
        head.prev = new_node

    # Return new node as new head
    return new_node

# Print the doubly linked list
def printList(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 2 <-> 3 <-> 4
    head = Node(2)
    head.next = Node(3)
    head.next.prev = head
    head.next.next = Node(4)
    head.next.next.prev = head.next

    # Print the original list
    print("Original Linked List:", end=\' \')
    printList(head)

    # Insert a new node at the front of the list
    head = insertBegin(head, 1)

    # Print the updated list
    print("After inserting Node 1 at the front:", end=\' \')
    printList(head)

````

C#
````
// C# Program to insert a node at the beginning of a
// doubly linked list

using System;

// Node structure for the doubly linked list
class Node {
    public int data;
public Node prev, next;

// Constructor for creating a new node
    public Node(int d) {
        data = d;
        prev = null;
next = null;
}
}

class GfG {

    // Insert a node at the beginning
    public static
    Node insertBegin(Node head, int data) {

        // Create a new node
        Node new_node = new Node(data);

// Make next of it as head
        new_node.next = head;

// Set previous of head as new node
        if (head != null) {
            head.prev = new_node;
}

        // Return new node as new head
        return new_node;
}

    // Print the doubly linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.data + " ");
            curr = curr.next;
}
      	Console.WriteLine();
}

    public static void Main(string[] args) {

        // Create a hardcoded doubly linked list:
        // 2 <-> 3 <-> 4
        Node head = new Node(2);
        head.next = new Node(3);
        head.next.prev = head;
        head.next.next = new Node(4);
        head.next.next.prev = head.next;

// Print the original list
        Console.Write("Original Linked List: ");
        printList(head);

// Insert a new node at the front of the list
        head = insertBegin(head, 1);

// Print the updated list
      	Console.Write
        ("After inserting Node 1 at the front: ");
        printList(head);
}
}

````

JavaScript
````
// JavaScript Program to insert a node at the
//beginning of doubly linked list

// Node structure for the doubly linked list
function Node(data) {
    this.data = data;
    this.prev = null;
    this.next = null;
}

// Insert a node at the beginning
function insertBegin(head, data) {

    // Create a new node
    const new_node = new Node(data);

// Make next of it as head
    new_node.next = head;

// Set previous of head as new node
    if (head !== null) {
        head.prev = new_node;
}

    // Return new node as new head
    return new_node;
}

// Print the doubly linked list
function printList(head) {
    let curr = head;
    while (curr !== null) {
        console.log(curr.data);
        curr = curr.next;
}
}

// Create a hardcoded doubly linked list:
// 2 <-> 3 <-> 4
let head = new Node(2);
head.next = new Node(3);
head.next.prev = head;
head.next.next = new Node(4);
head.next.next.prev = head.next;

// Print the original list
console.log("Original Linked List:");
printList(head);

// Insert a new node at the front of the list
console.log
("After inserting Node 1 at the front:");
let data = 1;
head = insertBegin(head, data);

// Print the updated list
printList(head);

````








**Output**
```

Original Linked List: 2 3 4
After inserting Node 1 at the front: 1 2 3 4

```

[Insertion at the End of Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-the-end-of-doubly-linked-list/)
---------------------------------------------------------------------------------------------------------------------------

![Insertion-at-the-End-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809123955/Insertion-at-the-End-in-Doubly-Linked-List.webp)

Insertion at the End in the Doubly Linked List


To insert a new node at the end of the doubly linked list, we can use
the following steps:

* Allocate memory for a new node and assign the provided value to its
  data field.
* Initialize the next pointer of the new node to nullptr.
* If the list is empty:
  + Set the previous pointer of the new node to nullptr.
  + Update the head pointer to point to the new node.
                                                                                          * If the list is not empty:
                                                                                          + Traverse the list starting from the head to reach the last
                                                                                          node.
                                                                                          + Set the next pointer of the last node to point to the new
                                                                                          node.
                                                                                          + Set the previous pointer of the new node to point to the last
                                                                                          node.

                                                                                          Below are the implementation of the above approach:

                                                                                          C++
                                                                                          ````
                                                                                          // C++ Program to insert a node at the end of
//doubly linked list

#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node *next, *prev;

    Node(int new_data) {
        data = new_data;
next = prev = nullptr;
}
};

// Function to insert a new node at the end of
//doubly linked list
Node *insertEnd(Node *head, int new_data) {

    // Create a new node
    Node *new_node = new Node(new_data);

// If the linked list is empty, set the new
  	//node as the head of linked list
    if (head == NULL) {
        head = new_node;
}
    else {
          Node *curr = head;
        while (curr->next != NULL) {
            curr = curr->next;
}

        // Set the next of last node to new node
        curr->next = new_node;

// Set prev of new node to last node
        new_node->prev = curr;
}

    // Return the head of the doubly linked list
    return head;
}

void printList(Node *head) {
    Node *curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
    cout << endl;
}

int main() {

    // Create a harcoded doubly linked list:
    // 1 <-> 2 <-> 3
    Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;

// Print the original list
    cout << "Original Linked List: ";
    printList(head);

// Insert a new node with data 4 at the end
    cout << "Inserting Node with data 4 at the end: ";
int data = 4;
    head = insertEnd(head, data);

// Print the updated list
    printList(head);

return 0;
}

````

C
````
// C Program to insert a node at the end of
//doubly linked list

#include <stdio.h>

struct Node {
    int data;
    struct Node *next;
    struct Node *prev;
};

// Function to create a new node with the given data
struct Node *createNode(int new_data) {
    struct Node *new_node =
    (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
return new_node;
}

// Function to insert a new node at the end of the
//doubly linked list
struct Node* insertEnd(struct Node *head, int new_data) {
    struct Node *new_node = createNode(new_data);

// If the linked list is empty, set the
 	//new node as the head
    if (head == NULL) {
        head = new_node;
} else {
        struct Node *curr = head;
        while (curr->next != NULL) {
            curr = curr->next;
}

        // Set the next of last node to new node
        curr->next = new_node;
// Set prev of new node to last node
        new_node->prev = curr;
}

    return head;
}

void printList(struct Node *head) {
    struct Node *curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
}
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;

// Print the original list
    printf("Original Linked List: ");
    printList(head);

// Insert a new node with data 4 at the end
    printf("Inserting Node with data 4 at the end: ");
    head = insertEnd(head, 4);

// Print the updated list
    printList(head);

return 0;
}

````

Java
````
// Java Program to insert a node at the end of
// doubly linked list

class Node {
    int data;
    Node next, prev;

    Node(int newData) {
        data = newData;
next = prev = null;
}
}

class GFG {

    // Function to insert a new node at the end of the
    // doubly linked list
    public static Node insertEnd(Node head, int newData) {

        // Create a new node
        Node newNode = new Node(newData);

// If the linked list is empty, set the new node as
        // the head
        if (head == null) {
            head = newNode;
}
        else {
            Node curr = head;
            while (curr.next != null) {
                curr = curr.next;
}

            // Set the next of last node to the new node
            curr.next = newNode;

// Set the prev of new node to the last node
            newNode.prev = curr;
}

        return head;
}

    // Function to print the doubly linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

// Print the original list
        System.out.println("Original Linked List: ");
        printList(head);

// Insert a new node with data 4 at the end
        System.out.println(
            "Inserting Node with data 4 at the end: ");
int data = 4;
        head = insertEnd(head, data);

// Print the updated list
        printList(head);
}
}

````

Python
````
# Python Program to insert a node at the end of
#doubly linked list

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

# Function to insert a new node at the end of the
#doubly linked list
def insert_end(head, new_data):

    # Create a new node
    new_node = Node(new_data)

    # If the linked list is empty, set the new node
    #as the head
    if head is None:
        head = new_node
    else:
        curr = head
        while curr.next is not None:
            curr = curr.next

        # Set the next of the last node to the new node
        curr.next = new_node

        # Set the prev of the new node to the last node
        new_node.prev = curr

    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    # Print the original list
    print("Original Linked List: ", end="")
    print_list(head)

    # Insert a new node with data 4 at the end
    print("Inserting Node with data 4 at the end: ", end="")
    data = 4
    head = insert_end(head, data)

    # Print the updated list
    print_list(head)

````

C#
````
// C# Program to insert a node at the end of
//doubly linked list

using System;

class Node {
    public int Data;
public Node Next;
public Node Prev;

public Node(int data) {
        Data = data;
Next = null;
        Prev = null;
}
}

class GFG {

    // Function to insert a new node at the end
  	//of the doubly linked list
    public static Node InsertEnd(Node head, int newData) {

          // Create a new node
        Node newNode = new Node(newData);

// If the linked list is empty, set the
      	//new node as the head
        if (head == null) {
            head = newNode;
}
        else {
            Node curr = head;
            while (curr.Next != null) {
                curr = curr.Next;
}

            // Set the next of the last node to
          	//the new node
            curr.Next = newNode;

// Set the prev of the new node to
          	//the last node
            newNode.Prev = curr;
}

        return head;
}

    // Function to print the doubly linked list
    public static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

// Print the original list
        Console.Write("Original Linked List: ");
        PrintList(head);

// Insert a new node with data 4 at the end
        Console.Write("Inserting Node with data 4 at the end: ");
int data = 4;
        head = InsertEnd(head, data);

// Print the updated list
        PrintList(head);
}
}

````

JavaScript
````
// Javascript Program to insert a node at the end of
//doublylinked list

class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

function insertEnd(head, newData) {

    // Create a new node
    const newNode = new Node(newData);

// If the linked list is empty, set the
    //new node as the head
    if (head === null) {
        head = newNode;
}
    else {
        let curr = head;
        while (curr.next !== null) {
            curr = curr.next;
}

        // Set the next of the last node to the
        //new node
        curr.next = newNode;

// Set the prev of the new node to the
        //last node
        newNode.prev = curr;
}

    return head;
}

function printList(head)
{
    let curr = head;
    let result = "";
    while (curr !== null) {
        result += curr.data + " ";
        curr = curr.next;
}
    console.log(result.trim());
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

// Print the original list
console.log("Original Linked List: ");
printList(head);

// Insert a new node with data 4 at the end
console.log("Inserting Node with data 4 at the end: ");
const data = 4;
head = insertEnd(head, data);

// Print the updated list
printList(head);

````




**Output**
```

Original Linked List: 1 2 3
Inserting Node with data 4 at the end: 1 2 3 4

```

[Insertion at a Specific Position in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-doubly-linked-list/)
---------------------------------------------------------------------------------------------------------------------------------------------------

To insert a node at a specific Position in doubly linked list, we can
use the following steps:

![Insertion-at-a-Specific-Position-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124039/Insertion-at-a-Specific-Position-in-Doubly-Linked-List.webp)


Insertion at a Specific Position in Doubly Linked List



To insert a new node at a specific position,

* If position = 1, create a new node and make it the head of the linked
  list and return it.
* Otherwise, traverse the list to reach the node at position – 1,
  say ****curr****.
* If the position is valid, create a new node with given data,
  say ****new\\_node****.
* Update the next pointer of new node to the next
                                                                                                                                             of current node and prev pointer of new node to current
                                                                                                                                             node, ****new\\_node->next = curr->next****and ****new\\_node->prev = curr.****
                                                                                                                                             * Similarly, update next pointer of current node to
                                                                                                                                                              thenew node, ****curr->next = new\\_node****.
                                                                                                                                                              * If the new node is not the last node, update prev pointer of new
                                                                                                                                                                                                          node’s next to the new node, ****new\\_node->next->prev = new\\_node.****

                                                                                                                                                                                                          Below is the implementation of the above approach:

                                                                                                                                                                                                          C++
                                                                                                                                                                                                          ````
                                                                                                                                                                                                          // C++ Program to insert a node at a given position

                                                                                                                                                                                                      #include <bits/stdc++.h>
                                                                                                                                                                                                      using namespace std;

struct Node {
    int data;
    Node *next, *prev;

    Node(int new_data) {
        data = new_data;
next = prev = nullptr;
}
};

// Function to insert a new node at a given position
Node *insertAtPosition(Node *head, int pos, int new_data) {

    // Create a new node
    Node *new_node = new Node(new_data);

// Insertion at the beginning
    if (pos == 1) {
        new_node->next = head;

// If the linked list is not empty, set the prev
      	//of head to new node
        if (head != NULL)
            head->prev = new_node;

// Set the new node as the head of linked list
        head = new_node;
return head;
}

    Node *curr = head;
// Traverse the list to find the node before the
    // insertion point
    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {
        curr = curr->next;
}

    // If the position is out of bounds
    if (curr == NULL) {
        cout << "Position is out of bounds." << endl;
        delete new_node;
return head;
}

    // Set the prev of new node to curr
    new_node->prev = curr;

// Set the new of new node to next of curr
    new_node->next = curr->next;

// Update the next of current node to new node
       curr->next = new_node;

// If the new node is not the last node, update prev
                                             //of next node to new node
                                             if (new_node->next != NULL)
                                             new_node->next->prev = new_node;

// Return the head of the doubly linked list
    return head;
}

void printList(Node *head) {
    Node *curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
    cout << endl;
}

int main() {

    // Create a harcoded doubly linked list:
    // 1 <-> 2 <-> 4
    Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(4);
    head->next->next->prev = head->next;

// Print the original list
    cout << "Original Linked List: ";
    printList(head);

// Insert new node with data 3 at position 3
    cout << "Inserting Node with data 3 at position 3: ";
int data = 3;
int pos = 3;
    head = insertAtPosition(head, pos, data);

// Print the updated list
    printList(head);

return 0;
}

````

C
````
// C Program to insert a node at a given position

#include <stdio.h>

struct Node {
    int data;
    struct Node * next;
    struct Node * prev;
};

// Function to create a new node with the given data
struct Node * createNode(int new_data) {
    struct Node * new_node =
        (struct Node * ) malloc(sizeof(struct Node));
    new_node -> data = new_data;
    new_node -> next = NULL;
return new_node;
}

// Function to insert a new node at a given position
struct Node * insertAtPosition(struct Node * head, int pos, int new_data) {
    // Create a new node
    struct Node * new_node = createNode(new_data);

// Insertion at the beginning
    if (pos == 1) {
        new_node -> next = head;

// If the linked list is not empty, set the
      //prev of head to new node
        if (head != NULL) {
            head -> prev = new_node;
}

        // Set the new node as the head of linked list
        head = new_node;
return head;
}

    struct Node * curr = head;

// Traverse the list to find the node before the insertion point
    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {
        curr = curr -> next;
}

    // If the position is out of bounds
    if (curr == NULL) {
        printf("Position is out of bounds.\\n");
        free(new_node);
return head;
}

    // Set the prev of new node to curr
    new_node -> prev = curr;

// Set the next of new node to next of curr
    new_node -> next = curr -> next;

// Update the next of current node to new node
       curr -> next = new_node;

// If the new node is not the last node, update
                                             //the prev of next node to new node
                                             if (new_node -> next != NULL) {
                                             new_node -> next -> prev = new_node;
}

    // Return the head of the doubly linked list
    return head;
}

// Function to print the linked list
void printList(struct Node * head) {
    struct Node * curr = head;
    while (curr != NULL) {
        printf("%d ", curr -> data);
        curr = curr -> next;
}
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 4
    struct Node * head = createNode(1);
    head -> next = createNode(2);
    head -> next -> prev = head;
    head -> next -> next = createNode(4);
    head -> next -> next -> prev = head -> next;

// Print the original list
    printf("Original Linked List: ");
    printList(head);

// Insert new node with data 3 at position 3
    printf("Inserting Node with data 3 at position 3: ");
int data = 3;
int pos = 3;
    head = insertAtPosition(head, pos, data);

// Print the updated list
    printList(head);

return 0;
}

````

Java
````
// Java Program to insert a node at a given position

class Node {
    int data;
    Node next;
    Node prev;

    Node(int new_data) {
        data = new_data;
next = prev = null;
}
}

class GFG {

    // Function to insert a new node at a given position
    public static Node insertAtPosition(Node head, int pos, int new_data) {
        // Create a new node
        Node new_node = new Node(new_data);

// Insertion at the beginning
        if (pos == 1) {
            new_node.next = head;

// If the linked list is not empty, set
          	//the prev of head to new node
            if (head != null) {
                head.prev = new_node;
}

            // Set the new node as the head of linked list
            head = new_node;
return head;
}

        Node curr = head;

// Traverse the list to find the node before
      	//the insertion point
        for (int i = 1; i < pos - 1 && curr != null; ++i) {
            curr = curr.next;
}

        // If the position is out of bounds
        if (curr == null) {
            System.out.println("Position is out of bounds.");
return head;
}

        // Set the prev of new node to curr
        new_node.prev = curr;

// Set the next of new node to next of curr
        new_node.next = curr.next;

// Update the next of current node to new node
       curr.next = new_node;

// If the new node is not the last node, update
                                             //prev of next node to new node
                                             if (new_node.next != null) {
                                             new_node.next.prev = new_node;
}

        // Return the head of the doubly linked list
        return head;
}

    // Function to print the linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 4
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(4);
        head.next.next.prev = head.next;

// Print the original list
        System.out.print("Original Linked List: ");
        printList(head);

// Insert new node with data 3 at position 3
        System.out.print("Inserting Node with data 3 at position 3: ");
int data = 3;
int pos = 3;
        head = insertAtPosition(head, pos, data);

// Print the updated list
        printList(head);
}
}

````

Python
````
# Python Program to insert a node at a given position

class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None
        self.prev = None

def insert_at_position(head, pos, new_data):

    # Create a new node
    new_node = Node(new_data)

    # Insertion at the beginning
    if pos == 1:
        new_node.next = head

        # If the linked list is not empty, set the
        #prev of head to new node
        if head is not None:
            head.prev = new_node

        # Set the new node as the head of the linked list
        head = new_node
        return head

    curr = head

    # Traverse the list to find the node before the
    #insertion point
    for _ in range(1, pos - 1):
        if curr is None:
            print("Position is out of bounds.")
            return head
        curr = curr.next

    # If the position is out of bounds
    if curr is None:
        print("Position is out of bounds.")
        return head

    # Set the prev of new node to curr
    new_node.prev = curr

    # Set the next of new node to next of curr
    new_node.next = curr.next

    # Update the next of current node to new node
                       curr.next = new_node

                       # If the new node is not the last node, update
                                                                   #prev of next node to new node
                                                                   if new_node.next is not None:
                                                                   new_node.next.prev = new_node

                                                                   return head

                                                                   def print_list(head):
                                                                   curr = head
                                                                   while curr is not None:
                                                                   print(curr.data, end=" ")
                                                                   curr = curr.next
                                                                   print()

                                                                   if __name__ == "__main__":

                                                                   # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 4
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(4)
    head.next.next.prev = head.next

    # Print the original list
    print("Original Linked List: ", end="")
    print_list(head)

    # Insert new node with data 3 at position 3
    print("Inserting Node with data 3 at position 3: ", end="")
    data = 3
    pos = 3
    head = insert_at_position(head, pos, data)

    # Print the updated list
    print_list(head)

````

C#
````
// C# Program to insert a node at a given position

using System;

class Node {
    public int Data;
public Node Next;
public Node Prev;

public Node(int data) {
        Data = data;
Next = null;
        Prev = null;
}
}

class GFG {

    // Function to insert a new node at a given position
    static Node InsertAtPosition(Node head, int pos, int newData) {

        // Create a new node
        Node newNode = new Node(newData);

// Insertion at the beginning
        if (pos == 1) {
            newNode.Next = head;
            if (head != null)
                head.Prev = newNode;
            head = newNode;
return head;
}

        Node curr = head;

// Traverse the list to find the node
      	 //before the insertion point
        for (int i = 1; i < pos - 1 && curr != null; ++i) {
            curr = curr.Next;
}

        // If the position is out of bounds
        if (curr == null) {
            Console.WriteLine("Position is out of bounds.");
return head;
}

        // Set the prev of new node to curr
        newNode.Prev = curr;

// Set the next of new node to the next of curr
        newNode.Next = curr.Next;

// Update the next of current node to new node
       curr.Next = newNode;

// If the new node is not the last node, update
                                             //prev of next node to new node
                                             if (newNode.Next != null)
                                             newNode.Next.Prev = newNode;

return head;
}

    // Function to print the list
    static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 4
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(4);
        head.Next.Next.Prev = head.Next;

// Print the original list
        Console.WriteLine("Original Linked List: ");
        PrintList(head);

// Insert new node with data 3 at position 3
        Console.WriteLine("Inserting Node with data 3 at position 3: ");
        head = InsertAtPosition(head, 3, 3);

// Print the updated list
        PrintList(head);
}
}

````

JavaScript
````
// Javascript Program to insert a node at a given position

class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

// Function to insert a new node at a given position
function insertAtPosition(head, pos, newData) {

    // Create a new node
    let newNode = new Node(newData);

// Insertion at the beginning
    if (pos === 1) {
        newNode.next = head;
        if (head !== null) {
            head.prev = newNode;
}
        head = newNode;
return head;
}

    let curr = head;

// Traverse the list to find the node
    //before the insertion point
    for (let i = 1; i < pos - 1 && curr !== null; ++i) {
        curr = curr.next;
}

    // If the position is out of bounds
    if (curr === null) {
        console.log("Position is out of bounds.");
return head;
}

    // Set the prev of new node to curr
    newNode.prev = curr;

// Set the next of new node to the next of curr
    newNode.next = curr.next;

// Update the next of current node to new node
       curr.next = newNode;

// If the new node is not the last node,
    // update prev of next node to new node
           if (newNode.next !== null) {
           newNode.next.prev = newNode;
}

    return head;
}

// Function to print the list
function printList(head) {
    let curr = head;
    while (curr !== null) {
        console.log(curr.data + " ");
        curr = curr.next;
}
    console.log();
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 4
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(4);
head.next.next.prev = head.next;

// Print the original list
console.log("Original Linked List:");
printList(head);

// Insert new node with data 3 at position 3
console.log("Inserting Node with data 3 at position 3:");
head = insertAtPosition(head, 3, 3);

// Print the updated list
printList(head);

````





**Output**
```

Original Linked List: 1 2 4
Inserting Node with data 3 at position 3: 1 2 3 4

```

[Deletion at the Beginning of Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-beginning-removal-of-first-node-in-a-doubly-linked-list/)
-----------------------------------------------------------------------------------------------------------------------------------------------------

![Deletion-at-the-Beginning-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124112/Deletion-at-the-Beginning-of-Doubly-Linked-List.webp)

Deletion at the Beginning of Doubly Linked List


To delete a node at the beginning in doubly linked list, we can use the
following steps:

* Check if the list is empty, there is nothing to delete. Return.
* Store the head pointer in a variable, say ****temp****.
* Update the head of linked list to the node next to the current head, ****head = head->next****.
                                                                        * If the new head is not NULL, update the previous pointer of new head
                                                                                                           to NULL, ****head->prev = NULL****.

                                                                                                           Below is the implementation of the above approach:

                                                                                                           C++
                                                                                                           ````
                                                                                                           // C++ Program to delete a node from the
// beginning of Doubly Linked List

#include <bits/stdc++.h>
using namespace std;

struct Node{
    int data;
    Node *prev;
    Node *next;
    Node(int d) {
      	data = d;
      	prev = next = nullptr;
}
};

// Deletes the first node (head) of the list
// and returns the second node as new head
Node *delHead(Node *head) {

    // If empty, return
    if (head == nullptr)
        return nullptr;

// Store in temp for deletion later
    Node *temp = head;

// Move head to the next node
    head = head->next;

// Set prev of the new head
    if (head != nullptr)
        head->prev = nullptr;

// Free memory and return new head
    delete temp;
return head;
}

void printList(Node *head) {
    for (Node *curr = head; curr != nullptr; curr = curr->next)
        cout << curr->data << " ";
    cout << endl;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the beginning: ");
    head = delHead(head);

    printList(head);

return 0;
}

````

C
````
// C Program to delete a node from the
// beginning of Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node *prev;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int data) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
return newNode;
}

// Function to delete the first node (head) of the list
// and return the second node as the new head
struct Node *delHead(struct Node *head) {
    // If empty, return NULL
    if (head == NULL)
        return NULL;

// Store in temp for deletion later
    struct Node *temp = head;

// Move head to the next node
    head = head->next;

// Set prev of the new head
    if (head != NULL)
        head->prev = NULL;

// Free memory and return new head
    free(temp);
return head;
}

void printList(struct Node *head) {
    struct Node *curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
}
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the beginning: ");
    head = delHead(head);

    printList(head);

return 0;
}

````

Java
````
// Java Program to delete a node from the
// beginning of Doubly Linked List

class Node {
    int data;
    Node prev;
    Node next;

    Node(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

class GFG {

    // Function to delete the first node (head) of the list
    // and return the second node as the new head
    public static Node delHead(Node head) {
        // If empty, return null
        if (head == null) {
            return null;
}

        // Store in temp for deletion later
        Node temp = head;

// Move head to the next node
        head = head.next;

// Set prev of the new head
        if (head != null) {
            head.prev = null;
}

        // Return new head
        return head;
}

    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

        System.out.print("Original Linked List: ");
        printList(head);

        System.out.print("After Deletion at the beginning: ");
        head = delHead(head);

        printList(head);
}
}

````

Python
````
# Python Program to delete a node from the
# beginning of Doubly Linked List

class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Function to delete the first node (head) of the list
# and return the second node as the new head
def del_head(head):

    # If empty, return None
    if head is None:
        return None

    # Store in temp for deletion later
    temp = head

    # Move head to the next node
    head = head.next

    # Set prev of the new head
    if head is not None:
        head.prev = None

    # Return new head
    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()


if __name__ == "__main__":

	# Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    print("Original Linked List: ", end="")
    print_list(head)

    print("After Deletion at the beginning: ", end="")
    head = del_head(head)

    print_list(head)

````

C#
````
// C# Program to delete a node from the
// beginning of Doubly Linked List

using System;

class Node {
    public int Data;
public Node Prev;
public Node Next;

public Node(int data) {
        Data = data;
        Prev = null;
Next = null;
}
}

class GFG {

    // Deletes the first node (head) of the list
    // and returns the second node as the new head
    public static Node DelHead(Node head) {

        // If empty, return null
        if (head == null)
            return null;

// Move head to the next node
        head = head.Next;

// Set prev of the new head
        if (head != null)
            head.Prev = null;

// Return new head
        return head;
}

    public static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

        Console.Write("Original Linked List: ");
        PrintList(head);

        Console.Write("After Deletion at the beginning: ");
        head = DelHead(head);

        PrintList(head);
}
}

````

JavaScript
````
// JavaScript Program to delete a node from the
// beginning of Doubly Linked List
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Deletes the first node (head) of the list and returns the second node as the new head
function delHead(head) {
    // If empty, return null
    if (head === null) {
        return null;
}

    // Store in temp for deletion later
    let temp = head;

// Move head to the next node
    head = head.next;

// Set prev of the new head
    if (head !== null) {
        head.prev = null;
}

    // Return new head
    return head;
}

// Function to print the list
function printList(head) {
    let curr = head;
    let output = \'\';
    while (curr !== null) {
        output += curr.data + \' \';
        curr = curr.next;
}
    console.log(output.trim());
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

console.log("Original Linked List: ");
printList(head);

console.log("After Deletion at the beginning: ");
head = delHead(head);

printList(head);

````



**Output**
```

Original Linked List: 1 2 3
After Deletion at the beginning: 2 3

```

[Deletion at the End of Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-end-removal-of-last-node-in-a-doubly-linked-list/)
----------------------------------------------------------------------------------------------------------------------------------------

![Deletion-at-the-End-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124140/Deletion-at-the-End-in-Doubly-Linked-List.webp)

Deletion at the End in Doubly Linked List


To delete a node at the end in doubly linked list, we can use the
following steps:

* Check if the doubly linked list is empty. If it is empty, then there
  is nothing to delete.
* If the list is not empty, then move to the last node of the doubly
  linked list, say ****curr****.
* Update the second-to-last node\'s next pointer to NULL, ****curr->prev->next = NULL****.
* Free the memory allocated for the node that was deleted.

Below is the implementation of the above approach:

C++
````
// C++ Program to delete a node from the end of
//Doubly Linked List

#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node *prev;
    Node *next;
    Node(int d) {
        data = d;
        prev = NULL;
        next = NULL;
    }
};

// Function to delete the last node of the doubly
// linked list
Node *delLast(Node *head) {

    // Corner cases
    if (head == NULL)
        return NULL;
    if (head->next == NULL) {
        delete head;
        return NULL;
    }

    // Traverse to the last node
    Node *curr = head;
    while (curr->next != NULL)
        curr = curr->next;

    // Update the previous node\'s next pointer
                                                                                         curr->prev->next = NULL;

// Delete the last node
    delete curr;

// Return the updated head
    return head;
}

void printList(Node *head) {
    Node *curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
    cout << endl;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the end: ");
    head = delLast(head);

    printList(head);

return 0;
}

````

C
````
// C Program to delete a node from the end of
//Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

// Function to delete the last node of the
//doubly linked list
struct Node* delLast(struct Node *head) {

    // Corner cases
    if (head == NULL)
        return NULL;
    if (head->next == NULL) {
        free(head);
return NULL;
}

    // Traverse to the last node
    struct Node *curr = head;
    while (curr->next != NULL)
        curr = curr->next;

// Update the previous node\'s next pointer
    curr->prev->next = NULL;

    // Delete the last node
    free(curr);

    // Return the updated head
    return head;
}

// Function to print the list
void printList(struct Node *head) {
    struct Node *curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }
    printf("\\n");
}

// Function to create a new node
struct Node* createNode(int data) {
    struct Node *newNode =
      (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the end: ");
    head = delLast(head);

    printList(head);

    return 0;
}

````

Java
````
// Java Program to delete a node from the end of
//Doubly Linked List

class Node {
    int data;
    Node prev;
    Node next;

    Node(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}

class GFG {

    // Function to delete the last node of the
  	//doubly linked list
    public static Node delLast(Node head) {

        // Corner cases
        if (head == null) {
            return null;
        }
        if (head.next == null) {
            return null;
        }

        // Traverse to the last node
        Node curr = head;
        while (curr.next != null) {
            curr = curr.next;
        }

        // Update the previous node\'s next pointer
       if (curr.prev != null) {
       curr.prev.next = null;
}

        // Return the updated head
        return head;
}

    // Function to print the list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

        System.out.print("Original Linked List: ");
        printList(head);

        System.out.print("After Deletion at the end: ");
        head = delLast(head);

        printList(head);
}
}

````

Python
````
# Python Program to delete a node from the end of
#Doubly Linked List

class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

def del_last(head):

    # Corner cases
    if head is None:
        return None
    if head.next is None:
        return None

    # Traverse to the last node
    curr = head
    while curr.next is not None:
        curr = curr.next

    # Update the previous node\'s next pointer
    if curr.prev is not None:
        curr.prev.next = None

    # Return the updated head
    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    print("Original Linked List: ", end="")
    print_list(head)

    print("After Deletion at the end: ", end="")
    head = del_last(head)

    print_list(head)

````

C#
````
// C# Program to delete a node from the end of
//Doubly Linked List

using System;

class Node {
    public int Data;
    public Node Prev;
    public Node Next;

    public Node(int data) {
        Data = data;
        Prev = null;
        Next = null;
    }
}

class GFG {

    // Function to delete the last node of the
  	//doubly linked list
    static Node DelLast(Node head) {

      	// Corner cases
        if (head == null)
            return null;
        if (head.Next == null) {
            return null;
        }

        // Traverse to the last node
        Node curr = head;
        while (curr.Next != null)
            curr = curr.Next;

        // Update the previous node\'s next pointer
                                     if (curr.Prev != null)
                                     curr.Prev.Next = null;

// Delete the last node
        curr = null;

// Return the updated head
        return head;
}

    // Function to print the list
    static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

        Console.Write("Original Linked List: ");
        PrintList(head);

        Console.Write("After Deletion at the end: ");
        head = DelLast(head);

        PrintList(head);
}
}

````

JavaScript
````
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Function to delete the last node of the
//doubly linked list
function delLast(head) {
    // Corner cases
    if (head === null) return null;
    if (head.next === null) {
        // Only one node in the list
        return null;
}

    // Traverse to the last node
    let curr = head;
    while (curr.next !== null) {
        curr = curr.next;
}

    // Update the previous node\'s next pointer
    if (curr.prev !== null) {
        curr.prev.next = null;
    }

    // Node curr is now deleted (garbage collected in JS)
    return head;
}

// Function to print the list
function printList(head) {
    let curr = head;
    while (curr !== null) {
        console.log(curr.data + " ");
        curr = curr.next;
    }
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

console.log("Original Linked List:");
printList(head);

console.log("After Deletion at the end:");
head = delLast(head);

printList(head);

````




**Output**
```

Original Linked List: 1 2 3
After Deletion at the end: 1 2

```

[Deletion at a Specific Position in Doubly Linked List](https://www.geeksforgeeks.org/delete-doubly-linked-list-node-given-position)
------------------------------------------------------------------------------------------------------------------------------------

![Deletion-at-a-Specific-Position-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124205/Deletion-at-a-Specific-Position-in-Doubly-Linked-List.webp)


Deletion at a Specific Position in Doubly Linked List



To delete a node at a specific position in doubly linked list, we can
use the following steps:

* Traverse to the node at the specified position, say ****curr****.
* If the position is valid, adjust the pointers to skip the node to be
  deleted.
  + If curr is not the head of the linked list, update the next
    pointer of the node before curr to point to the node after curr, ****curr->prev->next = curr-next****.
  + If curr is not the last node of the linked list, update the
    previous pointer of the node after curr to the node before curr, ****curr->next->prev = curr->prev****.
* Free the memory allocated for the deleted node.

Below is the implementation of the above approach:

C++
````
// C++ Program to delete node at a specific position
// in Doubly Linked List

#include <iostream>

using namespace std;

struct Node {
    int data;
    Node * prev;
    Node * next;
    Node(int d) {
        data = d;
        prev = next = NULL;
    }
};

// Function to delete a node at a specific position
// in the doubly linked list
Node * delPos(Node * head, int pos) {

    // If the list is empty
    if (!head)
        return head;

    Node * curr = head;

    // Traverse to the node at the given position
    for (int i = 1; curr && i < pos; ++i) {
        curr = curr -> next;
    }

    // If the position is out of range
    if (!curr)
        return head;

    // Update the previous node\'s next pointer
           if (curr -> prev)
           curr -> prev -> next = curr -> next;

// Update the next node\'s prev pointer
    if (curr -> next)
        curr -> next -> prev = curr -> prev;

    // If the node to be deleted is the head node
    if (head == curr)
        head = curr -> next;

    // Deallocate memory for the deleted node
    delete curr;
    return head;
}

// Function to print the doubly linked list
void printList(Node * head) {
    Node * curr = head;
    while (curr != nullptr) {
        cout << curr -> data << " ";
        curr = curr -> next;
    }
    cout << endl;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node * head = new Node(1);
    head -> next = new Node(2);
    head -> next -> prev = head;
    head -> next -> next = new Node(3);
    head -> next -> next -> prev = head -> next;

    cout << "Original Linked List: ";
    printList(head);

    cout << "After Deletion at the position 2: ";
    head = delPos(head, 2);

    printList(head);

    return 0;
}

````

C
````
// C Program to delete node at a specific position
//in Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node * prev;
    struct Node * next;
};

struct Node * createNode(int data) {
    struct Node * newNode = (struct Node * )
    malloc(sizeof(struct Node));
    newNode -> data = data;
    newNode -> prev = NULL;
    newNode -> next = NULL;
    return newNode;
}

// Function to delete a node at a specific
//position in the doubly linked list
struct Node * delPos(struct Node * head, int pos) {

    // If the list is empty
    if (head == NULL)
        return head;

    struct Node * curr = head;

    // Traverse to the node at the given position
    for (int i = 1; curr && i < pos; ++i) {
        curr = curr -> next;
    }

    // If the position is out of range
    if (curr == NULL)
        return head;

    // Update the previous node\'s next pointer
       if (curr -> prev)
       curr -> prev -> next = curr -> next;

// Update the next node\'s prev pointer
    if (curr -> next)
        curr -> next -> prev = curr -> prev;

    // If the node to be deleted is the head node
    if (head == curr)
        head = curr -> next;

    // Deallocate memory for the deleted node
    free(curr);
    return head;
}

// Function to print the doubly linked list
void printList(struct Node * head) {
    struct Node * curr = head;
    while (curr != NULL) {
        printf("%d ", curr -> data);
        curr = curr -> next;
    }
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node * head = createNode(1);
    struct Node * temp1 = createNode(2);
    struct Node * temp2 = createNode(3);

    // Link the nodes together
    head -> next = temp1;
    temp1 -> prev = head;
    temp1 -> next = temp2;
    temp2 -> prev = temp1;

    printf("Original Linked List: ");
    printList(head);

    // Delete node at position 2
    head = delPos(head, 2);

    printf("After Deletion at position 2: ");
    printList(head);

    return 0;
}

````

Java
````
// Java Program to delete node at a specific position in Doubly Linked List

class Node {
    int data;
    Node prev;
    Node next;

    Node(int d) {
        data = d;
        prev = null;
        next = null;
    }
}

class GFG {

    // Function to delete a node at a
  	//specific position in the doubly linked list
    public static Node delPos(Node head, int pos) {

        // If the list is empty
        if (head == null) {
            return head;
        }

        Node curr = head;

        // Traverse to the node at the given position
        for (int i = 1; curr != null && i < pos; ++i) {
            curr = curr.next;
        }

        // If the position is out of range
        if (curr == null) {
            return head;
        }

        // Update the previous node\'s next pointer
       if (curr.prev != null) {
       curr.prev.next = curr.next;
}

        // Update the next node\'s prev pointer
        if (curr.next != null) {
            curr.next.prev = curr.prev;
        }

        // If the node to be deleted is the head node
        if (head == curr) {
            head = curr.next;
        }

        // Return the updated head
        return head;
    }

    // Function to print the doubly linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

        System.out.print("Original Linked List: ");
        printList(head);

        System.out.print("After Deletion at position 2: ");
        head = delPos(head, 2);

        printList(head);
    }
}

````

Python
````
# Python Program to delete node at a specific position
#in Doubly Linked List


class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None


# Function to delete a node at a specific position
#in the doubly linked list
def del_pos(head, pos):
    # If the list is empty
    if head is None:
        return head

    curr = head

    # Traverse to the node at the given position
    for i in range(1, pos):
        if curr is None:
            return head
        curr = curr.next

    # If the position is out of range
    if curr is None:
        return head

    # Update the previous node\'s next pointer
               if curr.prev is not None:
               curr.prev.next = curr.next

               # Update the next node\'s prev pointer
    if curr.next is not None:
        curr.next.prev = curr.prev

    # If the node to be deleted is the head node
    if head == curr:
        head = curr.next

    # Return the updated head
    return head


def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()


if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    print("Original Linked List: ", end="")
    print_list(head)

    print("After Deletion at the position 2: ", end="")
    head = del_pos(head, 2)

    print_list(head)

````

C#
````
// C# Program to delete node at a specific position
//in Doubly Linked List

using System;

class Node {
    public int Data;
    public Node Prev;
    public Node Next;

    public Node(int data) {
        Data = data;
        Prev = null;
        Next = null;
    }
}

class Program {
    // Function to delete a node at a specific position
    // in the doubly linked list
    static Node DelPos(Node head, int pos) {
        // If the list is empty
        if (head == null)
            return head;

        Node curr = head;

        // Traverse to the node at the given position
        for (int i = 1; curr != null && i < pos; ++i) {
            curr = curr.Next;
        }

        // If the position is out of range
        if (curr == null)
            return head;

        // Update the previous node\'s next pointer
                     if (curr.Prev != null)
                     curr.Prev.Next = curr.Next;

// Update the next node\'s prev pointer
        if (curr.Next != null)
            curr.Next.Prev = curr.Prev;

        // If the node to be deleted is the head node
        if (head == curr)
            head = curr.Next;

        // Deallocate memory for the deleted node
        // In C#, garbage collection will handle this
      	//automatically

        return head;
    }

    // Function to print the doubly linked list
    static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
        }
        Console.WriteLine();
    }

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

        Console.Write("Original Linked List: ");
        PrintList(head);

        Console.Write("After Deletion at position 2: ");
        head = DelPos(head, 2);

        PrintList(head);
    }
}

````

JavaScript
````
class Node {
	constructor(data) {
		this.data = data;
		this.prev = null;
		this.next = null;
	}
}

// Function to delete a node at a specific position
// in the doubly linked list
function delPos(head, pos) {
	// If the list is empty
	if (head === null) return head;

	let curr = head;

	// Traverse to the node at the given position
	for (let i = 1; curr && i < pos; ++i) {
		curr = curr.next;
	}

	// If the position is out of range
	if (curr === null) return head;

	// Update the previous node\'s next pointer
       if (curr.prev) {
       curr.prev.next = curr.next;
}

	// Update the next node\'s prev pointer
	if (curr.next) {
		curr.next.prev = curr.prev;
	}

	// If the node to be deleted is the head node
	if (head === curr) {
		head = curr.next;
	}

	// Deallocate memory for the deleted node
	// In JavaScript, garbage collection handles
    //this automatically

	return head;
}

// Function to print the doubly linked list
function printList(head) {
	let curr = head;
	let result = [];
	while (curr !== null) {
		result.push(curr.data);
		curr = curr.next;
	}
	console.log(result.join(\' \'));
}


// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

console.log("Original Linked List:");
printList(head);

console.log("After Deletion at the position 2:");
head = delPos(head, 2);

printList(head);

````


**Output**
```

Original Linked List: 1 2 3
After Deletion at the position 2: 1 3

```

Advantages of Doubly Linked List
--------------------------------

* ****Efficient traversal in both directions:**** Doubly linked lists allow for efficient traversal of the list in both
  directions, making it suitable for applications where frequent
  insertions and deletions are required.
* ****Easy insertion and deletion of nodes:**** The presence of pointers to both the previous and next nodes makes it
  easy to insert or delete nodes from the list, without having to
  traverse the entire list.
* ****Can be used to implement a stack or queue:**** Doubly linked lists can be used to implement both stacks and queues,
  which are common data structures used in programming.

Disadvantages of Doubly Linked List
-----------------------------------

* ****More complex than singly linked lists:****
  Doubly linked lists are more complex than singly linked lists, as they
  require additional pointers for each node.
* ****More memory overhead:**** Doubly linked lists require more memory overhead than singly linked
  lists, as each node stores two pointers instead of one.', e'A doubly linked list
is a more complex data structure than a singly linked list, but it
offers several advantages. The main advantage of a doubly linked list is
that it allows for efficient traversal of the list in both directions.
This is because each node in the list contains a pointer to the previous
node and a pointer to the next node. This allows for quick and easy
insertion and deletion of nodes from the list, as well as efficient
traversal of the list in both directions.', 'Doubly Linked List Tutorial', 13, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('5579b7b8-f82f-4a7d-9fe5-7ec75bf66434', e'Basic Terminologies of Queue
----------------------------

* ****Front:**** Position of the entry in a queue ready to be served, that is, the
  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.
* ****Rear:****
  Position of the last entry in the queue, that is, the one most
  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.
* ****Size:**** Size refers to the ****current**** number of elements in the queue.
* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.

****Representation of Queue****
-------------------------------

![Representation-of-Queue-Data-Structure](https://media.geeksforgeeks.org/wp-content/uploads/20241212130245410876/Representation-of-Queue-Data-Structure-768.webp)

Operations on Queue
-------------------

### ****1. Enqueue:****

Enqueue operation ****adds (or stores) an element to the end of the queue****. 

****Steps:****

1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.
2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.
3. Insert the element at the rear.


![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)


![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)


![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)


![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)


![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)


![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)



Previous





Pause

Next





3 / 6



### ****2. Dequeue:****

Dequeue operation removes the element at the front of the queue. The
following steps are taken to perform the dequeue operation:


1. Check if the ****queue is empty****. If so, return an ****underflow**** error.
2. Remove the element at the ****front****.
3. ****Increment**** the ****front**** pointer to the next element.


![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)



Previous





Play

Next





1 / 6



### ****3. Peek or Front Operation:****

This operation returns the element at the front end without removing
it.

### 4. Size Operation:

This operation returns the numbers of elements present in the
queue.

### ****5. isEmpty Operation:****

This operation returns a boolean value that indicates whether the queue
is empty or not.

### ****6. isFull Operation:****

This operation returns a boolean value that indicates whether the queue
is full or not.

Implementation of Queue Data Structure
--------------------------------------

Queue can be implemented using following data structures:

* [Implementation of Queue using Arrays](https://www.geeksforgeeks.org/introduction-and-array-implementation-of-queue)
* [Implementation of Queue using Linked List](https://www.geeksforgeeks.org/queue-linked-list-implementation)

Complexity Analysis of Operations on Queue
------------------------------------------

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****enqueue**** | O(1) | O(1) |
| ****dequeue**** | O(1) | O(1) |
| front | O(1) | O(1) |
| size | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| isFull | O(1) | O(1) |

****Types of Queues****
-----------------------

Queue data structure can be classified into 4 types:

1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the
   element from the front of the queue.
2. [****Double-Ended Queue (Deque)****](https://www.geeksforgeeks.org/deque-set-1-introduction-applications)****:****
   In a double-ended queue the insertion and deletion operations, both
   can be performed from both ends. They are of two types:
   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be
     taken from only one end but deletion can be done from any of the
     ends.
   * ****Output Restricted Queue:****
     This is also a simple queue. In this type of queue, the input can
     be taken from both ends but deletion can be done from only one
     end.
3. [****Circular Queue:****](https://www.geeksforgeeks.org/introduction-to-circular-queue) This is a special type of queue where the last position is connected
   back to the first position. Here also the operations are performed in
   FIFO order.
4. [****Priority Queue****](https://www.geeksforgeeks.org/priority-queue-set-1-introduction)****:****
   A priority queue is a special queue where the elements are accessed
   based on the priority assigned to them. They are of two types:
   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in
     increasing order of their priority values. Element with smallest
     priority value is popped first.
   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in
     decreasing order of their priority values. Element with largest
     priority is popped first.

![Types-of-Queue](https://media.geeksforgeeks.org/wp-content/uploads/20241212125924381216/Types-of-Queue-660.webp)

****Applications of Queue Data Structure****
--------------------------------------------

Application of queue is common. In a computer system, there may be
queues of tasks waiting for the printer, for access to disk storage, or
even in a time-sharing system, for use of the CPU. Within a single
program, there may be multiple requests to be kept in a queue, or one
task may create other tasks, which must be done in turn by keeping them
in a queue.

* A Queue is always used as a buffer when we have a speed mismatch
  between a producer and consumer. For example keyboard and CPU.
* Queue can be used where we have a single resource and multiple
  consumers like a single CPU and multiple processes.
* In a network, a queue is used in devices such as a router/switch and
  mail queue.
* Queue can be used in various algorithm techniques like Breadth First
  Search, Topological Sort, etc.', e'Queue is a linear data structure that follows FIFO (First In First Out) Principle, so the first element inserted is the first to be popped out.
', 'Introduction to Queue Data Structure', 1, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('2a878929-d192-4a08-a92c-f93b22786c0f', e'**Types of Queues:**

There are **five different types of queues** that are used in
different scenarios. They are:

1. Input Restricted Queue (this is a Simple Queue)
2. Output Restricted Queue (this is also a Simple Queue)
3. Circular Queue
4. Double Ended Queue (Deque)
5. Priority Queue
   * Ascending Priority Queue
   * Descending Priority Queue

![Types of Queues](https://media.geeksforgeeks.org/wp-content/uploads/20220623134709/typesofqueues.jpg)

Types of Queues

**1.** [**Circular Queue**](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/)**:** Circular Queue is a linear data structure in which the
operations are performed based on FIFO (First In First Out) principle and
the last position is connected back to the first position to make a
circle. It is also called **‘Ring Buffer’**. This queue is
primarily used in the following cases:

1. **Memory Management:** The unused memory locations in the
   case of ordinary queues can be utilized in circular queues.
2. **Traffic system:** In a computer-controlled traffic
   system, circular queues are used to switch on the traffic lights one by
   one repeatedly as per the time set.
3. **CPU Scheduling:** Operating systems often maintain a
   queue of processes that are ready to execute or that are waiting for a
   particular event to occur.

The time complexity for the circular Queue is O(1).

**2. Input restricted Queue:** In this type of Queue, the
input can be taken from one side only(rear) and deletion of elements can
be done from both sides(front and rear). This kind of Queue does not
follow FIFO(first in first out).  This queue is used in cases where
the consumption of the data needs to be in FIFO order but if there is a
need to remove the recently inserted data for some reason and one such
case can be irrelevant data, performance issue, etc.



![Input Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131417/inputrestrictedqueue.jpg)

Input Restricted Queue

**Advantages of Input restricted Queue:**

* Prevents overflow and overloading of the queue by limiting the number of
  items added
* Helps maintain stability and predictable performance of the system

**Disadvantages of Input restricted Queue:**

* May lead to resource wastage if the restriction is set too low and items
  are frequently discarded
* May lead to waiting or blocking if the restriction is set too high and
  the queue is full, preventing new items from being added.

**3. Output restricted Queue:** In this type of Queue, the
input can be taken from both sides(rear and front) and the deletion of the
element can be done from only one side(front).  This queue is used in
the case where the inputs have some priority order to be executed and the
input can be placed even in the first place so that it is executed
first.

![Output Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131455/outputrestrictedqueue.jpg)

Output Restricted Queue

**4.** [**Double ended Queue**](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/)**:** Double Ended Queue is also a Queue data structure in
which the insertion and deletion operations are performed at both the ends
(front and rear). That means, we can insert at both front and rear
positions and can delete from both front and rear positions.  Since
Deque supports both stack and queue operations, it can be used as both.
The Deque data structure supports clockwise and anticlockwise rotations in
O(1) time which can be useful in certain applications. Also, the problems
where elements need to be removed and or added both ends can be
efficiently solved using Deque.

![Double Ended Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131811/doubleended.jpg)

Double Ended Queue

**5.** [**Priority Queue**](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)**:** A priority queue is a special type of queue in which
each element is associated with a priority and is served according to its
priority. There are two types of Priority Queues. They are:

1. **Ascending Priority Queue:** Element can be inserted
   arbitrarily but only smallest element can be removed. For example,
   suppose there is an array having elements 4, 2, 8 in the same order. So,
   while inserting the elements, the insertion will be in the same sequence
   but while deleting, the order will be 2, 4, 8.
2. **Descending priority Queue:** Element can be inserted
   arbitrarily but only the largest element can be removed first from the
   given Queue. For example, suppose there is an array having elements 4,
   2, 8 in the same order. So, while inserting the elements, the insertion
   will be in the same sequence but while deleting, the order will be 8, 4,
   2.

The time complexity of the Priority Queue is O(logn).

[**Applications of a Queue:**](https://www.geeksforgeeks.org/applications-of-queue-data-structure/)

The
[queue](https://www.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/)
is used when things don’t have to be processed immediately, but have to be
processed in First In First Out order like
[Breadth First Search](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/). This property of Queue makes it also useful in the following kind of
scenarios.

1. When a resource is shared among multiple consumers. Examples include
   [CPU scheduling](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/),
   [Disk Scheduling](https://www.geeksforgeeks.org/disk-scheduling-algorithms/).
2. When data is transferred asynchronously (data not necessarily received
   at the same rate as sent) between two processes. Examples include IO
   Buffers,
   [pipes](https://www.geeksforgeeks.org/piping-in-unix-or-linux/), file IO, etc.
3. Linear Queue: A linear queue is a type of queue where data elements are
   added to the end of the queue and removed from the front of the queue.
   Linear queues are used in applications where data elements need to be
   processed in the order in which they are received. Examples include
   printer queues and message queues.
4. Circular Queue: A circular queue is similar to a linear queue, but the
   end of the queue is connected to the front of the queue. This allows for
   efficient use of space in memory and can improve performance. Circular
   queues are used in applications where the data elements need to be
   processed in a circular fashion. Examples include CPU scheduling and
   memory management.
5. Priority Queue: A priority queue is a type of queue where each element
   is assigned a priority level. Elements with higher priority levels are
   processed before elements with lower priority levels. Priority queues
   are used in applications where certain tasks or data elements need to be
   processed with higher priority. Examples include operating system task
   scheduling and network packet scheduling.
6. Double-ended Queue: A double-ended queue, also known as a deque, is a
   type of queue where elements can be added or removed from either end of
   the queue. This allows for more flexibility in data processing and can
   be used in applications where elements need to be processed in multiple
   directions. Examples include job scheduling and searching algorithms.
7. Concurrent Queue: A concurrent queue is a type of queue that is designed
   to handle multiple threads accessing the queue simultaneously.
   Concurrent queues are used in multi-threaded applications where data
   needs to be shared between threads in a thread-safe manner. Examples
   include database transactions and web server requests.

**Issues of Queue :**

Some common issues that can arise when using queues:

1. Queue overflow: Queue overflow occurs when the queue reaches its maximum
   capacity and is unable to accept any more elements. This can cause data
   loss and can lead to application crashes.
2. Queue underflow: Queue underflow occurs when an attempt is made to
   remove an element from an empty queue. This can cause errors and
   application crashes.
3. Priority inversion: Priority inversion occurs in priority queues when a
   low-priority task holds a resource that a high-priority task needs. This
   can cause delays in processing and can impact system performance.
4. Deadlocks: Deadlocks occur when multiple threads or processes are
   waiting for each other to release resources, resulting in a situation
   where none of the threads can proceed. This can happen when using
   concurrent queues and can lead to system crashes.
5. Performance issues: Queue performance can be impacted by various
   factors, such as the size of the queue, the frequency of access, and the
   type of operations performed on the queue. Poor queue performance can
   lead to slower system performance and reduced user experience.
6. Synchronization issues: Synchronization issues can arise when multiple
   threads are accessing the same queue simultaneously. This can result in
   data corruption, race conditions, and other errors.
7. Memory management issues: Queues can use up significant amounts of
   memory, especially when processing large data sets. Memory leaks and
   other memory management issues can occur, leading to system crashes and
   other errors.

**Reference :**

Some references for further reading on queues:

1. “Data Structures and Algorithms in Java” by Robert Lafore – This book
   provides an in-depth explanation of different types of queues and their
   implementations in Java.
2. “Introduction to Algorithms” by Thomas H. Cormen et al. – This textbook
   covers the basic concepts of data structures and algorithms, including
   queues and their various applications.
3. “Concurrency in C# Cookbook” by Stephen Cleary – This book provides
   practical examples of how to use concurrent queues in C# programming.
4. “Queue (abstract data type)” on Wikipedia – This article provides an
   overview of queues and their properties, as well as examples of their
   applications.
5. “The Art of Computer Programming, Volume 1: Fundamental Algorithms” by
   Donald E. Knuth – This book includes a detailed analysis of different
   queue algorithms and their performance.
6. “Queues and the Producer-Consumer Problem” by Douglas C. Schmidt – This
   paper discusses how queues can be used to solve the producer-consumer
   problem in concurrent programming.', e'Queue is a linear structure that follows a particular order in which the
operations are performed. The order is First In First Out (FIFO). A good
example of a queue is any queue of consumers for a resource where the
consumer that came first is served first. In this article, the different
types of queues are discussed.', 'Different Types of Queues and its Applications', 2, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('562940a2-1089-4c6d-a938-5fe36049bc5f', e'**Basic Operations on Queue:**
------------------------------

Some of the basic operations for Queue in Data Structure are:

* **enqueue() –** Insertion of elements to the queue.
* **dequeue() –** Removal of elements from the queue.
* **peek() or front()-** Acquires the data element available
  at the front node of the queue without deleting it.
* **rear() –** This operation returns the element at the rear
  end without removing it.
* **isFull() –** Validates if the queue is full.
* **isEmpty() –** Checks if the queue is empty.
* **size():** This operation returns the size of the queue
  i.e. the total number of elements it contains.

![](https://media.geeksforgeeks.org/wp-content/uploads/20221209094646/Queue-768.png)

Queue Data Structure

### **Operation 1: enqueue()**

Inserts an element at the end of the queue i.e. at the rear end.

The following steps should be taken to enqueue (insert) data into a queue:

* Check if the queue is full.
* If the queue is full, return overflow error and exit.
* If the queue is not full, increment the rear pointer to point to the
  next empty space.
* Add the data element to the queue location, where the rear is pointing.
* return success.

![Enqueue representation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122158/fifo1-660x371.png)

Enqueue representation

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `printf``(``"\\nQueue is full\\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}` |
| --- |





Java
----

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `System.out.println(``"\\nQueue is full\\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `void` `enqueue(``struct` `Queue* queue,` `int` `item)`  `{`  `if` `(isFull(queue))`  `return``;`  `queue->rear = (queue->rear + 1) % queue->capacity;`  `queue->array[queue->rear] = item;`  `queue->size = queue->size + 1;`  `printf``(``"%d enqueued to queue\\n"``, item);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to add an item to the queue.`  `# It changes rear and size`  `def` `EnQueue(``self``, item):`  `if` `self``.isFull():`  `print``(``"Full"``)`  `return`  `self``.rear` `=` `(``self``.rear` `+` `1``)` `%` `(``self``.capacity)`  `self``.Q[``self``.rear]` `=` `item`  `self``.size` `=` `self``.size` `+` `1`  `print``(``"% s enqueued to queue"` `%` `str``(item))`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `void` `enqueue(``int` `item)`  `{`  `if` `(rear == max - 1) {`  `Console.WriteLine(``"Queue Overflow"``);`  `return``;`  `}`  `else` `{`  `ele[++rear] = item;`  `}`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `enqueue(element){`  `// adding element to the queue`  `this``.items.push(element);`  `}`    `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 2: dequeue()**

This operation removes and returns an element that is at the front end of
the queue.

The following steps are taken to perform the dequeue operation:

* Check if the queue is empty.
* If the queue is empty, return the underflow error and exit.
* If the queue is not empty, access the data where the front is pointing.
* Increment the front pointer to point to the next available data element.
* The Return success.

![Dequeue operation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122625/fifo2-660x371.png)

Dequeue operation

Below is the Implementation of above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `printf``(``"\\nQueue is empty\\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i = 0; i < rear - 1; i++) {`  `queue[i] = queue[i + 1];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}` |
| --- |





Java
----

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `System.out.println(``"\\nQueue is empty\\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i =` `0``; i < rear -` `1``; i++) {`  `queue[i] = queue[i +` `1``];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `int` `dequeue(``struct` `Queue* queue)`  `{`  `if` `(isEmpty(queue)) {`  `printf``(``"\\nQueue is empty\\n"``);`  `return``;`  `}`  `int` `item = queue->array[queue->front];`  `queue->front = (queue->front + 1) % queue->capacity;`  `queue->size = queue->size - 1;`  `return` `item;`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to remove an item from queue.`  `# It changes front and size`      `def` `DeQueue(``self``):`  `if` `self``.isEmpty():`  `print``(``"Queue is empty"``)`  `return`    `print``(``"% s dequeued from queue"` `%` `str``(``self``.Q[``self``.front]))`  `self``.front` `=` `(``self``.front` `+` `1``)` `%` `(``self``.capacity)`  `self``.size` `=` `self``.size` `-` `1`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `public` `int` `dequeue()`  `{`  `if` `(front == rear + 1) {`  `Console.WriteLine(``"Queue is Empty"``);`  `return` `-1;`  `}`  `else` `{`  `int` `p = ele[front++];`  `return` `p;`  `}`  `}`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `dequeue(){`  `// removing element from the queue`  `// returns underflow when called`  `// on empty queue`  `if``(``this``.isEmpty()){`  `document.write(``"<br>Queue is empty<br>"``);`  `return` `-1;`  `}`  `return` `this``.items.shift();`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 3: front()**

This operation returns the element at the front end without removing it.

The following steps are taken to perform the front operation:

* If the queue is empty return the most minimum value.
* otherwise, return the front value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `// Function to get front of queue`  `int` `front(Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}` |
| --- |





Java
----

  



  

  




| `// Function to get front of queue`  `int` `front(Queue queue)`  `{`  `if` `(isempty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.front];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to get front of queue`  `def` `que_front(``self``):`  `if` `self``.isempty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.front]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[front];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `// Function to get front of queue`  `front(){`  `// returns the Front element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[0];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 4 : rear()

This operation returns the element at the rear end without removing it.

The following steps are taken to perform the rear operation:

* If the queue is empty return the most minimum value.
* otherwise, return the rear value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue* queue)`  `{`  `if` `(isEmpty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}` |
| --- |





Java
----

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue queue)`  `{`  `if` `(isEmpty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.rear];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to get rear of queue`  `def` `que_rear(``self``):`  `if` `self``.isEmpty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.rear]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[rear];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `rear(){`  `// returns the Rear element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[``this``.items.length-1];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 5: isEmpty():**

This operation returns a boolean value that indicates whether the queue is
empty or not.

The following steps are taken to perform the Empty operation:

* check if front value is equal to -1 or not, if yes then return true
  means queue is empty.
* Otherwise return false, means queue is not empty

Below is the implementation of the above approach:

* C++
* Java
* C#
* C
* Python3
* Javascript

C++
---

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}` |
| --- |





Java
----

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `boolean` `isEmpty()`  `{`  `if` `(front == -``1``)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C#
--

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by lokeshmvs21.` |
| --- |





C
-

  



  

  




| `// Queue is empty when size is 0`  `bool` `isEmpty(``struct` `Queue* queue)`  `{`  `return` `(queue->size == 0);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Queue is empty when size is 0`  `def` `isEmpty(``self``):`  `return` `self``.size` `=``=` `0`  `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `</script>`  `isEmpty(){`  `// return true if the queue is empty.`  `return` `this``.items.length == 0;`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 6 : isFull()**

This operation returns a boolean value that indicates whether the queue is
full or not.

The following steps are taken to perform the isFull() operation:

* Check if front value is equal to zero and rear is equal to the capacity
  of queue if yes then return true.
* otherwise return false

Below is the Implementation of the above approach:

* C++
* Java
* C
* C#
* Python3
* Javascript

C++
---

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `bool` `isFull()`  `{`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}` |
| --- |





Java
----

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `boolean` `isFull()`  `{`  `if` `(front ==` `0` `&& rear == MAX_SIZE -` `1``) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Queue is full when size becomes`  `// equal to the capacity`  `bool` `isFull(``struct` `Queue* queue)`  `{`  `return` `(queue->size == queue->capacity);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `bool` `isFull(``int` `item) {` `return` `(rear == max - 1); }`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Queue is full when size becomes`  `# equal to the capacity`      `def` `isFull(``self``):`  `return` `self``.size` `=``=` `self``.capacity`    `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `function` `isFull() {`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityamaharshi21.` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 7: size()

This operation returns the size of the queue i.e. the total number of
elements it contains.

```
queuename.size()
Parameters :
No parameters are passed
Returns :
Number of elements in the container
```

* C++
* Java
* Python
* C#
* Javascript

C++
---

  



  

  




| `// CPP program to illustrate`  `// Implementation of size() function`  `#include <iostream>`  `#include <queue>`  `using` `namespace` `std;`    `int` `main()`  `{`  `int` `sum = 0;`  `queue<``int``> myqueue;`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `cout << myqueue.size();`    `return` `0;`  `}` |
| --- |





Java
----

  



  

  




| `// Java program to illustrate implementation of size()`  `// function`    `import` `java.util.*;`    `public` `class` `Main {`  `public` `static` `void` `main(String[] args)`  `{`  `int` `sum =` `0``;`  `Queue<Integer> myqueue =` `new` `LinkedList<>();`  `myqueue.add(``1``);`  `myqueue.add(``8``);`  `myqueue.add(``3``);`  `myqueue.add(``6``);`  `myqueue.add(``2``);`    `// Queue becomes 1, 8, 3, 6, 2`    `System.out.println(myqueue.size());`  `}`  `}`    `// This code is contributed by lokesh.` |
| --- |





Python
------

  



  

  




| `from` `collections` `import` `deque`    `def` `main():`  `sum` `=` `0`  `myqueue` `=` `deque()`  `myqueue.append(``1``)`  `myqueue.append(``8``)`  `myqueue.append(``3``)`  `myqueue.append(``6``)`  `myqueue.append(``2``)`    `# Queue becomes 1, 8, 3, 6, 2`    `print``(``len``(myqueue))`    `main()`    `# This code is contributed by aadityamaharshi21.` |
| --- |





C#
--

  



  

  




| `using` `System;`  `using` `System.Collections.Generic;`    `namespace` `ConsoleApp1 {`  `class` `MainClass {`  `public` `static` `void` `Main(``string``[] args)`  `{`  `int` `sum = 0;`  `Queue<``int``> myqueue =` `new` `Queue<``int``>();`  `myqueue.Enqueue(1);`  `myqueue.Enqueue(8);`  `myqueue.Enqueue(3);`  `myqueue.Enqueue(6);`  `myqueue.Enqueue(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `Console.WriteLine(myqueue.Count);`  `}`  `}`  `}`    `// This code is contributed by adityamaharshi21.` |
| --- |





Javascript
----------

  



  

  




| `// Javascript code`  `let sum = 0;`  `let myqueue=[];`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `console.log(myqueue.length);` |
| --- |







**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

', '', 'Basic Operations for Queue in Data Structure', 3, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('6c6539f0-a9f9-4639-b197-d3fc89870e6a', e'****Enqueue**** and when an element is deleted from the queue, then the operation is
known as ****Dequeue.****It is important to know that we cannot insert an element if the size of
the queue is full and cannot delete an element when the queue itself is
empty. If we try to insert an element even after the queue is full, then
such a condition is known as overflow whereas, if we try to delete an
element even after the queue is empty then such a condition is known as
underflow.

****Primary Queue Operations:****

* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue
  at the end i.e. at the rear end. (Where T is Generic i.e we can define
  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****
* ****int dequeue():****
  When this operation is performed, an element is removed from the front
  end and is returned. This operation take ****constant time i.e O(1).****

****Auxiliary Queue Operations:****

* ****int front():**** This operation will return the element at the front without removing
  it and it take O(1) time.
* ****int rear():**** This operation will return the element at the rear without removing
  it, Its Time Complexity is O(1).
* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This
  Operation also done in O(1).
* ****int size():**** This operation will return the size of the queue i.e. the total
  number of elements present in the queue and it’s time complexity is
  O(1).

****Types of Queues:****

* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version
  of a queue. Here, insertion of an element i.e. the Enqueue operation
  takes place at the rear end and removal of an element i.e. the Dequeue
  operation takes place at the front end.
* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In
  a circular queue, the element of the queue act as a circular ring. The
  working of a circular queue is similar to the linear queue except for
  the fact that the last element is connected to the first element. Its
  advantage is that the memory is utilized in a better way. This is
  because if there is an empty space i.e. if no element is present at a
  certain position in the queue, then an element can be easily added at
  that position.
* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it
  arranges the elements in a queue based on some priority. The priority
  can be something where the element with the highest value has the
  priority so it creates a queue with decreasing order of values. The
  priority can also be such that the element with the lowest value gets
  the highest priority so in turn it creates a queue with increasing
  order of values.
* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests
  double ended, it means that an element can be inserted or removed from
  both the ends of the queue unlike the other queues in which it can be
  done only from one end. Because of this property it may not obey the
  First In First Out property.

****Implementation of Queue:****

* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited
  number of elements.
* ****Linked list allocation:****
  A queue can be implemented using a linked list. It can organize an
  unlimited number of elements.

****Applications of Queue:****

* ****Multi programming:**** Multi programming means when multiple programs are running in the
  main memory. It is essential to organize these multiple programs and
  these multiple programs are organized as queues.
* ****Network:**** In a network, a queue is used in devices such as a router or a
  switch. another application of a queue is a mail queue which is a
  directory that stores data and controls files for mail messages.
* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that
  are scheduled to be executed one after another. These jobs are
  assigned to the processor one by one which is organized using a
  queue.
* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.

****Real-time application of Queue:****

* Working as a buffer between a slow and a fast device. For example
  keyboard and CPU, and two devices on network.
* ATM Booth Line
* Ticket Counter Line
* CPU task scheduling
* Waiting time of each customer at call centers.

****Advantages of Queue:****

* A large amount of data can be managed efficiently with ease.
* Operations such as insertion and deletion can be performed with ease
  as it follows the first in first out rule.
* Queues are useful when a particular service is used by multiple
  consumers.
* Queues are fast in speed for data inter-process communication.
* Queues can be used in the implementation of other data
  structures.

****Disadvantages of Queue:****

* The operations such as insertion and deletion of elements from the
  middle are time consuming.
* In a classical queue, a new element can only be inserted when the
  existing elements are deleted from the queue.
* Searching an element takes O(N) time.
* Maximum size of a queue must be defined prior in case of array
  implementation.', e'A Queue
is a linear data structure. This data structure follows a particular
order in which the operations are performed. The order is First In First Out (FIFO). It means that the element that is inserted first in the queue will
come out first and the element that is inserted last will come out last.', 'Applications, Advantages and Disadvantages of Queue', 4, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('3126233c-3e02-455e-8152-6d095b943168', e'Basic Terminologies of Queue
----------------------------

* ****Front:**** Position of the entry in a queue ready to be served, that is, the
  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.
* ****Rear:****
  Position of the last entry in the queue, that is, the one most
  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.
* ****Size:**** Size refers to the ****current**** number of elements in the queue.
* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.

****Representation of Queue****
-------------------------------

![Representation-of-Queue-Data-Structure](https://media.geeksforgeeks.org/wp-content/uploads/20241212130245410876/Representation-of-Queue-Data-Structure-768.webp)

Operations on Queue
-------------------

### ****1. Enqueue:****

Enqueue operation ****adds (or stores) an element to the end of the queue****. 

****Steps:****

1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.
2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.
3. Insert the element at the rear.


![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)


![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)


![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)


![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)


![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)


![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)



Previous





Pause

Next





3 / 6



### ****2. Dequeue:****

Dequeue operation removes the element at the front of the queue. The
following steps are taken to perform the dequeue operation:


1. Check if the ****queue is empty****. If so, return an ****underflow**** error.
2. Remove the element at the ****front****.
3. ****Increment**** the ****front**** pointer to the next element.


![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)



Previous





Play

Next





1 / 6



### ****3. Peek or Front Operation:****

This operation returns the element at the front end without removing
it.

### 4. Size Operation:

This operation returns the numbers of elements present in the
queue.

### ****5. isEmpty Operation:****

This operation returns a boolean value that indicates whether the queue
is empty or not.

### ****6. isFull Operation:****

This operation returns a boolean value that indicates whether the queue
is full or not.

Implementation of Queue Data Structure
--------------------------------------

Queue can be implemented using following data structures:

* [Implementation of Queue using Arrays](https://www.geeksforgeeks.org/introduction-and-array-implementation-of-queue)
* [Implementation of Queue using Linked List](https://www.geeksforgeeks.org/queue-linked-list-implementation)

Complexity Analysis of Operations on Queue
------------------------------------------

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****enqueue**** | O(1) | O(1) |
| ****dequeue**** | O(1) | O(1) |
| front | O(1) | O(1) |
| size | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| isFull | O(1) | O(1) |

****Types of Queues****
-----------------------

Queue data structure can be classified into 4 types:

1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the
   element from the front of the queue.
2. [****Double-Ended Queue (Deque)****](https://www.geeksforgeeks.org/deque-set-1-introduction-applications)****:****
   In a double-ended queue the insertion and deletion operations, both
   can be performed from both ends. They are of two types:
   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be
     taken from only one end but deletion can be done from any of the
     ends.
   * ****Output Restricted Queue:****
     This is also a simple queue. In this type of queue, the input can
     be taken from both ends but deletion can be done from only one
     end.
3. [****Circular Queue:****](https://www.geeksforgeeks.org/introduction-to-circular-queue) This is a special type of queue where the last position is connected
   back to the first position. Here also the operations are performed in
   FIFO order.
4. [****Priority Queue****](https://www.geeksforgeeks.org/priority-queue-set-1-introduction)****:****
   A priority queue is a special queue where the elements are accessed
   based on the priority assigned to them. They are of two types:
   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in
     increasing order of their priority values. Element with smallest
     priority value is popped first.
   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in
     decreasing order of their priority values. Element with largest
     priority is popped first.

![Types-of-Queue](https://media.geeksforgeeks.org/wp-content/uploads/20241212125924381216/Types-of-Queue-660.webp)

****Applications of Queue Data Structure****
--------------------------------------------

Application of queue is common. In a computer system, there may be
queues of tasks waiting for the printer, for access to disk storage, or
even in a time-sharing system, for use of the CPU. Within a single
program, there may be multiple requests to be kept in a queue, or one
task may create other tasks, which must be done in turn by keeping them
in a queue.

* A Queue is always used as a buffer when we have a speed mismatch
  between a producer and consumer. For example keyboard and CPU.
* Queue can be used where we have a single resource and multiple
  consumers like a single CPU and multiple processes.
* In a network, a queue is used in devices such as a router/switch and
  mail queue.
* Queue can be used in various algorithm techniques like Breadth First
  Search, Topological Sort, etc.', e'Queue is a linear data structure that follows FIFO (First In First Out) Principle, so the first element inserted is the first to be popped out.
', 'Introduction to Queue Data Structure', 5, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('8d4f2d0d-a9f3-49f5-a13e-9aa4fad99826', e'**Types of Queues:**

There are **five different types of queues** that are used in
different scenarios. They are:

1. Input Restricted Queue (this is a Simple Queue)
2. Output Restricted Queue (this is also a Simple Queue)
3. Circular Queue
4. Double Ended Queue (Deque)
5. Priority Queue
   * Ascending Priority Queue
   * Descending Priority Queue

![Types of Queues](https://media.geeksforgeeks.org/wp-content/uploads/20220623134709/typesofqueues.jpg)

Types of Queues

**1.** [**Circular Queue**](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/)**:** Circular Queue is a linear data structure in which the
operations are performed based on FIFO (First In First Out) principle and
the last position is connected back to the first position to make a
circle. It is also called **‘Ring Buffer’**. This queue is
primarily used in the following cases:

1. **Memory Management:** The unused memory locations in the
   case of ordinary queues can be utilized in circular queues.
2. **Traffic system:** In a computer-controlled traffic
   system, circular queues are used to switch on the traffic lights one by
   one repeatedly as per the time set.
3. **CPU Scheduling:** Operating systems often maintain a
   queue of processes that are ready to execute or that are waiting for a
   particular event to occur.

The time complexity for the circular Queue is O(1).

**2. Input restricted Queue:** In this type of Queue, the
input can be taken from one side only(rear) and deletion of elements can
be done from both sides(front and rear). This kind of Queue does not
follow FIFO(first in first out).  This queue is used in cases where
the consumption of the data needs to be in FIFO order but if there is a
need to remove the recently inserted data for some reason and one such
case can be irrelevant data, performance issue, etc.



![Input Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131417/inputrestrictedqueue.jpg)

Input Restricted Queue

**Advantages of Input restricted Queue:**

* Prevents overflow and overloading of the queue by limiting the number of
  items added
* Helps maintain stability and predictable performance of the system

**Disadvantages of Input restricted Queue:**

* May lead to resource wastage if the restriction is set too low and items
  are frequently discarded
* May lead to waiting or blocking if the restriction is set too high and
  the queue is full, preventing new items from being added.

**3. Output restricted Queue:** In this type of Queue, the
input can be taken from both sides(rear and front) and the deletion of the
element can be done from only one side(front).  This queue is used in
the case where the inputs have some priority order to be executed and the
input can be placed even in the first place so that it is executed
first.

![Output Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131455/outputrestrictedqueue.jpg)

Output Restricted Queue

**4.** [**Double ended Queue**](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/)**:** Double Ended Queue is also a Queue data structure in
which the insertion and deletion operations are performed at both the ends
(front and rear). That means, we can insert at both front and rear
positions and can delete from both front and rear positions.  Since
Deque supports both stack and queue operations, it can be used as both.
The Deque data structure supports clockwise and anticlockwise rotations in
O(1) time which can be useful in certain applications. Also, the problems
where elements need to be removed and or added both ends can be
efficiently solved using Deque.

![Double Ended Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131811/doubleended.jpg)

Double Ended Queue

**5.** [**Priority Queue**](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)**:** A priority queue is a special type of queue in which
each element is associated with a priority and is served according to its
priority. There are two types of Priority Queues. They are:

1. **Ascending Priority Queue:** Element can be inserted
   arbitrarily but only smallest element can be removed. For example,
   suppose there is an array having elements 4, 2, 8 in the same order. So,
   while inserting the elements, the insertion will be in the same sequence
   but while deleting, the order will be 2, 4, 8.
2. **Descending priority Queue:** Element can be inserted
   arbitrarily but only the largest element can be removed first from the
   given Queue. For example, suppose there is an array having elements 4,
   2, 8 in the same order. So, while inserting the elements, the insertion
   will be in the same sequence but while deleting, the order will be 8, 4,
   2.

The time complexity of the Priority Queue is O(logn).

[**Applications of a Queue:**](https://www.geeksforgeeks.org/applications-of-queue-data-structure/)

The
[queue](https://www.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/)
is used when things don’t have to be processed immediately, but have to be
processed in First In First Out order like
[Breadth First Search](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/). This property of Queue makes it also useful in the following kind of
scenarios.

1. When a resource is shared among multiple consumers. Examples include
   [CPU scheduling](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/),
   [Disk Scheduling](https://www.geeksforgeeks.org/disk-scheduling-algorithms/).
2. When data is transferred asynchronously (data not necessarily received
   at the same rate as sent) between two processes. Examples include IO
   Buffers,
   [pipes](https://www.geeksforgeeks.org/piping-in-unix-or-linux/), file IO, etc.
3. Linear Queue: A linear queue is a type of queue where data elements are
   added to the end of the queue and removed from the front of the queue.
   Linear queues are used in applications where data elements need to be
   processed in the order in which they are received. Examples include
   printer queues and message queues.
4. Circular Queue: A circular queue is similar to a linear queue, but the
   end of the queue is connected to the front of the queue. This allows for
   efficient use of space in memory and can improve performance. Circular
   queues are used in applications where the data elements need to be
   processed in a circular fashion. Examples include CPU scheduling and
   memory management.
5. Priority Queue: A priority queue is a type of queue where each element
   is assigned a priority level. Elements with higher priority levels are
   processed before elements with lower priority levels. Priority queues
   are used in applications where certain tasks or data elements need to be
   processed with higher priority. Examples include operating system task
   scheduling and network packet scheduling.
6. Double-ended Queue: A double-ended queue, also known as a deque, is a
   type of queue where elements can be added or removed from either end of
   the queue. This allows for more flexibility in data processing and can
   be used in applications where elements need to be processed in multiple
   directions. Examples include job scheduling and searching algorithms.
7. Concurrent Queue: A concurrent queue is a type of queue that is designed
   to handle multiple threads accessing the queue simultaneously.
   Concurrent queues are used in multi-threaded applications where data
   needs to be shared between threads in a thread-safe manner. Examples
   include database transactions and web server requests.

**Issues of Queue :**

Some common issues that can arise when using queues:

1. Queue overflow: Queue overflow occurs when the queue reaches its maximum
   capacity and is unable to accept any more elements. This can cause data
   loss and can lead to application crashes.
2. Queue underflow: Queue underflow occurs when an attempt is made to
   remove an element from an empty queue. This can cause errors and
   application crashes.
3. Priority inversion: Priority inversion occurs in priority queues when a
   low-priority task holds a resource that a high-priority task needs. This
   can cause delays in processing and can impact system performance.
4. Deadlocks: Deadlocks occur when multiple threads or processes are
   waiting for each other to release resources, resulting in a situation
   where none of the threads can proceed. This can happen when using
   concurrent queues and can lead to system crashes.
5. Performance issues: Queue performance can be impacted by various
   factors, such as the size of the queue, the frequency of access, and the
   type of operations performed on the queue. Poor queue performance can
   lead to slower system performance and reduced user experience.
6. Synchronization issues: Synchronization issues can arise when multiple
   threads are accessing the same queue simultaneously. This can result in
   data corruption, race conditions, and other errors.
7. Memory management issues: Queues can use up significant amounts of
   memory, especially when processing large data sets. Memory leaks and
   other memory management issues can occur, leading to system crashes and
   other errors.

**Reference :**

Some references for further reading on queues:

1. “Data Structures and Algorithms in Java” by Robert Lafore – This book
   provides an in-depth explanation of different types of queues and their
   implementations in Java.
2. “Introduction to Algorithms” by Thomas H. Cormen et al. – This textbook
   covers the basic concepts of data structures and algorithms, including
   queues and their various applications.
3. “Concurrency in C# Cookbook” by Stephen Cleary – This book provides
   practical examples of how to use concurrent queues in C# programming.
4. “Queue (abstract data type)” on Wikipedia – This article provides an
   overview of queues and their properties, as well as examples of their
   applications.
5. “The Art of Computer Programming, Volume 1: Fundamental Algorithms” by
   Donald E. Knuth – This book includes a detailed analysis of different
   queue algorithms and their performance.
6. “Queues and the Producer-Consumer Problem” by Douglas C. Schmidt – This
   paper discusses how queues can be used to solve the producer-consumer
   problem in concurrent programming.', e'Queue is a linear structure that follows a particular order in which the
operations are performed. The order is First In First Out (FIFO). A good
example of a queue is any queue of consumers for a resource where the
consumer that came first is served first. In this article, the different
types of queues are discussed.', 'Different Types of Queues and its Applications', 6, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('dd501d4c-f5c6-424f-9678-af343551671c', e'**Basic Operations on Queue:**
------------------------------

Some of the basic operations for Queue in Data Structure are:

* **enqueue() –** Insertion of elements to the queue.
* **dequeue() –** Removal of elements from the queue.
* **peek() or front()-** Acquires the data element available
  at the front node of the queue without deleting it.
* **rear() –** This operation returns the element at the rear
  end without removing it.
* **isFull() –** Validates if the queue is full.
* **isEmpty() –** Checks if the queue is empty.
* **size():** This operation returns the size of the queue
  i.e. the total number of elements it contains.

![](https://media.geeksforgeeks.org/wp-content/uploads/20221209094646/Queue-768.png)

Queue Data Structure

### **Operation 1: enqueue()**

Inserts an element at the end of the queue i.e. at the rear end.

The following steps should be taken to enqueue (insert) data into a queue:

* Check if the queue is full.
* If the queue is full, return overflow error and exit.
* If the queue is not full, increment the rear pointer to point to the
  next empty space.
* Add the data element to the queue location, where the rear is pointing.
* return success.

![Enqueue representation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122158/fifo1-660x371.png)

Enqueue representation

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `printf``(``"\\nQueue is full\\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}` |
| --- |





Java
----

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `System.out.println(``"\\nQueue is full\\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `void` `enqueue(``struct` `Queue* queue,` `int` `item)`  `{`  `if` `(isFull(queue))`  `return``;`  `queue->rear = (queue->rear + 1) % queue->capacity;`  `queue->array[queue->rear] = item;`  `queue->size = queue->size + 1;`  `printf``(``"%d enqueued to queue\\n"``, item);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to add an item to the queue.`  `# It changes rear and size`  `def` `EnQueue(``self``, item):`  `if` `self``.isFull():`  `print``(``"Full"``)`  `return`  `self``.rear` `=` `(``self``.rear` `+` `1``)` `%` `(``self``.capacity)`  `self``.Q[``self``.rear]` `=` `item`  `self``.size` `=` `self``.size` `+` `1`  `print``(``"% s enqueued to queue"` `%` `str``(item))`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `void` `enqueue(``int` `item)`  `{`  `if` `(rear == max - 1) {`  `Console.WriteLine(``"Queue Overflow"``);`  `return``;`  `}`  `else` `{`  `ele[++rear] = item;`  `}`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `enqueue(element){`  `// adding element to the queue`  `this``.items.push(element);`  `}`    `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 2: dequeue()**

This operation removes and returns an element that is at the front end of
the queue.

The following steps are taken to perform the dequeue operation:

* Check if the queue is empty.
* If the queue is empty, return the underflow error and exit.
* If the queue is not empty, access the data where the front is pointing.
* Increment the front pointer to point to the next available data element.
* The Return success.

![Dequeue operation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122625/fifo2-660x371.png)

Dequeue operation

Below is the Implementation of above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `printf``(``"\\nQueue is empty\\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i = 0; i < rear - 1; i++) {`  `queue[i] = queue[i + 1];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}` |
| --- |





Java
----

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `System.out.println(``"\\nQueue is empty\\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i =` `0``; i < rear -` `1``; i++) {`  `queue[i] = queue[i +` `1``];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `int` `dequeue(``struct` `Queue* queue)`  `{`  `if` `(isEmpty(queue)) {`  `printf``(``"\\nQueue is empty\\n"``);`  `return``;`  `}`  `int` `item = queue->array[queue->front];`  `queue->front = (queue->front + 1) % queue->capacity;`  `queue->size = queue->size - 1;`  `return` `item;`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to remove an item from queue.`  `# It changes front and size`      `def` `DeQueue(``self``):`  `if` `self``.isEmpty():`  `print``(``"Queue is empty"``)`  `return`    `print``(``"% s dequeued from queue"` `%` `str``(``self``.Q[``self``.front]))`  `self``.front` `=` `(``self``.front` `+` `1``)` `%` `(``self``.capacity)`  `self``.size` `=` `self``.size` `-` `1`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `public` `int` `dequeue()`  `{`  `if` `(front == rear + 1) {`  `Console.WriteLine(``"Queue is Empty"``);`  `return` `-1;`  `}`  `else` `{`  `int` `p = ele[front++];`  `return` `p;`  `}`  `}`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `dequeue(){`  `// removing element from the queue`  `// returns underflow when called`  `// on empty queue`  `if``(``this``.isEmpty()){`  `document.write(``"<br>Queue is empty<br>"``);`  `return` `-1;`  `}`  `return` `this``.items.shift();`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 3: front()**

This operation returns the element at the front end without removing it.

The following steps are taken to perform the front operation:

* If the queue is empty return the most minimum value.
* otherwise, return the front value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `// Function to get front of queue`  `int` `front(Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}` |
| --- |





Java
----

  



  

  




| `// Function to get front of queue`  `int` `front(Queue queue)`  `{`  `if` `(isempty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.front];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to get front of queue`  `def` `que_front(``self``):`  `if` `self``.isempty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.front]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[front];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `// Function to get front of queue`  `front(){`  `// returns the Front element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[0];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 4 : rear()

This operation returns the element at the rear end without removing it.

The following steps are taken to perform the rear operation:

* If the queue is empty return the most minimum value.
* otherwise, return the rear value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue* queue)`  `{`  `if` `(isEmpty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}` |
| --- |





Java
----

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue queue)`  `{`  `if` `(isEmpty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.rear];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to get rear of queue`  `def` `que_rear(``self``):`  `if` `self``.isEmpty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.rear]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[rear];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `rear(){`  `// returns the Rear element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[``this``.items.length-1];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 5: isEmpty():**

This operation returns a boolean value that indicates whether the queue is
empty or not.

The following steps are taken to perform the Empty operation:

* check if front value is equal to -1 or not, if yes then return true
  means queue is empty.
* Otherwise return false, means queue is not empty

Below is the implementation of the above approach:

* C++
* Java
* C#
* C
* Python3
* Javascript

C++
---

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}` |
| --- |





Java
----

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `boolean` `isEmpty()`  `{`  `if` `(front == -``1``)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C#
--

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by lokeshmvs21.` |
| --- |





C
-

  



  

  




| `// Queue is empty when size is 0`  `bool` `isEmpty(``struct` `Queue* queue)`  `{`  `return` `(queue->size == 0);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Queue is empty when size is 0`  `def` `isEmpty(``self``):`  `return` `self``.size` `=``=` `0`  `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `</script>`  `isEmpty(){`  `// return true if the queue is empty.`  `return` `this``.items.length == 0;`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 6 : isFull()**

This operation returns a boolean value that indicates whether the queue is
full or not.

The following steps are taken to perform the isFull() operation:

* Check if front value is equal to zero and rear is equal to the capacity
  of queue if yes then return true.
* otherwise return false

Below is the Implementation of the above approach:

* C++
* Java
* C
* C#
* Python3
* Javascript

C++
---

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `bool` `isFull()`  `{`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}` |
| --- |





Java
----

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `boolean` `isFull()`  `{`  `if` `(front ==` `0` `&& rear == MAX_SIZE -` `1``) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Queue is full when size becomes`  `// equal to the capacity`  `bool` `isFull(``struct` `Queue* queue)`  `{`  `return` `(queue->size == queue->capacity);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `bool` `isFull(``int` `item) {` `return` `(rear == max - 1); }`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Queue is full when size becomes`  `# equal to the capacity`      `def` `isFull(``self``):`  `return` `self``.size` `=``=` `self``.capacity`    `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `function` `isFull() {`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityamaharshi21.` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 7: size()

This operation returns the size of the queue i.e. the total number of
elements it contains.

```
queuename.size()
Parameters :
No parameters are passed
Returns :
Number of elements in the container
```

* C++
* Java
* Python
* C#
* Javascript

C++
---

  



  

  




| `// CPP program to illustrate`  `// Implementation of size() function`  `#include <iostream>`  `#include <queue>`  `using` `namespace` `std;`    `int` `main()`  `{`  `int` `sum = 0;`  `queue<``int``> myqueue;`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `cout << myqueue.size();`    `return` `0;`  `}` |
| --- |





Java
----

  



  

  




| `// Java program to illustrate implementation of size()`  `// function`    `import` `java.util.*;`    `public` `class` `Main {`  `public` `static` `void` `main(String[] args)`  `{`  `int` `sum =` `0``;`  `Queue<Integer> myqueue =` `new` `LinkedList<>();`  `myqueue.add(``1``);`  `myqueue.add(``8``);`  `myqueue.add(``3``);`  `myqueue.add(``6``);`  `myqueue.add(``2``);`    `// Queue becomes 1, 8, 3, 6, 2`    `System.out.println(myqueue.size());`  `}`  `}`    `// This code is contributed by lokesh.` |
| --- |





Python
------

  



  

  




| `from` `collections` `import` `deque`    `def` `main():`  `sum` `=` `0`  `myqueue` `=` `deque()`  `myqueue.append(``1``)`  `myqueue.append(``8``)`  `myqueue.append(``3``)`  `myqueue.append(``6``)`  `myqueue.append(``2``)`    `# Queue becomes 1, 8, 3, 6, 2`    `print``(``len``(myqueue))`    `main()`    `# This code is contributed by aadityamaharshi21.` |
| --- |





C#
--

  



  

  




| `using` `System;`  `using` `System.Collections.Generic;`    `namespace` `ConsoleApp1 {`  `class` `MainClass {`  `public` `static` `void` `Main(``string``[] args)`  `{`  `int` `sum = 0;`  `Queue<``int``> myqueue =` `new` `Queue<``int``>();`  `myqueue.Enqueue(1);`  `myqueue.Enqueue(8);`  `myqueue.Enqueue(3);`  `myqueue.Enqueue(6);`  `myqueue.Enqueue(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `Console.WriteLine(myqueue.Count);`  `}`  `}`  `}`    `// This code is contributed by adityamaharshi21.` |
| --- |





Javascript
----------

  



  

  




| `// Javascript code`  `let sum = 0;`  `let myqueue=[];`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `console.log(myqueue.length);` |
| --- |







**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

', '', 'Basic Operations for Queue in Data Structure', 7, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('21135289-e645-4045-a26c-697c91f3873f', e'****Enqueue**** and when an element is deleted from the queue, then the operation is
known as ****Dequeue.****It is important to know that we cannot insert an element if the size of
the queue is full and cannot delete an element when the queue itself is
empty. If we try to insert an element even after the queue is full, then
such a condition is known as overflow whereas, if we try to delete an
element even after the queue is empty then such a condition is known as
underflow.

****Primary Queue Operations:****

* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue
  at the end i.e. at the rear end. (Where T is Generic i.e we can define
  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****
* ****int dequeue():****
  When this operation is performed, an element is removed from the front
  end and is returned. This operation take ****constant time i.e O(1).****

****Auxiliary Queue Operations:****

* ****int front():**** This operation will return the element at the front without removing
  it and it take O(1) time.
* ****int rear():**** This operation will return the element at the rear without removing
  it, Its Time Complexity is O(1).
* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This
  Operation also done in O(1).
* ****int size():**** This operation will return the size of the queue i.e. the total
  number of elements present in the queue and it’s time complexity is
  O(1).

****Types of Queues:****

* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version
  of a queue. Here, insertion of an element i.e. the Enqueue operation
  takes place at the rear end and removal of an element i.e. the Dequeue
  operation takes place at the front end.
* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In
  a circular queue, the element of the queue act as a circular ring. The
  working of a circular queue is similar to the linear queue except for
  the fact that the last element is connected to the first element. Its
  advantage is that the memory is utilized in a better way. This is
  because if there is an empty space i.e. if no element is present at a
  certain position in the queue, then an element can be easily added at
  that position.
* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it
  arranges the elements in a queue based on some priority. The priority
  can be something where the element with the highest value has the
  priority so it creates a queue with decreasing order of values. The
  priority can also be such that the element with the lowest value gets
  the highest priority so in turn it creates a queue with increasing
  order of values.
* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests
  double ended, it means that an element can be inserted or removed from
  both the ends of the queue unlike the other queues in which it can be
  done only from one end. Because of this property it may not obey the
  First In First Out property.

****Implementation of Queue:****

* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited
  number of elements.
* ****Linked list allocation:****
  A queue can be implemented using a linked list. It can organize an
  unlimited number of elements.

****Applications of Queue:****

* ****Multi programming:**** Multi programming means when multiple programs are running in the
  main memory. It is essential to organize these multiple programs and
  these multiple programs are organized as queues.
* ****Network:**** In a network, a queue is used in devices such as a router or a
  switch. another application of a queue is a mail queue which is a
  directory that stores data and controls files for mail messages.
* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that
  are scheduled to be executed one after another. These jobs are
  assigned to the processor one by one which is organized using a
  queue.
* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.

****Real-time application of Queue:****

* Working as a buffer between a slow and a fast device. For example
  keyboard and CPU, and two devices on network.
* ATM Booth Line
* Ticket Counter Line
* CPU task scheduling
* Waiting time of each customer at call centers.

****Advantages of Queue:****

* A large amount of data can be managed efficiently with ease.
* Operations such as insertion and deletion can be performed with ease
  as it follows the first in first out rule.
* Queues are useful when a particular service is used by multiple
  consumers.
* Queues are fast in speed for data inter-process communication.
* Queues can be used in the implementation of other data
  structures.

****Disadvantages of Queue:****

* The operations such as insertion and deletion of elements from the
  middle are time consuming.
* In a classical queue, a new element can only be inserted when the
  existing elements are deleted from the queue.
* Searching an element takes O(N) time.
* Maximum size of a queue must be defined prior in case of array
  implementation.', e'A Queue
is a linear data structure. This data structure follows a particular
order in which the operations are performed. The order is First In First Out (FIFO). It means that the element that is inserted first in the queue will
come out first and the element that is inserted last will come out last.', 'Applications, Advantages and Disadvantages of Queue', 8, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('451c319e-a0a3-48e5-baca-ece2737e6010', e'Representation of Stack Data Structure:
---------------------------------------

Stack follows LIFO (Last In First Out) Principle so the element which
is pushed last is popped first.


![Stack-representation-in-Data-Structures-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp)

****Types of Stack:****
-----------------------

* ****Fixed Size Stack**** 
  : As the name suggests, a fixed size stack has a fixed size and cannot
  grow or shrink dynamically. If the stack is full and an attempt is
  made to add an element to it, an overflow error occurs. If the stack
  is empty and an attempt is made to remove an element from it, an
  underflow error occurs.
* ****Dynamic Size Stack**** 
  : A dynamic size stack can grow or shrink dynamically. When the stack
  is full, it automatically increases its size to accommodate the new
  element, and when the stack is empty, it decreases its size. This type
  of stack is implemented using a linked list, as it allows for easy
  resizing of the stack.

Basic Operations on Stack:
--------------------------

In order to make manipulations in a stack, there are certain operations
provided to us.


* ****push()****  to insert an element into the stack
* ****pop()****  to remove an element from the stack
* ****top()****  Returns the top element of the stack.
* ****isEmpty()****  returns true if stack is empty else false.
* ****isFull()****  returns true if the stack is full else false.

To implement stack, we need to maintain reference to the top
item.

### ****Push Operation on Stack****

Adds an item to the stack. If the stack is full, then it is said to be
an  ****Overflow condition.**** 

 ****Algorithm for Push Operation:**** 

* Before pushing the element to the stack, we check if the stack is  ****full****  .
* If the stack is full  ****(top == capacity-1)****  , then  ****Stack Overflows****  and we cannot insert the element to the stack.
* Otherwise, we increment the value of top by 1  ****(top = top + 1)****  and the new value is inserted at  ****top position****  .
* The elements can be pushed into the stack till we reach the  ****capacity****  of the stack.

![Push-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180844/Push-Operation-in-Stack-(1).webp)
### ****Pop Operation in Stack****

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an  ****Underflow condition.**** 

****Algorithm for Pop Operation:**** 

* Before popping the element from the stack, we check if the stack is  ****empty****  .
* If the stack is empty (top == -1), then  ****Stack Underflows****  and we cannot remove any element from the stack.
* Otherwise, we store the value at top, decrement the value of top by 1  ****(top = top – 1)****  and return the stored top value.

![Pop-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180943/Pop-Operation-in-Stack-(1).webp)
### ****Top or Peek Operation on Stack****

Returns the top element of the stack. 

****Algorithm for Top Operation:**** 

* Before returning the top element from the stack, we check if the
  stack is empty.
* If the stack is empty (top == -1), we simply print “Stack is empty”.
* Otherwise, we return the element stored at  ****index = top****  .

![Top-or-Peek-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181023/Top-or-Peek-Operation-in-Stack-(1).webp)
### ****isEmpty Operation in Stack Data Structure:****

Returns true if the stack is empty, else false. 

****Algorithm for isEmpty Operation****: 

* Check for the value of  ****top****  in stack.
* If  ****(top == -1)****, then the stack is  ****empty****  so return  ****true****  .
* Otherwise, the stack is not empty so return  ****false****  .

![isEmpty-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181101/isEmpty-Operation-in-Stack-(1).webp)
### isFull ****Operation in Stack**** ****Data Structure****:

Returns true if the stack is full, else false. 

****Algorithm for isFull Operation:**** 

* Check for the value of  ****top****  in stack.
* If  ****(top == capacity-1),****  then the stack is  ****full****  so return  ****true****.
* Otherwise, the stack is not full so return  ****false****.

![isFull-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181147/isFull-Operation-in-Stack-(1).webp)

Implementation of Stack
-----------------------


The basic operations that can be performed on a stack include push, pop,
and peek. There are two ways to implement a stack –


* [****Implementation of Stack using Array****](https://www.geeksforgeeks.org/implement-stack-using-array/)
* [****Implementation of Stack using Linked List****](https://www.geeksforgeeks.org/implement-a-stack-using-singly-linked-list/)

****Complexity Analysis of Operations on Stack Data Structure:****
------------------------------------------------------------------

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****push()**** | O(1) | O(1) |
| ****pop()**** | O(1) | O(1) |
| top() or  ****pee****k() | O(1) | O(1) |
| isEmpty() | O(1) | O(1) |
| isFull() | O(1) | O(1) |', e'Stack is a linear data structure that follows LIFO (Last In First Out) Principle, the last element inserted is the first to be popped out. It means
both insertion and deletion operations happen at one end only.', 'What is Stack Data Structure? A Complete Tutorial', 1, null, '95713603-63d1-4b75-8a89-1acdc0977459', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('63ddc11b-1888-48d8-afe0-f7153a56cc65', e'Implement Stack using Array:
----------------------------

> To implement a stack using an array, initialize an array and treat
> its end as the stack’s top. Implement ****push**** (add to end), ****pop**** (remove from end), and ****peek**** (check end) operations, handling cases for an ****empty**** or f****ull stack****.

****Step-by-step approach:****

1. ****Initialize an array**** to represent the stack.
2. Use the ****end of the array**** to represent the ****top of the stack****.
3. Implement ****push**** (add to end), ****pop**** (remove from the end), and ****peek**** (check end) operations, ensuring to handle empty and full stack
   conditions.

Implement Stack Operations using Array:
---------------------------------------


Here are the following operations of implement stack using array:

### ****Push Operation in Stack:****

Adds an item to the stack. If the stack is full, then it is said to be
an ****Overflow condition.****

****Algorithm for Push Operation:****

> * Before pushing the element to the stack, we check if the stack
>   is ****full****.
> * If the stack is full ****(top == capacity-1)****, then ****Stack Overflows****and we cannot insert the element to the stack.
> * Otherwise, we increment the value of top by 1 ****(top = top + 1)****and the new value is inserted at ****top position****.
> * The elements can be pushed into the stack till we reach
>   the ****capacity****of the stack.

![push-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)![push-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)


![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114220/push-operation-in-stack-2.webp)![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114220/push-operation-in-stack-2.webp)


![push-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114221/push-operation-in-stack-3.webp)![push-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114221/push-operation-in-stack-3.webp)


![push-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-4.webp)![push-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-4.webp)


![push-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-5.webp)![push-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-5.webp)


![push-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114223/push-operation-in-stack-6.webp)![push-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114223/push-operation-in-stack-6.webp)



Previous





Pause

Next





5 / 6

### ****Pop Operation in Stack:****

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an ****Underflow condition.****

****Algorithm for Pop Operation:****

> * Before popping the element from the stack, we check if the stack
>   is ****empty****.
> * If the stack is empty (top == -1), then ****Stack Underflows****and we cannot remove any element from the stack.
> * Otherwise, we store the value at top, decrement the value of top by
>   1 ****(top = top – 1)****and return the stored top value.

![pop-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)



Previous





Play

Next





1 / 6

  


### ****Top or Peek Operation in Stack:****

Returns the top element of the stack.

****Algorithm for Top Operation:****

> * Before returning the top element from the stack, we check if the
>   stack is empty.
> * If the stack is empty (top == -1), we simply print “Stack is
>   empty”.
> * Otherwise, we return the element stored at ****index = top****.

### ****isEmpty Operation in Stack:****

Returns true if the stack is empty, else false.

****Algorithm for isEmpty Operation****:

> * Check for the value of ****top****in stack.
> * If ****(top == -1)****, then the stack is ****empty****so return ****true****.
> * Otherwise, the stack is not empty so return ****false****.

### isFull ****Operation in Stack****:

Returns true if the stack is full, else false.

****Algorithm for isFull Operation:****

> * Check for the value of ****top****in stack.
> * If ****(top == capacity-1),****then the stack is ****full****so return ****true****.
> * Otherwise, the stack is not full so return ****false.****

Below is the implementation of the above approach:

C++
````
/* C++ program to implement basic stack 
operations */
#include <bits/stdc++.h> 

using namespace std; 

#define MAX 1000 

class Stack { 
    int top; 

public: 
    int a[MAX]; // Maximum size of Stack 

    Stack() { top = -1; } 
    bool push(int x); 
    int pop(); 
    int peek(); 
    bool isEmpty(); 
}; 

bool Stack::push(int x) 
{ 
    if (top >= (MAX - 1)) { 
        cout << "Stack Overflow"; 
        return false; 
    } 
    else { 
        a[++top] = x; 
        cout << x << " pushed into stack\\n"; 
        return true; 
    } 
} 

int Stack::pop() 
{ 
    if (top < 0) { 
        cout << "Stack Underflow"; 
        return 0; 
    } 
    else { 
        int x = a[top--]; 
        return x; 
    } 
} 
int Stack::peek() 
{ 
    if (top < 0) { 
        cout << "Stack is Empty"; 
        return 0; 
    } 
    else { 
        int x = a[top]; 
        return x; 
    } 
} 

bool Stack::isEmpty() 
{ 
    return (top < 0); 
} 

// Driver program to test above functions 
int main() 
{ 
    class Stack s; 
    s.push(10); 
    s.push(20); 
    s.push(30); 
    cout << s.pop() << " Popped from stack\\n"; 
    
    //print top element of stack after popping 
    cout << "Top element is : " << s.peek() << endl; 
    
    //print all elements in stack : 
    cout <<"Elements present in stack : "; 
    while(!s.isEmpty()) 
    { 
        // print top element in stack 
        cout << s.peek() <<" "; 
        // remove top element in stack 
        s.pop(); 
    } 

    return 0; 
}

````

C
````
// C program for array implementation of stack 
#include <limits.h> 
#include <stdio.h> 
#include <stdlib.h> 

// A structure to represent a stack 
struct Stack { 
    int top; 
    unsigned capacity; 
    int* array; 
}; 

// function to create a stack of given capacity. It initializes size of 
// stack as 0 
struct Stack* createStack(unsigned capacity) 
{ 
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack)); 
    stack->capacity = capacity; 
    stack->top = -1; 
    stack->array = (int*)malloc(stack->capacity * sizeof(int)); 
    return stack; 
} 

// Stack is full when top is equal to the last index 
int isFull(struct Stack* stack) 
{ 
    return stack->top == stack->capacity - 1; 
} 

// Stack is empty when top is equal to -1 
int isEmpty(struct Stack* stack) 
{ 
    return stack->top == -1; 
} 

// Function to add an item to stack. It increases top by 1 
void push(struct Stack* stack, int item) 
{ 
    if (isFull(stack)) 
        return; 
    stack->array[++stack->top] = item; 
    printf("%d pushed to stack\\n", item); 
} 

// Function to remove an item from stack. It decreases top by 1 
int pop(struct Stack* stack) 
{ 
    if (isEmpty(stack)) 
        return INT_MIN; 
    return stack->array[stack->top--]; 
} 

// Function to return the top from stack without removing it 
int peek(struct Stack* stack) 
{ 
    if (isEmpty(stack)) 
        return INT_MIN; 
    return stack->array[stack->top]; 
} 

// Driver program to test above functions 
int main() 
{ 
    struct Stack* stack = createStack(100); 

    push(stack, 10); 
    push(stack, 20); 
    push(stack, 30); 

    printf("%d popped from stack\\n", pop(stack)); 

    return 0; 
} 

````

Java
````
/* Java program to implement basic stack 
operations */
class Stack { 
    static final int MAX = 1000; 
    int top; 
    int a[] = new int[MAX]; // Maximum size of Stack 

    boolean isEmpty() 
    { 
        return (top < 0); 
    } 
    Stack() 
    { 
        top = -1; 
    } 

    boolean push(int x) 
    { 
        if (top >= (MAX - 1)) { 
            System.out.println("Stack Overflow"); 
            return false; 
        } 
        else { 
            a[++top] = x; 
            System.out.println(x + " pushed into stack"); 
            return true; 
        } 
    } 

    int pop() 
    { 
        if (top < 0) { 
            System.out.println("Stack Underflow"); 
            return 0; 
        } 
        else { 
            int x = a[top--]; 
            return x; 
        } 
    } 

    int peek() 
    { 
        if (top < 0) { 
            System.out.println("Stack Underflow"); 
            return 0; 
        } 
        else { 
            int x = a[top]; 
            return x; 
        } 
    } 
    
    void print(){ 
    for(int i = top;i>-1;i--){ 
    System.out.print(" "+ a[i]); 
    } 
} 
} 

// Driver code 
class Main { 
    public static void main(String args[]) 
    { 
        Stack s = new Stack(); 
        s.push(10); 
        s.push(20); 
        s.push(30); 
        System.out.println(s.pop() + " Popped from stack"); 
        System.out.println("Top element is :" + s.peek()); 
        System.out.print("Elements present in stack :"); 
        s.print(); 
    } 
} 

````

Python3
````
# Python program for implementation of stack 

# import maxsize from sys module 
# Used to return -infinite when stack is empty 
from sys import maxsize 

# Function to create a stack. It initializes size of stack as 0 
def createStack(): 
    stack = [] 
    return stack 

# Stack is empty when stack size is 0 
def isEmpty(stack): 
    return len(stack) == 0

# Function to add an item to stack. It increases size by 1 
def push(stack, item): 
    stack.append(item) 
    print(item + " pushed to stack ") 
    
# Function to remove an item from stack. It decreases size by 1 
def pop(stack): 
    if (isEmpty(stack)): 
        return str(-maxsize -1) # return minus infinite 
    
    return stack.pop() 

# Function to return the top from stack without removing it 
def peek(stack): 
    if (isEmpty(stack)): 
        return str(-maxsize -1) # return minus infinite 
    return stack[len(stack) - 1] 

# Driver program to test above functions     
stack = createStack() 
push(stack, str(10)) 
push(stack, str(20)) 
push(stack, str(30)) 
print(pop(stack) + " popped from stack") 

````

C#
````
// C# program to implement basic stack 
// operations 
using System; 

namespace ImplementStack { 
class Stack { 
    private int[] ele; 
    private int top; 
    private int max; 
    public Stack(int size) 
    { 
        ele = new int[size]; // Maximum size of Stack 
        top = -1; 
        max = size; 
    } 

    public void push(int item) 
    { 
        if (top == max - 1) { 
            Console.WriteLine("Stack Overflow"); 
            return; 
        } 
        else { 
            ele[++top] = item; 
        } 
    } 

    public int pop() 
    { 
        if (top == -1) { 
            Console.WriteLine("Stack is Empty"); 
            return -1; 
        } 
        else { 
            Console.WriteLine("{0} popped from stack ", ele[top]); 
            return ele[top--]; 
        } 
    } 

    public int peek() 
    { 
        if (top == -1) { 
            Console.WriteLine("Stack is Empty"); 
            return -1; 
        } 
        else { 
            Console.WriteLine("{0} popped from stack ", ele[top]); 
            return ele[top]; 
        } 
    } 

    public void printStack() 
    { 
        if (top == -1) { 
            Console.WriteLine("Stack is Empty"); 
            return; 
        } 
        else { 
            for (int i = 0; i <= top; i++) { 
                Console.WriteLine("{0} pushed into stack", ele[i]); 
            } 
        } 
    } 
} 

// Driver program to test above functions 
class Program { 
    static void Main() 
    { 
        Stack p = new Stack(5); 

        p.push(10); 
        p.push(20); 
        p.push(30); 
        p.printStack(); 
        p.pop(); 
    } 
} 
} 

````

JavaScript
````
/* javascript program to implement basic stack 
operations 
*/
var t = -1; 
    var MAX = 1000; 
    var a = Array(MAX).fill(0); // Maximum size of Stack 

    function isEmpty() { 
        return (t < 0); 
    } 

    function push(x) { 
        if (t >= (MAX - 1)) { 
            console.log("Stack Overflow"); 
            return false; 
        } else { 
        t+=1; 
            a[t] = x; 
            
            console.log(x + " pushed into stack<br/>"); 
            return true; 
        } 
    } 

    function pop() { 
        if (t < 0) { 
            console.log("Stack Underflow"); 
            return 0; 
        } else { 
            var x = a[t]; 
            t-=1; 
            return x; 
        } 
    } 

    function peek() { 
        if (t < 0) { 
            console.log("Stack Underflow"); 
            return 0; 
        } else { 
            var x = a[t]; 
            return x; 
        } 
    } 

    function print() { 
        for (i = t; i > -1; i--) { 
            console.log(" " + a[i]); 
        } 
    } 

        push(10); 
        push(20); 
        push(30); 
        console.log(pop() + " Popped from stack"); 
        console.log("<br/>Top element is :" + peek()); 
        console.log("<br/>Elements present in stack : "); 
        print(); 

````





58





1

```
/* javascript program to implement basic stack 
```

2

```
operations 
```

3

```
*/
```

4

```
var t = -1; 
```

5

```
    var MAX = 1000; 
```

6

```
    var a = Array(MAX).fill(0); // Maximum size of Stack 
```

7

```
​
```

8

```
    function isEmpty() { 
```

9

```
        return (t < 0); 
```

10

```
    } 
```

11

```
​
```

12

```
    function push(x) { 
```

13

```
        if (t >= (MAX - 1)) { 
```

14

```
            console.log("Stack Overflow"); 
```

15

```
            return false; 
```

16

```
        } else { 
```

17

```
        t+=1; 
```

18

```
            a[t] = x; 
```

19

```
            
```

20

```
            console.log(x + " pushed into stack<br/>"); 
```

21

```
            return true; 
```

22

```
        } 
```

23

```
    } 
```

24

```
​
```

25

```
    function pop() { 
```

26

```
        if (t < 0) { 
```

27

```
            console.log("Stack Underflow"); 
```

28

```
            return 0; 
```

29

```
        } else { 
```

30

```
            var x = a[t]; 
```

31

```
            t-=1; 
```

32

```
            return x; 
```

33

```
        } 
```

34

```
    } 
```

35

```
​
```

36

```
    function peek() { 
```

37

```
        if (t < 0) { 
```

38

```
            console.log("Stack Underflow"); 
```

39

```
            return 0; 
```

40

```
        } else { 
```

41

```
            var x = a[t]; 
```

42

```
            return x; 
```

43

```
        } 
```

44

```
    } 
```

45

```
​
```

46

```
    function print() { 
```

47

```
        for (i = t; i > -1; i--) { 
```

48

```
            console.log(" " + a[i]); 
```

49

```
        } 
```

50

```
    } 
```

51

```
​
```

52

```
        push(10); 
```

53

```
        push(20); 
```

54

```
        push(30); 
```

55

```
        console.log(pop() + " Popped from stack"); 
```

56

```
        console.log("<br/>Top element is :" + peek()); 
```

57

```
        console.log("<br/>Elements present in stack : "); 
```

58

```
        print();
```









  
**Output**
```

10 pushed into stack
20 pushed into stack
30 pushed into stack
30 Popped from stack
Top element is : 20
Elements present in stack : 20 10 
```
### Complexity Analysis:

* ****Time Complexity****:
  + `push`: O(1)
  + `pop`: O(1)
  + `peek`: O(1)
  + `is_empty`: O(1)
  + is\\_full: O(1)
* ****Auxiliary Space****: O(n), where n is the number of items in the stack.

Advantages of Array Implementation:
-----------------------------------

* Easy to implement.
* Memory is saved as pointers are not involved.

Disadvantages of Array Implementation:
--------------------------------------

* It is not dynamic i.e., it doesn’t grow and shrink depending on needs
  at runtime. [But in case of dynamic sized arrays like vector in C++,
  list in Python, ArrayList in Java, stacks can grow and shrink with
  array implementation as well].
* The total size of the stack must be defined beforehand.', e'Stack is a linear data structurewhich follows LIFO principle. In this article, we will learn how to implement Stack using
Arrays. In Array-based approach, all stack-related operations are
executed using arrays. Let’s see how we can implement each operation on
the stack utilizing the Array Data Structure.', 'Implement Stack using Array', 2, null, '95713603-63d1-4b75-8a89-1acdc0977459', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('cf945f38-3396-48d8-815b-81e37df21182', e'****Stack Operations:****
-------------------------

* [****push()****](https://www.geeksforgeeks.org/stack-push-and-pop-in-c-stl/)****:****
  Insert a new element into the stack i.e just insert a new element at
  the beginning of the linked list.
* [****pop()****](https://www.geeksforgeeks.org/stack-push-and-pop-in-c-stl/)****:****
  Return the top element of the Stack i.e simply delete the first
  element from the linked list.
* [****peek()****](https://www.geeksforgeeks.org/stack-peek-method-in-java/)****:**** Return the top element.
* ****display():**** Print all elements in Stack.

Push Operation:
---------------

> * Initialise a node
> * Update the value of that node by data i.e. ****node->data = data****
> * Now link this node to the top of the linked list
> * And update top pointer to the current node

Pop Operation:
--------------

> * First Check whether there is any node present in the linked list or
>   not, if not then return
> * Otherwise make pointer let say ****temp**** to the top node and move forward the top node by 1 step
> * Now free this temp node

Peek Operation:
---------------

> * Check if there is any node present or not, if not then
>   return.
> * Otherwise return the value of top node of the linked list

Display Operation:
------------------

> * Take a ****temp**** node and initialize it with top pointer
> * Now start traversing temp till it encounters NULL
> * Simultaneously print the value of the temp node

 

Below is the implementation of the above operations 

C++
````
// C++ program to implement a stack using singly linked list
#include <bits/stdc++.h>
using namespace std;

// Class representing a node in the linked list
class Node {
public:
    int data;
    Node* next;
    Node(int new_data) {
        this->data = new_data;
        this->next = nullptr;
    }
};

// Class to implement stack using a singly linked list
class Stack {

    // head of the linked list
    Node* head;

public:
    // Constructor to initialize the stack
    Stack() { this->head = nullptr; }

    // Function to check if the stack is empty
    bool isEmpty() {
      
        // If head is nullptr, the stack is empty
        return head == nullptr;
    }

    // Function to push an element onto the stack
    void push(int new_data) {
      
        // Create a new node with given data
        Node* new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (!new_node) {
            cout << "\\nStack Overflow";
        }

        // Link the new node to the current top node
        new_node->next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    void pop() {

        // Check for stack underflow
        if (this->isEmpty()) {
            cout << "\\nStack Underflow" << endl;
        }
        else {
            // Assign the current top to a temporary
            // variable
            Node* temp = head;

            // Update the top to the next node
            head = head->next;

            // Deallocate the memory of the old top node
            delete temp;
        }
    }

    // Function to return the top element of the stack
    int peek() {

        // If stack is not empty, return the top element
        if (!isEmpty())
            return head->data;
        else {
            cout << "\\nStack is empty";
            return INT_MIN;
        }
    }
};

// Driver program to test the stack implementation
int main() {
    // Creating a stack
    Stack st;

    // Push elements onto the stack
    st.push(11);
    st.push(22);
    st.push(33);
    st.push(44);

    // Print top element of the stack
    cout << "Top element is " << st.peek() << endl;

    // removing two elemements from the top
      cout << "Removing two elements..." << endl;
    st.pop();
    st.pop();

    // Print top element of the stack
    cout << "Top element is " << st.peek() << endl;

    return 0;
}

````

C
````
// C program to implement a stack using singly linked list
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

// Struct representing a node in the linked list
typedef struct Node {
    int data;
    struct Node* next;
} Node;
Node* createNode(int new_data) {
    Node* new_node = (Node*)malloc(sizeof(Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Struct to implement stack using a singly linked list
typedef struct Stack {
    Node* head;
} Stack;

// Constructor to initialize the stack
void initializeStack(Stack* stack) { stack->head = NULL; }

// Function to check if the stack is empty
int isEmpty(Stack* stack) {
  
    // If head is NULL, the stack is empty
    return stack->head == NULL;
}

// Function to push an element onto the stack
void push(Stack* stack, int new_data) {
  
    // Create a new node with given data
    Node* new_node = createNode(new_data);

    // Check if memory allocation for the new node failed
    if (!new_node) {
        printf("\\nStack Overflow");
        return;
    }

    // Link the new node to the current top node
    new_node->next = stack->head;

    // Update the top to the new node
    stack->head = new_node;
}

// Function to remove the top element from the stack
void pop(Stack* stack) {
  
    // Check for stack underflow
    if (isEmpty(stack)) {
        printf("\\nStack Underflow\\n");
        return;
    }
    else {
      
        // Assign the current top to a temporary variable
        Node* temp = stack->head;

        // Update the top to the next node
        stack->head = stack->head->next;

        // Deallocate the memory of the old top node
        free(temp);
    }
}

// Function to return the top element of the stack
int peek(Stack* stack) {
  
    // If stack is not empty, return the top element
    if (!isEmpty(stack))
        return stack->head->data;
    else {
        printf("\\nStack is empty");
        return INT_MIN;
    }
}

// Driver program to test the stack implementation
int main() {
  
    // Creating a stack
    Stack stack;
    initializeStack(&stack);

    // Push elements onto the stack
    push(&stack, 11);
    push(&stack, 22);
    push(&stack, 33);
    push(&stack, 44);

    // Print top element of the stack
    printf("Top element is %d\\n", peek(&stack));

  
      // removing two elemements from the top
      printf("Removing two elements...\\n");
    pop(&stack);
    pop(&stack);

    // Print top element of the stack
    printf("Top element is %d\\n", peek(&stack));

    return 0;
}

````

Java
````
// Java program to implement a stack using singly linked
// list

// Class representing a node in the linked list
class Node {
    int data;
    Node next;
    Node(int new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // Head of the linked list
    Node head;

    // Constructor to initialize the stack
    Stack() { this.head = null; }

    // Function to check if the stack is empty
    boolean isEmpty() {
      
        // If head is null, the stack is empty
        return head == null;
    }

    // Function to push an element onto the stack
    void push(int new_data) {
      
        // Create a new node with given data
        Node new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (new_node == null) {
            System.out.println("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    void pop() {
      
        // Check for stack underflow
        if (isEmpty()) {
            System.out.println("\\nStack Underflow");
            return;
        }
        else {
          
            // Assign the current top to a temporary
            // variable
            Node temp = head;

            // Update the top to the next node
            head = head.next;

            // Deallocate the memory of the old top node
            temp = null;
        }
    }

    // Function to return the top element of the stack
    int peek() {
      
        // If stack is not empty, return the top element
        if (!isEmpty())
            return head.data;
        else {
            System.out.println("\\nStack is empty");
            return Integer.MIN_VALUE;
        }
    }
}

// Driver code
public class Main {
    public static void main(String[] args)
    {
        // Creating a stack
        Stack st = new Stack();

        // Push elements onto the stack
        st.push(11);
        st.push(22);
        st.push(33);
        st.push(44);

        // Print top element of the stack
        System.out.println("Top element is " + st.peek());

        // removing two elemements from the top
          System.out.println("Removing two elements...");
        st.pop();
        st.pop();

        // Print top element of the stack
        System.out.println("Top element is " + st.peek());
    }
}

````

Python
````
# Java program to implement a stack using singly linked
# list

# Class representing a node in the linked list
class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Class to implement stack using a singly linked list
class Stack:
    def __init__(self):

        # head of the linked list
        self.head = None

    # Function to check if the stack is empty
    def is_empty(self):

        # If head is None, the stack is empty
        return self.head is None

    # Function to push an element onto the stack
    def push(self, new_data):

        # Create a new node with given data
        new_node = Node(new_data)

        # Check if memory allocation for the new node failed
        if not new_node:
            print("\\nStack Overflow")
            return

        # Link the new node to the current top node
        new_node.next = self.head

        # Update the top to the new node
        self.head = new_node

    # Function to remove the top element from the stack
    def pop(self):

        # Check for stack underflow
        if self.is_empty():
            print("\\nStack Underflow")
        else:

            # Assign the current top to a temporary variable
            temp = self.head

            # Update the top to the next node
            self.head = self.head.next

            # Deallocate the memory of the old top node
            del temp

    # Function to return the top element of the stack
    def peek(self):

        # If stack is not empty, return the top element
        if not self.is_empty():
            return self.head.data
        else:
            print("\\nStack is empty")
            return float(\'-inf\')


# Creating a stack
st = Stack()

# Push elements onto the stack
st.push(11)
st.push(22)
st.push(33)
st.push(44)

# Print top element of the stack
print("Top element is", st.peek())

# removing two elemements from the top
print("Removing two elements...");
st.pop()
st.pop()

# Print top element of the stack
print("Top element is", st.peek())

````

C#
````
// C# program to implement a stack using singly linked list
using System;

// Class representing a node in the linked list
class Node {
    public int data;
    public Node next;
    public Node(int new_data)
    {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // head of the linked list
    private Node head;

    // Constructor to initialize the stack
    public Stack() { this.head = null; }

    // Function to check if the stack is empty
    public bool isEmpty()
    {

        // If head is null, the stack is empty
        return head == null;
    }

    // Function to push an element onto the stack
    public void push(int new_data)
    {

        // Create a new node with given data
        Node new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (new_node == null) {
            Console.WriteLine("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    public void pop()
    {

        // Check for stack underflow
        if (this.isEmpty()) {
            Console.WriteLine("\\nStack Underflow");
        }
        else {

            // Update the top to the next node
            head = head.next;
            /* No need to manually free the memory of the
             * old head in C# */
        }
    }

    // Function to return the top element of the stack
    public int peek()
    {

        // If stack is not empty, return the top element
        if (!isEmpty())
            return head.data;
        else {
            Console.WriteLine("\\nStack is empty");
            return int.MinValue;
        }
    }
}

// Driver program to test the stack implementation
class GfG {
    static void Main(string[] args)
    {

        // Creating a stack
        Stack st = new Stack();

        // Push elements onto the stack
        st.push(11);
        st.push(22);
        st.push(33);
        st.push(44);

        // Print top element of the stack
        Console.WriteLine("Top element is " + st.peek());

        // removing two elemements from the top
          Console.WriteLine("Removing two elements...");
        st.pop();
        st.pop();

        // Print top element of the stack
        Console.WriteLine("Top element is " + st.peek());
    }
}

````

JavaScript
````
// Javascript program to implement a stack using singly
// linked list

// Class representing a node in the linked list
class Node {
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // Constructor to initialize the stack
    constructor() { this.head = null; }

    // Function to check if the stack is empty
    isEmpty() {
    
        // If head is null, the stack is empty
        return this.head === null;
    }

    // Function to push an element onto the stack
    push(new_data) {
    
        // Create a new node with given data
        const new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (!new_node) {
            console.log("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = this.head;

        // Update the top to the new node
        this.head = new_node;
    }

    // Function to remove the top element from the stack
    pop() {
    
        // Check for stack underflow
        if (this.isEmpty()) {
            console.log("\\nStack Underflow");
        }
        else {
        
            // Assign the current top to a temporary
            // variable
            let temp = this.head;

            // Update the top to the next node
            this.head = this.head.next;

            // Deallocate the memory of the old top node
            temp = null;
        }
    }

    // Function to return the top element of the stack
    peek() {
    
        // If stack is not empty, return the top element
        if (!this.isEmpty())
            return this.head.data;
        else {
            console.log("\\nStack is empty");
            return Number.MIN_VALUE;
        }
    }
}

// Driver program to test the stack implementation
const st = new Stack();

// Push elements onto the stack
st.push(11);
st.push(22);
st.push(33);
st.push(44);

// Print top element of the stack
console.log("Top element is " + st.peek());

// removing two elemements from the top
console.log("Removing two elements...");
st.pop();
st.pop();

// Print top element of the stack
console.log("Top element is " + st.peek());

````

  
**Output**
```

Top element is 44
Top element is 22

```

****Time Complexity:****
O(1), for all push(), pop(), and peek(), as we are not performing any
kind of traversal over the list. We perform all the operations through
the current pointer only.  
****Auxiliary Space:**** O(N), where N is the size of the stack


In this implementation, we define a Node class that represents a node
in the linked list, and a Stack class that uses this node class to
implement the stack. The head attribute of the Stack class points to the
top of the stack (i.e., the first node in the linked list).

To push an item onto the stack, we create a new node with the given
item and set its next pointer to the current head of the stack. We then
set the head of the stack to the new node, effectively making it the new
top of the stack.

To pop an item from the stack, we simply remove the first node from the
linked list by setting the head of the stack to the next node in the
list (i.e., the node pointed to by the next pointer of the current
head). We return the data stored in the original head node, which is the
item that was removed from the top of the stack.

### Benefits of implementing a stack using a singly linked list include:

****Dynamic memory allocation****: The size of the stack can be increased or decreased dynamically by
adding or removing nodes from the linked list, without the need to
allocate a fixed amount of memory for the stack upfront.

****Efficient memory usage:**** Since nodes in a singly linked list only have a next pointer and not a
prev pointer, they use less memory than nodes in a doubly linked
list.

****Easy implementation****: Implementing a stack using a singly linked list is straightforward
and can be done using just a few lines of code.

****Versatile****: Singly linked lists can be used to implement other data structures
such as queues, linked lists, and trees.

In summary, implementing a stack using a singly linked list is a simple
and efficient way to create a dynamic stack data structure in
Python.

### Real time examples of stack:

Stacks are used in various real-world scenarios where a last-in,
first-out (LIFO) data structure is required. Here are some examples of
real-time applications of stacks:

****Function call stack****: When a function is called in a program, the return address and all
the function parameters are pushed onto the function call stack. The
stack allows the function to execute and return to the caller function
in the reverse order in which they were called.

****Undo/Redo operations:****
In many applications, such as text editors, image editors, or web
browsers, the undo and redo functionalities are implemented using a
stack. Every time an action is performed, it is pushed onto the stack.
When the user wants to undo the last action, the top element of the
stack is popped and the action is reversed.

****Browser history:**** Web browsers use stacks to keep track of the pages visited by the user.
Every time a new page is visited, its URL is pushed onto the stack. When
the user clicks the “Back” button, the last visited URL is popped from
the stack and the user is directed to the previous page.

****Expression evaluation****: Stacks are used in compilers and interpreters to evaluate
expressions. When an expression is parsed, it is converted into postfix
notation and pushed onto a stack. The postfix expression is then
evaluated using the stack.

****Call stack in recursion:****
When a recursive function is called, its call is pushed onto the stack.
The function executes and calls itself, and each subsequent call is
pushed onto the stack. When the recursion ends, the stack is popped, and
the program returns to the previous function call.

In summary, stacks are widely used in many applications where LIFO
functionality is required, such as function calls, undo/redo operations,
browser history, expression evaluation, and recursive function
calls.
', 'To implement a stack using the singly linked list concept, all the singly linked list operations should be performed based on Stack operations LIFO(last in first out) and with the help of that knowledge, we are going to implement a stack using a singly linked list.', 'Implement a stack using singly linked list', 3, null, '95713603-63d1-4b75-8a89-1acdc0977459', null);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, exercise_id) VALUES ('a3e9b26a-8405-4132-a638-8fa5b1a3731e', e'Applications of Stacks:
-----------------------

* ****Function calls:****
  Stacks are used to keep track of the return addresses of function
  calls, allowing the program to return to the correct location after a
  function has finished executing.
* ****Recursion:**** Stacks are used to store the local variables and return addresses of
  recursive function calls, allowing the program to keep track of the
  current state of the recursion.
* ****Expression evaluation:**** Stacks are used to evaluate expressions in postfix notation (Reverse
  Polish Notation).
* ****Syntax parsing:**** Stacks are used to check the validity of syntax in programming
  languages and other formal languages.
* ****Memory management:**** Stacks are used to allocate and manage memory in some operating
  systems and programming languages.
* Used to solve popular problems like [Next Greater](https://www.geeksforgeeks.org/next-greater-element/), [Previous Greater](https://www.geeksforgeeks.org/previous-greater-element/), [Next Smaller](https://www.geeksforgeeks.org/next-smaller-element/), [Previous Smaller](https://www.geeksforgeeks.org/find-the-nearest-smaller-numbers-on-left-side-in-an-array/), [Largest Area in a Histogram](https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-using-stack/) and [Stock Span Problems](https://www.geeksforgeeks.org/the-stock-span-problem/).

Advantages of Stacks:
---------------------

* ****Simplicity:**** Stacks are a simple and easy-to-understand data structure, making
  them suitable for a wide range of applications.
* ****Efficiency:**** Push and pop operations on a stack can be performed in constant time ****(O(1))****, providing efficient access to data.
* ****Last-in, First-out (LIFO):****
  Stacks follow the LIFO principle, ensuring that the last element added
  to the stack is the first one removed. This behavior is useful in many
  scenarios, such as function calls and expression evaluation.
* ****Limited memory usage:**** Stacks only need to store the elements that have been pushed onto
  them, making them memory-efficient compared to other data
  structures.

Disadvantages of Stacks:
------------------------

* ****Limited access:****
  Elements in a stack can only be accessed from the top, making it
  difficult to retrieve or modify elements in the middle of the
  stack.
* ****Potential for overflow:**** If more elements are pushed onto a stack than it can hold, an
  overflow error will occur, resulting in a loss of data.
* ****Not suitable for random access:**** Stacks do not allow for random access to elements, making them
  unsuitable for applications where elements need to be accessed in a
  specific order.
* ****Limited capacity:****
  Stacks have a fixed capacity, which can be a limitation if the number
  of elements that need to be stored is unknown or highly
  variable.
', e'A stack is a linear data structure
in which the insertion of a new element and removal of an existing
element takes place at the same end represented as the top of the stack.', 'Applications, Advantages and Disadvantages of Stack', 4, null, '95713603-63d1-4b75-8a89-1acdc0977459', null);

INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (1, 'Data Structure', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (2, 'Algorithm', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (5, 'Problem Solving', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (6, 'Array', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (7, 'Queue', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (8, 'Recursive', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (9, 'Dynamic Programming', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (10, 'Matrix', null);


INSERT INTO public.course_category (course_id, category_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 5);
INSERT INTO public.course_category (course_id, category_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 1);
INSERT INTO public.course_category (course_id, category_id) VALUES ('e9d2858c-482e-4b04-8317-b93ce60c3581', 1);
INSERT INTO public.course_category (course_id, category_id) VALUES ('58220cca-f7ec-4188-9921-18e6ea20e4d7', 2);
INSERT INTO public.course_category (course_id, category_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 1);
INSERT INTO public.course_category (course_id, category_id) VALUES ('f19021ae-42fd-4c25-814c-f06027de04a9', 2);
INSERT INTO public.course_category (course_id, category_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 2);
INSERT INTO public.course_category (course_id, category_id) VALUES ('a24c71fe-2e77-4352-8449-a448ace4d400', 2);
INSERT INTO public.course_category (course_id, category_id) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', 1);
INSERT INTO public.course_category (course_id, category_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 1);
INSERT INTO public.course_category (course_id, category_id) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', 7);
INSERT INTO public.course_category (course_id, category_id) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', 6);
INSERT INTO public.course_category (course_id, category_id) VALUES ('58220cca-f7ec-4188-9921-18e6ea20e4d7', 8);
INSERT INTO public.course_category (course_id, category_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 9);
INSERT INTO public.course_category (course_id, category_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 10);

INSERT INTO public.sections (section_id, name) VALUES (1, 'Free Courses');
INSERT INTO public.sections (section_id, name) VALUES (2, 'Featured Courses');

INSERT INTO public.course_section (course_id, section_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('e9d2858c-482e-4b04-8317-b93ce60c3581', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('58220cca-f7ec-4188-9921-18e6ea20e4d7', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('f19021ae-42fd-4c25-814c-f06027de04a9', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('a24c71fe-2e77-4352-8449-a448ace4d400', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('c9b04774-3a81-43ab-ace6-5242360d9e07', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('95713603-63d1-4b75-8a89-1acdc0977459', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('e9d2858c-482e-4b04-8317-b93ce60c3581', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('58220cca-f7ec-4188-9921-18e6ea20e4d7', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('f19021ae-42fd-4c25-814c-f06027de04a9', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('a24c71fe-2e77-4352-8449-a448ace4d400', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('c9b04774-3a81-43ab-ace6-5242360d9e07', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('95713603-63d1-4b75-8a89-1acdc0977459', 2);



INSERT INTO public.problems (problem_id, acceptance_rate, description, problem_level, problem_name, score, is_available, is_published, problem_structure) VALUES ('7328995b-6079-4bd9-8be0-7c9152d5a73b', 0.00, e'You are given two integer arrays `nums1` and `nums2`, **sorted in non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.

**Merge** `nums1` and `nums2` into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be _stored_ inside the array `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.

#### Example 1:

```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
```

#### Example 2:

```
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
```

#### Example 3:

```
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
```', 'easy', e'Merge sorted array', 2, false, true, e'Problem Name: Merge Sorted Array
Function Name: mergeSortedArray
Input Structure:
Input Field: list<int> num1
Input Field: int m
Input Field: list<int> num2
Input Field: int n
Output Structure:
Output Field: list<int> result');

INSERT INTO public.problems (problem_id, acceptance_rate, description, problem_level, problem_name, score, is_available, is_published, problem_structure) VALUES ('73c532f9-4d55-4737-ae19-3006e02864cc', 0.00, e'You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the i<sup>th</sup> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`\'s.

Increment the large integer by one and return the resulting array of digits.

#### Example 1:

```
Input: digits = [1,2,3]
Output: [1,2,4]
```

#### Example 2:

```
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
```

#### Example 3:

```
Input: digits = [9]
Output: [1,0]
```', 'easy', 'Plus one', 2, false, true, e'Problem Name: Plus One
Function Name: plusOne
Input Structure:
Input Field: list<int> digits
Output Structure:
Output Field: list<int> result');
INSERT INTO public.problems (problem_id, acceptance_rate, description, problem_level, problem_name, score, is_available, is_published, problem_structure) VALUES ('82978535-a8da-46e1-a39a-31a232e3fffc', 0.00, e'Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with `O(log n)` runtime complexity.

#### Example 1:

```
Input: nums = [1,3,5,6], target = 5
Output: 2
```

#### Example 2:

```
Input: nums = [1,3,5,6], target = 2
Output: 1
```

#### Example 3:

```
Input: nums = [1,3,5,6], target = 7
Output: 4
```', 'easy', 'Search Insert Position', 2, false, true, e'Problem Name: Search Insert Position
Function Name: searchInsertPosition
Input Structure:
Input Field: list<int> nums
Input Field: int target
Output Structure:
Output Field: int result
');
INSERT INTO public.problems (problem_id, acceptance_rate, description, problem_level, problem_name, score, is_available, is_published, problem_structure) VALUES ('e608ebb7-07ef-4a2f-8081-92e5993e6118', 0.00, e'Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

#### Example 1:

```
Input: nums = [2,2,1]
Output: 1
```

#### Example 2:

```
Input: nums = [4,1,2,1,2]
Output: 4
```

#### Example 3:

```
Input: nums = [1]
Output: 1
```', 'easy', 'Single Number', 2, false, true, e'Problem Name: Single Number
Function Name: singleNumber
Input Structure:
Input Field: list<int> nums
Output Structure:
Output Field: int result');
INSERT INTO public.problems (problem_id, acceptance_rate, description, problem_level, problem_name, score, is_available, is_published, problem_structure) VALUES ('591b3457-2157-4d61-b03d-d53f8666342c', 0.00, e'Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

#### Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
```

#### Example 2:

```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

#### Example 3:

```
Input: nums = [3,3], target = 6
Output: [0,1]
```', 'easy', 'Two sum', 2, false, true, e'Function Name: twoSum
Input Structure:
Input Field: list<int> nums
Input Field: int target
Output Structure:
Output Field: list<int> result');

--INSERT INTO public.problems (problem_id, acceptance_rate, description, problem_level, problem_name, score, is_available, is_published, problem_structure) VALUES ('79751b4f-cad0-42ef-a592-f67298d08003', 0.00, 'string', 'string', 'string', 0, true, true, 'string');

INSERT INTO public.problems (
    problem_id,
    acceptance_rate,
    description,
    problem_level,
    problem_name,
    score,
    is_available,
    is_published,
    problem_structure
)
VALUES (
           'c3756efe-d408-4e99-844e-a55021fb7c02', -- Replace with a unique UUID
           0.00,
           e'Given a string `s` containing just the characters \'(\', \')\', \'{\', \'}\', \'[\', and \']\', determine if the input string is valid.

       An input string is valid if:
       1. Open brackets must be closed by the same type of brackets.
       2. Open brackets must be closed in the correct order.

       #### Example 1:

       ```
       Input: s = "()"
       Output: true
       ```

       #### Example 2:

       ```
       Input: s = "()[]{}"
       Output: true
       ```

       #### Example 3:

       ```
       Input: s = "(]"
       Output: false
       ```

       #### Example 4:

       ```
       Input: s = "([)]"
       Output: false
       ```

       #### Example 5:

       ```
       Input: s = "{[]}"
       Output: true
       ```

       #### Constraints:
       - 1 <= s.length <= 10^4
       - `s` consists of parentheses only: \'(\', \')\', \'{\', \'}\', \'[\', and \']\'.',
           'easy',
           'Valid Parentheses',
           3,
           true,
           false,
           e'Function Name: isValid
       Input Structure:
       Input Field: string s
       Output Structure:
       Output Field: boolean result'
       );


INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('23f35de8-7a82-4688-9253-6b5330894296', e'1
1
1
0
																										
0', '1', null, 1, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('eb1f21cf-b8fa-41cc-aea8-7224a85998c6', e'7
1 3 5 0 0 0 0
3
4
2 4 6 7
4', '1 2 3 4 5 6 7', null, 2, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('607a6878-899a-4f10-a3ff-106e36f6db7b', e'6
4 5 6 0 0 0
3
3
1 2 3
3', '1 2 3 4 5 6', null, 3, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('285e81b0-b13c-4a30-b861-228edd8fa05a', e'0
0
1
1', '1', null, 4, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('7d1d2398-47fd-480a-a662-b8bb892656a4', e'6
1 2 3 0 0 0
3
3
2 5 6
3', '1 2 2 3 5 6', null, 5, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('0ccce6f3-b6f1-4184-b13d-0aec69dfc148', '1
9', '1 0', null, 1, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('00222cc2-be0a-4b78-8e49-8a7572418dad', '4
4 3 2 1', '4 3 2 2', null, 2, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('6fbb0344-0bc8-4df2-a64d-785fb373a9a7', '3
9 9 9', '1 0 0 0', null, 3, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('8a85700f-ffb4-438b-8183-8f3aa1999c24', '39
7 2 8 5 0 9 1 2 9 5 3 6 6 7 3 2 8 4 3 7 9 5 7 7 4 7 4 9 4 7 0 1 1 1 7 4 0 0 6', '7 2 8 5 0 9 1 2 9 5 3 6 6 7 3 2 8 4 3 7 9 5 7 7 4 7 4 9 4 7 0 1 1 1 7 4 0 0 7', null, 4, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('d725244d-31f7-4ddc-b494-dc54cab67964', '3
1 2 3', '1 2 4', null, 5, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('4a9c10f0-eb2a-4b19-8e19-9edf117e76d8', '4
1 0 0 0', '1 0 0 1', null, 6, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('21a234fc-adc3-4012-9802-63ab716fb8c4', e'4
1 3 5 6
5', '2', null, 1, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('4703bfe2-5040-49f7-b728-bdea2b6c97e4', e'4
1 3 5 6
7', '4', null, 2, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('e8698f62-9051-49e0-8610-56c27a7dcb96', e'4
1 3 5 6
4', '2', null, 3, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('da031658-0ac7-4aae-99e5-6c01e2862b29', e'4
1 3 5 6
0', '0', null, 4, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('2becdcf8-1773-4d3a-b759-63fea450106c', e'4
1 3 5 6
2', '1', null, 5, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('93cfd193-1620-4e60-8c84-983041d205f0', '3
0 1 0', '1', null, 1, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('fad6d724-b8ce-4b6b-a1fb-f5a1e8b7e003', '1
1', '1', null, 2, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('f8e22dda-b2cf-473e-b10f-ca1069fd5630', '5
4 1 2 1 2', '4', null, 3, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('4343cfa0-4508-4157-b986-23e04fc60069', '5
3 3 7 8 8', '7', null, 4, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('e15bef99-a6dd-46a1-bbb0-af5ed9d06e09', '3
2 2 1', '1', null, 5, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('abf531db-e157-49e9-8310-beb37cffe58a', e'2
3 3
6', '0 1', null, 1, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('78dd79f1-3691-42da-9fcf-37e7c96c439f', e'4
1 0 0 7
8', '0 3', null, 2, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('5aedba91-125d-4cdc-99f3-43fc3d431bad', e'3
3 2 4
6', '1 2', null, 3, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('d915b2ea-eb2a-450b-aa28-e506bf55a856', e'4
2 7 11 15
9', '0 1', null, 4, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('ddd22af2-0e71-4768-ad6c-b7307395c108', e'4
4 6 10 2
12', '1 2', null, 5, '591b3457-2157-4d61-b03d-d53f8666342c');



INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (50, 'C (GCC 9.2.0)', 'C');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (54, 'C++ (GCC 9.2.0)', 'C++');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (51, 'C# (Mono 6.6.0.161)', 'C#');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (63, 'JavaScript (Node.js 12.14.0)', 'JavaScript');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (71, 'Python (3.8.1)', 'Python');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (74, 'TypeScript (3.7.4)', 'TypeScript');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (91, 'Java (JDK 17.0.6)', 'Java');


INSERT INTO public.problem_category (category_id, problem_id) VALUES (1, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (1, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (1, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (1, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (5, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (6, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (2, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (6, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (2, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (6, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (2, '591b3457-2157-4d61-b03d-d53f8666342c');

INSERT INTO public.problem_comments(
    comment_id, content, created_at, last_modified_at, user_uid, user_uuid,
    parent_comment_id, problem_id, replied_comment_id, number_of_likes, is_modified
) VALUES
('3177f55e-8fca-459c-96d4-90e51dae4588', 'i run now 7',
 '2025-02-21 16:43:00.683279+07', '2025-02-22 15:13:23.367305+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 NULL, '7328995b-6079-4bd9-8be0-7c9152d5a73b', NULL, 0, NULL),

('0dc0dfa1-cca9-42b4-bfad-f9379fdd139e', 'i run now 5',
 '2025-02-22 16:13:31.790966+07', '2025-02-22 16:13:58.301744+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 NULL, '7328995b-6079-4bd9-8be0-7c9152d5a73b', NULL, 0, NULL),

('1db65ea6-4237-4219-86ad-1f8bcee67e29', 'i run now 8',
 '2025-02-21 16:46:37.991912+07', '2025-02-22 13:07:38.136802+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 '3177f55e-8fca-459c-96d4-90e51dae4588', '7328995b-6079-4bd9-8be0-7c9152d5a73b',
 '3177f55e-8fca-459c-96d4-90e51dae4588', 0, NULL),

('9be6a2bc-e4b1-4b56-ac5d-77c06ac1b6df', 'i run now 3',
 '2025-02-21 22:02:03.547642+07', '2025-02-21 22:02:03.547642+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 NULL, '7328995b-6079-4bd9-8be0-7c9152d5a73b', NULL, 0, NULL),

('5ddd3184-4713-419c-8611-9cfd5e984c96', 'i run now 4',
 '2025-02-21 16:45:50.394167+07', '2025-02-22 17:56:49.763188+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 '3177f55e-8fca-459c-96d4-90e51dae4588', '7328995b-6079-4bd9-8be0-7c9152d5a73b',
 '3177f55e-8fca-459c-96d4-90e51dae4588', 0, NULL),

('c3265443-b55a-4f3b-b9b5-f00886ae409a', 'i run now 2',
 '2025-02-21 16:46:08.087696+07', '2025-02-22 18:11:22.526227+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 '3177f55e-8fca-459c-96d4-90e51dae4588', '7328995b-6079-4bd9-8be0-7c9152d5a73b',
 '5ddd3184-4713-419c-8611-9cfd5e984c96', 0, NULL);



INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('838dd085-dcea-4d9e-82f7-f9e8058d446c', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '573a0d23-196a-6b35-cf9c-6e168c18596a', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 15:04:07.230000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('23e66b94-4802-4124-8e51-227d021d4987', e'import sys
def searchInsertPosition(nums, target):
    l = 0
    r = len(nums)

    while l < r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[m] < target:
        l = m + 1
      else:
        r = m

    return l

if __name__ == \'__main__\':
    sizenums = int(input())
    nums = list(map(int, input().split()[:sizenums]))

    target = int(input())
    result = searchInsertPosition(nums, target)
    print(result)
', 'Python (3.8.1)', 20, 0, '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '82978535-a8da-46e1-a39a-31a232e3fffc', true, '2025-03-05 15:20:59.458000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('7eb3e1a4-6227-450d-a99f-2e846561c49b', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 14:57:17.134000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('cb1cf4b9-bbd4-4481-897e-7c96302d87f4', e'function plusOne(digits) {
    for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i] += 1;
            return digits;
        }
        digits[i] = 0;
    }
    return [1].concat(digits);
}

const input = require(\'fs\').readFileSync(\'/dev/stdin\', \'utf8\').trim().split(\'\\n\').join(\' \').split(\' \');
const size_digits = parseInt(input.shift());
const digits = input.splice(0, size_digits).map(Number);

const result = plusOne(digits);
console.log(result.join(\' \'));
', 'JavaScript (Node.js 12.14.0)', 20, 0, '59208f4f-d6ae-0792-0317-f36822578f81', '73c532f9-4d55-4737-ae19-3006e02864cc', true, '2025-03-05 15:19:20.024000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('4fd9a7eb-92cf-4899-97c8-f49c5ba24f66', e'import sys
def searchInsertPosition(nums, target):
    l = 0
    r = len(nums)

    while l < r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[m] < target:
        l = m + 1
      else:
        r = m

    return l

if __name__ == \'__main__\':
    sizenums = int(input())
    nums = list(map(int, input().split()[:sizenums]))

    target = int(input())
    result = searchInsertPosition(nums, target)
    print(result)
', 'Python (3.8.1)', 20, 0, '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '82978535-a8da-46e1-a39a-31a232e3fffc', true, '2025-03-05 15:20:59.458000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('34971531-94fa-4b3c-af60-7fdc611ce206', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 15:16:27.669000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('70e9ab41-1106-4562-b855-4427d48de154', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 15, 0, 'cabb0e34-1cdb-7818-5ab4-4018b7c81fe4', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 15:15:19.350000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('c89dfa85-9aeb-4948-926f-f10e6fc1f0de', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, 'aef57c4e-4011-1938-0086-86b46a63617c', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 15:04:07.230000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('835e0efb-6ab0-4c0b-ac69-5f9724b46022', e'function plusOne(digits) {
    for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i] += 1;
            return digits;
        }
        digits[i] = 0;
    }
    return [1].concat(digits);
}

const input = require(\'fs\').readFileSync(\'/dev/stdin\', \'utf8\').trim().split(\'\\n\').join(\' \').split(\' \');
const size_digits = parseInt(input.shift());
const digits = input.splice(0, size_digits).map(Number);

const result = plusOne(digits);
console.log(result.join(\' \'));
', 'JavaScript (Node.js 12.14.0)', 20, 0, '573a0d23-196a-6b35-cf9c-6e168c18596a', '73c532f9-4d55-4737-ae19-3006e02864cc', true, '2025-03-05 15:19:20.024000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('1db561e3-4482-41bf-9750-9faaf1c6d133', e'import sys
def searchInsertPosition(nums, target):
    l = 0
    r = len(nums)

    while l < r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[m] < target:
        l = m + 1
      else:
        r = m

    return l

if __name__ == \'__main__\':
    sizenums = int(input())
    nums = list(map(int, input().split()[:sizenums]))

    target = int(input())
    result = searchInsertPosition(nums, target)
    print(result)
', 'Python (3.8.1)', 20, 0, '341c45e0-d57e-4467-21fa-9ec708e60365', '82978535-a8da-46e1-a39a-31a232e3fffc', true, '2025-03-05 15:20:59.458000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('7982e122-efa7-4e33-a3ff-0522923ad9fd', e'import sys
def searchInsertPosition(nums, target):
    l = 0
    r = len(nums)

    while l < r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[m] < target:
        l = m + 1
      else:
        r = m

    return l

if __name__ == \'__main__\':
    sizenums = int(input())
    nums = list(map(int, input().split()[:sizenums]))

    target = int(input())
    result = searchInsertPosition(nums, target)
    print(result)
', 'Python (3.8.1)', 20, 0, '573a0d23-196a-6b35-cf9c-6e168c18596a', '82978535-a8da-46e1-a39a-31a232e3fffc', true, '2025-03-05 15:20:59.458000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('5fc0d1c1-601e-4a1a-a60f-589e42da43de', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '591b3457-2157-4d61-b03d-d53f8666342c', true, '2025-03-05 15:04:07.230000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('35c043a0-8bd1-44f0-b1b3-ecb5ab896542', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 15, 0, '59208f4f-d6ae-0792-0317-f36822578f81', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 15:15:19.350000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('7d7743ea-ca6d-40d1-8a9e-a1e6be0e9574', e'function plusOne(digits) {
    for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i] += 1;
            return digits;
        }
        digits[i] = 0;
    }
    return [1].concat(digits);
}

const input = require(\'fs\').readFileSync(\'/dev/stdin\', \'utf8\').trim().split(\'\\n\').join(\' \').split(\' \');
const size_digits = parseInt(input.shift());
const digits = input.splice(0, size_digits).map(Number);

const result = plusOne(digits);
console.log(result.join(\' \'));
', 'JavaScript (Node.js 12.14.0)', 20, 0, 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '73c532f9-4d55-4737-ae19-3006e02864cc', true, '2025-03-05 15:19:20.024000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('9885d7af-679a-4e67-9fa8-c6a1bd68382c', e'function plusOne(digits) {
    for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i] += 1;
            return digits;
        }
        digits[i] = 0;
    }
    return [1].concat(digits);
}

const input = require(\'fs\').readFileSync(\'/dev/stdin\', \'utf8\').trim().split(\'\\n\').join(\' \').split(\' \');
const size_digits = parseInt(input.shift());
const digits = input.splice(0, size_digits).map(Number);

const result = plusOne(digits);
console.log(result.join(\' \'));
', 'JavaScript (Node.js 12.14.0)', 20, 0, 'aef57c4e-4011-1938-0086-86b46a63617c', '73c532f9-4d55-4737-ae19-3006e02864cc', true, '2025-03-05 15:19:20.024000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('a253ffd2-f5fc-4004-a903-99e4d7751335', e'import sys
def searchInsertPosition(nums, target):
    l = 0
    r = len(nums)

    while l < r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[m] < target:
        l = m + 1
      else:
        r = m

    return l

if __name__ == \'__main__\':
    sizenums = int(input())
    nums = list(map(int, input().split()[:sizenums]))

    target = int(input())
    result = searchInsertPosition(nums, target)
    print(result)
', 'Python (3.8.1)', 20, 0, 'aef57c4e-4011-1938-0086-86b46a63617c', '82978535-a8da-46e1-a39a-31a232e3fffc', true, '2025-03-05 15:20:59.458000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('8c5455e6-96da-4018-8abf-30e65aaadaba', e'import sys
def searchInsertPosition(nums, target):
    l = 0
    r = len(nums)

    while l < r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[m] < target:
        l = m + 1
      else:
        r = m

    return l

if __name__ == \'__main__\':
    sizenums = int(input())
    nums = list(map(int, input().split()[:sizenums]))

    target = int(input())
    result = searchInsertPosition(nums, target)
    print(result)
', 'Python (3.8.1)', 20, 0, 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '82978535-a8da-46e1-a39a-31a232e3fffc', true, '2025-03-05 15:20:59.458000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('7539f9d4-8a30-402b-9081-59efc1a0e970', e'function plusOne(digits) {
    for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i] += 1;
            return digits;
        }
        digits[i] = 0;
    }
    return [1].concat(digits);
}

const input = require(\'fs\').readFileSync(\'/dev/stdin\', \'utf8\').trim().split(\'\\n\').join(\' \').split(\' \');
const size_digits = parseInt(input.shift());
const digits = input.splice(0, size_digits).map(Number);

const result = plusOne(digits);
console.log(result.join(\' \'));
', 'JavaScript (Node.js 12.14.0)', 20, 0, '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '73c532f9-4d55-4737-ae19-3006e02864cc', true, '2025-03-05 15:19:20.024000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('7a9e2b41-d9e0-4645-bf94-c74c2fb1460a', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '341c45e0-d57e-4467-21fa-9ec708e60365', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 15:16:27.669000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('1f761fef-6379-469c-9ff7-4b443d81010b', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, 'cabb0e34-1cdb-7818-5ab4-4018b7c81fe4', '591b3457-2157-4d61-b03d-d53f8666342c', true, '2025-03-05 14:57:17.134000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('7dedb18e-a73a-404d-85fb-9d00a2ad15f3', e'import sys
def searchInsertPosition(nums, target):
    l = 0
    r = len(nums)

    while l < r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[m] < target:
        l = m + 1
      else:
        r = m

    return l

if __name__ == \'__main__\':
    sizenums = int(input())
    nums = list(map(int, input().split()[:sizenums]))

    target = int(input())
    result = searchInsertPosition(nums, target)
    print(result)
', 'Python (3.8.1)', 20, 0, '59208f4f-d6ae-0792-0317-f36822578f81', '82978535-a8da-46e1-a39a-31a232e3fffc', true, '2025-03-05 15:20:59.458000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('6a28e722-6828-47a4-a9d7-3dda450c5cb0', e'function plusOne(digits) {
    for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i] += 1;
            return digits;
        }
        digits[i] = 0;
    }
    return [1].concat(digits);
}

const input = require(\'fs\').readFileSync(\'/dev/stdin\', \'utf8\').trim().split(\'\\n\').join(\' \').split(\' \');
const size_digits = parseInt(input.shift());
const digits = input.splice(0, size_digits).map(Number);

const result = plusOne(digits);
console.log(result.join(\' \'));
', 'JavaScript (Node.js 12.14.0)', 20, 0, '1974945b-162f-c609-9934-c330126caf14', '73c532f9-4d55-4737-ae19-3006e02864cc', true, '2025-03-05 15:19:20.024000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('73862ab4-8b8c-4bb0-901e-2750a9cc59e5', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '73c532f9-4d55-4737-ae19-3006e02864cc', true, '2025-03-05 15:04:07.230000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('77415a5e-37bb-4e14-9fa4-bfde079edbc6', e'import sys
def searchInsertPosition(nums, target):
    l = 0
    r = len(nums)

    while l < r:
      m = (l + r) // 2
      if nums[m] == target:
        return m
      if nums[m] < target:
        l = m + 1
      else:
        r = m

    return l

if __name__ == \'__main__\':
    sizenums = int(input())
    nums = list(map(int, input().split()[:sizenums]))

    target = int(input())
    result = searchInsertPosition(nums, target)
    print(result)
', 'Python (3.8.1)', 20, 0, '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '82978535-a8da-46e1-a39a-31a232e3fffc', true, '2025-03-05 15:20:59.458000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('08dd1872-e547-44e4-bf05-fd563bfd0f0a', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '591b3457-2157-4d61-b03d-d53f8666342c', true, '2025-03-05 15:04:07.230000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('d36ce982-331c-46f7-a2aa-93c4fb826057', e'function plusOne(digits) {
    for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i] += 1;
            return digits;
        }
        digits[i] = 0;
    }
    return [1].concat(digits);
}

const input = require(\'fs\').readFileSync(\'/dev/stdin\', \'utf8\').trim().split(\'\\n\').join(\' \').split(\' \');
const size_digits = parseInt(input.shift());
const digits = input.splice(0, size_digits).map(Number);

const result = plusOne(digits);
console.log(result.join(\' \'));
', 'JavaScript (Node.js 12.14.0)', 20, 0, '341c45e0-d57e-4467-21fa-9ec708e60365', '73c532f9-4d55-4737-ae19-3006e02864cc', true, '2025-03-05 15:19:20.024000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('0e3ed25f-90e6-4240-8a60-e6213f94f324', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, 'cabb0e34-1cdb-7818-5ab4-4018b7c81fe4', 'e608ebb7-07ef-4a2f-8081-92e5993e6118', true, '2025-03-05 15:16:27.669000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('fecc38c8-13e4-45a4-86bb-c1f8368d1c11', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 15, 0, '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '591b3457-2157-4d61-b03d-d53f8666342c', true, '2025-03-05 15:15:19.350000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('8d4d4c29-79b4-456e-8295-3eb15e625b5b', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '341c45e0-d57e-4467-21fa-9ec708e60365', '591b3457-2157-4d61-b03d-d53f8666342c', true, '2025-03-05 15:16:27.669000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('12485ad3-429b-464b-8029-bf16fad47508', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 15, 0, '573a0d23-196a-6b35-cf9c-6e168c18596a', '591b3457-2157-4d61-b03d-d53f8666342c', true, '2025-03-05 15:15:19.350000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('0e9581f7-cb44-42c5-b215-55a3601ae3a7', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 15, 0, 'cabb0e34-1cdb-7818-5ab4-4018b7c81fe4', '82978535-a8da-46e1-a39a-31a232e3fffc', true, '2025-03-05 15:15:19.350000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('db60151b-fa0e-4b5f-a7f5-d46cdfb24a67', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '73c532f9-4d55-4737-ae19-3006e02864cc', true, '2025-03-05 15:16:27.669000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('2764ae3f-e4b4-4074-b02b-8a56fa5d8692', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 15, 0, 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'e608ebb7-07ef-4a2f-8081-92e5993e6118', true, '2025-03-05 15:15:19.350000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('8c5742a4-b8fd-4253-862c-73253e9d26ba', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '1974945b-162f-c609-9934-c330126caf14', '591b3457-2157-4d61-b03d-d53f8666342c', true, '2025-03-05 14:57:17.134000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('14b90b9a-d9ba-44be-81be-347e97d33614', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '341c45e0-d57e-4467-21fa-9ec708e60365', 'e608ebb7-07ef-4a2f-8081-92e5993e6118', true, '2025-03-05 15:16:27.669000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('09be6f23-d72d-4a0e-aced-f30bf7e35684', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '591b3457-2157-4d61-b03d-d53f8666342c', true, '2025-03-05 14:57:17.134000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('b42da9cd-b69d-4082-a754-4f59033b9143', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 14:57:17.134000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('72d6e7c2-0ec3-4581-8d0c-c5325631b070', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 14:57:17.134000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('df121b91-1571-45c8-845b-4d0ce1d334e9', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 15, 0, '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 15:15:19.350000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('62d2ebf2-f9a5-4291-bd55-115f52bfb96e', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '1974945b-162f-c609-9934-c330126caf14', '7328995b-6079-4bd9-8be0-7c9152d5a73b', true, '2025-03-05 15:16:27.669000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('5a510bc3-cfa0-4d52-8b42-4db553b01cc4', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '73c532f9-4d55-4737-ae19-3006e02864cc', true, '2025-03-05 15:04:07.230000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('3b8dd294-058e-44d4-98c3-d9e14bab3dce', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'e608ebb7-07ef-4a2f-8081-92e5993e6118', true, '2025-03-05 15:04:07.230000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('018d8d4c-8436-46c2-a034-d9577b5a8cbc', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, '573a0d23-196a-6b35-cf9c-6e168c18596a', 'e608ebb7-07ef-4a2f-8081-92e5993e6118', true, '2025-03-05 14:57:17.134000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('b9e1b90a-a63e-47da-b452-b74eaa10788d', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {
  std::vector<int> result(m + n);
  int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (j >= 0) {
        if (i >= 0 && nums1[i] > nums2[j]) {
            result[k--] = nums1[i--];
        } else {
            result[k--] = nums2[j--];
        }
    }

    while (i >= 0) {
        result[k--] = nums1[i--];
    }

  return result;
}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 15, 0, '6eaea212-5351-45c3-3a53-9c9b9a407e1e', 'e608ebb7-07ef-4a2f-8081-92e5993e6118', true, '2025-03-05 15:15:19.350000');
INSERT INTO public.problem_submissions (submission_id, code, programming_language, score_achieved, submit_order, user_id, problem_id, is_solved, created_at) VALUES ('a3b73a9c-4525-45e1-bc7b-f57d3936ca89', e'#include <iostream>
#include <vector>
#include <string>

std::vector<int> mergeSortedArray(std::vector<int> nums1, int m, std::vector<int> nums2, int n) {\\n  std::vector<int> result(m + n);\\n  int i = m - 1;     \\n    int j = n - 1;    \\n    int k = m + n - 1;\\n\\n    while (j >= 0) {\\n        if (i >= 0 && nums1[i] > nums2[j]) {\\n            result[k--] = nums1[i--];\\n        } else {\\n            result[k--] = nums2[j--];\\n        }\\n    }\\n\\n    while (i >= 0) {\\n        result[k--] = nums1[i--];\\n    }\\n    \\n  return result;\\n}

int main() {
  int m;
int n;

  int size_num1;
  std::cin >> size_num1;
  std::vector<int> num1(size_num1);
  for(int i = 0; i < size_num1; ++i) std::cin >> num1[i];
 std::cin >> m;
 int size_num2;
  std::cin >> size_num2;
  std::vector<int> num2(size_num2);
  for(int i = 0; i < size_num2; ++i) std::cin >> num2[i];
 std::cin >> n;
  std::vector<int> result = mergeSortedArray(num1, m, num2, n);
  for (const auto &item : result) std::cout << item << \' \';
std::cout << std::endl;
  return 0;
}
', 'C++ (GCC 7.4.0)', 10, 0, 'aef57c4e-4011-1938-0086-86b46a63617c', 'e608ebb7-07ef-4a2f-8081-92e5993e6118', true, '2025-03-05 14:57:17.134000');


INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('7ed76fd1-c4bb-4bc9-a6e2-0b48e2e36ac2', 'In Queue', 0, 'null', 0, '018d8d4c-8436-46c2-a034-d9577b5a8cbc', '23f35de8-7a82-4688-9253-6b5330894296');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('be005588-c3e3-486f-86cc-b4427610a7c5', 'In Queue', 0, 'null', 0, '018d8d4c-8436-46c2-a034-d9577b5a8cbc', 'eb1f21cf-b8fa-41cc-aea8-7224a85998c6');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('28532c62-52ec-4738-8a94-95e230b9c5d8', 'In Queue', 0, 'null', 0, '018d8d4c-8436-46c2-a034-d9577b5a8cbc', '607a6878-899a-4f10-a3ff-106e36f6db7b');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('3fed16cd-09c9-4371-920c-2758315c6d6d', 'In Queue', 0, 'null', 0, '018d8d4c-8436-46c2-a034-d9577b5a8cbc', '285e81b0-b13c-4a30-b861-228edd8fa05a');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('5e78971a-72af-4c3a-bd58-26f0b7ff69c8', 'In Queue', 0, 'null', 0, '018d8d4c-8436-46c2-a034-d9577b5a8cbc', '7d1d2398-47fd-480a-a662-b8bb892656a4');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('f8189d62-4550-47f5-8d48-feb2dff0da8e', 'Compilation Error', null, null, 0, 'c89dfa85-9aeb-4948-926f-f10e6fc1f0de', 'eb1f21cf-b8fa-41cc-aea8-7224a85998c6');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('ca7bf7ea-4ce8-4630-8a9e-83ab4ad33b24', 'Compilation Error', null, null, 0, 'c89dfa85-9aeb-4948-926f-f10e6fc1f0de', '23f35de8-7a82-4688-9253-6b5330894296');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('985a7521-6c8c-44e8-9eff-2d2dde5212a8', 'Compilation Error', null, null, 0, 'c89dfa85-9aeb-4948-926f-f10e6fc1f0de', '285e81b0-b13c-4a30-b861-228edd8fa05a');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('9f68f2d4-51ae-4c29-a618-31579ca70a12', 'Compilation Error', null, null, 0, 'c89dfa85-9aeb-4948-926f-f10e6fc1f0de', '607a6878-899a-4f10-a3ff-106e36f6db7b');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('000426d0-76a7-40f6-bc87-ff34ca89180e', 'Compilation Error', null, null, 0, 'c89dfa85-9aeb-4948-926f-f10e6fc1f0de', '7d1d2398-47fd-480a-a662-b8bb892656a4');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('e8f8e960-2a84-4c41-9915-4fb2e48b736e', 'Accepted', 0.008, '1 ', 14652, '70e9ab41-1106-4562-b855-4427d48de154', '23f35de8-7a82-4688-9253-6b5330894296');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('068bd117-8c68-4f07-89d7-43cbd74eff96', 'Accepted', 0.003, '1 2 3 4 5 6 ', 5264, '70e9ab41-1106-4562-b855-4427d48de154', '607a6878-899a-4f10-a3ff-106e36f6db7b');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('24213ce2-1b5b-4aca-bb96-0957c8ae543d', 'Wrong Answer', 0.004, '', 1952, '70e9ab41-1106-4562-b855-4427d48de154', '285e81b0-b13c-4a30-b861-228edd8fa05a');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('ad04fa0b-b6be-44e7-bb8a-dbd3c1781894', 'Accepted', 0.004, '1 2 2 3 5 6 ', 1372, '70e9ab41-1106-4562-b855-4427d48de154', '7d1d2398-47fd-480a-a662-b8bb892656a4');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('87d633ac-d62b-4e25-a6b2-721c6f44c850', 'Accepted', 0.003, '1 2 3 4 5 6 7 ', 1244, '70e9ab41-1106-4562-b855-4427d48de154', 'eb1f21cf-b8fa-41cc-aea8-7224a85998c6');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('8a146cbe-5444-4efb-b48e-8576281ca921', 'Accepted', 0.004, '1 ', 3324, '62d2ebf2-f9a5-4291-bd55-115f52bfb96e', '23f35de8-7a82-4688-9253-6b5330894296');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('abb451ef-6e9f-49a4-8e56-bbd0125cb3b1', 'Accepted', 0.004, '1 2 3 4 5 6 7 ', 1292, '62d2ebf2-f9a5-4291-bd55-115f52bfb96e', 'eb1f21cf-b8fa-41cc-aea8-7224a85998c6');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('0748d68e-315b-4f51-a64c-b9c6fe31956e', 'Accepted', 0.003, '1 2 3 4 5 6 ', 960, '62d2ebf2-f9a5-4291-bd55-115f52bfb96e', '607a6878-899a-4f10-a3ff-106e36f6db7b');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('55f439c1-239c-4f63-a873-f97afdbbf13d', 'Wrong Answer', 0.012, '', 828, '62d2ebf2-f9a5-4291-bd55-115f52bfb96e', '285e81b0-b13c-4a30-b861-228edd8fa05a');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('1f58f3fb-c7fd-4ce3-81b0-3c23ebd09c20', 'Accepted', 0.003, '1 2 2 3 5 6 ', 3104, '62d2ebf2-f9a5-4291-bd55-115f52bfb96e', '7d1d2398-47fd-480a-a662-b8bb892656a4');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('ad6c6db3-3e04-4f25-b0a1-caeb1d2ce0be', 'Accepted', 0.066, '4 3 2 2', 15112, '835e0efb-6ab0-4c0b-ac69-5f9724b46022', '00222cc2-be0a-4b78-8e49-8a7572418dad');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('b48d2db5-77fd-4083-8c82-1d3c4813d59d', 'Accepted', 0.058, '1 0 0 0', 7788, '835e0efb-6ab0-4c0b-ac69-5f9724b46022', '6fbb0344-0bc8-4df2-a64d-785fb373a9a7');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('56eb1f8f-0b7f-4da1-85cd-37ca03f238c5', 'Accepted', 0.061, '7 2 8 5 0 9 1 2 9 5 3 6 6 7 3 2 8 4 3 7 9 5 7 7 4 7 4 9 4 7 0 1 1 1 7 4 0 0 7', 9012, '835e0efb-6ab0-4c0b-ac69-5f9724b46022', '8a85700f-ffb4-438b-8183-8f3aa1999c24');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('8e1698ec-eb85-4647-adaf-88740b8c84a9', 'Accepted', 0.071, '1 0', 21704, '835e0efb-6ab0-4c0b-ac69-5f9724b46022', '0ccce6f3-b6f1-4184-b13d-0aec69dfc148');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('3e1af1c7-3daa-4739-a004-c9f5379ecc4f', 'Accepted', 0.05, '1 2 4', 6744, '835e0efb-6ab0-4c0b-ac69-5f9724b46022', 'd725244d-31f7-4ddc-b494-dc54cab67964');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('87145b81-d15c-4b8e-b6a5-d77455b0da90', 'Accepted', 0.052, '1 0 0 1', 6868, '835e0efb-6ab0-4c0b-ac69-5f9724b46022', '4a9c10f0-eb2a-4b19-8e19-9edf117e76d8');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('70157a27-db5b-44aa-b98d-8d69ff917197', 'Accepted', 0.05, '2', 8252, '4fd9a7eb-92cf-4899-97c8-f49c5ba24f66', '21a234fc-adc3-4012-9802-63ab716fb8c4');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('88b078a8-8f40-4620-b425-a19dac06f328', 'Accepted', 0.12, '4', 3244, '4fd9a7eb-92cf-4899-97c8-f49c5ba24f66', '4703bfe2-5040-49f7-b728-bdea2b6c97e4');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('927b5ca6-daf1-417e-b3f2-186bc33f93e7', 'Accepted', 0.344, '2', 3204, '4fd9a7eb-92cf-4899-97c8-f49c5ba24f66', 'e8698f62-9051-49e0-8610-56c27a7dcb96');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('6545d9d6-79ec-4a79-8cc2-13df47de95e3', 'Accepted', 0.016, '0', 3280, '4fd9a7eb-92cf-4899-97c8-f49c5ba24f66', 'da031658-0ac7-4aae-99e5-6c01e2862b29');
INSERT INTO public.test_case_outputs (token, result_status, runtime, submission_output, memory, submission_id, testcase_id) VALUES ('b0c47d08-6c98-4001-a3cf-c3ea37d3bcb7', 'Accepted', 0.014, '1', 3348, '4fd9a7eb-92cf-4899-97c8-f49c5ba24f66', '2becdcf8-1773-4d3a-b759-63fea450106c');





INSERT INTO public.solutions (author_id, content, problem_id) VALUES (null, e'### **Problem Description**  
You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n` representing the number of elements in each array. Merge the two arrays so that `nums1` becomes a single array sorted in **non-decreasing order**.  

- `nums1` has a size of `m + n` with the last `n` slots set to `0`, which will store elements from `nums2`.  
- Modify `nums1` **in-place**, without returning anything.  

---

### **Approach**  

To merge the arrays in-place, we can solve this problem efficiently by merging from **right to left**, starting at the end of `nums1` and `nums2` (this prevents overwriting elements that haven’t been processed yet).  

**Optimal Solution:**  
1. Use three pointers:  
   - `p1`: Last valid element in `nums1` (`m - 1`)  
   - `p2`: Last element in `nums2` (`n - 1`)  
   - `p`: Points to the last position in `nums1` (`m + n - 1`)  
2. Compare the elements from `nums1[p1]` and `nums2[p2]`, and place the larger element at `nums1[p]`, then decrement `p`, `p1`, or `p2` accordingly.  
3. If there are any remaining elements in `nums2`, copy them to the beginning of `nums1`.  

---

### **Solutions in Different Languages:**  


```python
def merge(nums1, m, nums2, n):
    p1, p2, p = m - 1, n - 1, m + n - 1
    
    while p1 >= 0 and p2 >= 0:
        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
    
    # If there are remaining elements in nums2
    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1

# Example test cases
nums1 = [1, 2, 3, 0, 0, 0]
m = 3
nums2 = [2, 5, 6]
n = 3
merge(nums1, m, nums2, n)
print(nums1)  # Output: [1, 2, 2, 3, 5, 6]
```
```java
import java.util.Arrays;

public class MergeSortedArray {
    public static void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1, p2 = n - 1, p = m + n - 1;
        
        while (p1 >= 0 && p2 >= 0) {
            if (nums1[p1] > nums2[p2]) {
                nums1[p--] = nums1[p1--];
            } else {
                nums1[p--] = nums2[p2--];
            }
        }
        
        // Copy remaining elements from nums2 (if any)
        while (p2 >= 0) {
            nums1[p--] = nums2[p2--];
        }
    }

    public static void main(String[] args) {
        int[] nums1 = {1, 2, 3, 0, 0, 0};
        int m = 3;
        int[] nums2 = {2, 5, 6};
        int n = 3;
        merge(nums1, m, nums2, n);
        System.out.println(Arrays.toString(nums1));  // Output: [1, 2, 2, 3, 5, 6]
    }
}
```
```cpp
#include <iostream>
#include <vector>
using namespace std;

void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int p1 = m - 1, p2 = n - 1, p = m + n - 1;
    
    while (p1 >= 0 && p2 >= 0) {
        if (nums1[p1] > nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }
    
    // Copy remaining elements from nums2
    while (p2 >= 0) {
        nums1[p--] = nums2[p2--];
    }
}

int main() {
    vector<int> nums1 = {1, 2, 3, 0, 0, 0};
    int m = 3;
    vector<int> nums2 = {2, 5, 6};
    int n = 3;
    merge(nums1, m, nums2, n);
    for (int num : nums1) {
        cout << num << " ";
    }
    // Output: 1 2 2 3 5 6
}
```
```javascript
function merge(nums1, m, nums2, n) {
    let p1 = m - 1, p2 = n - 1, p = m + n - 1;

    while (p1 >= 0 && p2 >= 0) {
        if (nums1[p1] > nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }

    // Copy remaining elements from nums2 (if any)
    while (p2 >= 0) {
        nums1[p--] = nums2[p2--];
    }
}

// Example test case
let nums1 = [1, 2, 3, 0, 0, 0];
let m = 3;
let nums2 = [2, 5, 6];
let n = 3;
merge(nums1, m, nums2, n);
console.log(nums1);  // Output: [1, 2, 2, 3, 5, 6]
```
```typescript
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
    let p1 = m - 1, p2 = n - 1, p = m + n - 1;

    while (p1 >= 0 && p2 >= 0) {
        if (nums1[p1] > nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }

    // Copy remaining elements from nums2 (if any)
    while (p2 >= 0) {
        nums1[p--] = nums2[p2--];
    }
}

// Example test case
let nums1 = [1, 2, 3, 0, 0, 0];
let m = 3;
let nums2 = [2, 5, 6];
let n = 3;
merge(nums1, m, nums2, n);
console.log(nums1);  // Output: [1, 2, 2, 3, 5, 6]
```

---

### **Time Complexity:**  
- **Time:** `O(m + n)` since we iterate through all the elements of `nums1` and `nums2`.  
- **Space:** `O(1)` (in-place modification of `nums1`).  

This is an optimal solution that efficiently merges the arrays in sorted order.', '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.solutions (author_id, content, problem_id) VALUES (null, e'### Approach and Solution  
To solve this problem, we can follow a simple digit-by-digit approach, incrementing the last digit of the array by one. If this increment leads to a carry (i.e., the digit becomes 10), we set the current position to 0 and move the carry to the next left digit. This process is repeated until there are no more carry values left.  

If, after processing all the digits, we still have a carry (like `[9, 9, 9]` becoming `[0, 0, 0]` with a carry left), we insert `1` at the beginning of the array.  

---

### Code Implementations  

```python
def plusOne(digits):
    n = len(digits)
    
    # Traverse the array from the last digit to the first
    for i in range(n - 1, -1, -1):
        if digits[i] < 9:  # If the current digit is less than 9, increment it
            digits[i] += 1
            return digits
        else:
            digits[i] = 0  # Set the current digit to 0 if it becomes 10 and carry over
    
    # If all digits are 9, we need to add a 1 at the front (e.g., [9, 9] -> [1, 0, 0])
    return [1] + digits

# Example test cases
print(plusOne([1, 2, 3]))  # Output: [1, 2, 4]
print(plusOne([4, 3, 2, 1]))  # Output: [4, 3, 2, 2]
print(plusOne([9]))  # Output: [1, 0]
```
```java
import java.util.Arrays;

public class PlusOne {
    public static int[] plusOne(int[] digits) {
        int n = digits.length;
        
        // Traverse from the last digit to the first
        for (int i = n - 1; i >= 0; i--) {
            if (digits[i] < 9) {
                digits[i]++;
                return digits;
            }
            digits[i] = 0;  // Set to 0 and carry to the next digit
        }
        
        // If all digits were 9, we need to add an extra 1 at the beginning
        int[] result = new int[n + 1];
        result[0] = 1;
        return result;
    }

    public static void main(String[] args) {
        System.out.println(Arrays.toString(plusOne(new int[]{1, 2, 3})));  // Output: [1, 2, 4]
        System.out.println(Arrays.toString(plusOne(new int[]{4, 3, 2, 1})));  // Output: [4, 3, 2, 2]
        System.out.println(Arrays.toString(plusOne(new int[]{9})));  // Output: [1, 0]
    }
}
```
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> plusOne(vector<int>& digits) {
    int n = digits.size();
    
    // Traverse the array from last to first
    for (int i = n - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i]++;
            return digits;  // Return result when no carry is left
        }
        digits[i] = 0;  // Set to 0 and propagate carry
    }
    
    // If all digits are 9, add an extra 1 at the beginning
    digits.insert(digits.begin(), 1);
    return digits;
}

int main() {
    vector<int> digits1 = {1, 2, 3};
    vector<int> digits2 = {4, 3, 2, 1};
    vector<int> digits3 = {9};
    
    vector<int> result1 = plusOne(digits1);
    vector<int> result2 = plusOne(digits2);
    vector<int> result3 = plusOne(digits3);
    
    for (int num : result1) cout << num << " ";  // Output: 1 2 4
    cout << endl;
    
    for (int num : result2) cout << num << " ";  // Output: 4 3 2 2
    cout << endl;
    
    for (int num : result3) cout << num << " ";  // Output: 1 0
    cout << endl;
}
```
```javascript
function plusOne(digits) {
    let n = digits.length;
    
    // Traverse from the last digit to the first
    for (let i = n - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i]++;
            return digits;  // Return result after incrementing
        }
        digits[i] = 0;  // Set to 0 if 9 and propagate carry
    }
    
    // If all digits are 9, add a 1 at the front (e.g., [9, 9] -> [1, 0, 0])
    digits.unshift(1);
    return digits;
}

// Example test cases
console.log(plusOne([1, 2, 3]));  // Output: [1, 2, 4]
console.log(plusOne([4, 3, 2, 1]));  // Output: [4, 3, 2, 2]
console.log(plusOne([9]));  // Output: [1, 0]
```
```typescript
function plusOne(digits: number[]): number[] {
    let n = digits.length;
    
    for (let i = n - 1; i >= 0; i--) {
        if (digits[i] < 9) {
            digits[i]++;
            return digits;  // Return if increment is done without carry
        }
        digits[i] = 0;  // Handle carry by setting digit to 0
    }
    
    // If carry remains after all digits, add 1 at the beginning
    digits.unshift(1);
    return digits;
}

// Example test cases
console.log(plusOne([1, 2, 3]));  // Output: [1, 2, 4]
console.log(plusOne([4, 3, 2, 1]));  // Output: [4, 3, 2, 2]
console.log(plusOne([9]));  // Output: [1, 0]
```

---

### Time and Space Complexity:  
- **Time Complexity:** `O(n)` because we traverse the array from right to left.  
- **Space Complexity:** `O(1)` if the input array can be modified in-place. Otherwise, if new memory is allocated (like in Java or inserting elements in Python), the space complexity is `O(n)`.', '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.solutions (author_id, content, problem_id) VALUES (null, e'### Approach and Solution  
To achieve `O(log n)` runtime complexity, we can use **binary search**, which is efficient for searching in sorted arrays. The goal is to find the index of the target or determine where the target would fit if it is not present in the array.  

**Binary Search Approach:**  
1. Initialize two pointers: `left` at the start of the array and `right` at the end.  
2. Perform binary search:
   - Calculate the middle index: `mid = (left + right) // 2`.  
   - If `nums[mid] == target`, return `mid`.  
   - If `nums[mid] > target`, move `right` to `mid - 1`.  
   - If `nums[mid] < target`, move `left` to `mid + 1`.  
3. If the target is not found, return the `left` pointer, which will be at the position where the target should be inserted.  

---

### Code Implementations  
```python
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return left  # Return the index where the target should be inserted

# Example test cases
print(searchInsert([1, 3, 5, 6], 5))  # Output: 2
print(searchInsert([1, 3, 5, 6], 2))  # Output: 1
print(searchInsert([1, 3, 5, 6], 7))  # Output: 4
```
```java
public class SearchInsertPosition {
    public static int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return left;  // Return the insertion position
    }

    public static void main(String[] args) {
        System.out.println(searchInsert(new int[]{1, 3, 5, 6}, 5));  // Output: 2
        System.out.println(searchInsert(new int[]{1, 3, 5, 6}, 2));  // Output: 1
        System.out.println(searchInsert(new int[]{1, 3, 5, 6}, 7));  // Output: 4
    }
}
```
```cpp
#include <iostream>
#include <vector>
using namespace std;

int searchInsert(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return left;  // Return the insertion index
}

int main() {
    vector<int> nums = {1, 3, 5, 6};
    
    cout << searchInsert(nums, 5) << endl;  // Output: 2
    cout << searchInsert(nums, 2) << endl;  // Output: 1
    cout << searchInsert(nums, 7) << endl;  // Output: 4
}
```
```javascript
function searchInsert(nums, target) {
    let left = 0, right = nums.length - 1;
    
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        
        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return left;  // Return the insertion position
}

// Example test cases
console.log(searchInsert([1, 3, 5, 6], 5));  // Output: 2
console.log(searchInsert([1, 3, 5, 6], 2));  // Output: 1
console.log(searchInsert([1, 3, 5, 6], 7));  // Output: 4
```
```typescript
function searchInsert(nums: number[], target: number): number {
    let left = 0, right = nums.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return left;  // Return the position to insert the target
}

// Example test cases
console.log(searchInsert([1, 3, 5, 6], 5));  // Output: 2
console.log(searchInsert([1, 3, 5, 6], 2));  // Output: 1
console.log(searchInsert([1, 3, 5, 6], 7));  // Output: 4
```

---

### Time and Space Complexity  
- **Time Complexity:** `O(log n)` because we are performing a binary search.  
- **Space Complexity:** `O(1)` because we do not use any extra space, and the solution modifies pointers in place.  ', '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.solutions (author_id, content, problem_id) VALUES (null, e'# Solution Article  

## Approach 1: Brute Force  
### Algorithm  
The brute force approach is simple: loop through each element `x` and find if there is another value that equals `target - x`.  

### Implementation  
``` C++
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                if (nums[j] == target - nums[i]) {
                    return {i, j};
                }
            }
        }
        // Return an empty vector if no solution is found
        return {};
    }
};
```  
```C
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    for (int i = 0; i < numsSize; i++) {
        for (int j = i + 1; j < numsSize; j++) {
            if (nums[j] == target - nums[i]) {
                int* result = malloc(sizeof(int) * 2);
                result[0] = i;
                result[1] = j;
                *returnSize = 2;
                return result;
            }
        }
    }
    // Return an empty array if no solution is found
    *returnSize = 0;
    return malloc(sizeof(int) * 0);
}
```
```C#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        for (int i = 0; i < nums.Length; i++) {
            for (int j = i + 1; j < nums.Length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        // Return an empty array if no solution is found
        return new int[] {};
    }
}
```
```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        // If no valid pair is found, return an empty array instead of null
        return new int[] {};
    }
}
```
```JavaScript
var twoSum = function (nums, target) {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[j] === target - nums[i]) {
                return [i, j];
            }
        }
    }
    // Return an empty array if no solution is found
    return [];
};
```
```Python3
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[j] == target - nums[i]:
                    return [i, j]
        # Return an empty list if no solution is found
        return []
```
```TypeScript
function twoSum(nums: number[], target: number): number[] {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[j] === target - nums[i]) {
                return [i, j];
            }
        }
    }
    // Return an empty array if no solution is found
    return [];
}
```

### Complexity Analysis  
- **Time complexity**: O(n²)  
  - For each element, we try to find its complement by looping through the rest of the array, which takes O(n) time. Therefore, the overall time complexity is O(n²).  
- **Space complexity**: O(1)  
  - The space required does not depend on the size of the input array, so only constant space is used.  

---

## Approach 2: Two-pass Hash Table  
### Intuition  
To improve our runtime complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to get its index.  

Using a **hash table** can reduce the lookup time from O(n) to O(1) by trading space for speed. A hash table is well suited for this purpose because it supports fast lookup in near constant time. (Note that if a collision occurs, lookup could degenerate to O(n) time. However, with a well-chosen hash function, lookup remains amortized O(1) time.)  

### Algorithm  
A simple implementation involves two iterations:  
1. In the first iteration, add each element\'s value as a key and its index as a value to the hash table.  
2. In the second iteration, check if each element\'s complement (`target - nums[i]`) exists in the hash table. If it does exist, return the current element\'s index and its complement\'s index. **Note:** The complement must not be `nums[i]` itself!  

### Implementation  
``` C++
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        unordered_map<int, int> hash;
        for (int i = 0; i < nums.size(); i++) {
            hash[nums[i]] = i;
        }
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (hash.find(complement) != hash.end() && hash[complement] != i) {
                return {i, hash[complement]};
            }
        }
        // If no valid pair is found, return an empty vector
        return {};
    }
};
```  
```C
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    struct hashTable {
        int key;
        int value;
        UT_hash_handle hh;
    } *hashTable = NULL, *item, *tmpItem;

    for (int i = 0; i < numsSize; i++) {
        HASH_FIND_INT(hashTable, &nums[i], item);
        if (item) {
            int* result = malloc(sizeof(int) * 2);
            result[0] = item->value;
            result[1] = i;
            *returnSize = 2;
            HASH_ITER(hh, hashTable, item, tmpItem) {
                HASH_DEL(hashTable, item);
                free(item);
            }
            return result;
        }
        item = malloc(sizeof(struct hashTable));
        item->key = target - nums[i];
        item->value = i;
        HASH_ADD_INT(hashTable, key, item);
    }
    HASH_ITER(hh, hashTable, item, tmpItem) {
        HASH_DEL(hashTable, item);
        free(item);
    }
    *returnSize = 0;
    // If no valid pair is found, return an empty array
    return malloc(sizeof(int) * 0);
}
```
```C#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int, int> map = new Dictionary<int, int>();
        for (int i = 0; i < nums.Length; i++) {
            map[nums[i]] = i;
        }

        for (int i = 0; i < nums.Length; i++) {
            int complement = target - nums[i];
            if (map.ContainsKey(complement) && map[complement] != i) {
                return new int[] { i, map[complement] };
            }
        }

        // If no valid pair is found, return an empty array
        return new int[] {};
    }
}
```
```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement) && map.get(complement) != i) {
                return new int[] { i, map.get(complement) };
            }
        }
        // In case there is no solution, return an empty array
        return new int[] {};
    }
}
```
```JavaScript
var twoSum = function (nums, target) {
    const map = new Map();
    for (let i = 0; i < nums.length; i++) {
        map.set(nums[i], i);
    }
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement) && map.get(complement) !== i) {
            return [i, map.get(complement)];
        }
    }
    // If no valid pair is found, return an empty array
    return [];
};
```
```Python3
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for i in range(len(nums)):
            hashmap[nums[i]] = i
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in hashmap and hashmap[complement] != i:
                return [i, hashmap[complement]]
        # If no valid pair is found, return an empty list
        return []
```
```TypeScript
function twoSum(nums: number[], target: number): number[] {
    const map: Map<number, number> = new Map();
    for (let i = 0; i < nums.length; i++) {
        map.set(nums[i], i);
    }
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement) && map.get(complement) !== i) {
            return [i, map.get(complement)];
        }
    }
    // If no valid pair is found, return an empty array
    return [];
}
```



### Complexity Analysis  
- **Time complexity**: O(n)  
  - We traverse the list containing `n` elements exactly twice. Since the hash table reduces the lookup time to O(1), the overall time complexity is O(n).  
- **Space complexity**: O(n)  
  - The extra space required depends on the number of items stored in the hash table, which stores exactly `n` elements.  

---

## Approach 3: One-pass Hash Table  
### Algorithm  
It turns out we can do it in one pass! While iterating and inserting elements into the hash table, we also look back to check if the current element\'s complement already exists in the hash table. If it exists, we have found a solution and return the indices immediately.  

### Implementation  
``` C++
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        unordered_map<int, int> hash;
        for (int i = 0; i < nums.size(); ++i) {
            int complement = target - nums[i];
            if (hash.find(complement) != hash.end()) {
                return {hash[complement], i};
            }
            hash[nums[i]] = i;
        }
        // Return an empty vector if no solution is found
        return {};
    }
};
```  
```C
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    struct hashTable {
        int key;
        int value;
        UT_hash_handle hh;
    } *hashTable = NULL, *item;

    for (int i = 0; i < numsSize; i++) {
        int complement = target - nums[i];
        HASH_FIND_INT(hashTable, &complement, item);
        if (item) {
            int* result = malloc(sizeof(int) * 2);
            result[0] = item->value;
            result[1] = i;
            *returnSize = 2;
            HASH_CLEAR(hh, hashTable);  // Free the hash table
            return result;
        }
        item = malloc(sizeof(struct hashTable));
        item->key = nums[i];
        item->value = i;
        HASH_ADD_INT(hashTable, key, item);
    }
    *returnSize = 0;
    HASH_CLEAR(hh, hashTable);  // Free the hash table
    // Return an empty array if no solution is found
    return malloc(0);  // Allocate 0 bytes
}
```
```C#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int, int> map = new Dictionary<int, int>();
        for (int i = 0; i < nums.Length; i++) {
            int complement = target - nums[i];
            if (map.ContainsKey(complement)) {
                return new int[] { map[complement], i };
            }
            map[nums[i]] = i;
        }
        // Return an empty array if no solution is found
        return new int[] {};
    }
}
```
```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        // Return an empty array if no solution is found
        return new int[] {};
    }
}
```
```JavaScript
var twoSum = function (nums, target) {
    const map = new Map();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement)) {
            return [map.get(complement), i];
        }
        map.set(nums[i], i);
    }
    // Return an empty array if no solution is found
    return [];
};
```
```Python3
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in hashmap:
                return [i, hashmap[complement]]
            hashmap[nums[i]] = i
        # Return an empty list if no solution is found
        return []
```
```TypeScript
function twoSum(nums: number[], target: number): number[] {
    const map: Map<number, number> = new Map();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement)) {
            return [map.get(complement), i];
        }
        map.set(nums[i], i);
    }
    // Return an empty array if no solution is found
    return [];
}
```


### Complexity Analysis  
- **Time complexity**: O(n)  
  - We traverse the list containing `n` elements only once. Each lookup in the hash table costs only O(1) time.  
- **Space complexity**: O(n)  
  - The extra space required depends on the number of items stored in the hash table, which stores at most `n` elements.  
```  ', '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.solutions (author_id, content, problem_id) VALUES (null, e'### Approach and Solution  
To solve this problem in **linear time complexity** `O(n)` and using **constant extra space** `O(1)`, we can leverage **bitwise XOR**.  

#### XOR Properties:
1. `a ^ a = 0` (XOR of a number with itself is 0).  
2. `a ^ 0 = a` (XOR of a number with 0 is the number itself).  
3. XOR is commutative and associative, so the order of operations doesn\'t matter.  

Using these properties, if we XOR all numbers in the array, the numbers that appear twice will cancel each other out, and the remaining number will be the single one.

---

### Code Implementations  

```python
def singleNumber(nums):
    result = 0
    for num in nums:
        result ^= num  # XOR all numbers
    return result

# Example test cases
print(singleNumber([2, 2, 1]))       # Output: 1
print(singleNumber([4, 1, 2, 1, 2]))  # Output: 4
print(singleNumber([1]))              # Output: 1
```
```java
public class SingleNumber {
    public static int singleNumber(int[] nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;  // XOR all numbers
        }
        return result;
    }

    public static void main(String[] args) {
        System.out.println(singleNumber(new int[]{2, 2, 1}));       // Output: 1
        System.out.println(singleNumber(new int[]{4, 1, 2, 1, 2}));  // Output: 4
        System.out.println(singleNumber(new int[]{1}));              // Output: 1
    }
}
```
```cpp
#include <iostream>
#include <vector>
using namespace std;

int singleNumber(vector<int>& nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;  // XOR all numbers
    }
    return result;
}

int main() {
    vector<int> nums1 = {2, 2, 1};
    vector<int> nums2 = {4, 1, 2, 1, 2};
    vector<int> nums3 = {1};

    cout << singleNumber(nums1) << endl;  // Output: 1
    cout << singleNumber(nums2) << endl;  // Output: 4
    cout << singleNumber(nums3) << endl;  // Output: 1
}
```
```javascript
function singleNumber(nums) {
    let result = 0;
    for (let num of nums) {
        result ^= num;  // XOR all numbers
    }
    return result;
}

// Example test cases
console.log(singleNumber([2, 2, 1]));       // Output: 1
console.log(singleNumber([4, 1, 2, 1, 2]));  // Output: 4
console.log(singleNumber([1]));              // Output: 1
```
```typescript
function singleNumber(nums: number[]): number {
    let result = 0;
    for (const num of nums) {
        result ^= num;  // XOR all numbers
    }
    return result;
}

// Example test cases
console.log(singleNumber([2, 2, 1]));       // Output: 1
console.log(singleNumber([4, 1, 2, 1, 2]));  // Output: 4
console.log(singleNumber([1]));              // Output: 1
```

---

### Time and Space Complexity  
- **Time Complexity:** `O(n)` – We traverse the array once.  
- **Space Complexity:** `O(1)` – Only a single variable `result` is used, which does not depend on the input size.  ', 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
