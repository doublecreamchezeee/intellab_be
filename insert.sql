CREATE EXTENSION IF NOT EXISTS "vector";

CREATE TABLE IF NOT EXISTS embeddings (
                                          id SERIAL PRIMARY KEY,
                                          embedding vector,
                                          text text,
                                          created_at timestamptz DEFAULT now()
    );

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

create table problems
(
    problem_id         uuid not null default uuid_generate_v4()
        primary key,
    acceptance_rate    numeric(5, 2) default 0 check(acceptance_rate>=0.0 and acceptance_rate <= 100.00),
    average_rating     numeric(5, 2) default 0 check(average_rating >= 0.0 and average_rating <= 5.0),
    description        text default '',
    problem_level      varchar(20) check(problem_level in ('easy','medium','hard')) default 'easy',
    problem_name       varchar(255) not null,
    score              integer,
    is_available       boolean       default false,
    is_published       boolean       default false,
    problem_structure text,
	author_id             uuid,
    current_creation_step integer       default 1,
	created_at timestamp(6) without time zone,
	current_creation_step_description character varying(255) COLLATE pg_catalog."default",
    is_completed_creation boolean       default false
);

alter table problems
    owner to postgres;

create table solutions
(
    author_id  uuid,
    content    text,
    problem_id uuid not null
        constraint fkrm3misp2p4syk4tcnefnqspbl
            references problems ON DELETE CASCADE,
    primary key (problem_id, author_id)
);

alter table solutions
    owner to postgres;

create table hints
(
    level      integer not null,
    content    text,
    problem_id uuid    not null
        constraint fks7m1vov834a6stk5o5gg70ask
            references problems,
    primary key (level, problem_id)
);

alter table hints
    owner to postgres;

create table programming_language
(
    programming_language_id integer not null
        primary key,
    long_name               varchar(50),
    short_name              varchar(20)
);

alter table programming_language
    owner to postgres;

create table default_code
(
    code        text,
    language_id integer not null
        constraint fka8c6jrkgcbeexifxoaa7w80h2
            references programming_language,
    problem_id  uuid    not null
        constraint fkcxolaif2yhkurw5v9lrbkty4u
            references problems,
    primary key (language_id, problem_id)
);

alter table default_code
    owner to postgres;

create table problem_submissions
(
    submission_id        uuid not null default uuid_generate_v4()
        primary key,
    code                 text,
    programming_language varchar(50),
    score_achieved       integer,
    submit_order         integer,
    user_id              uuid,
    problem_id           uuid
        constraint fkatyso4hx6mtu96ixk88g328er
            references problems,
    is_solved            boolean,
    created_at           timestamp(6) default current_timestamp
);

alter table problem_submissions
    owner to postgres;

create table problem_run_code
(
    run_code_id          uuid not null default uuid_generate_v4()
        primary key,
    code                 text,
    programming_language varchar(50),
    score_achieved       integer,
    user_id              uuid,
    problem_id           uuid
        constraint fk8li9cde1nrixxl9ciymf5u4j
            references problems
);

alter table problem_run_code
    owner to postgres;

create table test_cases
(
    testcase_id    uuid not null default uuid_generate_v4()
        primary key,
    input          text,
    output         text,
    user_id        uuid,
    testcase_order integer,
    problem_id     uuid not null
        constraint fkk0300c33ccc0im12utqoxu0m6
            references problems
);

alter table test_cases
    owner to postgres;

create table test_case_outputs
(
    token             uuid,
    result_status     varchar(30),
    runtime           real,
    submission_output text,
    memory            real,
    submission_id     uuid not null
        constraint fkniol765wvj61q9t6lrlhhx091
            references problem_submissions,
    testcase_id       uuid not null
        constraint fkawdt7u0ci9lvfrnphpho4p6xd
            references test_cases,
    primary key (submission_id, testcase_id)
);

alter table test_case_outputs
    owner to postgres;

create table test_case_run_code_outputs
(
    result_status       character varying(30),
    runtime             real,
    submission_output   text,
    token               uuid,
    run_code_id         uuid NOT NULL default uuid_generate_v4()
        constraint fkqk1slm0542aw7no8dvm68t0s
            references problem_run_code,
    testcase_id         uuid NOT NULL default uuid_generate_v4()
        constraint fke8fk765lvj2kta83rtpc7hb8
            references test_cases,
    compile_output      text,
    error               text,
    memory_usage        text,
    message             text,
    status_id           integer,
    constraint test_case_run_code_outputs_pkey
        primary key (run_code_id, testcase_id)
);

alter table test_case_run_code_outputs
    owner to postgres;


-- Table: public.badges

-- DROP TABLE IF EXISTS public.badges;

CREATE TABLE IF NOT EXISTS public.badges
(
    image text COLLATE pg_catalog."default",
    badge_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    type character varying(20) COLLATE pg_catalog."default",
    badge_id serial,
    CONSTRAINT badges_pkey PRIMARY KEY (badge_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.badges
    OWNER to postgres;



-- Table: public.achievements

-- DROP TABLE IF EXISTS public.achievements;

CREATE TABLE IF NOT EXISTS public.achievements
(
    user_id uuid NOT NULL,
    achieved_date timestamp(6) with time zone,
    badge_id integer NOT NULL,
    CONSTRAINT achievements_pkey PRIMARY KEY (badge_id, user_id),
    CONSTRAINT fkj05i4hctg7rpv2d5w2bouiy0r FOREIGN KEY (badge_id)
        REFERENCES public.badges (badge_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.achievements
    OWNER to postgres;

	

create table leaderboard
(
    user_id        uuid not null,
    score          bigint not null default 0,
    leaderboard_id uuid not null
        primary key,
    advanced       integer,
    beginner       integer,
    intermediate   integer,
    total_course   integer,
    easy           integer,
    hard           integer,
    medium         integer,
    total_problem  integer,
    type           varchar(255)
);

alter table leaderboard
    owner to postgres;

create table notifications
(
    id           uuid not null
        primary key,
    message      text default '',
    recipient_id uuid,
    timestamp    timestamp(6) with time zone default current_timestamp,
    title        varchar(255) default '',
    type         smallint
        constraint notifications_type_check
            check ((type >= 0) AND (type <= 3)),
    mark_as_read boolean default false
);

alter table notifications
    owner to postgres;





create table report_options
(
    report_option_id uuid not null default uuid_generate_v4()
        primary key,
    handle_action    varchar(255),
    report_reason    varchar(255),
    type             varchar(20)
);

alter table report_options
    owner to postgres;

create table streak_records
(
    last_access  timestamp(6) with time zone,
    streak_score integer,
    user_uid     varchar(255) not null
);

alter table streak_records
    owner to postgres;


create table topics
(
    topic_id        uuid default uuid_generate_v4() not null
        primary key,
    content         text,
    number_of_likes bigint default 0,
    post_reach      varchar(10) check (post_reach in ('public', 'private')) default 'public',
    title           varchar(255),
    user_id         varchar(255)
);



alter table topics
    owner to postgres;

create table comments
(
    comment_id         uuid not null
        primary key,
    content            text,
    number_of_likes bigint default 0,
    created            timestamp(6) with time zone default current_timestamp,
    last_modified      timestamp(6) with time zone,
    user_id            uuid,
    parent_comment_id  uuid
        constraint fkst79ninfcw8cbrihoedh118xk
            references comments,
    replied_comment_id uuid
        constraint fkbd3tl8jha2ib2812q9p9yxcmo
            references comments,
    topic_id           uuid
        constraint fkhanwncw4vn5t5syodhdma5sip
            references topics
);

alter table comments
    owner to postgres;

create table comment_reactions
(
    user_id            uuid not null,
    comment_comment_id uuid not null
        constraint fkq6o8wtr8e4nhe4ya9yhnm4mli
            references comments,
    primary key (comment_comment_id, user_id),
    active boolean default true
);

alter table comment_reactions
    owner to postgres;


create table comment_reports
(
    owner_id         uuid not null,
    content          text,
    status           varchar(10),
    user_id          uuid,
    destination_id   uuid not null
        constraint fksscjqt1wyjomldmqvx7u6iqhy
            references comments,
    report_option_id uuid not null
        constraint fkfkwxdv8wp5h56wq69jnp5ux3g
            references report_options,
    primary key (destination_id, owner_id, report_option_id)
);

alter table comment_reports
    owner to postgres;

create table courses
(
    course_id      uuid default uuid_generate_v4() not null
        primary key,
    course_name    varchar(255),
    description    text,
    level          varchar(20) check(level in ('Beginner','Intermediate','Advanced')),
    price          numeric(11, 2) default 0.00,
    unit_price     varchar(10) default 'VNĐ',
    user_id        uuid,
    topic_id       uuid
        constraint uk23uffat5pnitvcg67ugi4kvck
            unique
        constraint fklljvfay1x0yv1gm2xmd6s7j9b
            references topics,
    average_rating DECIMAL(3,2) default 0.00,
    review_count   integer default 0,
	score          integer default 0,
    current_creation_step integer default 1,
    is_available boolean default false,
    course_image text,
    is_completed_creation boolean default false,
    template_code         integer        default 1,
    created_at timestamp(6) with time zone
);

alter table courses
    owner to postgres;

create table lessons
(
    lesson_id    uuid default uuid_generate_v4() not null
        primary key,
    content      text,
    description  text,
    lesson_name  varchar(255),
    lesson_order integer not null default 1,
    is_quiz_visible boolean DEFAULT false,
    problem_id   uuid,
    course_id    uuid                            not null
        constraint fk2uhy91p0gnptep0xxwaal7gnu
            references courses
);

alter table lessons
    owner to postgres;


create table exercises
(
    exercise_id   uuid not null default uuid_generate_v4()
        primary key,
    description   text,
    exercise_name varchar(255),
    passing_questions      integer,
    questions_per_exercise integer,

    lesson_id              uuid
        constraint uk9yqkdn70s99mfseuswi0mspbi
            unique
        constraint fkevmwr324tb3wfuachs1jimucn
            references lessons
);

alter table exercises
    owner to postgres;


create table questions
(
    question_id      uuid not null default uuid_generate_v4()
        primary key,
    correct_answer   varchar(255),
    created_at       timestamp(6) with time zone default current_timestamp,
    question_content text,
    question_type    char check(question_type in ('S','M')),
    status           varchar(10) check (status in ('active', 'unavailable')),
    updated_at       timestamp(6) with time zone,
    question_order integer DEFAULT 1,
    exercise_id      uuid
        constraint fkostmdcxvqgrn6vvu29bkbyfjp
            references exercises
);

alter table questions
    owner to postgres;

create table options
(
    option_order integer not null,
    content      varchar(255),
    question_id  uuid    not null
        constraint fkjglnbyg0fqsplv75m2oi42ji1
            references questions,
    primary key (option_order, question_id)
);

alter table options
    owner to postgres;


create table learning_lesson
(
    learning_id        uuid not null default uuid_generate_v4()
        primary key,
    is_done_practice   boolean,
    is_done_theory     boolean,
    last_accessed_date timestamp(6) with time zone,
    status             varchar(10),
    user_id            uuid,
    lesson_id          uuid
        constraint fktl0duxtv32rt2myr59sv7d3r3
            references lessons ON DELETE CASCADE
);

alter table learning_lesson
    owner to postgres;

create table assignments
(
    assignment_id uuid not null default uuid_generate_v4()
        primary key,
    score         numeric(4, 2),
    submit_date   timestamp(6) with time zone,
    submit_order  integer,
    exercise_id   uuid
        constraint fkadkhyietaewgkc3cj0tr8kfon
            references exercises,
    learning_id   uuid not null
        constraint fka5frurhonloarunth7ldi7ahb
            references learning_lesson
);

alter table assignments
    owner to postgres;

create table assignment_details
(
    submit_order  integer not null,
    answer        varchar(20),
    unit_score    numeric(4, 2),
    assignment_id uuid    not null
        constraint fkt8xkuef7x94oj86nfxgq85yg9
            references assignments,
    question_id   uuid    not null
        constraint fk2ymomgwidfms2ucwbdqrevu9x
            references questions,
    primary key (assignment_id, submit_order)
);

alter table assignment_details
    owner to postgres;

create table other_object_reports
(
    owner_id         uuid not null,
    content          text,
    status           varchar(10),
    user_id          uuid,
    destination_id   uuid not null
        constraint fkg6fa7rtsqjtg9imov1j508ors
            references topics,
    report_option_id uuid not null
        constraint fk9ajip7upweyynaymq36mt7mo4
            references report_options,
    primary key (destination_id, owner_id, report_option_id)
);

alter table other_object_reports
    owner to postgres;

create table reviews
(
    review_id uuid    not null default uuid_generate_v4()
        primary key,
    comment   text,
    rating    integer not null check (rating >= 0 and rating <= 5),
    user_uuid   uuid,
    user_uid varchar,
    create_at timestamp(6) with time zone default current_timestamp,
    last_modified_at timestamp(6) with time zone,
    course_id uuid    not null
        constraint fkl9h49973yigjg39ov07a9mog6
            references courses
);

alter table reviews
    owner to postgres;
create table certificates
(
    certificate_id  uuid not null
        primary key,
    certificate_url text,
    completed_date  timestamp(6) with time zone default current_timestamp
);

alter table certificates
    owner to postgres;

create table user_courses
(
    user_uid           uuid not null,
    last_accessed_date timestamp(6) with time zone,
    progress_percent   numeric(5, 2) check ((progress_percent>= 0.00) and (progress_percent <= 100.00)),
    status             varchar(10),
    latest_lesson_id   uuid,
    enroll_using_subscription boolean default FALSE,
    access_status varchar(20),
    course_id          uuid not null
        constraint fkcve18frw4nbxwrq0qh78dgipc
            references courses,
    certificate_id     uuid
        constraint ukc837lk3wvu491io9pfiauof89
            unique
        constraint fk44luvbgh95mw3c0yarrbpfv9t
            references certificates,
    primary key (course_id, user_uid)
);

alter table user_courses
    owner to postgres;

create table categories
(
    category_id   integer      not null
        primary key,
    category_name varchar(100) not null,
    parent_id     integer
        constraint fkcidcf2xf6eebpieowr7m02pg5
            references categories
);

alter table categories
    owner to postgres;

create table course_category
(
    course_id   uuid    not null
        constraint fkl4r5vdloyu8rtqoh4ei49y2x2
            references courses ON DELETE CASCADE,
    category_id integer not null
        constraint fky6fhus0rcvwiik7rk5l99j3j
            references categories
);

alter table course_category
    owner to postgres;

create table question_category
(
    question_id uuid    not null
        constraint fkssojn51nglg3ydh1lwbk62hyr
            references questions,
    category_id integer not null
        constraint fkpo1ya01k2p6b6b03b4elbvow6
            references categories
);

alter table question_category
    owner to postgres;

create table sections
(
    section_id integer not null
        primary key,
    name       varchar(255)
);

alter table sections
    owner to postgres;

create table course_section
(
    course_id  uuid    not null
        constraint fk61t4e9fdsniv4cui65oih8sr3
            references courses ON DELETE CASCADE,
    section_id integer not null
        constraint fkidr2cur1nxr2hy5pnf9rsplwi
            references sections
);

alter table course_section
    owner to postgres;

create table problem_category
(
    category_id integer not null,
    problem_id  uuid    not null
        constraint fk2rg82j2evmwbfrglcpvhwpxfa
            references problems,
    primary key (category_id, problem_id)
);

alter table problem_category
    owner to postgres;



create table course_summary
(
    course_id       uuid not null
        primary key
        constraint fk_c_cs
            references courses ON DELETE CASCADE,
    course_name     varchar(255),
    summary_content text
);

alter table course_summary
    owner to postgres;

create table problem_comments
(
    comment_id          uuid not null default uuid_generate_v4()
        primary key,
    content               text,
    is_modified         boolean,
    number_of_likes     INTEGER,
    created_at          timestamp(6) with time zone,
    last_modified_at    timestamp(6) with time zone,
    user_uuid           uuid,
    user_uid            varchar,
    problem_id  uuid    not null
        constraint fkju03qoqky593eka4s5okbssn5
            references problems,
    parent_comment_id   uuid
        constraint fkfppcc9srw5ppiweo0qjvbls6a
            references problem_comments,
    replied_comment_id  uuid
        constraint fk9rxtnbox2bfnt1582r6apsnls
            references problem_comments
);

alter table problem_comments
    owner to postgres;

create table problem_comment_reactions
(
    user_uuid uuid not null,
    problem_comment_comment_id uuid not null
        constraint fka45m53xgm1j7twrchtcvg5cax
            references problem_comments,
    primary key (user_uuid, problem_comment_comment_id),
    active boolean default true
);

alter table problem_comment_reactions
    owner to postgres;

create table vnpay_payment_premium_package
(
    payment_premium_package_id uuid not null default uuid_generate_v4()
        primary key,
    user_uuid uuid,
    user_uid text,
    start_date timestamp(6) with time zone,
    end_date timestamp(6) with time zone,
    package_type text,
    status text,
    duration integer
);

alter table vnpay_payment_premium_package
    owner to postgres;

create table vnpay_payment
(
    payment_id uuid not null default uuid_generate_v4()
        primary key,
    user_uid varchar,
    user_uuid uuid not null,
    transaction_status text,
    response_code text,
    total_payment_amount float4,
    currency text,
    paid_amount float4,
    bank_code text,
    transaction_reference text,
    created_at timestamp(6) with time zone,
    received_at timestamp(6) with time zone,
    bank_transaction_no text,
    transaction_no text,
    order_description text,
    payment_for text,
    payment_premium_package_id uuid
        constraint uk4l2cq58r9gpl4h1f315p8e3ng
            unique
        constraint fkl1j58k29u0wph49ltbulycpwe
            references vnpay_payment_premium_package
);

alter table vnpay_payment
    owner to postgres;


create table vnpay_payment_courses
(
    course_id uuid not null,
    user_uid text,
    payment_id uuid
        constraint fkqbo2u2em1wlor0eeu9alboqoy
            references vnpay_payment,
    primary key (course_id, user_uid)
);

alter table vnpay_payment_courses
    owner to postgres;

create table view_solution_behaviors
(
    id         integer generated by default as identity
        primary key,
    created_at timestamp(6),
    problem_id uuid,
    user_id    uuid
);

alter table view_solution_behaviors
    owner to postgres;

-- Lessons(Lesson_Order)
-- Bảng tầm ảnh hưởng
-- Đây là bảng lưu các dữ liệu master nên sẽ thường xuyên có các hành động xóa sửa
-- Hàng động xóa gần như không được xóa và sửa vì đây là bảng ghi lại các transaction ghi lại dữ liệu lịch sử
--  		| Thêm  | xóa   |  sửa
--	Lessons	|	+	|	+	|	+ [Lessons(lesson_order)]
--		  	|		|		|

CREATE OR REPLACE FUNCTION gen_learning_lesson()
RETURNS TRIGGER AS $$
BEGIN
	IF NOT EXISTS (
	    SELECT 1 
	    FROM user_courses 
	    WHERE course_id = NEW.course_id
	) THEN
	    RETURN NEW;
	END IF;

	WITH user_ids AS(
		SELECT user_uid as user_id
		FROM user_courses
		WHERE course_id = NEW.course_id
	)
	INSERT INTO learning_lesson(is_done_practice,status,user_id,lesson_id)
	SELECT false, 'NEW', user_ids.user_id, NEW.lesson_id
	FROM user_ids; 
	
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically call the function before insert
-- CREATE TRIGGER trigger_set_lesson_order
CREATE TRIGGER trigger_gen_learning_lesson
AFTER INSERT ON lessons
FOR EACH ROW
EXECUTE FUNCTION gen_learning_lesson();



-- CREATE OR REPLACE FUNCTION public.set_lesson_order()
--     RETURNS trigger AS $$
-- DECLARE
-- 	has_quiz BOOLEAN;
-- 	max_order INT;
--     order_exists BOOLEAN;
-- BEGIN
-- 	-- Get the maximum lesson_order for this course
--     SELECT COALESCE(MAX(lesson_order), 0) INTO max_order
--     FROM lessons
--     WHERE course_id = NEW.course_id;
    
--     -- If new.lesson_order is null, set it to max+1 (or 1 if no lessons exist)
--     IF NEW.lesson_order IS NULL THEN
--         NEW.lesson_order := max_order + 1;
--     ELSE
--         -- Check if there's already a lesson with this order in the same course
--         SELECT EXISTS (
--             SELECT 1 FROM lessons 
--             WHERE course_id = NEW.course_id 
--             AND lesson_order = NEW.lesson_order
--         ) INTO order_exists;
        
--         IF order_exists THEN
-- 			-- Bring this condition into 
--             -- Shift all lessons with order >= new.lesson_order up by 1
--             -- UPDATE lessons
--             -- SET lesson_order = lesson_order + 1
--             -- WHERE course_id = NEW.course_id AND lesson_id != NEW.lesson_id
--             -- AND lesson_order >= NEW.lesson_order;
--         ELSE
--             -- If the requested order is higher than max+1, set to max+1
--             IF NEW.lesson_order > max_order + 1 THEN
--                 NEW.lesson_order := max_order + 1;
--             END IF;
--         END IF;
--     END IF;

-- 	IF (NOT NEW.is_quiz_visible) THEN
-- 		RETURN NEW;
-- 	END IF;


--     IF (NEW.is_quiz_visible) THEN
-- 		SELECT EXISTS
-- 			(SELECT 1
-- 			FROM EXERCISES WHERE LESSON_ID = NEW.LESSON_ID)
-- 		INTO has_quiz;
-- 	END IF;

-- 	IF (NOT has_quiz) THEN
-- 		RAISE EXCEPTION 'VALIDATE DATA: %', 'lesson doesn''s have quiz to make visible';
-- 	END IF;
-- 	RETURN NEW;
-- END;
-- $$ language plpgsql;


-- CREATE TRIGGER set_lesson_is_quiz_visible
-- BEFORE INSERT OR UPDATE ON lessons
-- FOR EACH ROW EXECUTE FUNCTION set_lesson_order();



-- FUNCTION: public.set_avg_acceptance()

-- DROP FUNCTION IF EXISTS public.set_avg_acceptance();

CREATE OR REPLACE FUNCTION public.set_avg_acceptance()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
DECLARE
    new_avg_acceptance numeric(5,2);
	is_bonus boolean;
BEGIN

	new_avg_acceptance := (
		SELECT AVG(is_solved::int)
		FROM problem_submissions
		WHERE problem_id = NEW.problem_id
		GROUP BY problem_id
	);

	UPDATE problems 
	SET acceptance_rate = new_avg_acceptance 
	WHERE problem_id = NEW.problem_id;

	IF (NEW.is_solved) THEN
		IF NOT EXISTS (	SELECT 1 
						FROM view_solution_behaviors 
						WHERE problem_id = NEW.problem_id
							AND user_id = NEW.user_id) THEN
			WITH accepted_submissions as(
				SELECT *
				FROM problem_submissions 
				WHERE problem_id = NEW.problem_id
					AND user_id = NEW.user_id AND is_solved = true
			)
			SELECT count(*) = 1
			from  accepted_submissions ac_s
			into is_bonus;

			
			WITH last_submit as
			(
				SELECT *
				FROM problem_submissions 
				WHERE problem_id = NEW.problem_id
					AND user_id = NEW.user_id
				ORDER BY created_at desc
				LIMIT 1
			)
			SELECT is_bonus and (NEW.submission_id = last_submit.submission_id)
			FROM last_submit into is_bonus;

			IF (is_bonus) THEN
				IF NOT EXISTS(SELECT 1 FROM leaderboard WHERE user_id = NEW.user_id AND type = 'problem') THEN 
					INSERT INTO leaderboard (user_id, score, easy, hard, medium, total_problem, type)
					SElECT NEW.user_id, p.score, 
							case when p.problem_level = 'easy' then 1 else 0 end as easy, 
							case when p.problem_level = 'medium' then 1 else 0 end as medium,
							case when p.problem_level = 'hard' then 1 else 0 end as hard, 
							1, 'problem'
					FROM problems p 
					where p.problem_id = NEW.problem_id;
					IF NOT EXISTS(SELECT 1 FROM leaderboard WHERE user_id = NEW.user_id AND type = 'all') THEN 
						INSERT INTO leaderboard (user_id, score, easy, hard, medium, total_problem, type)
						SElECT NEW.user_id, p.score, 
							case when p.problem_level = 'easy' then 1 else 0 end as easy, 
							case when p.problem_level = 'medium' then 1 else 0 end as medium,
							case when p.problem_level = 'hard' then 1 else 0 end as hard, 
							1, 'all'
						FROM problems p 
						where p.problem_id = NEW.problem_id;
					ELSE 
						UPDATE leaderboard
						SET score = leaderboard.score + p.score,
						    easy = CASE WHEN p.problem_level = 'easy' THEN leaderboard.easy + 1 ELSE leaderboard.easy END,
						    medium = CASE WHEN p.problem_level = 'medium' THEN leaderboard.medium + 1 ELSE leaderboard.medium END,
						    hard = CASE WHEN p.problem_level = 'hard' THEN leaderboard.hard + 1 ELSE leaderboard.hard END,
						    total_problem = leaderboard.total_problem + 1
						FROM problems p
						WHERE p.problem_id = NEW.problem_id
					  		AND leaderboard.user_id = NEW.user_id
					  		AND type = 'all';
					END IF;
				ELSE 
					UPDATE leaderboard
					SET score = leaderboard.score + p.score,
					    easy = CASE WHEN p.problem_level = 'easy' THEN leaderboard.easy + 1 ELSE leaderboard.easy END,
					    medium = CASE WHEN p.problem_level = 'medium' THEN leaderboard.medium + 1 ELSE leaderboard.medium END,
					    hard = CASE WHEN p.problem_level = 'hard' THEN leaderboard.hard + 1 ELSE leaderboard.hard END,
					    total_problem = leaderboard.total_problem + 1
					FROM problems p
					WHERE p.problem_id = NEW.problem_id
					  AND leaderboard.user_id = NEW.user_id
					  AND type = 'problem';

					UPDATE leaderboard
						SET score = leaderboard.score + p.score,
						    easy = CASE WHEN p.problem_level = 'easy' THEN leaderboard.easy + 1 ELSE leaderboard.easy END,
						    medium = CASE WHEN p.problem_level = 'medium' THEN leaderboard.medium + 1 ELSE leaderboard.medium END,
						    hard = CASE WHEN p.problem_level = 'hard' THEN leaderboard.hard + 1 ELSE leaderboard.hard END,
						    total_problem = leaderboard.total_problem + 1
						FROM problems p
						WHERE p.problem_id = NEW.problem_id
					  		AND leaderboard.user_id = NEW.user_id
					  		AND type = 'all';
				END IF;
			END IF;
		END IF;
	END IF;
	
	
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.set_avg_acceptance()
    OWNER TO postgres;


CREATE TRIGGER update_problem_agv_acceptance
AFTER INSERT OR UPDATE ON problem_submissions
FOR EACH ROW EXECUTE FUNCTION set_avg_acceptance();






	


INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (1, 'Data Structure', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (2, 'Algorithm', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (5, 'Problem Solving', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (6, 'Array', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (7, 'Queue', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (8, 'Recursive', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (9, 'Dynamic Programming', null);
INSERT INTO public.categories (category_id, category_name, parent_id) VALUES (10, 'Matrix', null);


INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('dbfea360-dda9-46a5-9487-ea624080bb60', 'What is Stack Data Structure? A Complete Tutorial', null, null, 'Stack', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('5fe612b4-3998-44c7-85b2-2e4e973a38a7', 'The logical thinking and problem-solving skills through practical programming exercises. You’ll learn how to analyze problems, design algorithms, and optimize solution. By the end of the course, you’ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications.', null, null, 'Logic Building Problems', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('f8a1c71a-39ef-406f-b5e3-93b5c4deb5bc', 'A foundational understanding of Data Structures and Algorithms (DSA). You’ll explore key concepts like arrays, linked lists, stacks, queues, trees, and graphs, along with essential algorithms for searching, sorting, and traversal. By mastering these principles, you’ll enhance your problem-solving skills and prepare for advanced programming challenges and technical interviews.', null, null, 'Introduction to DSA', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('ed7db5f2-03dc-4a0c-a7c6-5549b1c5c090', 'The fundamentals and applications of the matrix as a data structure. You’ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming.', null, null, 'Matrix Data Structure Guide', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('067b8270-f488-41b8-a741-9d118e9dc6c4', 'An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving.', null, null, 'Linked List Data Structure Guide', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('5df3554d-160e-45b9-989a-ebd58ee65235', 'A detailed guide to mastering heaps, including min-heaps and max-heaps. Learn heap operations like insertion, deletion, and heapify, along with their applications in priority queues, sorting algorithms, and efficient problem-solving. Essential for optimizing tasks involving hierarchical data.', null, null, 'Heap Data Structure Guide', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('f16f21af-1f53-4b7d-be4f-368c17574f02', 'A concise guide to understanding and applying recursion in programming. Covers key concepts like base cases, recursive calls, and stack behavior, along with examples in problems such as factorials, Fibonacci sequences, tree traversals, and divide-and-conquer algorithms. Perfect for building efficient and elegant solution.', null, null, 'Guide on Recursive Algorithms', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('dd29f271-a9df-4fcc-a742-127dd269f84b', 'An essential guide to exploring graph algorithms and their applications. Covers fundamental concepts like BFS, DFS, shortest path algorithms (Dijkstra, Bellman-Ford), and minimum spanning trees (Kruskal, Prim). Ideal for solving complex network-based problems in various domains.', null, null, 'Guide on Graph Algorithms', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('a926fe6d-ded3-4127-9558-599fa430e1f6', 'A practical guide to greedy algorithms, focusing on solving optimization problems step-by-step. Learn key strategies with examples like activity selection, Huffman coding, and Kruskal’s algorithm. Perfect for building efficient and straightforward solution.', null, null, 'Guide on Greedy Algorithms', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('0a489a2f-a622-4ba9-a94d-70d5624e1309', 'A comprehensive guide to dynamic programming, covering principles like overlapping subproblems and optimal substructure. Master classic problems such as knapsack, longest common subsequence, and matrix chain multiplication. Ideal for tackling complex optimization challenges.', null, null, 'Dynamic Programming Guide', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('95795791-8e54-4cce-8272-c06c15df68fc', 'An essential guide to bitwise operations and their applications in algorithm design. Covers AND, OR, XOR, shifts, and tricks for solving problems like subsets, power-of-two checks, and fast calculations. Perfect for low-level optimization and competitive programming.', null, null, 'Bitwise Algorithms Guide', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('01e7b3b3-a36a-4679-b082-14c2ad622628', 'Introduction to Queue Data Structure', null, null, 'Queue', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('d9fbda58-f71b-4567-affe-4fbab0933feb', 'What is Stack Data Structure? A Complete Tutorial', null, null, 'Stack', null);
INSERT INTO public.topics (topic_id, content, number_of_likes, post_reach, title, user_id) VALUES ('a9e73bb9-21d3-445c-bd9d-6ed22eac6450', 'Introduction to DSA III: Trees & Hierarchical Data', 0, 'public', 'Introduction to DSA III: Trees & Hierarchical Data', null);


INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'Dynamic Programming Guide', 'A comprehensive guide to dynamic programming, covering principles like overlapping subproblems and optimal substructure. Master classic problems such as knapsack, longest common subsequence, and matrix chain multiplication. Ideal for tackling complex optimization challenges.', 'Advanced', 100000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '0a489a2f-a622-4ba9-a94d-70d5624e1309', null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/2170852_0c34_7.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'Matrix Data Structure Guide', 'The fundamentals and applications of the matrix as a data structure. You’ll learn how to represent, manipulate, and solve problems involving matrices, including operations like addition, multiplication, transposition, and common algorithms for pathfinding, transformations, and dynamic programming. Perfect for mastering 2D data organization and computation in programming.', 'Beginner', 100000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'ed7db5f2-03dc-4a0c-a7c6-5549b1c5c090', null, null, 10, 4, true, 'https://img-c.udemycdn.com/course/240x135/1248732_d2c9_3.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'TAOCP 3', 'Basic to Advanced TAOCP Part 3', 'Advanced', 200000.00, 'VND', null, null, null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/1319940_748e_2.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'TAOCP 4', 'Basic to Advanced TAOCP Part 4', 'Advanced', 300000.00, 'VND', null, null, null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/4978572_b8cb_3.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('58220cca-f7ec-4188-9921-18e6ea20e4d7', 'Guide on Recursive Algorithms', 'A concise guide to understanding and applying recursion in programming. Covers key concepts like base cases, recursive calls, and stack behavior, along with examples in problems such as factorials, Fibonacci sequences, tree traversals, and divide-and-conquer algorithms. Perfect for building efficient and elegant solution.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'f16f21af-1f53-4b7d-be4f-368c17574f02', null, null, 20, 4, true, 'https://img-c.udemycdn.com/course/480x270/5542494_55db_6.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'The Logic Building Problems', 'Logical thinking and problem-solving skills through practical programming exercises. You’ll learn how to analyze problems, design algorithms, and optimize solution. By the end of the course, you’ll confidently tackle various problem types, including sorting, searching, recursion, and basic data structures, preparing you for coding challenges and real-world applications.', 'Beginner', 100000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '5fe612b4-3998-44c7-85b2-2e4e973a38a7', null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/4527338_a47e_9.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('a24c71fe-2e77-4352-8449-a448ace4d400', 'Bitwise Algorithms Guide', 'An essential guide to bitwise operations and their applications in algorithm design. Covers AND, OR, XOR, shifts, and tricks for solving problems like subsets, power-of-two checks, and fast calculations. Perfect for low-level optimization and competitive programming.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '95795791-8e54-4cce-8272-c06c15df68fc', null, null, 10, 4, true, 'https://substackcdn.com/image/fetch/w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F2107a8d5-63b6-411e-ae05-f9d7498e52cb_714x483.png', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'Linked List Data Structure Guide', 'An in-depth guide to understanding and implementing linked lists. Explore concepts like singly, doubly, and circular linked lists, along with common operations such as insertion, deletion, traversal, and reversal. Ideal for mastering dynamic data organization and memory-efficient problem-solving.', 'Beginner', 50000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '067b8270-f488-41b8-a741-9d118e9dc6c4', null, null, 40, 4, true, 'https://img-c.udemycdn.com/course/480x270/4034058_8dc2_2.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('e9d2858c-482e-4b04-8317-b93ce60c3581', 'Heap Data Structure Guide', 'A detailed guide to mastering heaps, including min-heaps and max-heaps. Learn heap operations like insertion, deletion, and heapify, along with their applications in priority queues, sorting algorithms, and efficient problem-solving. Essential for optimizing tasks involving hierarchical data.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '5df3554d-160e-45b9-989a-ebd58ee65235', null, null, 20, 4, true, 'https://img-c.udemycdn.com/course/480x270/4197610_0c93.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('f19021ae-42fd-4c25-814c-f06027de04a9', 'Guide on Greedy Algorithms', 'A practical guide to greedy algorithms, focusing on solving optimization problems step-by-step. Learn key strategies with examples like activity selection, Huffman coding, and Kruskal’s algorithm. Perfect for building efficient and straightforward solution.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'a926fe6d-ded3-4127-9558-599fa430e1f6', null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/2619556_7863_2.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'TAOCP 5', 'Basic to Advanced TAOCP Part 5', 'Advanced', 400000.00, 'VND', null, null, null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/2535748_5050_6.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'TAOCP 1', 'Basic to Advanced TAOCP Part 1', 'Advanced', 50000.00, 'VND', null, null, null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/1395136_3f8a_3.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'Advanced DSA: Advanced Algorithms Mastery', 'Basic to Advanced DSA', 'Advanced', 100000.00, 'VND', null, null, null, null, 30, 4, true, 'https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/dd1abac9-220d-4c4d-a8c5-d755e2606800/public', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('c9b04774-3a81-43ab-ace6-5242360d9e07', 'Queue', 'The Queue lesson series dives into the mechanics of this fundamental data structure, which follows the FIFO (First In, First Out) principle. You’ll learn how to perform operations such as enqueue, dequeue, and peek, while also exploring its variations like Circular Queues and Priority Queues. Practical applications, including task scheduling, buffering, and breadth-first search algorithms, will help solidify your understanding. This series is perfect for beginners and anyone looking to master essential programming concepts.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', '01e7b3b3-a36a-4679-b082-14c2ad622628', null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/2484706_b943.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'Introduction to DSA II: Recursion & Algorithmic Thinking', 'Unlock the power of recursive problem-solving and advanced algorithms. Dive deep into search/sort techniques (Binary Search, QuickSort, MergeSort), hashing principles, and space-time complexity analysis. Perfect for strengthening your ability to optimize solutions for real-world problems.', 'Beginner', 100000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'f8a1c71a-39ef-406f-b5e3-93b5c4deb5bc', null, null, 20, 4, true, 'https://res.cloudinary.com/diyn1vkim/image/upload/v1749970652/CourseAvatar/8ff4ea92-41f2-4d49-b230-0281874efb2d.webp', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('95713603-63d1-4b75-8a89-1acdc0977459', 'Stack', 'The Stack lesson series offers a comprehensive introduction to one of the fundamental data structures in programming. You''ll explore how a Stack operates based on the LIFO (Last In, First Out) principle, perform core operations such as push, pop, and peek, and apply these concepts to real-world problems like validating parentheses, converting expressions, or building a browser''s backtracking system. This series is ideal for beginners and those looking to strengthen their understanding of data structures.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'd9fbda58-f71b-4567-affe-4fbab0933feb', null, null, 20, 4, true, 'https://teaching4imgs.com.au/wp-content/uploads/2023/09/default-product-card.png', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'TAOCP 2', 'Basic to Advanced TAOCP Part 2', 'Advanced', 100000.00, 'VND', null, null, null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/3976394_79f4.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'TAOCP 6', 'Basic to Advanced TAOCP Part 6', 'Advanced', 500000.00, 'VND', null, null, null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/4461212_146f_5.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'TAOCP 7', 'Basic to Advanced TAOCP Part 7', 'Advanced', 1000000.00, 'VND', null, null, null, null, 30, 4, true, 'https://img-c.udemycdn.com/course/480x270/5251934_7367_7.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'Guide on Graph Algorithms', 'An essential guide to exploring graph algorithms and their applications. Covers fundamental concepts like BFS, DFS, shortest path algorithms (Dijkstra, Bellman-Ford), and minimum spanning trees (Kruskal, Prim). Ideal for solving complex network-based problems in various domains.', 'Intermediate', 50000.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'dd29f271-a9df-4fcc-a742-127dd269f84b', null, null, 50, 4, true, 'https://img-c.udemycdn.com/course/480x270/1426692_2edd_2.jpg', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('2d282726-865b-41fb-8cf5-7a2116099466', 'Intermediate DSA: Trees & Hierarchical Data', 'Explore hierarchical data with binary trees, BSTs, and self-balancing AVL trees. Learn traversal methods, collision handling in hashing, and tree-based optimizations. Ideal for tackling non-linear data scenarios like filesystems and database indexing.', 'Intermediate', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'a9e73bb9-21d3-445c-bd9d-6ed22eac6450', 0, 0, 50, 4, true, 'https://res.cloudinary.com/diyn1vkim/image/upload/v1749971892/CourseAvatar/2d282726-865b-41fb-8cf5-7a2116099466.png', true, 1, null);
INSERT INTO public.courses (course_id, course_name, description, level, price, unit_price, user_id, topic_id, average_rating, review_count, score, current_creation_step, is_available, course_image, is_completed_creation, template_code, created_at) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', e'Introduction to DSA I: Foundations & Linear Structures', 'Master the building blocks of Data Structures! This course covers arrays, matrices, linked lists, stacks, and queues - the essential linear structures that power efficient data organization. Learn to implement, analyze, and apply these structures while solidifying your understanding of Big-O notation and algorithmic thinking.', 'Beginner', 0.00, 'VND', '4d0c8d27-4509-402b-cf6f-58686cd47319', 'dbfea360-dda9-46a5-9487-ea624080bb60', null, null, 20, 4, true, 'https://courseclub.site/wp-content/uploads/2022/10/NeetCode.jpg', true, 1, null);



INSERT INTO public.course_category (course_id, category_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 5);
INSERT INTO public.course_category (course_id, category_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 1);
INSERT INTO public.course_category (course_id, category_id) VALUES ('e9d2858c-482e-4b04-8317-b93ce60c3581', 1);
INSERT INTO public.course_category (course_id, category_id) VALUES ('58220cca-f7ec-4188-9921-18e6ea20e4d7', 2);
INSERT INTO public.course_category (course_id, category_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 1);
INSERT INTO public.course_category (course_id, category_id) VALUES ('f19021ae-42fd-4c25-814c-f06027de04a9', 2);
INSERT INTO public.course_category (course_id, category_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 2);
INSERT INTO public.course_category (course_id, category_id) VALUES ('a24c71fe-2e77-4352-8449-a448ace4d400', 2);
INSERT INTO public.course_category (course_id, category_id) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', 1);
INSERT INTO public.course_category (course_id, category_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 1);
INSERT INTO public.course_category (course_id, category_id) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', 7);
INSERT INTO public.course_category (course_id, category_id) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', 6);
INSERT INTO public.course_category (course_id, category_id) VALUES ('58220cca-f7ec-4188-9921-18e6ea20e4d7', 8);
INSERT INTO public.course_category (course_id, category_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 9);
INSERT INTO public.course_category (course_id, category_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 10);

INSERT INTO public.sections (section_id, name) VALUES (1, 'Free Courses');
INSERT INTO public.sections (section_id, name) VALUES (2, 'Featured Courses');

INSERT INTO public.course_section (course_id, section_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('e9d2858c-482e-4b04-8317-b93ce60c3581', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('58220cca-f7ec-4188-9921-18e6ea20e4d7', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('f19021ae-42fd-4c25-814c-f06027de04a9', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('a24c71fe-2e77-4352-8449-a448ace4d400', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('c9b04774-3a81-43ab-ace6-5242360d9e07', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('95713603-63d1-4b75-8a89-1acdc0977459', 1);
INSERT INTO public.course_section (course_id, section_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('e9d2858c-482e-4b04-8317-b93ce60c3581', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('58220cca-f7ec-4188-9921-18e6ea20e4d7', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('f19021ae-42fd-4c25-814c-f06027de04a9', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('a24c71fe-2e77-4352-8449-a448ace4d400', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('dc8c4016-8dba-4baf-afea-ada6f0c21ae4', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('c9b04774-3a81-43ab-ace6-5242360d9e07', 2);
INSERT INTO public.course_section (course_id, section_id) VALUES ('95713603-63d1-4b75-8a89-1acdc0977459', 2);

INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('bc7282ef-2185-47e3-acbc-5b5597cbbbfc', e'****Examples :****





```
Input:  1/2 + 3/2
Output: 2/1

Input:  1/3 + 3/9
Output: 2/3

Input:  1/5 + 3/15
Output: 2/5
```







****Algorithm to add two fractions****





* Find a common denominator by finding the LCM (Least Common Multiple) of the two denominators.
* Change the

  [fractions](https://www.geeksforgeeks.org/fractions/)
  to have the same denominator and add both terms.
* Reduce the final fraction obtained into its simpler form by dividing both numerator and denominator by their largest common factor.





C++

````
// C++ program to add 2 fractions
#include<bits/stdc++.h>
using namespace std;

// Function to return gcd of a and b
int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b%a, a);
}

// Function to convert the obtained fraction
// into it\'s simplest form
void lowest(int &den3, int &num3)
{
    // Finding gcd of both terms
    int common_factor = gcd(num3,den3);

// Converting both terms into simpler
    // terms by dividing them by common factor
    den3 = den3/common_factor;
    num3 = num3/common_factor;
}

//Function to add two fractions
void addFraction(int num1, int den1, int num2,
                 int den2, int &num3, int &den3)
{
    // Finding gcd of den1 and den2
    den3 = gcd(den1,den2);

// Denominator of final fraction obtained
    // finding LCM of den1 and den2
    // LCM * GCD = a * b
    den3 = (den1*den2) / den3;

// Changing the fractions to have same denominator
    // Numerator of the final fraction obtained
    num3 = (num1)*(den3/den1) + (num2)*(den3/den2);

// Calling function to convert final fraction
    // into it\'s simplest form
    lowest(den3,num3);
}

// Driver program
int main()
{
    int num1=1, den1=500, num2=2, den2=1500, den3, num3;
    addFraction(num1, den1, num2, den2, num3, den3);
    printf("%d/%d + %d/%d is equal to %d/%d\\n", num1, den1,
                                   num2, den2, num3, den3);
    return 0;
}

````

Java

````
// Java program to add 2 fractions

class GFG{
// Function to return gcd of a and b
static int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b%a, a);
}

// Function to convert the obtained fraction
// into it\'s simplest form
static void lowest(int den3, int num3)
{
    // Finding gcd of both terms
    int common_factor = gcd(num3,den3);

// Converting both terms into simpler
    // terms by dividing them by common factor
    den3 = den3/common_factor;
    num3 = num3/common_factor;
    System.out.println(num3+"/"+den3);
}

//Function to add two fractions
static void addFraction(int num1, int den1,
                        int num2, int den2)
{
    // Finding gcd of den1 and den2
    int den3 = gcd(den1,den2);

// Denominator of final fraction obtained
    // finding LCM of den1 and den2
    // LCM * GCD = a * b
    den3 = (den1*den2) / den3;

// Changing the fractions to have same denominator
    // Numerator of the final fraction obtained
    int num3 = (num1)*(den3/den1) + (num2)*(den3/den2);

// Calling function to convert final fraction
    // into it\'s simplest form
    lowest(den3,num3);
}

// Driver program
public static void main(String[] args)
{
    int num1=1, den1=500, num2=2, den2=1500;
    System.out.print(num1+"/"+den1+" + "+num2+"/"+den2+" is equal to ");
    addFraction(num1, den1, num2, den2);
}
}
// This code is contributed by mits

````

Python3

````
# Python3 program to add 2 fractions

# Function to return gcd of a and b
def gcd(a, b):
    if (a == 0):
        return b;
    return gcd(b % a, a);

# Function to convert the obtained
# fraction into it\'s simplest form
def lowest(den3, num3):

    # Finding gcd of both terms
    common_factor = gcd(num3, den3);

    # Converting both terms
    # into simpler terms by
    # dividing them by common factor
    den3 = int(den3 / common_factor);
    num3 = int(num3 / common_factor);
    print(num3, "/", den3);

# Function to add two fractions
def addFraction(num1, den1, num2, den2):

    # Finding gcd of den1 and den2
    den3 = gcd(den1, den2);

    # Denominator of final
    # fraction obtained finding
    # LCM of den1 and den2
    # LCM * GCD = a * b
    den3 = (den1 * den2) / den3;

    # Changing the fractions to
    # have same denominator Numerator
    # of the final fraction obtained
    num3 = ((num1) * (den3 / den1) +
            (num2) * (den3 / den2));

    # Calling function to convert
    # final fraction into it\'s
    # simplest form
    lowest(den3, num3);

# Driver Code
num1 = 1; den1 = 500;
num2 = 2; den2 = 1500;

print(num1, "/", den1, " + ", num2, "/",
      den2, " is equal to ", end = "");
addFraction(num1, den1, num2, den2);

# This code is contributed by mits

````

C#

````
// C# program to add 2 fractions

class GFG{
// Function to return gcd of a and b
static int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b%a, a);
}

// Function to convert the obtained fraction
// into it\'s simplest form
static void lowest(int den3, int num3)
{
    // Finding gcd of both terms
    int common_factor = gcd(num3,den3);

// Converting both terms into simpler
    // terms by dividing them by common factor
    den3 = den3/common_factor;
    num3 = num3/common_factor;
    System.Console.WriteLine(num3+"/"+den3);
}

//Function to add two fractions
static void addFraction(int num1, int den1, int num2, int den2)
{
    // Finding gcd of den1 and den2
    int den3 = gcd(den1,den2);

// Denominator of final fraction obtained
    // finding LCM of den1 and den2
    // LCM * GCD = a * b
    den3 = (den1*den2) / den3;

// Changing the fractions to have same denominator
    // Numerator of the final fraction obtained
    int num3 = (num1)*(den3/den1) + (num2)*(den3/den2);

// Calling function to convert final fraction
    // into it\'s simplest form
    lowest(den3,num3);
}

// Driver program
public static void Main()
{
    int num1=1, den1=500, num2=2, den2=1500;
    System.Console.Write(num1+"/"+den1+" + "+num2+"/"+den2+" is equal to ");
    addFraction(num1, den1, num2, den2);
}
}
// This code is contributed by mits

````

JavaScript

````
<script>

// Javascript program to add 2 fractions

// Function to return gcd of a and b

const gcd = (a, b) => {
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

// Function to convert the
// obtained fraction into
// it\'s simplest form

const lowest = (den3, num3) => {
    // Finding gcd of both terms
    let common_factor = gcd(num3, den3);

// Converting both terms
    // into simpler terms by
    // dividing them by common factor

    den3 = parseInt(den3 / common_factor);
    num3 = parseInt(num3 / common_factor);

    document.write(`${num3}/${den3}`)
}


// Function to add two fractions
const addFraction = (num1, den1, num2, den2) => {
    // Finding gcd of den1 and den2
    let den3 = gcd(den1, den2);

// Denominator of final
    // fraction obtained finding
    // LCM of den1 and den2
    // LCM * GCD = a * b
    den3 = (den1 * den2) / den3;

// Changing the fractions to
    // have same denominator Numerator
    // of the final fraction obtained
    let num3 = ((num1) * (den3 / den1) +
            (num2) * (den3 / den2));

// Calling function to convert
    // final fraction into it\'s
    // simplest form
    lowest(den3, num3);
}

// Driver Code
let num1 = 1;
let den1 = 500;
let num2 = 2;
let den2 = 1500;

document.write(`${num1}/${den1} + ${num2}/${den2} is equal to `);

addFraction(num1, den1, num2, den2);

// This code is contributed by _saurabh_jaiswal

</script>

````

PHP

````
<?php
// PHP program to add
// 2 fractions

// Function to return
// gcd of a and b
function gcd($a, $b)
{
    if ($a == 0)
        return $b;
    return gcd($b % $a, $a);
}

// Function to convert the
// obtained fraction into
// it\'s simplest form
function lowest(&$den3, &$num3)
{
    // Finding gcd of both terms
    $common_factor = gcd($num3, $den3);

// Converting both terms
    // into simpler terms by
    // dividing them by common factor

    $den3 = (int)$den3 / $common_factor;
    $num3 = (int) $num3 / $common_factor;
}

// Function to add
// two fractions
function addFraction($num1, $den1, $num2,
                     $den2, &$num3, &$den3)
{
    // Finding gcd of den1 and den2
    $den3 = gcd($den1, $den2);

// Denominator of final
    // fraction obtained finding
    // LCM of den1 and den2
    // LCM * GCD = a * b
    $den3 = ($den1 * $den2) / $den3;

// Changing the fractions to
    // have same denominator Numerator
    // of the final fraction obtained
    $num3 = ($num1) * ($den3 / $den1) +
            ($num2) * ($den3 / $den2);

// Calling function to convert
    // final fraction into it\'s
    // simplest form
    lowest($den3, $num3);
}

// Driver Code
$num1 = 1; $den1 = 500;
$num2 = 2; $den2 = 1500;
$den3; $num3;
addFraction($num1, $den1, $num2,
            $den2, $num3, $den3);
echo $num1, "/", $den1, " + ",
     $num2,"/", $den2, " is equal to ",
               $num3, "/", $den3, "\\n";

// This code is contributed by aj_36
?>

````

****Output :****


```
1/500 + 2/1500 is equal to 1/300
```

****Time Complexity:****
O(log(min(a, b)), where a and b are two integers.


****Auxiliary Space:****
O(1), no extra space required so it is a constant.
', 'Add two fraction a/b and c/d and print answer in simplest form.', 'Program to add two fractions', 2, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('aad6df64-c3f4-40e1-961b-817fa187f81f', e'
****Examples:****


```
Input: n = 15
Output: false
Divisors of 15 are 1, 3 and 5. Sum of
divisors is 9 which is not equal to 15.
Input: n = 6
Output: true
Divisors of 6 are 1, 2 and 3. Sum of
divisors is 6.


```




Recommended Practice

[Perfect Number](https://www.geeksforgeeks.org/problems/perfect-number3759/1/)


[Try It!](https://www.geeksforgeeks.org/problems/perfect-number3759/1/)


A

****Simple Solution****
is to go through every number from 1 to n-1 and check if it is a divisor. Maintain sum of all divisors. If sum becomes equal to n, then return true, else return false.



An

****Efficient Solution****
is to go through numbers till square root of n. If a number ‘i’ divides n, then add both ‘i’ and n/i to sum.



Below is the implementation of efficient solution.





C++
---

















```
// C++ program to check if a given number is perfect
// or not
#include<iostream>
using namespace std;

// Returns true if n is perfect
bool isPerfect( long long int n)
{
// To store sum of divisors
long long int sum = 1;

// Find all divisors and add them
for ( long long int i=2; i*i<=n; i++)
{
if (n%i==0)
{
if (i*i!=n)
sum = sum + i + n/i;
else
sum=sum+i;
}
}
// If sum of divisors is equal to
// n, then n is a perfect number
if (sum == n && n != 1)
return true ;

return false ;
}

// Driver program
int main()
{
cout << "Below are all perfect numbers till 10000\\n" ;
for ( int n =2; n<10000; n++)
if (isPerfect(n))
cout << n << " is a perfect number\\n" ;

return 0;
}
```





Java
----

















```
// Java program to check if a given
// number is perfect or not
import java.io.*;
public class GFG
{

// Returns true if n is perfect
static boolean isPerfect( int n)
{
// To store sum of divisors
int sum = 1 ;

// Find all divisors and add them
for ( int i = 2 ; i * i <= n; i++)
{
if (n % i== 0 )
{
if (i * i != n)
sum = sum + i + n / i;
else
sum = sum + i;
}
}
// If sum of divisors is equal to
// n, then n is a perfect number
if (sum == n && n != 1 )
return true ;

return false ;
}

// Driver program
public static void main (String[] args)
{
System.out.println( "Below are all perfect" +
"numbers till 10000" );
for ( int n = 2 ; n < 10000 ; n++)
if (isPerfect(n))
System.out.println( n +
" is a perfect number" );
}
}

// This code is contributed by mits
```





Python3
-------

















```
# Python3 code to check if a given
# number is perfect or not

# Returns true if n is perfect
def isPerfect( n ):

# To store sum of divisors
sum = 1

# Find all divisors and add them
i = 2
while i * i < = n:
if n % i = = 0 :
sum = sum + i + n / i
i + = 1

# If sum of divisors is equal to
# n, then n is a perfect number

return ( True if sum = = n and n! = 1 else False )

# Driver program
print ( "Below are all perfect numbers till 10000" )
n = 2
for n in range ( 10000 ):
if isPerfect (n):
print (n , " is a perfect number" )

# This code is contributed by "Sharad_Bhardwaj".
```





C#
--

















```
// C# program to check if a given
// number is perfect or not

class GFG
{

// Returns true if n is perfect
static bool isPerfect( int n)
{
// To store sum of divisors
int sum = 1;

// Find all divisors and add them
for ( int i = 2; i * i <= n; i++)
{
if (n % i==0)
{
if (i * i != n)
sum = sum + i + n / i;
else
sum = sum + i;
}
}
// If sum of divisors is equal to
// n, then n is a perfect number
if (sum == n && n != 1)
return true ;

return false ;
}

// Driver program
static void Main()
{
System.Console.WriteLine( "Below are all perfect" +
"numbers till 10000" );
for ( int n = 2; n < 10000; n++)
if (isPerfect(n))
System.Console.WriteLine( n +
" is a perfect number" );
}
}

// This code is contributed by chandan_jnu
```





Javascript
----------

















```
<script>

// Javascript program to check if a given number is perfect
// or not

// Returns true if n is perfect
function isPerfect(n)
{
// To store sum of divisors
sum = 1;

// Find all divisors and add them
for (let i=2; i*i<=n; i++)
{
if (n%i==0)
{
if (i*i!=n)
sum = sum + i + n/i;
else
sum=sum+i;
}
}
// If sum of divisors is equal to
// n, then n is a perfect number
if (sum == n && n != 1)
return true ;

return false ;
}

// Driver program

document.write( "Below are all perfect numbers till 10000" + "<br>" );
for (let n =2; n<10000; n++)
if (isPerfect(n))
document.write(n + " is a perfect number" + "<br>" );

// This code is contributed by Mayank Tyagi

</script>
```





PHP
---

















```
<?php
// PHP program to check if a given number
// is perfect or not

// Returns true if n is perfect
function isPerfect( $n )
{
// To store sum of divisors
$sum = 1;

// Find all divisors and add them
for ( $i = 2; $i * $i <= $n ; $i ++)
{
if ( $n % $i == 0)
{
if ( $i * $i != $n )
$sum = $sum + $i + (int)( $n / $i );
else
$sum = $sum + $i ;
}
}
// If sum of divisors is equal to
// n, then n is a perfect number
if ( $sum == $n && $n != 1)
return true;

return false;
}

// Driver Code
echo "Below are all perfect numbers till 10000\\n" ;
for ( $n = 2; $n < 10000; $n ++)
if (isPerfect( $n ))
echo "$n is a perfect number\\n" ;

// This code is contributed by mits
?>
```







**Output**
```
Below are all perfect numbers till 10000
6 is a perfect number
28 is a perfect number
496 is a perfect number
8128 is a perfect number



```

****Time Complexity:****
O(log(n))

', 'A number is a perfect number if is equal to sum of its proper divisors, that is, sum of its positive divisors excluding the number itself. Write a function to check if a given number is perfect or not.', 'Perfect Number', 3, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('ddbdf68b-6bcc-4c3f-8472-f24f5f5d1320', e'Given a positive integer

****n****
, find its square root. If

****n****
is not a perfect square, then return

****floor****
of

****√n****
.


****Examples :****


> ****Input:****
> n = 4
>
>
>
> ****Output:****
> 2
>
>
>
> ****Explanation:****
> The square root of 4 is 2.
>
>
> ****Input:****
> n = 11
>
>
>
> ****Output:****
> 3
>
>
>
> ****Explanation:****
> The square root of 11 lies in between 3 and 4 so floor of the square root is 3.

Table of Content

* [[Naive Approach] Using a loop – O(sqrt(n)) Time and O(1) Space](#approach-1-using-a-loop-on-time-and-o1-space)
* [[Expected Approach] Using Binary Search – O(logn) Time and O(1) Space](#approach-2-using-binary-search-ologn-time-and-o1-space)
* [[Alternate Approach] Using Built In functions – O(logn) Time and O(1) Space](#approach-3-using-built-in-functions-ologn-time-and-o1-space)
* [[Alternate Approach] Using Formula Used by Pocket Calculators – O(1) Time and O(1) Space](#approach-4-using-formula-used-by-pocket-calculators-o1-time-and-o1-space)
### [Naive Approach] Using a loop – O(sqrt(n)) Time and O(1) Space


As, we know that square root of a positive integer is always

****greater****
than or

****equal****
to one. So we start iterating from

****1****
and calculate the square of each number. We continue the iteration until we reach to an

****integer****
whose square is

****greater****
than the given integer, then the integer just

****before****
it will be our answer.


C++

````
// C++ program to find the square root of
// given integer using a loop

#include <iostream>
using namespace std;

int floorSqrt(int n) {

    // Start iteration from 1 until the
    // square of a number exceeds n
    int res = 1;
    while(res*res <= n){
        res++;
    }

    // return the largest integer whose
    // square is less than or equal to n
    return res - 1;
}

int main() {
    int n = 11;
    cout << floorSqrt(n);
    return 0;
}

````

C

````
// C program to find the square root of
// given integer using a loop

#include <stdio.h>

int floorSqrt(int n) {

    // Start iteration from 1 until the
    // square of a number exceeds n
    int res = 1;
    while (res * res <= n) {
        res++;
    }

    // return the largest integer whose
    // square is less than or equal to n
    return res - 1;
}

int main() {
    int n = 11;
    printf("%d", floorSqrt(n));
    return 0;
}

````

Java

````
// Java program to find the square root of
// given integer using a loop

class GfG {

    static int floorSqrt(int n) {

        // Start iteration from 1 until the
        // square of a number exceeds n
        int res = 1;
        while (res * res <= n) {
            res++;
        }

        // return the largest integer whose
        // square is less than or equal to n
        return res - 1;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(floorSqrt(n));
    }
}

````

Python

````
# Python program to find the square root of
# given integer using a loop

def floorSqrt(n):

    # Start iteration from 1 until the
    # square of a number exceeds n
    res = 1
    while res * res <= n:
        res += 1

    # return the largest integer whose
    # square is less than or equal to n
    return res - 1

if __name__ == "__main__":
    n = 11
    print(floorSqrt(n))

````

C#

````
// C# program to find the square root of
// given integer using a loop

using System;

class GfG {

    static int floorSqrt(int n) {

        // Start iteration from 1 until the
        // square of a number exceeds n
        int res = 1;
        while (res * res <= n) {
            res++;
        }

        // return the largest integer whose
        // square is less than or equal to n
        return res - 1;
    }

    static void Main() {
        int n = 11;
        Console.WriteLine(floorSqrt(n));
    }
}

````

JavaScript

````
// JavaScript program to find the square root of
// given integer using a loop

function floorSqrt(n) {

    // Start iteration from 1 until the
    // square of a number exceeds n
    let res = 1;
    while (res * res <= n) {
        res++;
    }

    // return the largest integer whose
    // square is less than or equal to n
    return res - 1;
}

// Driver Code
let n = 11;
console.log(floorSqrt(n));

````




**Output**
```
3
```
### [Expected Approach] Using Binary Search – O(logn) Time and O(1) Space

> The square root of an integer follows a
>
> ****monotonic****
> pattern, because as we
>
> ****increase****
> any number, it’s square also
>
> ****increases****
> . If the square of a number is
>
> ****greater****
> than given integer, then square root will definitely exist
>
> ****before****
> this number. Conversely, if the square of a number is
>
> ****less****
> than or
>
> ****equal****
> to
>
> ****n****
> , then either this number is the square root or it lies after this number.
>
>
>
> Therefore, we can use
>
> [binary search](https://www.geeksforgeeks.org/binary-search/)
> to find the square root of n. I
>
> ****nitial search****
> space will be 1 to the given integer itself, because square root of any positive integer always exists within this range.












C++

````
// C++ program to find the square root of given integer
// using binary search

#include <iostream>
using namespace std;

int floorSqrt(int n) {

    // Initial search space
    int lo = 1, hi = n;
    int res = 1;

    while(lo <= hi) {
        int mid = lo + (hi - lo)/2;

        // If square of mid is less than or equal to n
        // update the result and search in upper half
        if(mid*mid <= n) {
            res = mid;
            lo = mid + 1;
        }

        // If square of mid exceeds n,
          // search in the lower half
        else {
            hi = mid - 1;
        }
    }

    return res;
}

int main() {
    int n = 11;
    cout << floorSqrt(n);
    return 0;
}

````

C

````
// C program to find the square root of given integer
// using binary search

#include <stdio.h>

int floorSqrt(int n) {

    // Initial search space
    int lo = 1, hi = n;
    int res = 1;

    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;

        // If square of mid is less than or equal to n
        // update the result and search in upper half
        if (mid * mid <= n) {
            res = mid;
            lo = mid + 1;
        }

        // If square of mid exceeds n,
        // search in the lower half
        else {
            hi = mid - 1;
        }
    }

    return res;
}

int main() {
    int n = 11;
    printf("%d", floorSqrt(n));
    return 0;
}

````

Java

````
// Java program to find the square root of given integer
// using binary search

class GfG {

    static int floorSqrt(int n) {

        // Initial search space
        int lo = 1, hi = n;
        int res = 1;

        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;

            // If square of mid is less than or equal to n
            // update the result and search in upper half
            if (mid * mid <= n) {
                res = mid;
                lo = mid + 1;
            }

            // If square of mid exceeds n,
            // search in the lower half
            else {
                hi = mid - 1;
            }
        }

        return res;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(floorSqrt(n));
    }
}

````

Python

````
# Python program to find the square root of given integer
# using binary search

def floorSqrt(n):

    # Initial search space
    lo = 1
    hi = n
    res = 1

    while lo <= hi:
        mid = lo + (hi - lo) // 2

        # If square of mid is less than or equal to n
        # update the result and search in upper half
        if mid * mid <= n:
            res = mid
            lo = mid + 1

        # If square of mid exceeds n,
        # search in the lower half
        else:
            hi = mid - 1

    return res

if __name__ == "__main__":
    n = 11
    print(floorSqrt(n))

````

C#

````
// C# program to find the square root of given integer
// using binary search

using System;

class GfG {

    static int floorSqrt(int n) {

        // Initial search space
        int lo = 1, hi = n;
        int res = 1;

        while (lo <= hi) {
            int mid = lo + (hi - lo) / 2;

            // If square of mid is less than or equal to n
            // update the result and search in upper half
            if (mid * mid <= n) {
                res = mid;
                lo = mid + 1;
            }

            // If square of mid exceeds n,
            // search in the lower half
            else {
                hi = mid - 1;
            }
        }

        return res;
    }

    static void Main() {
        int n = 11;
        Console.WriteLine(floorSqrt(n));
    }
}

````

JavaScript

````
// JavaScript program to find the square root of given integer
// using binary search

function floorSqrt(n) {

    // Initial search space
    let lo = 1, hi = n;
    let res = 1;

    while (lo <= hi) {
        let mid = lo + Math.floor((hi - lo) / 2);

        // If square of mid is less than or equal to n
        // update the result and search in upper half
        if (mid * mid <= n) {
            res = mid;
            lo = mid + 1;
        }

        // If square of mid exceeds n,
        // search in the lower half
        else {
            hi = mid - 1;
        }
    }

    return res;
}

let n = 11;
console.log(floorSqrt(n));

````




**Output**
```
3
```
### [Alternate Approach] Using Built In functions – O(logn) Time and O(1) Space


We can directly use built in functions to find square root of an integer.


C++

````
// C++ program to find the square root of given
// integer using built in square root function

#include <iostream>
#include <cmath>
using namespace std;

int floorSqrt(int n) {

      // Square root using sqrt function, it returns
      // the double value, which is casted to integer
      int res = sqrt(n);
      return res;
}

int main() {
    int n = 11;
    cout << floorSqrt(n);
    return 0;
}

````

C

````
// C program to find the square root of given
// integer using built in square root function

#include <stdio.h>
#include <math.h>

int floorSqrt(int n) {

    // Square root using sqrt function, it returns
    // the double value, which is casted to integer
    int res = sqrt(n);
    return res;
}

int main() {
    int n = 11;
    printf("%d", floorSqrt(n));
    return 0;
}

````

Java

````
// Java program to find the square root of given
// integer using built in square root function

class GfG {

    static int floorSqrt(int n) {

        // Square root using sqrt function, it returns
        // the double value, which is casted to integer
        int res = (int)Math.sqrt(n);
        return res;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(floorSqrt(n));
    }
}

````

Python

````
# Python program to find the square root of given
# integer using built in square root function

import math

def floorSqrt(n):

    # Square root using sqrt function, it returns
    # the double value, which is casted to integer
    res = int(math.sqrt(n))
    return res

if __name__ == "__main__":
    n = 11
    print(floorSqrt(n))

````

C#

````
// C# program to find the square root of given
// integer using built in square root function

using System;

class GfG {

    static int floorSqrt(int n) {

        // Square root using sqrt function, it returns
        // the double value, which is casted to integer
        int res = (int)Math.Sqrt(n);
        return res;
    }

    static void Main() {
        int n = 11;
        Console.WriteLine(floorSqrt(n));
    }
}

````

JavaScript

````
// JavaScript program to find the square root of given
// integer using built in square root function

function floorSqrt(n) {

    // Square root using sqrt function, it returns
    // the double value, which is casted to integer
    let res = Math.floor(Math.sqrt(n));
    return res;
}

let n = 11;
console.log(floorSqrt(n));

````




**Output**
```
3
```
### [Alternate Approach] Using Formula Used by Pocket Calculators – O(1) Time and O(1) Space

[Pocket calculator](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Exponential_identity)
uses the mathematical formula

****√n = e****
****1/2 \\* ln(n)****
to compute the square root of an integer n. Below is mathematical proof of this formula:


> Let’s say square root of n is x:
>
>
>
> ****x = √n****
>
>
> Squaring both the sides:
>
>
>
> x
>
> 2 =
> n
>
>
>
> Taking log on both the sides:
>
>
>
> => ln(x
>
> 2
> ) = ln(n)
>
>
>
> => 2\\*ln(x) = ln(n)
>
>
>
> => ln(x) = 1/2 \\* ln(n)
>
>
>
> To isolate x, exponentiate both sides with base e:
>
>
>
> => x = e
>
> 1/2 \\* ln(n)
>
>
> x is the square root of n:
>
>
>
> ****√n****
> = e
>
> 1/2 \\* ln(n)


Because of the way computations are done in computers in case of decimals, the result from the expression may be slightly less than the actual square root. Therefore, we will also consider the

****next integer****
after the calculated result as a potential answer.


C++

````
// C++ program to find the square root of given integer
// using mathematical formula

#include <iostream>
#include <cmath>
using namespace std;

int floorSqrt(int n) {

      // Calculating square root using mathematical formula
    int res = exp(0.5 * log(n));

    // If square of  res + 1 is less than or equal to n
      // then, it will be our answer
    if ((res + 1) * (res + 1) <= n) {
        res++;
    }

    return res;
}

int main() {
    int n = 11;
    cout << floorSqrt(n);
    return 0;
}

````

C

````
// C program to find the square root of given integer
// using mathematical formula

#include <stdio.h>
#include <math.h>

int floorSqrt(int n) {

    // Calculating square root using mathematical formula
    int res = exp(0.5 * log(n));

    // If square of res + 1 is less than or equal to n
    // then, it will be our answer
    if ((res + 1) * (res + 1) <= n) {
        res++;
    }

    return res;
}

int main() {
    int n = 11;
    printf("%d", floorSqrt(n));
    return 0;
}

````

Java

````
// Java program to find the square root of given integer
// using mathematical formula

class GfG {

    static int floorSqrt(int n) {

        // Calculating square root using mathematical formula
        int res = (int)Math.exp(0.5 * Math.log(n));

        // If square of res + 1 is less than or equal to n
        // then, it will be our answer
        if ((res + 1) * (res + 1) <= n) {
            res++;
        }

        return res;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(floorSqrt(n));
    }
}

````

Python

````
# Python program to find the square root of given integer
# using mathematical formula

import math

def floorSqrt(n):

    # Calculating square root using mathematical formula
    res = int(math.exp(0.5 * math.log(n)))

    # If square of res + 1 is less than or equal to n
    # then, it will be our answer
    if (res + 1) ** 2 <= n:
        res += 1

    return res

if __name__ == "__main__":
    n = 11
    print(floorSqrt(n))

````

C#

````
// C# program to find the square root of given integer
// using mathematical formula

using System;

class GfG {

    static int floorSqrt(int n) {

        // Calculating square root using mathematical formula
        int res = (int)Math.Exp(0.5 * Math.Log(n));

        // If square of res + 1 is less than or equal to n
        // then, it will be our answer
        if ((long)(res + 1) * (res + 1) <= n) {
            res++;
        }

        return res;
    }

    static void Main() {
        int n = 11;
        Console.WriteLine(floorSqrt(n));
    }
}

````

JavaScript

````
// JavaScript program to find the square root of given integer
// using mathematical formula

function floorSqrt(n) {

    // Calculating square root using mathematical formula
    let res = Math.floor(Math.exp(0.5 * Math.log(n)));

    // If square of res + 1 is less than or equal to n
    // then, it will be our answer
    if ((res + 1) * (res + 1) <= n) {
        res++;
    }

    return res;
}

let n = 11;
console.log(floorSqrt(n));

````




**Output**
```
3

```', '', 'Square root of an integer', 7, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('0f843284-a32b-478b-af5b-85f375980a0b', e'# Time Complexity
The time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the input. Note that the time to run is a function of the length of the input and not the actual execution time of the machine on which the algorithm is running on.

The valid algorithm takes a finite amount of time for execution. The time required by the algorithm to solve given problem is called ***time complexity***  of the algorithm. Time complexity is very useful measure in algorithm analysis.

 It is the time needed for the completion of an algorithm. To estimate the time complexity, we need to consider the cost of each fundamental instruction and the number of times the instruction is executed.

Example 1: Addition of two scalar variables.

```pseudo-code
Algorithm ADD SCALAR(A, B)  
// Description: Perform arithmetic addition of two numbers  
// Input: Two scalar variables A and B  
// Output: variable C, which holds the addition of A and B  
C <- A + B  
return C
```

The addition of two scalar numbers requires one addition operation. the time complexity of this algorithm is constant, so T(n) = O(1) .

In order to calculate time complexity on an algorithm, it is assumed that a **constant time c** is taken to execute one operation, and then the total operations for an input length on **N** are calculated. Consider an example to understand the process of calculation: Suppose a problem is to [find whether a pair **(X, Y)** exists in an array, A of **N** elements whose sum is **Z**](https://www.geeksforgeeks.org/given-an-array-a-and-a-number-x-check-for-pair-in-a-with-sum-as-x/). The simplest idea is to consider every pair and check if it satisfies the given condition or not.

The pseudo-code is as follows:

```pseudo-code
int a[n];  
for(int i = 0;i < n;i++)  
	cin >> a[i]  
	
for(int i = 0;i < n;i++)  
	for(int j = 0;j < n;j++)  
		if(i!=j && a[i]+a[j] == z)  
			return true  
return false
```

Below is the implementation of the above approach:

```cpp
// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;

// Function to find a pair in the given
// array whose sum is equal to z
bool findPair(int a[], int n, int z)
{
    // Iterate through all the pairs
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)

            // Check if the sum of the pair
            // (a[i], a[j]) is equal to z
            if (i != j && a[i] + a[j] == z)
                return true;

    return false;
}

// Driver Code
int main()
{
    // Given Input
    int a[] = { 1, -2, 1, 0, 5 };
    int z = 0;
    int n = sizeof(a) / sizeof(a[0]);

    // Function Call
    if (findPair(a, n, z))
        cout << "True";
    else
        cout << "False";
    return 0;
}
```
```java
// Java program for the above approach
import java.lang.*;
import java.util.*;

class GFG{

// Function to find a pair in the given
// array whose sum is equal to z
static boolean findPair(int a[], int n, int z)
{
    
    // Iterate through all the pairs
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
        
            // Check if the sum of the pair
            // (a[i], a[j]) is equal to z
            if (i != j && a[i] + a[j] == z)
                return true;

    return false;
}

// Driver code
public static void main(String[] args)
{
    
    // Given Input
    int a[] = { 1, -2, 1, 0, 5 };
    int z = 0;
    int n = a.length;
    
    // Function Call
    if (findPair(a, n, z))
        System.out.println("True");
    else
        System.out.println("False");
}
}

// This code is contributed by avijitmondal1998
```
```python
# Python3 program for the above approach

# Function to find a pair in the given
# array whose sum is equal to z
def findPair(a, n, z) :
    
    # Iterate through all the pairs
    for i in range(n) :
        for j in range(n) :

            # Check if the sum of the pair
            # (a[i], a[j]) is equal to z
            if (i != j and a[i] + a[j] == z) :
                return True

    return False

# Driver Code

# Given Input
a = [ 1, -2, 1, 0, 5 ]
z = 0
n = len(a) 

# Function Call
if (findPair(a, n, z)) :
    print("True")
else :
    print("False")
    
    # This code is contributed by splevel62.
```
```csharp
// C# program for above approach
using System;

class GFG{

// Function to find a pair in the given
// array whose sum is equal to z
static bool findPair(int[] a, int n, int z)
{
    
    // Iterate through all the pairs
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
        
            // Check if the sum of the pair
            // (a[i], a[j]) is equal to z
            if (i != j && a[i] + a[j] == z)
                return true;

    return false;
}

// Driver Code
static void Main()
{
     // Given Input
    int[] a = { 1, -2, 1, 0, 5 };
    int z = 0;
    int n = a.Length;
    
    // Function Call
    if (findPair(a, n, z))
        Console.WriteLine("True");
    else
        Console.WriteLine("False");
}
}

// This code is contributed by sanjoy_62.
```
```javascript
<script>

// JavaScript program for the above approach

// Function to find a pair in the given
// array whose sum is equal to z
function findPair(a, n, z)
{
    
    // Iterate through all the pairs
    for(let i = 0; i < n; i++)
        for(let j = 0; j < n; j++)
        
            // Check if the sum of the pair
            // (a[i], a[j]) is equal to z
            if (i != j && a[i] + a[j] == z)
                return true;

    return false;
}

// Driver Code

// Given Input
let a = [ 1, -2, 1, 0, 5 ];
let z = 0;
let n = a.length;

// Function Call
if (findPair(a, n, z))
    document.write("True");
else
    document.write("False");
    
// This code is contributed by code_hunt

</script>
```

```output
False
```
Assuming that each of the operations in the computer takes approximately constant time, let it be **c**. The number of lines of code executed actually depends on the value of **Z**. During analyses of the algorithm, mostly the worst-case scenario is considered, i.e., when there is no pair of elements with sum equals **Z**. In the worst case, 

-   **N*c** operations are required for input.
-   The outer loop **i** loop runs **N** times.
-   For each **i**, the inner loop **j** loop runs **N** times.

So total execution time is **N * c + N * N * c + c**. Now ignore the lower order terms since the lower order terms are relatively insignificant for large input, therefore only the highest order term is taken (without constant) which is **N*N** in this case. Different notations are used to describe the limiting behavior of a function, but since the worst case is taken so [big-O notation](https://www.geeksforgeeks.org/analysis-algorithms-big-o-analysis/) will be used to represent the time complexity.

Hence, the time complexity is **O(N$^2$)** for the above algorithm. Note that the time complexity is solely based on the number of elements in array **A** i.e the input length, so if the length of the array will increase the time of execution will also increase.

**Order of growth** is how the time of execution depends on the length of the input. In the above example, it is clearly evident that the time of execution quadratically depends on the length of the array. Order of growth will help to compute the running time with ease.

**Another Example:** Let\'s calculate the time complexity of the below algorithm:

```cpp
count = 0 
for (int i = N; i > 0; i /= 2) 
  for (int j = 0; j < i; j++) 
    count++;
```
```java
int count = 0 ;
for (int i = N; i > 0; i /= 2) 
    for (int j = 0; j < i; j++) 
        count++;

//This code is contributed by Shubham Singh
```
```python
count = 0 
i = N
while(i > 0):
  for j in range(i):
    count+=1
  i /= 2
  
  # This code is contributed by subhamsingh10
```
```csharp
int count = 0 ;
for (int i = N; i > 0; i /= 2) 
    for (int j = 0; j < i; j++) 
        count++;

// This code is contributed by Shubham Singh
```
```javascript
let count = 0 
for(let i = N; i > 0; i /= 2) 
    for(let j = 0; j < i; j++) 
        count += 1;
 
// This code is contributed by Shubham Singh
```

This is a tricky case. In the first look, it seems like the complexity is **O(N * log N)**. **N** for the **j′s** loop and **log(N)** for **i′s** loop. But it\'s wrong. Let\'s see why.

Think about how many times **count++** will run. 

-   When **i = N**, it will run **N** times.
-   When **i = N / 2**, it will run **N / 2** times.
-   When **i = N / 4**, it will run **N / 4** times.
-   And so on.

The total number of times **count++** will run is **N + N/2 + N/4+...+1= 2 * N**. So the time complexity will be **O(N)**.

Some general time complexities are listed below with the input range for which they are accepted in competitive programming: 

|Input Length|Worst Accepted Time Complexity|Usually type of solutions|
|---|---|---|
|10 -12|O(N!)|[Recursion](https://www.geeksforgeeks.org/recursion/) and [backtracking](https://www.geeksforgeeks.org/backtracking-algorithms/)|
|15-18|O(2$^N$* N)|Recursion, backtracking, and [bit manipulation](https://www.geeksforgeeks.org/bits-manipulation-important-tactics/)|
|18-22|O(2$^N$*N)|Recursion, backtracking, and bit manipulation|
|30-40|O(2$^{N/2}$* N)|[Meet in the middle](https://www.geeksforgeeks.org/meet-in-the-middle/), [Divide and Conquer](https://www.geeksforgeeks.org/divide-and-conquer-introduction/)|
|100|O(N$^4$)|[Dynamic programming](https://www.geeksforgeeks.org/dynamic-programming/), [Constructive](https://www.geeksforgeeks.org/basic/constructive-algorithms/)|
|400|O(N$^3$)|Dynamic programming, Constructive|
|2K|O(N$^2$* log N)|Dynamic programming, [Binary Search](https://www.geeksforgeeks.org/binary-search/), [Sorting](https://www.geeksforgeeks.org/sorting-algorithms/),Divide and Conquer|
|10K|O(N$^2$)|Dynamic programming, [Graph](https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/) , [Trees](https://www.geeksforgeeks.org/binary-tree-data-structure/), Constructive|
|1M|O(N* log N)|Sorting, Binary Search, Divide and Conquer|
|100M|O(N), O(log N), O(1)|Constructive, [Mathematical](https://www.geeksforgeeks.org/mathematical-algorithms/), [Greedy Algorithms](https://www.geeksforgeeks.org/greedy-algorithms-general-structure-and-applications/)|

# Space Complexity

**Definition:** Problem-solving using computer requires memory to hold temporary data or final result while the program is in execution. The amount of memory required by the algorithm to solve given problem is called **space complexity** of the algorithm.

The space complexity of an algorithm quantifies the amount of space taken by an algorithm to run as a function of the length of the input. Consider an example: Suppose a problem to find the [frequency of array elements](https://www.geeksforgeeks.org/counting-frequencies-of-array-elements/).

It is the amount of memory needed for the completion of an algorithm. 

To estimate the memory requirement we need to focus on two parts: 

**(1) A fixed part:** It is independent of the input size. It includes memory for instructions (code), constants, variables, etc.

**(2) A variable part:** It is dependent on the input size. It includes memory for recursion stack, referenced variables, etc.

**Example : Addition of two scalar variables**

```pseudo-code
Algorithm ADD SCALAR(A, B)  
//Description: Perform arithmetic addition of two numbers  
//Input: Two scalar variables A and B  
//Output: variable C, which holds the addition of A and B  
C <— A+B  
return C
```

The addition of two scalar numbers requires one extra memory location to hold the result. Thus the space complexity of this algorithm is constant, hence S(n) = O(1).

The pseudo-code is as follows: 

```pseudo-code
int freq[n];  
int a[n];  
for(int i = 0; i<n; i++)  
{  
 cin>>a[i];  
 freq[a[i]]++;  
}
```

Below is the implementation of the above approach:

```cpp
int freq[n];  
int a[n];  
for(int i = 0; i<n; i++)  
{  
 cin>>a[i];  
 freq[a[i]]++;  
}
```
```java
// Java program for the above approach
import java.util.*;
class GFG{

  // Function to count frequencies of array items
  static void countFreq(int arr[], int n)
  {
    HashMap<Integer,Integer> freq = new HashMap<>();

    // Traverse through array elements and
    // count frequencies
    for (int i = 0; i < n; i++) {
      if(freq.containsKey(arr[i])){
        freq.put(arr[i], freq.get(arr[i])+1);
      }
      else{
        freq.put(arr[i], 1);
      }
    }

    // Traverse through map and print frequencies
    for (Map.Entry<Integer,Integer> x : freq.entrySet())
      System.out.print(x.getKey()+ " " +  x.getValue() +"\\n");
  }

  // Driver Code
  public static void main(String[] args)
  {
    // Given array
    int arr[] = { 10, 20, 20, 10, 10, 20, 5, 20 };
    int n = arr.length;

    // Function Call
    countFreq(arr, n);
  }
}

// This code is contributed by gauravrajput1
```
```python
# Python program for the above approach

# Function to count frequencies of array items
def countFreq(arr, n):
    freq = dict()
    
    # Traverse through array elements and
    # count frequencies
    for i in arr:
        if i not in freq:
            freq[i] = 0
        freq[i]+=1
        
    # Traverse through map and print frequencies
    for x in freq:
        print(x, freq[x])

# Driver Code

# Given array
arr =  [10, 20, 20, 10, 10, 20, 5, 20 ]
n = len(arr)

# Function Call
countFreq(arr, n)

# This code is contributed by Shubham Singh
```
```csharp
// C# program for the above approach

using System;
using System.Collections.Generic;

public class GFG {

    // Function to count frequencies of array items
    static void countFreq(int[] arr, int n)
    {
        Dictionary<int, int> freq
            = new Dictionary<int, int>();

        // Traverse through array elements and count
        // frequencies
        for (int i = 0; i < n; i++) {
            if (freq.ContainsKey(arr[i])) {
                freq[arr[i]] += 1;
            }
            else {
                freq.Add(arr[i], 1);
            }
        }

        // Traverse through dictionary and print frequencies
        foreach(KeyValuePair<int, int> x in freq)
        {
            Console.WriteLine(x.Key + " " + x.Value);
        }
    }

    static public void Main()
    {

        // Given array
        int[] arr = { 10, 20, 20, 10, 10, 20, 5, 20 };
        int n = arr.Length;

        // Function Call
        countFreq(arr, n);
    }
}

// This code is contributed by lokeshmvs21
```
```javascript
<script>
// Javascript program for the above approach

// Function to count frequencies of array items
function countFreq(arr, n) {
    let freq = new Map();
    arr.sort((a, b) => a - b)

    // Traverse through array elements and
    // count frequencies
    for (let i = 0; i < n; i++) {
        if (freq.has(arr[i])) {
            freq.set(arr[i], freq.get(arr[i]) + 1)
        } else {
            freq.set(arr[i], 1)
        }
    }


    // Traverse through map and print frequencies
    for (let x of freq)
        document.write(x[0] + " " + x[1] + "<br>");
}

// Driver Code

// Given array
let arr = [10, 20, 20, 10, 10, 20, 5, 20];
let n = arr.length;

// Function Call
countFreq(arr, n);

// This code is contributed by Saurabh Jaiswal
</script>
```

Here two arrays of length **N**, and variable **i** are used in the algorithm so, the total space used is **N * c + N * c + 1 * c = 2N * c + c**, where **c** is a unit space taken. For many inputs, constant **c** is insignificant, and it can be said that the space complexity is **O(N)**.

There is also **auxiliary space,** which is different from space complexity. The main difference is where space complexity quantifies the total space used by the algorithm, auxiliary space quantifies the extra space that is used in the algorithm apart from the given input. In the above example, the auxiliary space is the space used by the freq[] array because that is not part of the given input. So total auxiliary space is **N * c + c** which is **O(N)** only.', 'Many times there are more than one ways to solve a problem with different algorithms and we need a way to compare multiple ways.', 'Time Complexity and Space Complexity', 5, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('70160121-cc81-453f-94b3-fc1c2e1477c4', e'![Red-black-Tree-banner](https://media.geeksforgeeks.org/wp-content/uploads/20240520123005/Red-black-Tree-banner.webp)

# What is a Red-Black Tree?

A **Red-Black Tree** is a self-balancing [binary search tree](https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion) where each node has an additional attribute: a color, which can be either **red** or **black**. The primary objective of these trees is to maintain balance during insertions and deletions, ensuring efficient data retrieval and manipulation.

# Properties of Red-Black Trees

A [Red-Black Tree](https://www.geeksforgeeks.org/introduction-to-red-black-tree) have the following properties:

1.  **Node Color**: Each node is either red or **black**.
2.  **Root Property**: The root of the tree is always **black**.
3.  **Red Property**: Red nodes cannot have red children (no two consecutive red nodes on any path).
4.  **Black Property**: Every path from a node to its descendant null nodes (leaves) has the same number of **black** nodes.
5.  **Leaf Property**: All leaves (NIL nodes) are **black**.

These properties ensure that the longest path from the root to any leaf is no more than twice as long as the shortest path, maintaining the tree\'s balance and efficient performance.

## Example of Red-Black Tree:

![New-Project-8](https://media.geeksforgeeks.org/wp-content/uploads/20250425171943144717/New-Project-8.webp)

The **Correct Red-Black Tree** in above image ensures that every path from the root to a leaf node has the same number of black nodes. In this case, there is one (excluding the root node).

The **Incorrect Red Black Tree** does not follow the red-black properties as **two red nodes** are adjacent to each other. Another problem is that one of the paths to a leaf node has zero black nodes, whereas the other two contain a black node.

# Why Red-Black Trees?

Most of the BST operations (e.g., search, max, min, insert, delete.. etc) take **O(h)** time where h is the height of the [BST](https://www.geeksforgeeks.org/binary-search-tree-data-structure). The cost of these operations may become **O(n)** for a skewed [Binary tree.](https://www.geeksforgeeks.org/binary-tree-data-structure) If we make sure that the height of the tree remains **O(log n)** after every insertion and deletion, then we can guarantee an upper bound of **O(log n)** for all these operations. The height of a Red-Black tree is always **O(log n)** where n is the number of nodes in the tree. 

| Sr. No. | Algorithm | Time Complexity |
| --- | --- | --- |
| 1. | Search | O(log n) |
| 2. | Insert | O(log n) |
| 3. | Delete | O(log n) |

## Comparison with AVL Tree:

The AVL trees are more balanced compared to Red-Black Trees, but they may cause more rotations during insertion and deletion. So if your application involves frequent insertions and deletions, then Red-Black trees should be preferred. And if the insertions and deletions are less frequent and search is a more frequent operation, then [AVL tree](https://www.geeksforgeeks.org/avl-tree-set-1-insertion) should be preferred over the Red-Black Tree.

## How does a Red-Black Tree ensure balance?

A simple example to understand balancing is, that a chain of 3 nodes is not possible in the Red-Black tree. We can try any combination of colors and see if all of them violate the Red-Black tree property. 

![](https://media.geeksforgeeks.org/wp-content/uploads/20220602135051/3NodedRedBlacktree.jpg)

Proper structure of three noded Red-black tree

# Interesting points about Red-Black Tree:

-   The **black** height of the red-black tree is the number of black nodes on a path from the root node to a leaf node. Leaf nodes are also counted as **black** nodes. So, a red-black tree of height **h** has **black height >= h/2**.
-   Height of a red-black tree with **n** nodes is **h<= 2 log2**$^{(n + 1)}$.
-   All leaves (NIL) are **black**.
-   The **black** depth of a node is defined as the number of black nodes from the root to that node i.e the number of black ancestors.

# Basic Operations on Red-Black Tree:

The basic operations on a Red-Black Tree include:

1.  Insertion
2.  Search
3.  Deletion
4.  Rotation

## 1. [Insertion](https://www.geeksforgeeks.org/insertion-in-red-black-tree)

Inserting a new node in a Red-Black Tree involves a two-step process: performing a standard [binary search tree (BST) insertion](https://www.geeksforgeeks.org/insertion-in-binary-search-tree), followed by fixing any violations of Red-Black properties.

#### **Insertion Steps**

1.  **BST Insert**: Insert the new node like in a standard BST.
2.  **Fix Violations**:
    -   If the parent of the new node is **black**, no properties are violated.
    -   If the parent is **red**, the tree might violate the Red Property, requiring fixes.

#### **Fixing Violations During Insertion**

After inserting the new node as a **red** node, we might encounter several cases depending on the colors of the node\'s parent and uncle (the sibling of the parent):

-   **Case 1: Uncle is Red**: Recolor the parent and uncle to **black**, and the grandparent to **red**. Then move up the tree to check for further violations.
-   **Case 2: Uncle is Black**:
    -   **Sub-case 2.1: Node is a right child**: Perform a left rotation on the parent.
    -   **Sub-case 2.2: Node is a left child**: Perform a right rotation on the grandparent and recolor appropriately.

## 2. Searching

Searching for a node in a Red-Black Tree is similar to searching in a standard **Binary Search Tree (BST)**. The search operation follows a straightforward path from the **root** to a **leaf**, comparing the target value with the current node\'s value and moving left or right accordingly.

#### Search Steps

1.  **Start at the Root**: Begin the search at the root node.
2.  **Traverse the Tree**:
    -   If the target value is equal to the current node\'s value, the node is found.
    -   If the target value is less than the current node\'s value, move to the left child.
    -   If the target value is greater than the current node\'s value, move to the right child.
3.  **Repeat**: Continue this process until the target value is found or a NIL node is reached (indicating the value is not present in the tree).

## 3. [Deletion](https://www.geeksforgeeks.org/deletion-in-red-black-tree)

Deleting a node from a Red-Black Tree also involves a two-step process: performing the BST deletion, followed by fixing any violations that arise.

#### Deletion Steps

1.  **BST Deletion**: Remove the node using standard BST rules.
2.  **Fix Double Black**:
    -   If a black node is deleted, a "double black" condition might arise, which requires specific fixes.

#### Fixing Violations During Deletion

When a black node is deleted, we handle the double black issue based on the sibling\'s color and the colors of its children:

-   **Case 1: Sibling is Red**: Rotate the parent and recolor the sibling and parent.
-   **Case 2: Sibling is Black**:
    -   **Sub-case 2.1: Sibling\'s children are black**: Recolor the sibling and propagate the double black upwards.
    -   **Sub-case 2.2: At least one of the sibling\'s children is red**:
        -   **If the sibling\'s far child is red**: Perform a rotation on the parent and sibling, and recolor appropriately.
        -   **If the sibling\'s near child is red**: Rotate the sibling and its child, then handle as above.

## 4. Rotation

Rotations are fundamental operations in maintaining the balanced structure of a Red-Black Tree (RBT). They help to preserve the properties of the tree, ensuring that the longest path from the root to any leaf is no more than twice the length of the shortest path. Rotations come in two types: **left rotations** and **right rotations.**

#### **1. Left Rotation**

A left rotation at node 𝑥**x** moves 𝑥**x** down to the left and its right child 𝑦**y** up to take 𝑥**x**’s place.

``` 
Before Rotation:

    x                                              
     \\                                             
      y                                                         
     / \\                                                     
    a   b                                                     

After Left Rotation:

      y
     / \\
    x   b
     \\
      a
```

***Left Rotation Steps:***

1.  Set **y** to be the right child of **x**.
2.  Move **y**’s left subtree to **x**’s right subtree.
3.  Update the parent of **x** and **y**.
4.  Update **x**’s parent to point to **y** instead of **x**.
5.  Set **y**’s left child to **x**.
6.  Update **x**’s parent to **y**.

***Pseudocode of Left Rotation:***

```c
// Utility function to perform left rotation
void leftRotate(Node* x)
{
    Node* y = x->right;
    x->right = y->left;
    if (y->left != NIL) {
        y->left->parent = x;
    }
    y->parent = x->parent;
    if (x->parent == nullptr) {
        root = y;
    }
    else if (x == x->parent->left) {
        x->parent->left = y;
    }
    else {
        x->parent->right = y;
    }
    y->left = x;
    x->parent = y;
}
```

#### **2. Right Rotation**

A right rotation at node 𝑥**x** moves 𝑥**x** down to the right and its left child 𝑦**y** up to take 𝑥**x**’s place.
```
Befor Right Rotation:    

      x
     /
    y
   / \\
  a   b

After Right Rotation:

    y
   / \\
  a   x
     /
    b
```

***Right Rotation Steps:***

1.  Set ***y*** to be the left child of ***x***.
2.  Move **y**’s right subtree to **x**’s left subtree.
3.  Update the parent of ***x*** and ***y***.
4.  Update **x**’s parent to point to ***y*** instead of ***x***.
5.  Set **y**’s right child to **x**.
6.  Update **x**’s parent to **y**.

***Pseudocode of Right Rotation:***
```c
// Utility function to perform right rotation
void rightRotate(Node* x)
{
    Node* y = x->left;
    x->left = y->right;
    if (y->right != NIL) {
        y->right->parent = x;
    }
    y->parent = x->parent;
    if (x->parent == nullptr) {
        root = y;
    }
    else if (x == x->parent->right) {
        x->parent->right = y;
    }
    else {
        x->parent->left = y;
    }
    y->right = x;
    x->parent = y;
}
```
## When to Perform Rotations?

Rotations in Red-Black Trees are typically performed during insertions and deletions to maintain the properties of the tree. Below are the scenarios for rotations:

#### **1. Fixing Violations after Insertion**

When a new node is inserted, it is always colored red. This can create violations of Red-Black Tree properties, specifically:

-   The root must be **black**.
-   **Red** nodes cannot have **red** children.

**Case Analysis for Fixing Insertions:**

-   **Case 1: Recoloring and Propagating Upwards**
    -   If the parent and uncle of the new node are both **red**, recolor the parent and uncle to **black**, and the grandparent to **red**. Then, recursively apply the fix-up to the grandparent.
-   **Case 2: Rotation and Recoloring**
    -   If the new node’s uncle is **black** and the new node is the right child of a left child (or vice versa), perform a rotation to move the new node up and align it.
    -   If the new node’s uncle is **black** and the new node is the left child of a left child (or right of a right), perform a rotation and recolor the parent and grandparent to fix the violation.

#### **2. Fixing Violations after Deletion**

After deletion, the tree might need fixing to restore properties:

-   When a black node is removed, or a red node is replaced by a black node, a double-black situation can arise.

**Case Analysis for Fixing Deletions:**

-   **Case 1: Sibling is Red**
    -   Recolor the sibling and the parent, and perform a rotation.
-   **Case 2: Sibling is Black with Black Children**
    -   Recolor the sibling to red and move the problem up to the parent.
-   **Case 3: Sibling is Black with at least one Red Child**
    -   Rotate and recolor to fix the double-black issue.

## Implementation of Red-Black Tree:

Here\'s a detailed implementation of a Red-Black Tree including insertion, search, and rotation functions:

## Advantages of Red-Black Trees:

-   **Balanced:** Red-Black Trees are self-balancing, meaning they automatically maintain a balance between the heights of the left and right subtrees. This ensures that search, insertion, and deletion operations take O(log n) time in the worst case.
-   **Efficient search, insertion, and deletion:** Due to their balanced structure, Red-Black Trees offer efficient operations. Search, insertion, and deletion all take O(log n) time in the worst case.
-   **Simple to implement:** The rules for maintaining the Red-Black Tree properties are relatively simple and straightforward to implement.
-   **Widely used:** Red-Black Trees are a popular choice for implementing various data structures, such as maps, sets, and priority queues.

## Disadvantages of Red-Black Trees:

-   **More complex than other balanced trees:** Compared to simpler balanced trees like AVL trees, Red-Black Trees have more complex insertion and deletion rules.
-   **Constant overhead:** Maintaining the Red-Black Tree properties adds a small overhead to every insertion and deletion operation.
-   **Not optimal for all use cases:** While efficient for most operations, Red-Black Trees might not be the best choice for applications where frequent insertions and deletions are required, as the constant overhead can become significant.

## Applications of Red-Black Trees:

-   **Implementing maps and sets:** Red-Black Trees are often used to implement maps and sets, where efficient search, insertion, and deletion are crucial.
-   **Priority queues:** Red-Black Trees can be used to implement priority queues, where elements are ordered based on their priority.
-   **File systems:** Red-Black Trees are used in some file systems to manage file and directory structures.
-   **In-memory databases:** Red-Black Trees are sometimes used in in-memory databases to store and retrieve data efficiently.
-   **Graphics and game development:** Red-Black Trees can be used in graphics and game [development](https://www.geeksforgeeks.org/class-10-social-science-economics-chapter-1-development) for tasks like collision detection and pathfinding.
', 'Red Black Trees are a type of balanced binary search tree that use a set of rules to maintain balance, ensuring logarithmic time complexity for operations, regardless of the initial shape of the tree.', 'Introduction to Red-Black Tree', 16, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('039efe3e-47d0-410e-b3db-a9e64d9bedd7', e'![Stack-representation-in-Data-Structures-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp)

# Types of Stack

* ****Fixed Size Stack****
  : As the name suggests, a fixed size stack has a fixed size and cannot
  grow or shrink dynamically. If the stack is full and an attempt is
  made to add an element to it, an overflow error occurs. If the stack
  is empty and an attempt is made to remove an element from it, an
  underflow error occurs.
* ****Dynamic Size Stack****
  : A dynamic size stack can grow or shrink dynamically. When the stack
  is full, it automatically increases its size to accommodate the new
  element, and when the stack is empty, it decreases its size. This type
  of stack is implemented using a linked list, as it allows for easy
  resizing of the stack.

# Basic Operations on Stack

In order to make manipulations in a stack, there are certain operations
provided to us.


* ****push()****  to insert an element into the stack
* ****pop()****  to remove an element from the stack
* ****top()****  Returns the top element of the stack.
* ****isEmpty()****  returns true if stack is empty else false.
* ****isFull()****  returns true if the stack is full else false.

To implement stack, we need to maintain reference to the top
item.

# Push Operation on Stack

Adds an item to the stack. If the stack is full, then it is said to be
an  ****Overflow condition.****

 ****Algorithm for Push Operation:****

* Before pushing the element to the stack, we check if the stack is  ****full****  .
* If the stack is full  ****(top == capacity-1)****  , then  ****Stack Overflows****  and we cannot insert the element to the stack.
* Otherwise, we increment the value of top by 1  ****(top = top + 1)****  and the new value is inserted at  ****top position****  .
* The elements can be pushed into the stack till we reach the  ****capacity****  of the stack.

![Push-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180844/Push-Operation-in-Stack-(1).webp)
# Pop Operation in Stack

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an  ****Underflow condition.****

****Algorithm for Pop Operation:****

* Before popping the element from the stack, we check if the stack is  ****empty****  .
* If the stack is empty (top == -1), then  ****Stack Underflows****  and we cannot remove any element from the stack.
* Otherwise, we store the value at top, decrement the value of top by 1  ****(top = top – 1)****  and return the stored top value.

![Pop-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180943/Pop-Operation-in-Stack-(1).webp)
# Top or Peek Operation on Stack

Returns the top element of the stack.

****Algorithm for Top Operation:****

* Before returning the top element from the stack, we check if the
  stack is empty.
* If the stack is empty (top == -1), we simply print “Stack is empty”.
* Otherwise, we return the element stored at  ****index = top****  .

![Top-or-Peek-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181023/Top-or-Peek-Operation-in-Stack-(1).webp)
# isEmpty Operation in Stack Data Structure

Returns true if the stack is empty, else false.

****Algorithm for isEmpty Operation****:

* Check for the value of  ****top****  in stack.
* If  ****(top == -1)****, then the stack is  ****empty****  so return  ****true****  .
* Otherwise, the stack is not empty so return  ****false****  .

![isEmpty-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181101/isEmpty-Operation-in-Stack-(1).webp)
# isFull Operation in Stack Data Structure

Returns true if the stack is full, else false.

****Algorithm for isFull Operation:****

* Check for the value of  ****top****  in stack.
* If  ****(top == capacity-1),****  then the stack is  ****full****  so return  ****true****.
* Otherwise, the stack is not full so return  ****false****.

![isFull-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181147/isFull-Operation-in-Stack-(1).webp)

# Implementation of Stack


The basic operations that can be performed on a stack include push, pop,
and peek. There are two ways to implement a stack –


* [****Implementation of Stack using Array****](https://www.geeksforgeeks.org/implement-stack-using-array/)
* [****Implementation of Stack using Linked List****](https://www.geeksforgeeks.org/implement-a-stack-using-singly-linked-list/)

# Complexity Analysis of Operations on Stack Data Structure

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****push()**** | O(1) | O(1) |
| ****pop()**** | O(1) | O(1) |
| top() or  ****pee****k() | O(1) | O(1) |
| isEmpty() | O(1) | O(1) |
| isFull() | O(1) | O(1) |
![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20230726165552/Stack-Data-Structure.png)

# Applications of Stacks:

-   ****Function calls:**** Stacks are used to keep track of the return addresses of function calls, allowing the program to return to the correct location after a function has finished executing.
-   ****Recursion:**** Stacks are used to store the local variables and return addresses of recursive function calls, allowing the program to keep track of the current state of the recursion.
-   ****Expression evaluation:**** Stacks are used to evaluate expressions in postfix notation (Reverse Polish Notation).
-   ****Syntax parsing:**** Stacks are used to check the validity of syntax in programming languages and other formal languages.
-   ****Memory management:**** Stacks are used to allocate and manage memory in some operating systems and programming languages.
-   Used to solve popular problems like [Next Greater](https://www.geeksforgeeks.org/next-greater-element/), [Previous Greater](https://www.geeksforgeeks.org/previous-greater-element/), [Next Smaller](https://www.geeksforgeeks.org/next-smaller-element/), [Previous Smaller](https://www.geeksforgeeks.org/find-the-nearest-smaller-numbers-on-left-side-in-an-array/), [Largest Area in a Histogram](https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-using-stack/) and [Stock Span Problems](https://www.geeksforgeeks.org/the-stock-span-problem/).

# Advantages of Stacks:

-   ****Simplicity:**** Stacks are a simple and easy-to-understand data structure, making them suitable for a wide range of applications.
-   ****Efficiency:**** Push and pop operations on a stack can be performed in constant time ****(O(1))****, providing efficient access to data.
-   ****Last-in, First-out (LIFO):**** Stacks follow the LIFO principle, ensuring that the last element added to the stack is the first one removed. This behavior is useful in many scenarios, such as function calls and expression evaluation.
-   ****Limited memory usage:**** Stacks only need to store the elements that have been pushed onto them, making them memory-efficient compared to other data structures.

# Disadvantages of Stacks:

-   ****Limited access:**** Elements in a stack can only be accessed from the top, making it difficult to retrieve or modify elements in the middle of the stack.
-   ****Potential for overflow:**** If more elements are pushed onto a stack than it can hold, an overflow error will occur, resulting in a loss of data.
-   ****Not suitable for random access:**** Stacks do not allow for random access to elements, making them unsuitable for applications where elements need to be accessed in a specific order.
-   ****Limited capacity:**** Stacks have a fixed capacity, which can be a limitation if the number of elements that need to be stored is unknown or highly variable.

 ', 'Stack is a linear data structure that follows LIFO (Last In First Out) Principle', 'What is Stack Data Structure? A Complete Tutorial', 11, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('98378e7c-1240-46fe-be25-0032ad7aa554', e'****Example:****


> ****Input:****
>
>
> {{1, 2, 3}
>
>
>
> {4, 5, 6}
>
>
>
> {7, 8, 9}}
>
>
>
> ****Output:****
> 1 2 4 7 5 3 6 8 9
>
>
> ****Input :****
> [[1, 2, 3, 4],
>
>
>
> [5, 6, 7, 8],
>
>
>
> [9, 10, 11, 12],
>
>
>
> [13, 14, 15, 16]]
>
>
>
> ****Output::****
> 1 2 5 9 6 3 4 7 10 13 14 11 8 12 15 16


This approach uses a diagonal traversal technique to print the matrix in a zig-zag pattern. It iterates through the matrix diagonally, switching between incrementing the row and column indices based on the current position. This creates a zig-zag path that covers all elements of the matrix.


Below is the implementation of the above approach:


C++

````
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Utility function to print matrix in zig-zag form
void zigZagMatrix(vector<vector<int>>& mat) {
    int n = mat.size();
    int m = mat[0].size();
    int row = 0, col = 0;

    // Boolean variable that is true if we need
    // to increment \'row\' value;
    // otherwise, false if we increment \'col\' value.
    bool row_inc = 0;

    // Print the first half of the zig-zag pattern
    int mn = min(m, n);
    for (int len = 1; len <= mn; ++len) {
        for (int i = 0; i < len; ++i) {
            cout << mat[row][col] << " ";

            if (i + 1 == len) break;

            // If row_inc is true, increment row
            // and decrement col;
            // otherwise, decrement row and increment col.
            if (row_inc) ++row, --col;
            else --row, ++col;
        }

        if (len == mn) break;

        // Update row or col value based on the
        // last increment
        if (row_inc) ++row, row_inc = false;
        else ++col, row_inc = true;
    }

    // Adjust row and col for the second half of the matrix
    if (row == 0) {
        if (col == m - 1) ++row;
        else ++col;
        row_inc = 1;
    } else {
        if (row == n - 1) ++col;
        else ++row;
        row_inc = 0;
    }

    // Print the second half of the zig-zag pattern
    int MAX = max(m, n) - 1;
    for (int len, diag = MAX; diag > 0; --diag) {
        len = (diag > mn) ? mn : diag;
        for (int i = 0; i < len; ++i) {
            cout << mat[row][col] << " ";

            if (i + 1 == len) break;

            // Update row or col value based on the last increment
            if (row_inc) ++row, --col;
            else ++col, --row;
        }

        // Update row and col based on position in the matrix
        if (row == 0 || col == m - 1) {
            if (col == m - 1) ++row;
            else ++col;
            row_inc = true;
        } else if (col == 0 || row == n - 1) {
            if (row == n - 1) ++col;
            else ++row;
            row_inc = false;
        }
    }
}

// Driver code
int main() {
    vector<vector<int>> mat = { { 1, 2, 3 },
                                { 4, 5, 6 },
                                { 7, 8, 9 } };
    zigZagMatrix(mat);

    return 0;
}

````

Java

````
public class ZigZagMatrix {

    // Utility function to print matrix in zig-zag form
    public static void zigZagMatrix(int[][] mat) {
        int n = mat.length;
        int m = mat[0].length;
        int row = 0, col = 0;

        // Boolean variable that is true if we need to
        // increment \'row\' value;
        // otherwise, false if we increment \'col\' value.
        boolean rowInc = false;

        // Print the first half of the zig-zag pattern
        int minDim = Math.min(m, n);
        for (int len = 1; len <= minDim; ++len) {
            for (int i = 0; i < len; ++i) {
                System.out.print(mat[row][col] + " ");

                if (i + 1 == len) break;

                // If rowInc is true, increment row and decrement col;
                // otherwise, decrement row and increment col.
                if (rowInc) {
                    row++;
                    col--;
                } else {
                    row--;
                    col++;
                }
            }

            if (len == minDim) break;

            // Update row or col value based on the last increment
            if (rowInc) {
                row++;
                rowInc = false;
            } else {
                col++;
                rowInc = true;
            }
        }

        // Adjust row and col for the second half of the matrix
        if (row == 0) {
            if (col == m - 1) row++;
            else col++;
            rowInc = true;
        } else {
            if (row == n - 1) col++;
            else row++;
            rowInc = false;
        }

        // Print the second half of the zig-zag pattern
        int maxDim = Math.max(m, n) - 1;
        for (int len, diag = maxDim; diag > 0; --diag) {
            len = (diag > minDim) ? minDim : diag;
            for (int i = 0; i < len; ++i) {
                System.out.print(mat[row][col] + " ");

                if (i + 1 == len) break;

                // Update row or col value based on the last increment
                if (rowInc) {
                    row++;
                    col--;
                } else {
                    col++;
                    row--;
                }
            }

            // Update row and col based on position in the matrix
            if (row == 0 || col == m - 1) {
                if (col == m - 1) row++;
                else col++;
                rowInc = true;
            } else if (col == 0 || row == n - 1) {
                if (row == n - 1) col++;
                else row++;
                rowInc = false;
            }
        }
    }

    // Driver code
    public static void main(String[] args) {
        int[][] mat = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        zigZagMatrix(mat);
    }
}

````

Python

````
# Utility function to print matrix in zig-zag form

def zig_zag_matrix(mat):
    n = len(mat)
    m = len(mat[0])
    row = 0
    col = 0

    # Boolean variable that is true if we need
    # to increment \'row\' value;
    # otherwise, false if we increment \'col\' value.
    row_inc = False

    # Print the first half of the zig-zag pattern
    mn = min(m, n)
    for length in range(1, mn + 1):
        for i in range(length):
            print(mat[row][col], end=\' \')

            if i + 1 == length:
                break

            # If row_inc is true, increment row
            # and decrement col;
            # otherwise, decrement row and increment col.
            if row_inc:
                row += 1
                col -= 1
            else:
                row -= 1
                col += 1

        if length == mn:
            break

        # Update row or col value based on the
        # last increment
        if row_inc:
            row += 1
            row_inc = False
        else:
            col += 1
            row_inc = True

    # Adjust row and col for the second half of the matrix
    if row == 0:
        if col == m - 1:
            row += 1
        else:
            col += 1
        row_inc = True
    else:
        if row == n - 1:
            col += 1
        else:
            row += 1
        row_inc = False

    # Print the second half of the zig-zag pattern
    MAX = max(m, n) - 1
    for diag in range(MAX, 0, -1):
        length = mn if diag > mn else diag
        for i in range(length):
            print(mat[row][col], end=\' \')

            if i + 1 == length:
                break

            # Update row or col value based on the last increment
            if row_inc:
                row += 1
                col -= 1
            else:
                col += 1
                row -= 1

        # Update row and col based on position in the matrix
        if row == 0 or col == m - 1:
            if col == m - 1:
                row += 1
            else:
                col += 1
            row_inc = True
        elif col == 0 or row == n - 1:
            if row == n - 1:
                col += 1
            else:
                row += 1
            row_inc = False

# Driver code
if __name__ == \'__main__\':
    mat = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]
    zig_zag_matrix(mat)

````

C#

````
using System;
using System.Collections.Generic;

class Program
{
    static void ZigZagMatrix(int[,] mat)
    {
        int n = mat.GetLength(0);
        int m = mat.GetLength(1);
        int row = 0;
        int col = 0;

        // Boolean variable that is true if we need
        // to increment \'row\' value;
        // otherwise, false if we increment \'col\' value.
        bool rowInc = false;

        // Print the first half of the zig-zag pattern
        int mn = Math.Min(m, n);
        for (int length = 1; length <= mn; length++)
        {
            for (int i = 0; i < length; i++)
            {
                Console.Write(mat[row, col] + " ");

                if (i + 1 == length)
                    break;

                // If rowInc is true, increment row
                // and decrement col;
                // otherwise, decrement row and increment col.
                if (rowInc)
                {
                    row++;
                    col--;
                }
                else
                {
                    row--;
                    col++;
                }
            }

            if (length == mn)
                break;

            // Update row or col value based on the
            // last increment
            if (rowInc)
            {
                row++;
                rowInc = false;
            }
            else
            {
                col++;
                rowInc = true;
            }
        }

        // Adjust row and col for the second half of the matrix
        if (row == 0)
        {
            if (col == m - 1)
                row++;
            else
                col++;
            rowInc = true;
        }
        else
        {
            if (row == n - 1)
                col++;
            else
                row++;
            rowInc = false;
        }

        // Print the second half of the zig-zag pattern
        int MAX = Math.Max(m, n) - 1;
        for (int diag = MAX; diag > 0; diag--)
        {
            int length = (diag > mn) ? mn : diag;
            for (int i = 0; i < length; i++)
            {
                Console.Write(mat[row, col] + " ");

                if (i + 1 == length)
                    break;

                // Update row or col value based on the last increment
                if (rowInc)
                {
                    row++;
                    col--;
                }
                else
                {
                    col++;
                    row--;
                }
            }

            // Update row and col based on position in the matrix
            if (row == 0 || col == m - 1)
            {
                if (col == m - 1)
                    row++;
                else
                    col++;
                rowInc = true;
            }
            else if (col == 0 || row == n - 1)
            {
                if (row == n - 1)
                    col++;
                else
                    row++;
                rowInc = false;
            }
        }
    }

    // Driver code
    static void Main()
    {
        int[,] mat = new int[,] {
            { 1, 2, 3 },
            { 4, 5, 6 },
            { 7, 8, 9 }
        };
        ZigZagMatrix(mat);
    }
}

````

JavaScript

````
function zigZagMatrix(mat) {
    const n = mat.length;
    const m = mat[0].length;
    let row = 0;
    let col = 0;

    // Boolean variable that is true if we need
    // to increment \'row\' value;
    // otherwise, false if we increment \'col\' value.
    let rowInc = false;

    // Print the first half of the zig-zag pattern
    const mn = Math.min(m, n);
    for (let length = 1; length <= mn; length++) {
        for (let i = 0; i < length; i++) {
            process.stdout.write(mat[row][col] + \' \');

            if (i + 1 === length) break;

            // If rowInc is true, increment row
            // and decrement col;
            // otherwise, decrement row and increment col.
            if (rowInc) {
                row++;
                col--;
            } else {
                row--;
                col++;
            }
        }

        if (length === mn) break;

        // Update row or col value based on the
        // last increment
        if (rowInc) {
            row++;
            rowInc = false;
        } else {
            col++;
            rowInc = true;
        }
    }

    // Adjust row and col for the second half of the matrix
    if (row === 0) {
        if (col === m - 1) row++;
        else col++;
        rowInc = true;
    } else {
        if (row === n - 1) col++;
        else row++;
        rowInc = false;
    }

    // Print the second half of the zig-zag pattern
    const MAX = Math.max(m, n) - 1;
    for (let diag = MAX; diag > 0; diag--) {
        const length = diag > mn ? mn : diag;
        for (let i = 0; i < length; i++) {
            process.stdout.write(mat[row][col] + \' \');

            if (i + 1 === length) break;

            // Update row or col value based on the last increment
            if (rowInc) {
                row++;
                col--;
            } else {
                col++;
                row--;
            }
        }

        // Update row and col based on position in the matrix
        if (row === 0 || col === m - 1) {
            if (col === m - 1) row++;
            else col++;
            rowInc = true;
        } else if (col === 0 || row === n - 1) {
            if (row === n - 1) col++;
            else row++;
            rowInc = false;
        }
    }
}

// Driver code
const mat = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
zigZagMatrix(mat);

````




**Output**
```
1 2 4 7 5 3 6 8 9
```

****Time complexity:****
O(n\\*m)



****Auxiliary space:****
O(1), since no extra space has been taken.

', 'Given a matrix of 2D array of n rows and m columns. Print this matrix in ZIG-ZAG fashion as shown in figure.', 'Print matrix in zig-zag fashion', 2, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('630b6281-246f-490e-bb03-77b0b5ea16f1', e'Two common ways of traversing a matrix are row-major-order and column-major-order



****Row Major Order:****
When matrix is accessed row by row.



****Column Major Order:****
When matrix is accessed column by column.



****Examples:****

> ****Input :****
> mat[][] = {{1, 2, 3},
>
>
>
> {4, 5, 6},
>
>
>
> {7, 8, 9}}
>
>
> ****Output :****
> Row-wise: 1 2 3 4 5 6 7 8 9
>
>
>
> Col-wise : 1 4 7 2 5 8 3 6 9


In many problems (like

[Search in a Matrix](https://www.geeksforgeeks.org/search-in-a-matrix-or-2d-array/)
), we can use any of the above two, so the question arises which one to use?


If we see according to time complexity, both lead to

****O(n****
****2****
****)****
, but when it comes to cache level one of the orders access will be faster as compare to other one. It depends on the language we are using. Most of the languages including C, C++, Java, Python, C# and JavaScrtipt


store matrix in row major form so while accessing the i+1

th
element after i

th
, most probably it will lead to a hit, which will further reduce the time of program.


The following codes are showing the time difference in row major and column major access.


C++

````
#include <iostream>
#include <vector>
#include <ctime>

using namespace std;

void rowMajor(vector<vector<int>>& arr) {
    int rows = arr.size();
    int cols = arr[0].size();

    // Accessing elements row-wise
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            arr[i][j]++;
        }
    }
}

void colMajor(vector<vector<int>>& arr) {
    int rows = arr.size();
    int cols = arr[0].size();

    // Accessing elements column-wise
    for (int j = 0; j < cols; j++) {
        for (int i = 0; i < rows; i++) {
            arr[i][j]++;
        }
    }
}

int main() {
    int n = 1000; // Size of the matrix (n x n)
    vector<vector<int>> arr(n, vector<int>(n, 0));

    // Time taken by row-major order
    clock_t t = clock();
    rowMajor(arr);
    t = clock() - t;
    cout << "Row major access time: " << t / (double)CLOCKS_PER_SEC << " s\\n";

    // Time taken by column-major order
    t = clock();
    colMajor(arr);
    t = clock() - t;
    cout << "Column major access time: " << t / (double)CLOCKS_PER_SEC << " s\\n";

    return 0;
}

````

C

````
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

#define MAX 1000 // Size of the matrix (MAX x MAX)

void rowMajor(int arr[MAX][MAX]) {
    // Accessing elements row-wise
    for (int i = 0; i < MAX; i++) {
        for (int j = 0; j < MAX; j++) {
            arr[i][j]++;
        }
    }
}

void colMajor(int arr[MAX][MAX]) {
    // Accessing elements column-wise
    for (int j = 0; j < MAX; j++) {
        for (int i = 0; i < MAX; i++) {
            arr[i][j]++;
        }
    }
}

int main() {
    int arr[MAX][MAX] = {0}; // Initialize matrix with zeros

    // Time taken by row-major order
    clock_t t = clock();
    rowMajor(arr);
    t = clock() - t;
    printf("Row major access time: %f s\\n", (double)t / CLOCKS_PER_SEC);

    // Time taken by column-major order
    t = clock();
    colMajor(arr);
    t = clock() - t;
    printf("Column major access time: %f s\\n", (double)t / CLOCKS_PER_SEC);

    return 0;
}

````

Java

````
import java.time.Duration;
import java.time.Instant;
import java.util.*;

class GFG {

    static void rowMajor(int[][] arr) {
        int rows = arr.length;
        int cols = arr[0].length;

        // Accessing elements row-wise
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                arr[i][j]++;
            }
        }
    }

    static void colMajor(int[][] arr) {
        int rows = arr.length;
        int cols = arr[0].length;

        // Accessing elements column-wise
        for (int j = 0; j < cols; j++) {
            for (int i = 0; i < rows; i++) {
                arr[i][j]++;
            }
        }
    }

    public static void main(String[] args) {
        int n = 1000; // Size of the matrix (n x n)
        int[][] arr = new int[n][n];

        // Time taken by row-major order
        Instant start = Instant.now();
        rowMajor(arr);
        Instant end = Instant.now();
        System.out.println("Row major access time: " + Duration.between(start, end));

        // Time taken by column-major order
        start = Instant.now();
        colMajor(arr);
        end = Instant.now();
        System.out.println("Column major access time: " + Duration.between(start, end));
    }
}

````

Python

````
from time import perf_counter

def row_major(arr):
    rows = len(arr)
    cols = len(arr[0])

    # Accessing elements row-wise
    for i in range(rows):
        for j in range(cols):
            arr[i][j] += 1

def col_major(arr):
    rows = len(arr)
    cols = len(arr[0])

    # Accessing elements column-wise
    for j in range(cols):
        for i in range(rows):
            arr[i][j] += 1

if __name__ == \'__main__\':

    n = 1000  # Size of the matrix (n x n)
    arr = [[0] * n for _ in range(n)]

    # Time taken by row-major order
    t_start = perf_counter()
    row_major(arr)
    t_row = perf_counter() - t_start
    print("Row major access time: {:.2f} s".format(t_row))

    # Time taken by column-major order
    t_start = perf_counter()
    col_major(arr)
    t_col = perf_counter() - t_start
    print("Column major access time: {:.2f} s".format(t_col))

````

C#

````
using System;

public class GFG {
    public static void RowMajor(int[,] arr) {
        int rows = arr.GetLength(0);
        int cols = arr.GetLength(1);

        // Accessing elements row-wise
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                arr[i, j]++;
            }
        }
    }

    public static void ColMajor(int[,] arr) {
        int rows = arr.GetLength(0);
        int cols = arr.GetLength(1);

        // Accessing elements column-wise
        for (int j = 0; j < cols; j++) {
            for (int i = 0; i < rows; i++) {
                arr[i, j]++;
            }
        }
    }

    public static void Main(string[] args) {
        int n = 1000; // Size of the matrix (n x n)
        int[,] arr = new int[n, n];

        // Time taken by row-major order
        var start = DateTime.UtcNow;
        RowMajor(arr);
        var end = DateTime.UtcNow;
        TimeSpan spanR = end - start;
        Console.WriteLine("Row major access time: " + spanR.TotalSeconds + " s");

        // Time taken by column-major order
        start = DateTime.UtcNow;
        ColMajor(arr);
        end = DateTime.UtcNow;
        TimeSpan spanC = end - start;
        Console.WriteLine("Column major access time: " + spanC.TotalSeconds + " s");
    }
}

````

JavaScript

````
function rowMajor(arr) {
    let rows = arr.length;
    let cols = arr[0].length;

    // Accessing elements row-wise
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            arr[i][j]++;
        }
    }
}

function colMajor(arr) {
    let rows = arr.length;
    let cols = arr[0].length;

    // Accessing elements column-wise
    for (let j = 0; j < cols; j++) {
        for (let i = 0; i < rows; i++) {
            arr[i][j]++;
        }
    }
}

// Driver code
let n = 1000; // Size of the matrix (n x n)
let arr = Array.from({ length: n }, () => Array(n).fill(0));

// Time taken by row-major order
let start = Date.now();
rowMajor(arr);
let end = Date.now();
console.log(`Row major access time: ${end - start} ms`);

// Time taken by column-major order
start = Date.now();
colMajor(arr);
end = Date.now();
console.log(`Column major access time: ${end - start} ms`);

````

****Time Complexity:****
O(MAX\\*MAX)



****Auxiliary Space:****
O(MAX\\*MAX)', '', 'Row-wise vs column-wise traversal of matrix', 3, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('c009b1a3-025d-4295-841e-6faecee91690', e'Given a matrix

****mat[n][m]****
and an element

****target****
. return true if the target is present in the matrix, else return false.


****Examples:****

> ****Input****
> : mat[][] = { {10, 51, 9},
>
>
>
> {14, 20, 21},
>
>
>
> {30, 24, 43} }
>
>
>
> ****target****
> = 14
>
>
>
> ****Output****
> : Found
>
>
>
>
>
> ****Input****
> : mat[][] = {{31, 5, 9, 11},
>
>
>
> {14, 7, 21, 26},
>
>
>
> {30, 4, 43, 50} }
>
>
>
> ****target****
> = 42
>
>
>
> ****Output****
> : Not Found


We traverse the mat[][] and compare target with every element of the matrix. If matches, then return true If we reach the end we will return false.


C++

````
// C++ program to search target in a matrix
#include <bits/stdc++.h>
using namespace std;

bool matrixSearch(vector<vector<int> >& mat, int x)
{
    int n = mat.size(), m = mat[0].size();

    // Compare each element one by one
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (mat[i][j] == x)
                return true;
    return false;
}

int main() {
    vector<vector<int> > mat = { { 1, 5, 9, 11 },
                                 { 14, 20, 21, 26 },
                                 { 30, 34, 43, 50 } };
    if (matrixSearch(mat, 14))
        cout << "Found\\n";
    else
        cout << "Not Found\\n";

    return 0;
}

````

C

````
// C program to check position of target Linearly
#include <stdbool.h>
#include <stdio.h>

#define MAX 100

bool matrixSearch(int mat[MAX][MAX], int n, int m,
                        int x)
{
    // Compare each element one by one
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (mat[i][j] == x) {
                return true;
            }
        }
    }
    return false;
}

int main()
{
    int mat[MAX][MAX] = { { 1, 5, 9, 11 },
                          { 14, 20, 21, 26 },
                          { 30, 34, 43, 50 } };
    // Number of rows
  	int n = 3;

    // Number of columns
    int m = 4;

    // Element to search
    int x = 14;

    if (matrixSearch(mat, n, m, x)) {
        printf("Found\\n");
    }
    else {
        printf("Not Found\\n");
    }

    return 0;
}

````

Java

````
// Java program to check position of target Linearly
import java.util.*;

class GfG {

    public static boolean matrixSearch(int[][] mat,
                                             int x)
    {
        int n = mat.length;
        int m = mat[0].length;

        // Compare each element one by one
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (mat[i][j] == x) {
                    return true;
                }
            }
        }
        return false;
    }

    public static void main(String[] args)
    {
        int[][] mat = { { 1, 5, 9, 11 },
                        { 14, 20, 21, 26 },
                        { 30, 34, 43, 50 } };
        if (matrixSearch(mat, 14)) {
            System.out.println("Found");
        }
        else {
            System.out.println("Not Found");
        }
    }
}

````

Python

````
# Python program to check position of target Linearly
def matrixSearch(mat, x):
    n = len(mat)
    m = len(mat[0])

    # Compare each element one by one
    for i in range(n):
        for j in range(m):
            if mat[i][j] == x:
                return True
    return False


if __name__ == "__main__":
    mat = [
        [1, 5, 9, 11],
        [14, 20, 21, 26],
        [30, 34, 43, 50]
    ]
    if matrixSearch(mat, 14):
        print("Found")
    else:
        print("Not Found")

````

C#

````
// C# program to check position of target Linearly
using System;

class GfG {
    public static bool matrixSearch(int[, ] mat, int x)
    {
        int n = mat.GetLength(0);
        int m = mat.GetLength(1);

        // Compare each element one by one
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (mat[i, j] == x)
                    return true;

        return false;
    }

    public static void Main()
    {
        int[, ] mat = { { 1, 5, 9, 11 },
                        { 14, 20, 21, 26 },
                        { 30, 34, 43, 50 } };

        if (matrixSearch(mat, 14))
            Console.WriteLine("Found");
        else
            Console.WriteLine("Not Found");
    }
}

````

JavaScript

````
// Javascript program to check position of target Linearly
function matrixSearch(mat, x)
{
    let n = mat.length;
    let m = mat[0].length;

    // Compare each element one by one
    for (let i = 0; i < n; i++)
        for (let j = 0; j < m; j++)
            if (mat[i][j] === x)
                return true;

    return false;
}

let mat = [
    [ 1, 5, 9, 11 ], [ 14, 20, 21, 26 ], [ 30, 34, 43, 50 ]
];

if (matrixSearch(mat, 14))
    console.log("Found");
else
    console.log("Not Found");

````




**Output**
```
Found

```



****Time Complexity :****
O(n \\* m), where n and m are the rows and column of matrix.



****Auxiliary Space :****
O(1)', '', 'Search in a Matrix or 2D Array', 4, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('c810809a-8425-4105-91f6-cc98e64ead3e', e'

Given two

****N****
x

****M matrices****
. Find a

****N****
x

****M****
matrix as the sum of given matrices each value at the sum of values of corresponding elements of the given two matrices.


![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/program-for-addition-of-two-matrices-1024x512.png)

****Approach:****
Below is the idea to solve the problem.


> Iterate over every cell of matrix (i, j), add the corresponding values of the two matrices and store in a single matrix i.e. the resultant matrix.


Follow the below steps to Implement the idea:


* Initialize a resultant matrix res[N][M].
* Run a for loop for counter

  ****i****
  as each row and in each iteration:
  + Run a for loop for counter

    ****j****
    as each column and in each iteration:
    - Add values of the two matrices for index i, j and store in res[i][j].
* Return res.


Below is the Implementation of above approach.


C++

````
#include <iostream>
#include <vector>
using namespace std;

void add(vector<vector<int>>& A, vector<vector<int>>& B,
                                 vector<vector<int>>& C) {
    int n = A.size();
    int m = A[0].size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
}

int main() {
    vector<vector<int>> A = { {1, 1, 1},
                              {2, 2, 2},
                              {3, 3, 3},
                              {4, 4, 4} };

    vector<vector<int>> B = { {1, 1, 1},
                              {2, 2, 2},
                              {3, 3, 3},
                              {4, 4, 4} };

    int n = A.size();
    int m = A[0].size();
    vector<vector<int>> C(n, vector<int>(m));

    add(A, B, C);

    cout << "Result matrix is:" << endl;
    for (const auto& row : C) {
        for (int val : row) {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define N 4  // Number of rows
#define M 3  // Number of columns

void add(int A[][M], int B[][M], int C[][M]) {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
}

int main() {
    int A[N][M] = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };
    int B[N][M] = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };
    int C[N][M];

    add(A, B, C);

    printf("Result matrix is:\\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            printf("%d ", C[i][j]);
        }
        printf("\\n");
    }
    return 0;
}

````

Java

````
public class GfG {
    public static void add(int[][] A, int[][] B, int[][] C) {
        int n = A.length;
        int m = A[0].length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                C[i][j] = A[i][j] + B[i][j];
            }
        }
    }

    public static void main(String[] args) {
        int[][] A = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };
        int[][] B = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4} };
        int[][] C = new int[4][3];
        add(A, B, C);

        System.out.println("Result matrix is:");
        for (int[] row : C) {
            for (int val : row) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
    }
}

````

Python

````
def add(A, B):
    n = len(A)
    m = len(A[0])
    C = [[0] * m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            C[i][j] = A[i][j] + B[i][j]
    return C

A = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ]
B = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ]
C = add(A, B)

print("Result matrix is:")
for row in C:
    print(\' \'.join(map(str, row)))

````

JavaScript

````
function add(A, B) {
    let n = A.length;
    let m = A[0].length;
    let C = Array.from({ length: n }, () => Array(m).fill(0));
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
    return C;
}

const A = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];
const B = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];
const C = add(A, B);

console.log("Result matrix is:");
C.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
function add($A, $B) {
    $n = count($A);
    $m = count($A[0]);
    $C = array_fill(0, $n, array_fill(0, $m, 0));
    for ($i = 0; $i < $n; $i++) {
        for ($j = 0; $j < $m; $j++) {
            $C[$i][$j] = $A[$i][$j] + $B[$i][$j];
        }
    }
    return $C;
}

$A = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];
$B = [ [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4] ];
$C = add($A, $B);

echo "Result matrix is:\\n";
foreach ($C as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is
2 2 2 2
4 4 4 4
6 6 6 6
8 8 8 8
```

****Time complexity:****
O(n x m).



****Auxiliary space:****
O(n x m).  since n

2
extra space has been taken for storing results


The program can be extended for rectangular matrices. The following post can be useful for extending this program.', '', 'Program for addition of two matrices', 5, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('1196e9db-ba66-4fc1-af17-824bf7fd8444', e'

Given two

[matrices](https://www.geeksforgeeks.org/matrices/)
, the task is to multiply them. Matrices can either be square or rectangular:


****Examples:****


> ****(Square Matrix Multiplication)****
>
> ****Input:****
> m1[m][n] = { {1, 1}, {2, 2} }
>
>
>
> m2[n][p] = { {1, 1}, {2, 2} }
>
>
>
> ****Output:****
> res[m][p] = { {3, 3}, {6, 6} }
>
>
> ****(Rectangular Matrix Multiplication)****
>
> ****Input:****
> m1[3][2] = { {1, 1}, {2, 2}, {3, 3} }
>
>
>
> m2[2][3] = { {1, 1, 1}, {2, 2, 2} }
>
>
>
> ****Output:****
> res[3][3] = { {3, 3, 3}, {6, 6, 6}, {9, 9, 9} }
>
>
> ![](https://media.geeksforgeeks.org/wp-content/uploads/20210902010632/MatrixMultiply1001jpeg001.jpeg)

****Multiplication of two Square or Rectangular Matrices****
------------------------------------------------------------

> * The number of columns in Matrix-1 must be equal to the number of rows in Matrix-2.
> * Output of multiplication of Matrix-1 and Matrix-2, results with equal to the number of rows of Matrix-1 and  the number of columns of Matrix-2 i.e. rslt[R1][C2]


Below is the implementation of the multiplication of two

[matrices](https://www.geeksforgeeks.org/matrices/)
:





C++

````
#include <iostream>
#include <vector>
using namespace std;

void mulMat(vector<vector<int>>& m1, vector<vector<int>>& m2,
            vector<vector<int>>& res) {
    int r1 = m1.size();
    int c1 = m1[0].size();
    int r2 = m2.size();
    int c2 = m2[0].size();

    if (c1 != r2) {
        cout << "Invalid Input" << endl;
        exit(EXIT_FAILURE);
    }

    // Resize result matrix to fit the result dimensions
    res.resize(r1, vector<int>(c2, 0));

    for (int i = 0; i < r1; i++) {
        for (int j = 0; j < c2; j++) {
            for (int k = 0; k < c1; k++) {
                res[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
}

// Driver code
int main() {
    vector<vector<int>> m1 = { {1, 1}, {2, 2} };
    vector<vector<int>> m2 = { {1, 1}, {2, 2} };
    vector<vector<int>> res;

    mulMat(m1, m2, res);

    cout << "Multiplication of given two matrices is:\\n";
    for (const auto& row : res) {
        for (int val : row) {
            cout << val << "\\t";
        }
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R1 2 // number of rows in Matrix-1
#define C1 2 // number of columns in Matrix-1
#define R2 2 // number of rows in Matrix-2
#define C2 2 // number of columns in Matrix-2

void mulMat(int m1[][C1], int m2[][C2], int rslt[][C2]) {
    if (C1 != R2) {
       printf("Invalid Input");
       return;
    }

    for (int i = 0; i < R1; i++) {
        for (int j = 0; j < C2; j++) {
            rslt[i][j] = 0;

            // Changed R2 to C1 for correct multiplication
            for (int k = 0; k < C1; k++) {
                rslt[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
}

int main() {
    int m1[R1][C1] = { { 1, 1 },
                       { 2, 2 } };

    int m2[R2][C2] = { { 1, 1 },
                       { 2, 2 } };

    int rslt[R1][C2]; // Result matrix

    // Function call to multiply matrices
    mulMat(m1, m2, rslt);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R1; i++) {
        for (int j = 0; j < C2; j++) {
            printf("%d\\t", rslt[i][j]);
        }
        printf("\\n");
    }

    return 0;
}

````

Java

````
public class MatrixMultiplication {

    public static void mulMat(int[][] m1, int[][] m2, int[][] res) {
        int r1 = m1.length;
        int c1 = m1[0].length;
        int r2 = m2.length;
        int c2 = m2[0].length;

        if (c1 != r2) {
            System.out.println("Invalid Input");
            System.exit(1);
        }

        // Perform matrix multiplication
        for (int i = 0; i < r1; i++) {
            for (int j = 0; j < c2; j++) {
                res[i][j] = 0; // Initialize result cell
                for (int k = 0; k < c1; k++) {
                    res[i][j] += m1[i][k] * m2[k][j];
                }
            }
        }
    }

    public static void main(String[] args) {
        int[][] m1 = {
            {1, 1},
            {2, 2}
        };

        int[][] m2 = {
            {1, 1},
            {2, 2}
        };

        int r1 = m1.length;
        int c2 = m2[0].length;
        int[][] res = new int[r1][c2]; // Resultant matrix

        mulMat(m1, m2, res);

        System.out.println("Multiplication of given two matrices is:");
        for (int i = 0; i < r1; i++) {
            for (int j = 0; j < c2; j++) {
                System.out.print(res[i][j] + "\\t");
            }
            System.out.println();
        }
    }
}

````

Python

````
def mulMat(m1, m2):
    r1 = len(m1)
    c1 = len(m1[0])
    r2 = len(m2)
    c2 = len(m2[0])

    if c1 != r2:
        print("Invalid Input")
        return None

    # Initialize the result matrix with zeros
    res = [[0] * c2 for _ in range(r1)]

    # Perform matrix multiplication
    for i in range(r1):
        for j in range(c2):
            for k in range(c1):
                res[i][j] += m1[i][k] * m2[k][j]

    return res

# Driver code
if __name__ == "__main__":
    m1 = [
        [1, 1],
        [2, 2]
    ]

    m2 = [
        [1, 1],
        [2, 2]
    ]

    result = mulMat(m1, m2)

    print("Multiplication of given two matrices is:")
    for row in result:
        print(" ".join(map(str, row)))

````

C#

````
using System;

class Program
{
    static int[,] MulMat(int[,] m1, int[,] m2)
    {
        int r1 = m1.GetLength(0);
        int c1 = m1.GetLength(1);
        int r2 = m2.GetLength(0);
        int c2 = m2.GetLength(1);

        if (c1 != r2)
        {
            Console.WriteLine("Invalid Input");
            return null;
        }

        // Initialize the result matrix
        int[,] res = new int[r1, c2];

        // Perform matrix multiplication
        for (int i = 0; i < r1; i++)
        {
            for (int j = 0; j < c2; j++)
            {
                for (int k = 0; k < c1; k++)
                {
                    res[i, j] += m1[i, k] * m2[k, j];
                }
            }
        }

        return res;
    }

    static void Main()
    {
        int[,] m1 = { { 1, 1 }, { 2, 2 } };
        int[,] m2 = { { 1, 1 }, { 2, 2 } };

        int[,] result = MulMat(m1, m2);

        if (result != null)
        {
            Console.WriteLine("Multiplication of given two matrices is:");
            for (int i = 0; i < result.GetLength(0); i++)
            {
                for (int j = 0; j < result.GetLength(1); j++)
                {
                    Console.Write(result[i, j] + "\\t");
                }
                Console.WriteLine();
            }
        }
    }
}

````

JavaScript

````
function mulMat(m1, m2) {
    const r1 = m1.length;
    const c1 = m1[0].length;
    const r2 = m2.length;
    const c2 = m2[0].length;

    if (c1 !== r2) {
        console.log("Invalid Input");
        return null;
    }

    // Initialize the result matrix
    const res = Array.from({ length: r1 }, () => Array(c2).fill(0));

    // Perform matrix multiplication
    for (let i = 0; i < r1; i++) {
        for (let j = 0; j < c2; j++) {
            for (let k = 0; k < c1; k++) {
                res[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }

    return res;
}

// Driver code
const m1 = [
    [1, 1],
    [2, 2]
];

const m2 = [
    [1, 1],
    [2, 2]
];

const result = mulMat(m1, m2);

if (result) {
    console.log("Multiplication of given two matrices is:");
    for (const row of result) {
        console.log(row.join(" "));
    }
}

````




**Output**
```
Multiplication of given two matrices is:
3    3
6    6
```

****Time complexity:****
O(R1 \\* C2 \\* R2) for given matrices mat1[R1][C1] and mat2[R2][C2]



****Auxiliary space:****
O(R1 \\* C2)


****Multiplication of Rectangular Matrices using Pointers in C/C++:****
-----------------------------------------------------------------------


To solve the problem follow the below idea:


> We use pointers in C/C++ to multiply matrices

****Prerequisite:****

[How to pass a 2D array as a parameter in C?](https://www.geeksforgeeks.org/pass-2d-array-parameter-c/)


Below is the implementation of the above approach:


C

````
#include <stdio.h>
#include <stdlib.h>

#define R1 2 // number of rows in Matrix-1
#define C1 2 // number of columns in Matrix-1
#define R2 2 // number of rows in Matrix-2
#define C2 2 // number of columns in Matrix-2

void mulMat(int (*m1)[C1], int (*m2)[C2], int (*rslt)[C2]) {
    if (C1 != R2) {
        printf("Invalid Input");
        return;
    }

    for (int i = 0; i < R1; i++) {
        for (int j = 0; j < C2; j++) {
            rslt[i][j] = 0; // Initialize result matrix element

            for (int k = 0; k < C1; k++) { // Use C1 for multiplication
                rslt[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
}

int main() {
    int m1[R1][C1] = { { 1, 1 },
                       { 2, 2 } };

    int m2[R2][C2] = { { 1, 1 },
                       { 2, 2 } };

    int rslt[R1][C2]; // Result matrix

    // Function call to multiply matrices
    mulMat(m1, m2, rslt);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R1; i++) {
        for (int j = 0; j < C2; j++) {
            printf("%d\\t", rslt[i][j]);
        }
        printf("\\n");
    }

    return 0;
}

````




**Output**
```
3 3
6 6
```

  ', '', 'Program to multiply two matrices', 6, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('40524f43-e22b-4dcf-9a51-965bd4affe1e', e'Given a

****sorted****
matrix

****mat[][]****
of size

****nxm****
and an


element

****x****
, the task is to find if x is

****present****
in the matrix or not. Matrix is

****sorted****
in a way such that all elements in a

****row are sorted in increasing order****
and for row i, where 1 <= i <= n-1, the

****first element****
of

****row i****
is

****greater than or equal****
to the

****last element****
of

****row i-1.****


****Examples:****

> ****Input:****
> x = 14, mat[][] = [[ 1, 5, 9],
>
>
>
> [14, 20, 21],
>
>
>
> [30, 34, 43]]
>
>
>
> ****Output:****
> true
>
>
> ****Input:****
> x = 42, mat[][] = [[ 1, 5, 9, 11],
>
>
>
> [14, 20, 21, 26],
>
>
>
> [30, 34, 43, 50]]
>
>
>
> ****Output:****
> false

Table of Content

* [[Naive Approach] Comparing with all elements – O(n\\*m) Time and O(1) Space](#naive-solution-onm-time-and-o1-space)
* [[Better Approach] Using Binary Search Twice – O(logn + logm) Time and O(1) Space](#using-binary-search-two-times-olog-n-log-m-time-and-o1-space)
* [[Expected Approach] Using Binary Search Once – O(log(n\\*m)) and O(1) Space](#using-one-binary-search-olognm-and-o1-space)
### ****[Naive Approach] Comparing with all elements – O(n\\*m) Time and O(1) Space****


In this approach, we will iterate through the entire

****matrix mat[][]****
and compare

****each element****
with

****x****
. If an element matches the x, we will

****return true****
. Otherwise, at the end of the traversal, we will

****return false.****
Please refer to

[Searching Algorithms for 2D Arrays (Matrix)](https://www.geeksforgeeks.org/searching-algorithms-for-a-2d-arrays-matrix/)
to know more about the implementation.


### ****[Better Approach] Using Binary Search Twice –**** O(logn + logm) Time and O(1) Space


First, we locate the row where the

****target x****
might be by using

****binary search****
, and then we apply binary search again within that row.



> To find the correct row, we perform
>
> ****binary search****
> on the
>
> ****first****
> elements of the middle row.
>
>
>
> Start with l
>
> ****ow = 0****
> and
>
> ****high = n – 1.****
>
> 1. If
>
>    ****x is smaller****
>    than the
>
>    ****first element****
>    of the middle row
>
>    ****(a[mid][0]),****
>    then x will be smaller than all elements in rows >= mid, so update
>
>    ****high = mid – 1.****
> 2. If
>
>    ****x is greater****
>    than the
>
>    ****first element****
>    of the middle row
>
>    ****(a[mid][0])****
>    , then x will be greater than all elements in rows < mid, so store the current mid row and update
>
>    ****low = mid + 1****
>    .
>
>
> Once we have found the
>
> ****correct row,****
> we can apply
>
> ****binary search****
> within that row to search for the
>
> ****target****
> element
>
> ****x****
> .

C++

````
// C++ program to search in the sorted matrix using
// Binary Search two times

#include <iostream>
#include <vector>
using namespace std;

// Function to binary search for x in arr[]
bool search(vector<int> &arr, int x) {
    int lo = 0, hi = arr.size() - 1;

    while (lo <= hi) {
        int mid = (lo + hi) / 2;

        if (x == arr[mid])
            return true;
        if (x < arr[mid])
            hi = mid - 1;
        else
            lo = mid + 1;
    }
    return false;
}

bool searchMatrix(vector<vector<int>> &mat, int x) {
    int n = mat.size(), m = mat[0].size();
    int lo = 0, hi = n - 1;
    int row = -1;

    while (lo <= hi) {
        int mid = (lo + hi) / 2;

        // If the first element of mid row is equal to x,
        // return true
        if (x == mat[mid][0])
            return true;

        // If x is greater than first element of mid row,
        // store the mid row and search in lower half
        if (x > mat[mid][0]) {
            row = mid;
            lo = mid + 1;
        }

        // If x is smaller than first element of mid row,
        // search in upper half
        else
            hi = mid - 1;
    }

    // If x is smaller than all elements of mat[][]
    if (row == -1)
        return false;

    return search(mat[row], x);
}

int main() {
    vector<vector<int>> mat = {{1, 5, 9}, {14, 20, 21}, {30, 34, 43}};
    int x = 14;

    if (searchMatrix(mat, x))
        cout << "true";
    else
        cout << "false";

    return 0;
}

````

Java

````
// Java program to search in the sorted matrix using
// Binary Search two times

class GfG {

    // Function to binary search for x in arr[]
    static boolean search(int[] arr, int x) {
        int lo = 0, hi = arr.length - 1;

        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            if (x == arr[mid])
                return true;
            if (x < arr[mid])
                hi = mid - 1;
            else
                lo = mid + 1;
        }
        return false;
    }

    static boolean searchMatrix(int[][] mat, int x) {
        int n = mat.length, m = mat[0].length;
        int lo = 0, hi = n - 1;
        int row = -1;

        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            // If the first element of mid row is equal to x,
            // return true
            if (x == mat[mid][0])
                return true;

            // If x is greater than first element of mid row,
            // store the mid row and search in lower half
            if (x > mat[mid][0]) {
                row = mid;
                lo = mid + 1;
            }

            // If x is smaller than first element of mid row,
            // search in upper half
            else
                hi = mid - 1;
        }

        // If x is smaller than all elements of mat[][]
        if (row == -1)
            return false;

        return search(mat[row], x);
    }

    public static void main(String[] args) {
        int[][] mat = {
            {1, 5, 9},
            {14, 20, 21},
            {30, 34, 43}
        };
        int x = 14;

        if (searchMatrix(mat, x))
            System.out.println("true");
        else
            System.out.println("false");
    }
}

````

Python

````
# Python program to search in the sorted matrix using
# Binary Search two times

# Function to binary search for x in arr[]
def search(arr, x):
    lo = 0
    hi = len(arr) - 1

    while lo <= hi:
        mid = (lo + hi) // 2

        if x == arr[mid]:
            return True
        if x < arr[mid]:
            hi = mid - 1
        else:
            lo = mid + 1
    return False

def searchMatrix(mat, x):
    n = len(mat)
    m = len(mat[0])
    lo = 0
    hi = n - 1
    row = -1

    while lo <= hi:
        mid = (lo + hi) // 2

        # If the first element of mid row is equal to x,
        # return true
        if x == mat[mid][0]:
            return True

        # If x is greater than first element of mid row,
        # store the mid row and search in lower half
        if x > mat[mid][0]:
            row = mid
            lo = mid + 1

        # If x is smaller than first element of mid row,
        # search in upper half
        else:
            hi = mid - 1

    # If x is smaller than all elements of mat[][]
    if row == -1:
        return False

    return search(mat[row], x)

if __name__ == "__main__":
    mat = [[1, 5, 9], [14, 20, 21], [30, 34, 43]]
    x = 14

    if searchMatrix(mat, x):
        print("true")
    else:
        print("false")

````

C#

````
// C# program to search in the sorted matrix using
// Binary Search two times

using System;

class GfG {

    // Function to binary search for x in arr[]
    static bool Search(int[] arr, int x) {
        int lo = 0, hi = arr.Length - 1;

        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            if (x == arr[mid])
                return true;
            if (x < arr[mid])
                hi = mid - 1;
            else
                lo = mid + 1;
        }
        return false;
    }

    static bool SearchMatrix(int[][] mat, int x) {
        int n = mat.Length, m = mat[0].Length;
        int lo = 0, hi = n - 1;
        int row = -1;

        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            // If the first element of mid row is equal to x,
            // return true
            if (x == mat[mid][0])
                return true;

            // If x is greater than first element of mid row,
            // store the mid row and search in lower half
            if (x > mat[mid][0]) {
                row = mid;
                lo = mid + 1;
            }

            // If x is smaller than first element of mid row,
            // search in upper half
            else
                hi = mid - 1;
        }

        // If x is smaller than all elements of mat[][]
        if (row == -1)
            return false;

        return Search(mat[row], x);
    }

    static void Main(string[] args) {
        int[][] mat = new int[][] {
            new int[] {1, 5, 9},
            new int[] {14, 20, 21},
            new int[] {30, 34, 43}
        };
        int x = 14;

        if (SearchMatrix(mat, x))
            Console.WriteLine("true");
        else
            Console.WriteLine("false");
    }
}

````

JavaScript

````
// JavaScript program to search in the sorted matrix using
// Binary Search two times

// Function to binary search for x in arr[]
function search(arr, x) {
    let lo = 0, hi = arr.length - 1;

    while (lo <= hi) {
        let mid = Math.floor((lo + hi) / 2);

        if (x === arr[mid])
            return true;
        if (x < arr[mid])
            hi = mid - 1;
        else
            lo = mid + 1;
    }
    return false;
}

function searchMatrix(mat, x) {
    let n = mat.length, m = mat[0].length;
    let lo = 0, hi = n - 1;
    let row = -1;

    while (lo <= hi) {
        let mid = Math.floor((lo + hi) / 2);

        // If the first element of mid row is equal to x,
        // return true
        if (x === mat[mid][0])
            return true;

        // If x is greater than first element of mid row,
        // store the mid row and search in lower half
        if (x > mat[mid][0]) {
            row = mid;
            lo = mid + 1;
        }

        // If x is smaller than first element of mid row,
        // search in upper half
        else
            hi = mid - 1;
    }

    // If x is smaller than all elements of mat[][]
    if (row === -1)
        return false;

    return search(mat[row], x);
}

// Driver Code
const mat = [
    [1, 5, 9],
    [14, 20, 21],
    [30, 34, 43]
];
const x = 14;

if (searchMatrix(mat, x))
    console.log("true");
else
    console.log("false");

````




**Output**
```
true
```
### ****[Expected Approach] Using Binary Search Once –**** O(log(n\\*m)) and O(1) Space

> The idea is to
>
> ****consider the given matrix as 1D array****
> and
>
> ****apply****
> only one
>
> ****binary search.****
> For example, for a matrix of size
>
> ****n x m a****
> nd we can consider it as a
>
> ****1D array****
> of size n\\*m
>
> ****,****
> then the
>
> ****first index****
> would be
>
> ****0****
> and
>
> ****last index****
> would
>
> ****n\\*m-1.****
> So
>
> ****,****
> we need to do binary search from low = 0 to high = (n\\*m-1)
>
> ****.****
>
> ****How to find the element in 2D matrix corresponding to index = mid?****
>
>
> Since each row of mat[][] will have
>
> ****m****
> elements, so we can find the row of the element as
>
> ****(mid / m)****
> and the column of the element as
>
> ****(mid % m)****
> . Then, we can compare
>
> ****x****
> with
>
> ****arr[mid/m][mid%m]****
> for each mid and complete our binary search.












C++

````
// C++ program to search in the sorted matrix using
// binary search

#include <iostream>
#include <vector>
using namespace std;

bool searchMatrix(vector<vector<int>>& mat, int x) {
    int n = mat.size(), m = mat[0].size();

    int lo = 0, hi = n * m - 1;
    while (lo <= hi) {
        int mid = (lo + hi) / 2;

        // Find row and column of element at mid index
        int row = mid / m;
        int col = mid % m;

        // If x is found, return true
        if (mat[row][col] == x)
            return true;

        // If x is greater than mat[row][col], search in
        // right half
        if (mat[row][col] < x)
            lo = mid + 1;

        // If x is less than mat[row][col], search in
        // left half
        else
            hi = mid - 1;
    }
    return false;
}

int main() {
    vector<vector<int>> mat = {{1, 5, 9}, {14, 20, 21}, {30, 34, 43}};
    int x = 14;

    if (searchMatrix(mat, x))
        cout << "true";
    else
        cout << "false";

    return 0;
}

````

Java

````
// Java program to search in the sorted matrix using
// binary search

class GfG {

    // Function to search for x in the matrix using binary search
    static boolean searchMatrix(int[][] mat, int x) {
        int n = mat.length, m = mat[0].length;

        int lo = 0, hi = n * m - 1;
        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            // Find row and column of element at mid index
            int row = mid / m;
            int col = mid % m;

            // If x is found, return true
            if (mat[row][col] == x)
                return true;

            // If x is greater than mat[row][col], search in
            // right half
            if (mat[row][col] < x)
                lo = mid + 1;

            // If x is less than mat[row][col], search in
            // left half
            else
                hi = mid - 1;
        }
        return false;
    }

    public static void main(String[] args) {
        int[][] mat = {{1, 5, 9}, {14, 20, 21}, {30, 34, 43}};
        int x = 14;

        if (searchMatrix(mat, x))
            System.out.println("true");
        else
            System.out.println("false");
    }
}

````

Python

````
# Python program to search in the sorted matrix using
# binary search

# Function to search for x in the matrix using binary search
def searchMatrix(mat, x):
    n = len(mat)
    m = len(mat[0])

    lo, hi = 0, n * m - 1
    while lo <= hi:
        mid = (lo + hi) // 2

        # Find row and column of element at mid index
        row = mid // m
        col = mid % m

        # If x is found, return true
        if mat[row][col] == x:
            return True

        # If x is greater than mat[row][col], search in
        # right half
        if mat[row][col] < x:
            lo = mid + 1

        # If x is less than mat[row][col], search in
        # left half
        else:
            hi = mid - 1

    return False

if __name__ == "__main__":
    mat = [[1, 5, 9], [14, 20, 21], [30, 34, 43]]
    x = 14

    if searchMatrix(mat, x):
        print("true")
    else:
        print("false")

````

C#

````
// C# program to search in the sorted matrix using
// binary search

using System;

class GfG {

    // Function to search for x in the matrix using binary search
    static bool searchMatrix(int[,] mat, int x) {
        int n = mat.GetLength(0), m = mat.GetLength(1);

        int lo = 0, hi = n * m - 1;
        while (lo <= hi) {
            int mid = (lo + hi) / 2;

            // Find row and column of element at mid index
            int row = mid / m;
            int col = mid % m;

            // If x is found, return true
            if (mat[row, col] == x)
                return true;

            // If x is greater than mat[row, col], search in
            // right half
            if (mat[row, col] < x)
                lo = mid + 1;

            // If x is less than mat[row, col], search in
            // left half
            else
                hi = mid - 1;
        }
        return false;
    }

    static void Main() {
        int[,] mat = { { 1, 5, 9 }, { 14, 20, 21 }, { 30, 34, 43 } };
        int x = 14;

        if (searchMatrix(mat, x))
            Console.WriteLine("true");
        else
            Console.WriteLine("false");
    }
}

````

JavaScript

````
// JavaScript program to search in the sorted matrix using
// binary search

// Function to search for x in the matrix using binary search
function searchMatrix(mat, x) {
    let n = mat.length, m = mat[0].length;

    let lo = 0, hi = n * m - 1;
    while (lo <= hi) {
        let mid = Math.floor((lo + hi) / 2);

        // Find row and column of element at mid index
        let row = Math.floor(mid / m);
        let col = mid % m;

        // If x is found, return true
        if (mat[row][col] === x)
            return true;

        // If x is greater than mat[row][col], search in
        // right half
        if (mat[row][col] < x)
            lo = mid + 1;

        // If x is less than mat[row][col], search in
        // left half
        else
            hi = mid - 1;
    }
    return false;
}

// Driver Code
let mat = [[1, 5, 9], [14, 20, 21], [30, 34, 43]];
let x = 14;

if (searchMatrix(mat, x))
    console.log("true");
else
    console.log("false");

````




**Output**
```
true
```', '', 'Search element in a sorted matrix', 7, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('9d3e7774-66e8-4f47-8589-0f78ccd0f6ea', e'Given a

[matrix](https://www.geeksforgeeks.org/matrix/)

****mat[][]****
of size

****n x m****
, the task is to traverse this matrix

[using recursion](https://www.geeksforgeeks.org/recursion/)
.



****Examples:****


> ****Input:****
> mat[][] = [[1, 2, 3],
>
>
>
> [4, 5, 6],
>
>
>
> [7, 8, 9]]
>
>
>
> ****Output:****
> 1 2 3 4 5 6 7 8 9
>
>
>
>
>
> ****Input:****
> mat[][] = [[11, 12, 13],
>
>
>
> [14, 15, 16],
>
>
>
> [17, 18, 19]]
>
>
>
> ****Output:****
> 11 12 13 14 15 16 17 18 19

****Approach:****


* Check If the current position is in the bottom-right corner of the matrix
  + Print the value at that position
  + End the recursion
* Print the value at the current position
* Check If the end of the current row has not been reached
  + Move right
* Check If the end of the current column has been reached
  + Move down to the next row


Below is the implementation of the above approach:


C++

````
//C++ program to traverse the matrix using recursion
#include <iostream>
#include <vector>

using namespace std;

// Recursive function to traverse the matrix
void traverse(vector<vector<int>>& mat, int i, int j) {

    // If the current position is the bottom-right
      // corner of the matrix
    if (i == mat.size() - 1 && j == mat[0].size() - 1) {
        cout << mat[i][j] << endl;
        return;
    }

    // Print the value at the current position
    cout << mat[i][j] << " ";

    // If the end of the current row has
      // not been reached
    if (j < mat[0].size() - 1) {

        // Move right
        traverse(mat, i, j + 1);
    }

    // If the end of the current column has been reached
    else if (i < mat.size() - 1) {

        // Move down to the next row
        traverse(mat, i + 1, 0);
    }
}

int main() {
    vector<vector<int>> mat = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
    traverse(mat, 0, 0);
    return 0;
}

````

Java

````
//Java program to traverse the matrix using recursion
import java.util.Arrays;

class GfG {

    // Recursive function to traverse the matrix
    static void traverse(int[][] mat, int i, int j) {

        // If the current position is the bottom-right
        // corner of the matrix
        if (i == mat.length - 1 && j == mat[0].length - 1) {
            System.out.println(mat[i][j]);
            return;
        }

        // Print the value at the current position
        System.out.print(mat[i][j] + " ");

        // If the end of the current row has not
          // been reached
        if (j < mat[0].length - 1) {

            // Move right
            traverse(mat, i, j + 1);
        }

        // If the end of the current column has been reached
        else if (i < mat.length - 1) {

            // Move down to the next row
            traverse(mat, i + 1, 0);
        }
    }

    public static void main(String[] args) {
        int[][] mat = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
        traverse(mat, 0, 0);
    }
}

````

Python

````
#Python program to traverse the matrix using recursion
def traverse(mat, i, j):

    # If the current position is the bottom-
    # right corner of the matrix
    if i == len(mat) - 1 and j == len(mat[0]) - 1:
        print(mat[i][j])
        return

    # Print the value at the current position
    print(mat[i][j], end=" ")

    # If the end of the current row has not
    # been reached
    if j < len(mat[0]) - 1:

        # Move right
        traverse(mat, i, j + 1)

    # If the end of the current column
    # has been reached
    elif i < len(mat) - 1:

        # Move down to the next row
        traverse(mat, i + 1, 0)

mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
traverse(mat, 0, 0)

````

C#

````
//C# program to traverse the matrix using recursion
using System;

class GfG {

    // Recursive function to traverse the matrix
    static void Traverse(int[,] mat, int i, int j) {
        int rows = mat.GetLength(0);
        int cols = mat.GetLength(1);

        // If the current position is the bottom-right
          // corner of the matrix
        if (i == rows - 1 && j == cols - 1) {
            Console.WriteLine(mat[i, j]);
            return;
        }

        // Print the value at the current position
        Console.Write(mat[i, j] + " ");

        // If the end of the current row has
          // not been reached
        if (j < cols - 1) {

            // Move right
            Traverse(mat, i, j + 1);
        }

        // If the end of the current column
          // has been reached
        else if (i < rows - 1) {

            // Move down to the next row
            Traverse(mat, i + 1, 0);
        }
    }

    static void Main() {

        int[,] mat = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
        Traverse(mat, 0, 0);
    }
}

````

JavaScript

````
//Javascript program to traverse the matrix using recursion
function traverse(mat, i, j) {
    const rows = mat.length;
    const cols = mat[0].length;

    // If the current position is the bottom-right
    // corner of the matrix
    if (i === rows - 1 && j === cols - 1) {
        console.log(mat[i][j]);
        return;
    }

    // Print the value at the current position
    console.log(mat[i][j] + " ");

    // If the end of the current row has not been reached
    if (j < cols - 1) {

        // Move right
        traverse(mat, i, j + 1);
    }
    // If the end of the current column has been reached
    else if (i < rows - 1) {

        // Move down to the next row
        traverse(mat, i + 1, 0);
    }
}

const mat = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
traverse(mat, 0, 0);

````




**Output**
```
1 2 3 4 5 6 7 8 9

```

****Time Complexity:****
O(N \\* M)



****Auxiliary Space:****
O(M), because of recursive calling

', '', 'Traverse a given Matrix using Recursion', 8, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('e9c94003-0430-44e0-ac55-fda3101baf00', e'Given two integers ****a**** and ****b**** (b != 0), the task is to return the fraction ****a/b**** in string format. If the fractional part is repeating, enclose the repeating part in parentheses.****Examples:****


> ****Input****
> : a = 1, b = 2
>
>
>
> ****Output****
> : “0.5”
>
>
>
> ****Explanation:****
> 1/2 = 0.5 with no repeating part.
>
>
>
>
>
> ****Input****
> : a = 50, b = 22
>
>
>
> ****Output****
> : “2.(27)”
>
>
>
> ****Explanation:****
> 50/22 = 2.27272727… Since fractional part (27) is repeating, it is enclosed in parentheses.

****Approach****
:


> The idea is to first calculate the integral quotient (absolute part before decimal point) and then calculate the fractional part. To check if the fractional part is repeating, insert the remainder (a % b) in a
>
> [hash map](https://www.geeksforgeeks.org/hashing-data-structure/)
> with key as remainder and value as the index position at which this remainder occurs. If at any point of time, the remainder becomes zero, then there doesn’t exist a repeating fraction otherwise if the remainder is already found in the map, then there exists a repeating fraction.

C++

````
// C++ Program to convert fraction to string

#include <iostream>
#include <unordered_map>
using namespace std;

string calculateFraction(int a, int b) {

    // If the numerator is zero, answer is 0
    if (a == 0)
        return "0";

    // If exactly one of the numerator or denominator
    // is negative, then result will be negative
    string res = (a < 0) ^ (b < 0) ? "-" : "";

    a = abs(a);
    b = abs(b);

    // Calculate and Append the part before decimal point
    res += to_string(a / b);

    int rem = a % b;

    // If completely divisible, return res
    if (rem == 0)
        return res;

    res.append(".");
    unordered_map<int, int> mp;

    while (rem > 0) {

        // If this remainder is already seen,
        // then there exists a repeating fraction.
        if (mp.find(rem) != mp.end()) {

            res.insert(mp[rem], "(");
            res.append(")");
            break;
        }

        // If the remainder is seen for the first time,
        // store its index
        mp[rem] = res.size();

        rem = rem * 10;

        // Calculate quotient, append it to result and
        // calculate next remainder
        res += to_string(rem / b);
        rem = rem % b;
    }

    return res;
}

int main() {
    int a = 50, b = 22;
    cout << calculateFraction(a, b) << endl;
    return 0;
}

````

Java

````
// Java Program to convert fraction to string

import java.util.HashMap;

class GfG {
    static String calculateFraction(int a, int b) {

        // If the numerator is zero, answer is "0"
        if (a == 0)
            return "0";

        // If exactly one of the numerator or denominator
        // is negative, then result will be negative
        String res = (a < 0) ^ (b < 0) ? "-" : "";

        a = Math.abs(a);
        b = Math.abs(b);

        // Calculate and Append the part before decimal point
        res += Integer.toString(a / b);

        int rem = a % b;

        // If completely divisible, return res
        if (rem == 0)
            return res;

        res += ".";
        HashMap<Integer, Integer> mp = new HashMap<>();

        while (rem > 0) {

            // If this remainder is already seen,
            // then there exists a repeating fraction.
            if (mp.containsKey(rem)) {
                res = res.substring(0, mp.get(rem)) + "(" + res.substring(mp.get(rem)) + ")";
                break;
            }

            // If the remainder is seen for the first time,
            // store its index
            mp.put(rem, res.length());

            rem = rem * 10;

            // Calculate quotient, append it to result and
            // calculate next remainder
            res += Integer.toString(rem / b);
            rem = rem % b;
        }

        return res;
    }

    public static void main(String[] args) {
        int a = 50, b = 22;
        System.out.println(calculateFraction(a, b));
    }
}

````

Python

````
# Python Program to convert fraction to string

def calculateFraction(a, b):

    # If the numerator is zero, answer is "0"
    if a == 0:
        return "0"

    # If exactly one of the numerator or denominator
    # is negative, then result will be negative
    res = "-" if (a < 0) ^ (b < 0) else ""

    a = abs(a)
    b = abs(b)

    # Calculate and Append the part before decimal point
    res += str(a // b)

    rem = a % b

    # If completely divisible, return res
    if rem == 0:
        return res

    res += "."
    mp = {}

    while rem > 0:

        # If this remainder is already seen,
        # then there exists a repeating fraction.
        if rem in mp:
            res = res[:mp[rem]] + "(" + res[mp[rem]:] + ")"
            break

        # If the remainder is seen for the first time,
        # store its index
        mp[rem] = len(res)

        rem = rem * 10

        # Calculate quotient, append it to result and
        # calculate next remainder
        res += str(rem // b)
        rem = rem % b

    return res

if __name__ == "__main__":
    a = 50
    b = 22
    print(calculateFraction(a, b))

````

C#

````
// C# Program to convert fraction to string

using System;
using System.Collections.Generic;

class GfG {
    static string calculateFraction(int a, int b) {

        // If the numerator is zero, answer is "0"
        if (a == 0)
            return "0";

        // If exactly one of the numerator or denominator
        // is negative, then result will be negative
        string res = (a < 0) ^ (b < 0) ? "-" : "";

        a = Math.Abs(a);
        b = Math.Abs(b);

        // Calculate and Append the part before decimal point
        res += a / b;

        int rem = a % b;

        // If completely divisible, return res
        if (rem == 0)
            return res;

        res += ".";
        Dictionary<int, int> mp = new Dictionary<int, int>();

        while (rem > 0) {

            // If this remainder is already seen,
            // then there exists a repeating fraction.
            if (mp.ContainsKey(rem)) {
                res = res.Insert(mp[rem], "(");
                res += ")";
                break;
            }

            // If the remainder is seen for the first time,
            // store its index
            mp[rem] = res.Length;

            rem = rem * 10;

            // Calculate quotient, append it to result and
            // calculate next remainder
            res += rem / b;
            rem = rem % b;
        }

        return res;
    }

    static void Main() {
        int a = 50, b = 22;
        Console.WriteLine(calculateFraction(a, b));
    }
}

````

JavaScript

````
// JavaScript Program to convert fraction to string

function calculateFraction(a, b) {

    // If the numerator is zero, answer is "0"
    if (a === 0) {
        return "0";
    }

    // If exactly one of the numerator or denominator
    // is negative, then result will be negative
    let res = (a < 0) ^ (b < 0) ? "-" : "";

    a = Math.abs(a);
    b = Math.abs(b);

    // Calculate and Append the part before decimal point
    res += Math.floor(a / b);

    let rem = a % b;

    // If completely divisible, return res
    if (rem === 0) {
        return res;
    }

    res += ".";
    let mp = new Map();

    while (rem > 0) {
        // If this remainder is already seen,
        // then there exists a repeating fraction.
        if (mp.has(rem)) {
            let repeatIndex = mp.get(rem);
            res = res.substring(0, repeatIndex) + "("
                        + res.substring(repeatIndex) + ")";
            break;
        }

        // If the remainder is seen for the first time,
        // store its index
        mp.set(rem, res.length);

        rem = rem * 10;

        // Calculate quotient, append it to result and
        // calculate next remainder
        res += Math.floor(rem / b);
        rem = rem % b;
    }

    return res;
}

// Driver Code
let a = 50, b = 22;
console.log(calculateFraction(a, b));

````
**Output**
```
2.(27)

```

****Time Complexity****
: O(max(log10(a), log10(b))), we can make any number of recurring digits in the fraction. For example:


* 2/9 = 0.22222..
* 21/99 = 0.212121…
* 213/999 = 0.213213…
* 2134/9999 = 0.21342134…
* 21345/99999 = 0.2134521345… and so on.

****Auxiliary Space****
: O(max(log10(a), log10(b))), to store the result.

', '', 'Fraction to Recurring Decimal', 1, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('1b6d1c4b-b27f-48f6-a074-6891bfbd3ab6', e'Given Principal

****p****
, Rate

****r****
and Time

****t,****
the task is to calculate Simple Interest.


****Examples :****

> ****Input****
> : p = 10000, r = 5, t = 5
>
>
>
> ****Output****
> :2500
>
>
>
> ****Explanation****
> : We need to find simple interest on Rs. 10,000 at the rate of 5% for 5 units of time.
>
>
> ****Input****
> : p = 3000, r = 7, t = 1
>
>
>
> ****Output****
> :210


The basic idea is to calculate by applying the formula

****SI = (p x t x r)/100****

C++

````
// CPP program to find simple interest for
// given principal amount, time and rate of interest
#include<iostream>
using namespace std;

float simpleInterest(float p, float t, float r){
    /* Calculate simple interest  */
    float ans = (p * t * r) / 100;
    return ans;
}

int main() {

    float p = 1, r = 1, t = 1;
    cout <<simpleInterest(p,r,t);

    return 0;
}

````

C

````
#include <stdio.h>

float simpleInterest(float p, float t, float r) {
    /* Calculate simple interest  */
    float ans = (p * t * r) / 100;
    return ans;
}

int main() {
    float p = 1, r = 1, t = 1;
    printf("%f", simpleInterest(p, r, t));
    return 0;
}

````

Java

````
class GfG {
    static float simpleInterest(float p, float t, float r) {
        /* Calculate simple interest  */
        return (p * t * r) / 100;
    }

    public static void main(String[] args) {
        float p = 1, r = 1, t = 1;
        System.out.println(simpleInterest(p, r, t));
    }
}

````

Python

````
def simpleInterest(p, t, r):
    /* Calculate simple interest  */
    return (p * t * r) / 100

if __name__ == "__main__":
  p = 1
  r = 1
  t = 1
  print(simpleInterest(p, r, t))

````

C#

````
using System;

class GfG {
    public static float SimpleInterest(float p, float t, float r) {
        /* Calculate simple interest  */
        return (p * t * r) / 100;
    }

    static void Main() {
        float p = 1, r = 1, t = 1;
        Console.WriteLine(SimpleInterest(p, r, t));
    }
}

````

JavaScript

````
function simpleInterest(p, t, r) {
    /* Calculate simple interest  */
    return (p * t * r) / 100;
}

//driver code
let p = 1, r = 1, t = 1;
console.log(simpleInterest(p, r, t));

````




**Output**
```
0.01
```

****Time complexity****
: O(1)



****Auxiliary Space****
: O(1)
', '', 'Program to find simple interest', 14, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('2bbe24be-6a3c-49ad-bb76-363d65e58895', e'Given a number

****n****
, check whether it is even or odd. Return

****true****
for even and

****false****
for odd.


****Examples:****


> ****Input****
> : 2
>
>
>
> ****Output****
> : true
>
>
> ****Input****
> : 5
>
>
>
> ****Output****
> : false

Table of Content

* [By Finding the Remainder – O(1) Time and O(1) Space](#by-finding-the-reminder-o1-time-and-o1-space)
* [Using Bitwise AND Operator – O(1) Time and O(1) Space](#using-bitwaise-operators-o1-time-and-o1-space)
* [Using Bitwise Shift Operators – O(1) Time and O(1) Space](#using-bitwaise-shift-operators-o1-time-and-o1-space)
### By Finding the Remainder – O(1) Time and O(1) Space


We can check the remainder when divided by 2. If the remainder is 0, the number is even; otherwise, it is odd


C++

````
// A simple C++ program to check for even or odd
#include <iostream>
using namespace std;

bool isEven(int n) {
  return (n % 2 == 0);
}

int main() {
    int n = 101;
    if(isEven(n))
         cout << "true";
      else
        cout << "false";

    return 0;
}

````

Java

````
// Java program  to check for even or odd
class GfG {

    public static boolean isEven(int n)  {
        return (n % 2 == 0);
    }

    public static void main(String[] args) {
        int n = 101;
        if (isEven(n) == true)
            System.out.print("true");
        else
            System.out.print("false");
    }
}

````

Python

````
# A simple Python3 code check for even or odd

def isEven(n):
    return (n % 2 == 0)


if __name__ == "__main__":
  n = 101
  if is_even(n):
      print("true")
  else:
      print("false")

````

C#

````
// C# program toif __name__ == "__main__":
using System;
class GfG {
    public static bool isEven(int n) {
        return (n % 2 == 0);
    }

    public static void Main() {
        int n = 101;
        if (isEven(n) == true)
            Console.WriteLine("true");
        else
            Console.WriteLine("false");
    }
}

````

JavaScript

````
// A simple Javascript program to
// check for even or odd

function isEven(n) {
    return (n % 2 == 0);
}

// Driver code

    let n = 101;
    if (isEven(n)) {
        console.log("true");
    } else {
        console.log("false");
    }

````




**Output**
```
false
```
### Using Bitwise AND Operator – O(1) Time and O(1) Space

> The last bit of all odd numbers is always 1, while for even numbers it’s 0. So, when performing bitwise AND operation with 1, odd numbers give 1, and even numbers give 0.
>
>
> Ex: 5 (101) -> 101
>
>
>
> & 001
>
>
>
> —-
>
>
>
> 001 , so this we can say it is an odd number.

C++

````
// A simple C++ program to check for even or odd
#include <iostream>
using namespace std;

bool isEven(int n) {
        if ((n & 1) == 0)
            return true;
        else
            return false;
}

int main() {
    int n = 101;
     if (isEven(n) == true)
        cout<<"true";
       else
        cout<<"false";

    return 0;
}

````

C

````
#include <math.h>
#include <stdio.h>

bool isEven(int n) {
         if ((n & 1) == 0)
            return true;
        else
            return false;
}

int main() {
    int n = 101;
    if (isEven) {
        printf("true");
    }
    else {
        printf("false");
    }
    return 0;
}

````

Java

````
// Java program to
// check for even or odd
class GfG {
    public static boolean isEven(int n){
        if ((n & 1) == 0)
            return true;
        else
            return false;
    }

    public static void main(String[] args) {
        int n = 101;
        if (isEven(n) == true)
            System.out.print("true");
        else
            System.out.print("false");
    }
}

````

Python

````
# A Python3 code program
# to check for even or odd
def isEven(n):

    # n&1 is 1, then odd, else even
    if (n & 1) == 0:
        return True
    else:
        return False

if __name__ == "__main__":
  n = 101
  if isEven(n):
      print("true")
  else:
      print("false")

````

C#

````
// C# program  to check for even or odd
using System;

class GfG {
    public static bool isEven(int n)   {
        if ((n & 1) == 0)
            return true;
        else
            return false;
    }

    public static void Main() {
        int n = 101;
        if (isEven(n) == true)
            Console.WriteLine("true");
        else
            Console.WriteLine("false");
    }
}

````

JavaScript

````
// A simple JavaScript program to
// check for even or odd

function isEven(n) {

 // n & 1 is 1, then odd, else even
 if ((n & 1) === 0) {
        return true;
    } else {
        return false;
    }
}

// Driver code
let n = 101;
if (isEven(n)) {
    console.log("true");
} else {
    console.log("false");
}

````




**Output**
```
false
```

****Time Complexity: O(1)****


****Auxiliary Space: O(1)****

### Using Bitwise Shift Operators – O(1) Time and O(1) Space

![](https://media.geeksforgeeks.org/wp-content/uploads/20221201114030/Group1.png)
C++

````
#include <bits/stdc++.h>
using namespace std;

bool isEven(int n) {
  if (n == (n >> 1) << 1) {
        return true;
    }
    else {
        return false;
    }
}

int main() {

  int n = 4;
  if (isEven(n) == true)
        cout<<"true";
   else
        cout<<"false";

    return 0;
}

````

Java

````
// Java program to
// check for even or odd
class GfG {
    public static boolean isEven(int n){
       if (n == (n >> 1) << 1)
            return true;
        else
            return false;
    }

    public static void main(String[] args) {
        int n = 4;
        if (isEven(n) == true)
            System.out.print("true");
        else
            System.out.print("false");
    }
}

````

Python

````
# A Python3 code program
# to check for even or odd
def isEven(n):

    if n == (n >> 1) << 1:
        return True
    else:
        return False

if __name__ == "__main__":
  n = 4
  if isEven(n):
      print("true")
  else:
      print("false")

````

C#

````
// C# program  to check for even or odd
using System;

class GfG {
    public static bool isEven(int n)   {
        if (n == (n >> 1) << 1)
            return true;
        else
            return false;
    }

    public static void Main() {
        int n = 4;
        if (isEven(n) == true)
            Console.WriteLine("true");
        else
            Console.WriteLine("false");
    }
}

````

JavaScript

````
// A simple JavaScript program to
// check for even or odd

function isEven(n) {

    if (n == (n >> 1) << 1)
       return true;
    else
       return false;
}

// Driver code
let n = 4;
if (isEven(n)) {
    console.log("true");
} else {
    console.log("false");
}

````




**Output**
```
true
```
', '', 'Check whether a given number is even or odd', 20, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('73a6da6a-6cb0-4600-8d3a-228da18c1cba', e'# Basic Operations on BST (additional)

## Deletion in Binary Search Tree
Given a ****BST****, the task is to delete a node in this ****BST****, which can be broken down into 3 scenarios:

### Case 1. Delete a Leaf Node in BST

![d1](https://media.geeksforgeeks.org/wp-content/uploads/20230726182925/d1.png)


### Case 2. Delete a Node with Single Child in BST

> Deleting a single child node is also simple in BST. ****Copy the child to the node and delete the node****. 

![file](https://media.geeksforgeeks.org/wp-content/uploads/20231004182120/file.png)


### Case 3. Delete a Node with Both Children in BST

> Deleting a node with both children is not so simple. Here we have to ****delete the node is such a way, that the resulting tree follows the properties of a BST.****  
> 
> The trick is to find the inorder successor of the node. Copy contents of the inorder successor to the node, and delete the inorder successor.

****Note:**** Inorder predecessor can also be used.

![d3](https://media.geeksforgeeks.org/wp-content/uploads/20231006112704/d3.png)


  
****Note:**** Inorder successor is needed only when the right child is not empty. In this particular case, the inorder successor can be obtained by finding the minimum value in the right child of the node.

### Recursive Implementation of Deletion operation in a BST:

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int key;
    Node* left;
    Node* right;
    Node(int k){
        key = k;
        left = right = nullptr;
    }
};

// Note that it is not a generic inorder
// successor function. It mainly works
// when right child is not empty which is 
// the case wwe need in BST delete
Node* getSuccessor(Node* curr){
    curr = curr->right;
    while (curr != nullptr && curr->left != nullptr)
        curr = curr->left;
    return curr;
}

// This function deletes a given key x from
// the give BST and returns modified root of
// the BST (if it is modified)
Node* delNode(Node* root, int x){

    // Base case
    if (root == nullptr)
        return root;

    // If key to be searched is in a subtree
    if (root->key > x)
        root->left = delNode(root->left, x);
    else if (root->key < x)
        root->right = delNode(root->right, x);

    // If root matches with the given key
    else {

        // Cases when root has 0 children
        // or only right child
        if (root->left == nullptr) {
            Node* temp = root->right;
            delete root;
            return temp;
        }

        // When root has only left child
        if (root->right == nullptr) {
            Node* temp = root->left;
            delete root;
            return temp;
        }

        // When both children are present
        Node* succ = getSuccessor(root);
        root->key = succ->key;
        root->right = delNode(root->right, succ->key);
    }
    return root;
}

// Utility function to do inorder
// traversal
void inorder(Node* root){
    if (root != nullptr) {
        inorder(root->left);
        cout << root->key << " ";
        inorder(root->right);
    }
}

int main(){
    Node* root = new Node(10);
    root->left = new Node(5);
    root->right = new Node(15);
    root->right->left = new Node(12);
    root->right->right = new Node(18);
    int x = 15;

    root = delNode(root, x);
    inorder(root);
    return 0;
}
```
```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

# Note that it is not a generic inorder successor 
# function. It mainly works when the right child
# is not empty, which is  the case we need in BST
# delete.
def get_successor(curr):
    curr = curr.right
    while curr is not None and curr.left is not None:
        curr = curr.left
    return curr

# This function deletes a given key x from the
# given BST and returns the modified root of the 
# BST (if it is modified).
def del_node(root, x):
  
    # Base case
    if root is None:
        return root

    # If key to be searched is in a subtree
    if root.key > x:
        root.left = del_node(root.left, x)
    elif root.key < x:
        root.right = del_node(root.right, x)
        
    else:
        # If root matches with the given key

        # Cases when root has 0 children or 
        # only right child
        if root.left is None:
            return root.right

        # When root has only left child
        if root.right is None:
            return root.left

        # When both children are present
        succ = get_successor(root)
        root.key = succ.key
        root.right = del_node(root.right, succ.key)
        
    return root

# Utility function to do inorder traversal
def inorder(root):
    if root is not None:
        inorder(root.left)
        print(root.key, end=" ")
        inorder(root.right)

# Driver code
if __name__ == "__main__":
    root = Node(10)
    root.left = Node(5)
    root.right = Node(15)
    root.right.left = Node(12)
    root.right.right = Node(18)
    x = 15

    root = del_node(root, x)
    inorder(root)
    print()
```
```javascript
class Node {
    constructor(key) {
        this.key = key;
        this.left = null;
        this.right = null;
    }
}

// Note that it is not a generic inorder successor
// function. It mainly works when the right child 
// is not empty, which is  the case we need in BST
// delete.
function getSuccessor(curr) {
    curr = curr.right;
    while (curr !== null && curr.left !== null) {
        curr = curr.left;
    }
    return curr;
}

// This function deletes a given key x from the
// given BST and returns the modified root of the
// BST (if it is modified).
function delNode(root, x) {
    // Base case
    if (root === null) {
        return root;
    }

    // If key to be searched is in a subtree
    if (root.key > x) {
        root.left = delNode(root.left, x);
    } else if (root.key < x) {
        root.right = delNode(root.right, x);
    } else {
        // If root matches with the given key

        // Cases when root has 0 children or 
        // only right child
        if (root.left === null) 
            return root.right;

        // When root has only left child
        if (root.right === null) 
            return root.left;

        // When both children are present
        let succ = getSuccessor(root);
        root.key = succ.key;
        root.right = delNode(root.right, succ.key);
    }
    return root;
}

// Utility function to do inorder traversal
function inorder(root) {
    if (root !== null) {
        inorder(root.left);
        console.log(root.key + " ");
        inorder(root.right);
    }
}

// Driver code
let root = new Node(10);
root.left = new Node(5);
root.right = new Node(15);
root.right.left = new Node(12);
root.right.right = new Node(18);
let x = 15;

root = delNode(root, x);
inorder(root);
console.log();
```

```output
5 10 12 18
```

****Time Complexity:**** O(h), where h is the height of the BST.   
****Auxiliary Space:**** O(h).

The above recursive solution does two traversals across height when both the children are not NULL. We can optimize the solution for this particular case. Please refer [Optimized Recursive Delete in BST](https://www.geeksforgeeks.org/optimized-recursive-delete-in-bst/) for details.

We can avoid extra O(h) space and recursion call overhead with iterative solution. The iterative solution has same time complexity but works more efficiently.

### Iterative Implementation of Deletion operation in a BST
The intuition behind deleting the inorder successor in Case 2 is that the inorder successor of a node with two children will always be greater than all elements in the left sub-tree of the node since it is the smallest node in the right sub-tree of the node and the inorder successor of the node will always be smaller than all other nodes in the right sub-tree of the node. 

This preserves the BST property of all nodes in the left sub-tree  of a given node are smaller than the given node and all nodes in the right sub-tree of the given node are greater than the given node. 

Below is the implementation of the above approach: 

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int key;
    Node* left;
    Node* right;
    Node(int k)
    {
        key = k;
        left = right = NULL;
    }
};

// Iterative Function to delete
// \'key\' from the BST.
Node* delIterative(Node* root, int key)
{
    Node* curr = root;
    Node* prev = NULL;

    // Check if the key is actually
    // present in the BST.
    // the variable prev points to
    // the parent of the key to be deleted.
    while (curr != NULL && curr->key != key) {
        prev = curr;
        if (key < curr->key)
            curr = curr->left;
        else
            curr = curr->right;
    }

    // Key not present
    if (curr == NULL) 
        return root;

    // Check if the node to be
    // deleted has atmost one child.
    if (curr->left == NULL || curr->right == NULL) {

        // newCurr will replace
        // the node to be deleted.
        Node* newCurr;

        // if the left child does not exist.
        if (curr->left == NULL)
            newCurr = curr->right;
        else
            newCurr = curr->left;

        // check if the node to
        // be deleted is the root.
        if (prev == NULL)
            return newCurr;

        // check if the node to be deleted
        // is prev\'s left or right child
        // and then replace this with newCurr
        if (curr == prev->left)
            prev->left = newCurr;
        else
            prev->right = newCurr;

        // free memory of the
        // node to be deleted.
        delete curr;
    }

    // node to be deleted has
    // two children.
    else {
        
        // Compute the inorder successor
        Node* p = NULL;
        Node* temp = curr->right;
        while (temp->left != NULL) {
            p = temp;
            temp = temp->left;
        }

        // check if the parent of the inorder
        // successor is the curr or not(i.e. curr=
        // the node which has the same data as
        // the given data by the user to be
        // deleted). if it isn\'t, then make the
        // the left child of its parent equal to
        // the inorder successor\'d right child.
        if (p != NULL)
            p->left = temp->right;

        // if the inorder successor was the
        // curr (i.e. curr = the node which has the
        // same data as the given data by the
        // user to be deleted), then make the
        // right child of the node to be
        // deleted equal to the right child of
        // the inorder successor.
        else
            curr->right = temp->right;

        curr->key = temp->key;
        
        delete temp;
    }
    return root;
}


// Utility function to do inorder
// traversal
void inorder(Node* root)
{
    if (root != NULL) {
        inorder(root->left);
        cout << root->key << " ";
        inorder(root->right);
    }
}

// Driver code
int main()
{
    Node* root = new Node(10);
    root->left = new Node(5);
    root->right = new Node(15);
    root->right->left = new Node(12);
    root->right->right = new Node(18);
    int x = 15;

    root = delIterative(root, x);
    inorder(root);
    return 0;
}
```
```java
class Node {
    int key;
    Node left, right;

    Node(int key) {
        this.key = key;
        this.left = this.right = null;
    }
}

class GfG {

    public static Node delIterative(Node root, int key) {
        Node curr = root;
        Node prev = null;

        // Check if the key is actually present in the BST.
        // The variable prev points to the parent of the key
        // to be deleted.
        while (curr != null && curr.key != key) {
            prev = curr;
            if (key < curr.key)
                curr = curr.left;
            else
                curr = curr.right;
        }

        // Key not present
        if (curr == null)
            return root;

        // Check if the node to be deleted has at most one child.
        if (curr.left == null || curr.right == null) {
            Node newCurr;

            // If the left child does not exist.
            if (curr.left == null)
                newCurr = curr.right;
            else
                newCurr = curr.left;

            // Check if the node to be deleted is the root.
            if (prev == null)
                return newCurr;

            // Check if the node to be deleted is prev\'s left or
            // right child and then replace this with newCurr.
            if (curr == prev.left)
                prev.left = newCurr;
            else
                prev.right = newCurr;
        } else {
          
            // Node to be deleted has two children.
            Node p = null;
            Node temp = curr.right;
            while (temp.left != null) {
                p = temp;
                temp = temp.left;
            }

            if (p != null)
                p.left = temp.right;
            else
                curr.right = temp.right;

            curr.key = temp.key;
        }
        return root;
    }

    // Utility function to do inorder traversal
    public static void inorder(Node root) {
        if (root != null) {
            inorder(root.left);
            System.out.print(root.key + " ");
            inorder(root.right);
        }
    }

    // Driver code
    public static void main(String[] args) {
        Node root = new Node(10);
        root.left = new Node(5);
        root.right = new Node(15);
        root.right.left = new Node(12);
        root.right.right = new Node(18);
        int x = 15;

        root = delIterative(root, x);
        inorder(root);
    }
}
```
```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

# Iterative approach to
# delete \'key\' from the BST.
def del_iterative(root, key):
    curr = root
    prev = None

    # First check if the key is
    # actually present in the BST.
    # the variable prev points to the
    # parent of the key to be deleted
    while (curr != None and curr.key != key):
        prev = curr
        if curr.key < key:
            curr = curr.right
        else:
            curr = curr.left

    if curr == None:
        return root

    # Check if the node to be
    # deleted has atmost one child
    if curr.left == None or\\
            curr.right == None:

        # newCurr will replace
        # the node to be deleted.
        newCurr = None

        # if the left child does not exist.
        if curr.left == None:
            newCurr = curr.right
        else:
            newCurr = curr.left

        # check if the node to
        # be deleted is the root.
        if prev == None:
            return newCurr

        # Check if the node to be
        # deleted is prev\'s left or
        # right child and then
        # replace this with newCurr
        if curr == prev.left:
            prev.left = newCurr
        else:
            prev.right = newCurr

        curr = None

    # node to be deleted
    # has two children.
    else:
        p = None
        temp = None

        # Compute the inorder
        # successor of curr.
        temp = curr.right
        while(temp.left != None):
            p = temp
            temp = temp.left

        # check if the parent of the
        # inorder successor is the root or not.
        # if it isn\'t, then make the left
        # child of its parent equal to the
        # inorder successor\'s right child.
        if p != None:
            p.left = temp.right

        else:

            # if the inorder successor was
            # the root, then make the right child
            # of the node to be deleted equal
            # to the right child of the inorder
            # successor.
            curr.right = temp.right

        curr.data = temp.key

    return root

def inorder(root):
    if root is not None:
        inorder(root.left)
        print(root.key, end=" ")
        inorder(root.right)

# Driver code
if __name__ == "__main__":
    root = Node(10)
    root.left = Node(5)
    root.right = Node(15)
    root.right.left = Node(12)
    root.right.right = Node(18)
    x = 15

    root = del_iterative(root, x)
    inorder(root)
```
```javascript
class Node {
    constructor(key) {
        this.key = key;
        this.left = this.right = null;
    }
}

function delIterative(root, key) {
    let curr = root;
    let prev = null;

    // Check if the key is actually present in the BST.
    // The variable prev points to the parent of the key
    // to be deleted.
    while (curr !== null && curr.key !== key) {
        prev = curr;
        if (key < curr.key) {
            curr = curr.left;
        } else {
            curr = curr.right;
        }
    }

    // Key not present
    if (curr === null) {
        return root;
    }

    // Check if the node to be deleted has at most one child.
    if (curr.left === null || curr.right === null) {
        let newCurr = (curr.left === null) ? curr.right : curr.left;

        // Check if the node to be deleted is the root.
        if (prev === null) {
            return newCurr;
        }

        // Check if the node to be deleted is prev\'s left or
        // right child and then replace this with newCurr.
        if (curr === prev.left) {
            prev.left = newCurr;
        } else {
            prev.right = newCurr;
        }
        
    } else {
        // Node to be deleted has two children.
        let p = null;
        let temp = curr.right;
        while (temp.left !== null) {
            p = temp;
            temp = temp.left;
        }

        if (p !== null) {
            p.left = temp.right;
        } else {
            curr.right = temp.right;
        }

        curr.key = temp.key;
    }

    return root;
}

function inorder(root) {
    if (root !== null) {
        inorder(root.left);
        process.stdout.write(root.key + " ");
        inorder(root.right);
    }
}

// Driver code
const root = new Node(10);
root.left = new Node(5);
root.right = new Node(15);
root.right.left = new Node(12);
root.right.right = new Node(18);
const x = 15;

const newRoot = delIterative(root, x);
inorder(newRoot);
```

```output
5 10 12 18
```

Time Complexity : O(h) where h is height of the BST  
Auxiliary Space: O(1)

>Continuing in the following lesson', 'Delete in Binary Search Tree', 'Binary Search Tree Part 2: Delete Operation', 8, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('82a0d245-a665-4ec2-a2fe-145f7e841ef1', e'
You are given a

****cubic dice****
with

****6****
faces. All the individual faces have a number printed on them. The numbers are in the range of

****1 to 6****
, like any ordinary dice. You will be provided with a face of this cube, your task is to guess the number on the opposite face of the cube.


****Examples:****

> ****Input:****
> n = 2
>
>
>
> ****Output:****
> 5
>
>
>
> ****Explanation:****
> For dice facing number 5 opposite face will have the number 2.
>
>
> ****Input:****
> 6 = 6
>
>
>
> ****Output:****
> 1

Table of Content

* [[Naive Approach] Using if-else – O(1) Time and O(1) Space](#naive-approach-using-ifelse-o1-time-and-o1-space)
* [[Expected Approach] Using Sum of two sides – O(1) Time and O(1) Space](#expected-approach-using-sum-of-two-sides-o1-time-and-o1-space)
### ****[Naive Approach] Using if-else – O(1) Time and O(1) Space****

> In a normal 6-faced dice, 1 is opposite to 6, 2 is opposite to 5, and 3 is opposite to 4. Hence a normal if-else-if block can be placed

C++

````
// C++ program for the above approach
#include<bits/stdc++.h>
using namespace std;

int oppositeFaceOfDice(int n) {

  if(n==1){
    cout<<6;
  }else if(n==2){
    cout<<5;
  }else if(n==3){
    cout<<4;
  }else if(n==4){
    cout<<3;
  }else if(n==5){
    cout<<2;
  }else{
    cout<<1;
  }
}

int main() {

    int n = 2;
    oppositeFaceOfDice(n);

    return 0;
}

````

Java

````
// Java program to find opposite face of dice
class Dice {
    static int oppositeFaceOfDice(int n) {
        if (n == 1) {
            System.out.println(6);
        } else if (n == 2) {
            System.out.println(5);
        } else if (n == 3) {
            System.out.println(4);
        } else if (n == 4) {
            System.out.println(3);
        } else if (n == 5) {
            System.out.println(2);
        } else {
            System.out.println(1);
        }
        return 0;
    }

    public static void main(String[] args) {
        int n = 2;
        oppositeFaceOfDice(n);
    }
}

````

Python

````
# Python program to find opposite face of dice
def opposite_face_of_dice(n):
    if n == 1:
        print(6)
    elif n == 2:
        print(5)
    elif n == 3:
        print(4)
    elif n == 4:
        print(3)
    elif n == 5:
        print(2)
    else:
        print(1)

if __name__ == "__main__":
  n = 2
  opposite_face_of_dice(n)

````

C#

````
// C# program to find opposite face of dice
using System;

class Program {
    static void OppositeFaceOfDice(int n) {
        if (n == 1) {
            Console.WriteLine(6);
        } else if (n == 2) {
            Console.WriteLine(5);
        } else if (n == 3) {
            Console.WriteLine(4);
        } else if (n == 4) {
            Console.WriteLine(3);
        } else if (n == 5) {
            Console.WriteLine(2);
        } else {
            Console.WriteLine(1);
        }
    }

    static void Main() {
        int n = 2;
        OppositeFaceOfDice(n);
    }
}

````

JavaScript

````
// JavaScript program to find opposite face of dice
function oppositeFaceOfDice(n) {
    if (n === 1) {
        console.log(6);
    } else if (n === 2) {
        console.log(5);
    } else if (n === 3) {
        console.log(4);
    } else if (n === 4) {
        console.log(3);
    } else if (n === 5) {
        console.log(2);
    } else {
        console.log(1);
    }
}

//driver code
let n = 2;
oppositeFaceOfDice(n);

````




**Output**
```
5
```
### [Expected Approach] Using Sum of two sides – O(1) Time and O(1) Space

> The idea is based on the observation that the sum of two opposite sides of a cubical dice is equal to
>
> ****7****
> . So, just subtract the given
>
> ****n****
> from
>
> ****7****
> and print the answer.

C++

````
// C++ program for the above approach
#include<bits/stdc++.h>
using namespace std;

int oppositeFaceOfDice(int n) {

    // Stores number on opposite face
    // of dice
    int ans = 7 - n;
    cout << ans;
}

int main() {

    int n = 2;
    oppositeFaceOfDice(n);

    return 0;
}

````

Java

````
// Java program for the above approach
import java.io.*;

class GfG {

    static void oppositeFaceOfDice(int n)  {

        // Stores number on opposite face
        // of dice
        int ans = 7 - n;
        System.out.println(ans);
    }

    public static void main(String[] args) {

        int n = 2;
        oppositeFaceOfDice(n);
    }
}

````

Python

````
# Python3 program for the above approach
def oppositeFaceOfDice(n):

    # Stores number on opposite face
    # of dice
    ans = 7 - n
    print(ans)

if __name__ == "__main__":
  n = 2
  oppositeFaceOfDice(n)

````

C#

````
// C# program for the above approach
using System;
using System.Collections.Generic;

class GfG{

static void oppositeFaceOfDice(int n) {

    // Stores number on opposite face
    // of dice
    int ans = 7 - n;
    Console.Write(ans);
}

public static void Main() {

    int n = 2;
    oppositeFaceOfDice(n);
}
}

````

JavaScript

````
// JavaScript program for the above approach

function oppositeFaceOfDice(n) {
  // Stores number on opposite face
  // of dice
  let ans = 7 - n;
  console.log(ans);
}

// Driver Code
let n = 2;
oppositeFaceOfDice(n);

````




**Output**
```
5
```

*****Time Complexity:*****
**O(1)**


*****Auxiliary Space:*****
**O(1)**
', '', 'The Logic Building Problems', 15, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('ddd30ce5-7b19-476e-ab39-8ea4f71a40f6', e'
Given two integers

****n****
and

****m (m != 0)****
. Find the number closest to

****n****
and divisible by

****m****
. If there is more than one such number, then output the one having maximum absolute value.


****Examples:****


> Input: n = 13, m = 4
>
>
>
> Output: 12
>
>
>
> Explanation: 12 is the closest to 13, divisible by 4.
>
>
> Input: n = -15, m = 6
>
>
>
> Output: -18
>
>
>
> Explanation: Both -12 and -18 are closest to -15, but-18 has the maximum absolute value.

Table of Content

* [[Naive Approach] – O(m) Time and O(1) Space](#naive-approach-om-time-and-o1-space)
* [[Expected Approach] By finding Quotient – O(1) Time and O(1) Space](#expected-approach-by-finding-quotient-o1-time-and-o1-space)
### [Naive Approach] – O(m) Time and O(1) Space

> The basic idea is to start checking from n – m to n + m one by one and tack the closest number.

C++

````
// C++ implementation to find the number closest to n
// and divisible by m
#include <bits/stdc++.h>
using namespace std;

int closestNumber(int n, int m) {
    // find the quotient
   int closest = 0;
    int minDifference = INT_MAX;

    // Check numbers around n
    for (int i = n - abs(m); i <= n + abs(m); ++i) {
        if (i % m == 0) {
            int difference = abs(n - i);

            if (difference < minDifference ||
               (difference == minDifference && abs(i) > abs(closest))) {
                closest = i;
                minDifference = difference;
            }
        }
    }
    return closest;
}

int main() {
    int n = 13, m = 4;
    cout << closestNumber(n, m) << endl;

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int closestNumber(int n, int m) {
    // find the quotient
    int closest = 0;
    int minDifference = INT_MAX;

    // Check numbers around n
    for (int i = n - abs(m); i <= n + abs(m); ++i) {
        if (i % m == 0) {
            int difference = abs(n - i);

            if (difference < minDifference ||
               (difference == minDifference && abs(i) > abs(closest))) {
                closest = i;
                minDifference = difference;
            }
        }
    }
    return closest;
}

int main() {
    int n = 13, m = 4;
    printf("%d\\n", closestNumber(n, m));

    return 0;
}

````

Java

````
// Java implementation to find the number closest to n
// and divisible by m
class Main {
    static int closestNumber(int n, int m) {
        // find the quotient
        int closest = 0;
        int minDifference = Integer.MAX_VALUE;

        // Check numbers around n
        for (int i = n - Math.abs(m); i <= n + Math.abs(m); ++i) {
            if (i % m == 0) {
                int difference = Math.abs(n - i);

                if (difference < minDifference ||
                   (difference == minDifference && Math.abs(i) > Math.abs(closest))) {
                    closest = i;
                    minDifference = difference;
                }
            }
        }
        return closest;
    }

    public static void main(String[] args) {
        int n = 13, m = 4;
        System.out.println(closestNumber(n, m));
    }
}

````

Python

````
# Python implementation to find the number closest to n
# and divisible by m
def closest_number(n, m):
    # find the quotient
    closest = 0
    min_difference = float(\'inf\')

    # Check numbers around n
    for i in range(n - abs(m), n + abs(m) + 1):
        if i % m == 0:
            difference = abs(n - i)

            if difference < min_difference or \\
                        (difference == min_difference and abs(i) > abs(closest)):
                closest = i
                min_difference = difference
    return closest


if __name__ == "__main__":
  n = 13
  m = 4
  print(closest_number(n, m))

````

C#

````
// C# implementation to find the number closest to n
// and divisible by m
using System;

class GfG {
    static int ClosestNumber(int n, int m) {

        // find the quotient
        int closest = 0;
        int minDifference = int.MaxValue;

        // Check numbers around n
        for (int i = n - Math.Abs(m); i <= n + Math.Abs(m); ++i) {
            if (i % m == 0) {
                int difference = Math.Abs(n - i);

                if (difference < minDifference ||
                   (difference == minDifference && Math.Abs(i) > Math.Abs(closest))) {
                    closest = i;
                    minDifference = difference;
                }
            }
        }
        return closest;
    }

    static void Main() {
        int n = 13, m = 4;
        Console.WriteLine(ClosestNumber(n, m));
    }
}

````

JavaScript

````
// JavaScript implementation to find the number closest to n
// and divisible by m
function closestNumber(n, m) {

    // find the quotient
    let closest = 0;
    let minDifference = Infinity;

    // Check numbers around n
    for (let i = n - Math.abs(m); i <= n + Math.abs(m); i++) {
        if (i % m === 0) {
            let difference = Math.abs(n - i);

            if (difference < minDifference ||
               (difference === minDifference && Math.abs(i) > Math.abs(closest))) {
                closest = i;
                minDifference = difference;
            }
        }
    }
    return closest;
}

//driver code
let n = 13, m = 4;
console.log(closestNumber(n, m));

````




**Output**
```
12

```
### [Expected Approach] By finding Quotient – O(1) Time and O(1) Space

> We find the value of n/m. Then we find closest of two possibilities. One is q \\* m other is (m \\* (q + 1)) or (m \\* (q – 1)) depending on whether one of the given two numbers is negative or not.

C++

````
// C++ implementation to find the number closest to n
// and divisible by m
#include <bits/stdc++.h>
using namespace std;

int closestNumber(int n, int m) {
    // find the quotient
    int q = n / m;

    // 1st possible closest number
    int n1 = m * q;

    // 2nd possible closest number
    int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));

    // if true, then n1 is the required closest number
    if (abs(n - n1) < abs(n - n2))
        return n1;

    // else n2 is the required closest number
    return n2;
}

int main() {
    int n = 13, m = 4;
    cout << closestNumber(n, m) << endl;

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

int closestNumber(int n, int m) {
    // find the quotient
    int q = n / m;

    // 1st possible closest number
    int n1 = m * q;

    // 2nd possible closest number
    int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));

    // if true, then n1 is the required closest number
    if (abs(n - n1) < abs(n - n2))
        return n1;

    // else n2 is the required closest number
    return n2;
}

int main() {
    int n = 13, m = 4;
    printf("%d\\n", closestNumber(n, m));

    return 0;
}

````

Java

````
// Java implementation to find the number closest to n
// and divisible by m
class GfG {

    static int closestNumber(int n, int m)  {
        // find the quotient
        int q = n / m;

        // 1st possible closest number
        int n1 = m * q;

        // 2nd possible closest number
        int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));

        // if true, then n1 is the required closest number
        if (Math.abs(n - n1) < Math.abs(n - n2))
            return n1;

        // else n2 is the required closest number
        return n2;
    }

    public static void main(String args[]) {
        int n = 13, m = 4;
        System.out.println(closestNumber(n, m));

    }
}

````

Python

````
# Python 3 implementation to find
# the number closest to n

def closestNumber(n, m) :
    # Find the quotient
    q = int(n / m)

    # 1st possible closest number
    n1 = m * q

    # 2nd possible closest number
    if((n * m) > 0) :
        n2 = (m * (q + 1))
    else :
        n2 = (m * (q - 1))

    # if true, then n1 is the required closest number
    if (abs(n - n1) < abs(n - n2)) :
        return n1

    # else n2 is the required closest number
    return n2


if __name__ == "__main__":
  n = 13; m = 4
  print(closestNumber(n, m))

````

C#

````
// C# implementation to find the
// number closest to n and divisible by m
using System;

class GfG {

    static int closestNumber(int n, int m) {
        // find the quotient
        int q = n / m;

        // 1st possible closest number
        int n1 = m * q;

        // 2nd possible closest number
        int n2 = (n * m) > 0 ? (m * (q + 1)) : (m * (q - 1));

        // if true, then n1 is the required closest number
        if (Math.Abs(n - n1) < Math.Abs(n - n2))
            return n1;

        // else n2 is the required closest number
        return n2;
    }

    public static void Main()  {
        int n = 13, m = 4;
        Console.WriteLine(closestNumber(n, m));

    }
}

````

JavaScript

````
// Javascript implementation to find
// the number closest to n and
// divisible by m

function closestNumber(n, m) {

    // find the quotient
    let q = parseInt(n / m);

    // 1st possible closest number
    let n1 = m * q;

    // 2nd possible closest number
    let n2 = (n * m) > 0 ?
        (m * (q + 1)) : (m * (q - 1));

    // if true, then n1 is the
    // required closest number
    if (Math.abs(n - n1) < Math.abs(n - n2))
        return n1;

    // else n2 is the required
    // closest number
    return n2;
}

// Driver Code
let n = 13;
let m = 4;
console.log(closestNumber(n, m));

````




**Output**
```
12

```

****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1)


', '', 'Find the number closest to n and divisible by m', 16, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('7e9a63b3-707f-46f9-a983-79eab80f9bce', e'

Given two variables, x, and y, swap two variables without using a third variable.


![](https://www.geeksforgeeks.org/wp-content/uploads/CommonArticleDesign16.png)



****Method 1 (Using Addition and subtraction)****


The idea is to get a sum in one of the two given

[numbers](https://www.geeksforgeeks.org/numbers/)
. The numbers can then be swapped using the sum and subtraction from the sum.


C++

````
// C++ Program to swap two numbers  without
// using temporary variable
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int x = 10, y = 5;

    // Code to swap \'x\' and \'y\'
    x = x + y; // x now becomes 15
    y = x - y; // y becomes 10
    x = x - y; // x becomes 5
    cout << "After Swapping: x =" << x << ", y=" << y;
}

// This code is contributed by mohit kumar.

````

C

````
#include <stdio.h>
int main()
{
    int x = 10, y = 5;

    // Code to swap \'x\' and \'y\'
    x = x + y; // x now becomes 15
    y = x - y; // y becomes 10
    x = x - y; // x becomes 5

    printf("After Swapping: x = %d, y = %d", x, y);

    return 0;
}

````

Java

````
// Java Program to swap two numbers  without
// using temporary variable
import java.io.*;

class Geeks {

    public static void main(String a[])
    {
        int x = 10;
        int y = 5;
        x = x + y;
        y = x - y;
        x = x - y;
        System.out.println("After swapping:"
                           + " x = " + x + ", y = " + y);
    }
}

// This code is contributed by Mayank Tyagi

````

Python

````
x = 10
y = 5

# Code to swap \'x\' and \'y\'

# x now becomes 15
x = x + y

# y becomes 10
y = x - y

# x becomes 5
x = x - y
print("After Swapping: x =", x, " y =", y)

# This code is contributed
# by Sumit Sudhakar

````

C#

````
// Program to swap two numbers  without
// using temporary variable
using System;

class GFG {
    public static void Main()
    {
        int x = 10;
        int y = 5;

        x = x + y;
        y = x - y;
        x = x - y;
        Console.WriteLine("After swapping: x = " + x
                          + ", y = " + y);
    }
}

// This code is contributed by Sam007

````

JavaScript

````
<script>

// Javascript program to swap two
// numbers without using temporary
// variable

let x = 10, y = 5;

// Code to swap \'x\' and \'y\'

// x now becomes 15
x = x + y;

// y becomes 10
y = x - y;

// x becomes 5
x = x - y;

document.write("After Swapping: x =" + x + ", y=" + y);

// This code is contributed by mukesh07

</script>

````

PHP

````
<?php
// PHP Program to swap two
// numbers without using
// temporary variable
$x = 10; $y = 5;

// Code to swap \'x\' and \'y\'
$x = $x + $y; // x now becomes 15
$y = $x - $y; // y becomes 10
$x = $x - $y; // x becomes 5

echo "After Swapping: x = ",
       $x, ", ", "y = ", $y;

// This code is contributed by m_kit
?>

````




**Output**
```
After Swapping: x =5, y=10

```

****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Method 2: (Using Multiplication and division)****


Multiplication and division can also be used for swapping.




C++

````
// C++ Program to swap two numbers without using temporary
// variable
#include <bits/stdc++.h>
using namespace std;

int main()
{ // NOTE - for this code to work in a generalised sense, y
  // !- 0 to prevent zero division
    int x = 10, y = 5;

    if (y == 0) {
        y = x;
        x = 0;
    }
    else if (x == 0) {
        x = y;
        y = 0;
    }
    // Code to swap \'x\' and \'y\'
    else {
        x = x * y; // x now becomes 50
        y = x / y; // y becomes 10
        x = x / y; // x becomes 5
    }
    cout << "After Swapping: x =" << x << ", y=" << y;
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

C

````
// C Program to swap two numbers without using temporary
// variable
#include <stdio.h>
int main()
{
    int x = 10, y = 5;

    if (y == 0) {
        y = x;
        x = 0;
    }
    else if (x == 0) {
        x = y;
        y = 0;
    }
    // Code to swap \'x\' and \'y\'
    else {
        x = x * y; // x now becomes 50
        y = x / y; // y becomes 10
        x = x / y; // x becomes 5
    }

    printf("After Swapping: x = %d, y = %d", x, y);

    return 0;
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

Java

````
// Java Program to swap two numbers without using temporary
// variable
import java.io.*;

class GFG {
    public static void main(String[] args)
    {
        int x = 10;
        int y = 5;

        if (y == 0) {
            y = x;
            x = 0;
        }
        else if (x == 0) {
            x = y;
            y = 0;
        }
        // Code to swap \'x\' and \'y\'
        else {
            x = x * y; // x now becomes 50
            y = x / y; // y becomes 10
            x = x / y; // x becomes 5
        }

        System.out.println("After swapping:"
                           + " x = " + x + ", y = " + y);
    }
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

Python

````
# Python3 program to
# swap two numbers
# without using
# temporary variable
x = 10
y = 5

# code to swap
# \'x\' and \'y\'

if y == 0:
    y = x
    x = 0
elif x == 0:
    x = y
    y = 0
else:
    x = x * y
    y = x // y
    x = x // y


print("After Swapping: x =",
      x, " y =", y)

# This code is contributed
# by @ajit

````

C#

````
// C# Program to swap two
// numbers without using
// temporary variable
using System;

class GFG {
    static public void Main()
    {
        int x = 10;
        int y = 5;

        if (y == 0) {
            y = x;
            x = 0;
        }
        else if (x == 0) {
            x = y;
            y = 0;
        }
        // Code to swap \'x\' and \'y\'
        else {
            x = x * y; // x now becomes 50
            y = x / y; // y becomes 10
            x = x / y; // x becomes 5
        }

        Console.WriteLine("After swapping:"
                          + " x = " + x + ", y = " + y);
    }
}

// This code is contributed by ajit.

````

JavaScript

````
<script>

// Javascript program to swap two numbers
// without using temporary variable
var x = 10;
var y = 5;

// Code to swap \'x\' and \'y\'
if (y == 0)
{ y = x; x = 0; }
else if (x == 0) { x = y; y = 0; }
    // Code to swap \'x\' and \'y\'
  else
  {x = x * y; // x now becomes 50
    y = x / y; // y becomes 10
    x = x / y; // x becomes 5
    }

document.write("After swapping:" + " x = " +
               x + ", y = " + y);

// This code is contributed by shikhasingrajput

</script>

````




**Output**
```
After Swapping: x =5, y=10

```

****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Method 3: (Using Bitwise XOR)****



The bitwise XOR operator can be used to swap two variables. The XOR of two numbers x and y returns a number that has all the bits as 1 wherever bits of x and y differ. For example, XOR of 10 (In Binary 1010) and 5 (In Binary 0101) is 1111, and XOR of 7 (0111) and 5 (0101) is (0010).


C++

````
// C++ code to swap using XOR
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int x = 10, y = 5;
    // Code to swap \'x\' (1010) and \'y\' (0101)
    x = x ^ y; // x now becomes 15 (1111)
    y = x ^ y; // y becomes 10 (1010)
    x = x ^ y; // x becomes 5 (0101)
    cout << "After Swapping: x =" << x << ", y=" << y;
    return 0;
}

// This code is contributed by mohit kumar.

````

C

````
// C code to swap using XOR
#include <stdio.h>
int main()
{
    int x = 10, y = 5;

    // Code to swap \'x\' (1010) and \'y\' (0101)
    x = x ^ y; // x now becomes 15 (1111)
    y = x ^ y; // y becomes 10 (1010)
    x = x ^ y; // x becomes 5 (0101)

    printf("After Swapping: x = %d, y = %d", x, y);

    return 0;
}

````

Java

````
// Java code to swap using XOR
import java.io.*;

public class GFG {

    public static void main(String a[])
    {
        int x = 10;
        int y = 5;

        // Code to swap \'x\' (1010) and \'y\' (0101)
        x = x ^ y; // x now becomes 15 (1111)
        y = x ^ y; // y becomes 10 (1010)
        x = x ^ y; // x becomes 5 (0101)

        System.out.println("After swap: x = "
                           + x + ", y = " + y);
    }
}

// This code is contributed by Mayank Tyagi

````

Python

````
# Python3 code to swap using XOR

x = 10
y = 5

# Code to swap \'x\' and \'y\'
x = x ^ y; # x now becomes 15 (1111)
y = x ^ y; # y becomes 10 (1010)
x = x ^ y; # x becomes 5 (0101)

print ("After Swapping: x = ", x, " y =", y)

# This code is contributed by
# Sumit Sudhakar

````

C#

````
// C# program to swap using XOR
using System;

class GFG {
    public static void Main()
    {
        int x = 10;
        int y = 5;

        // Code to swap \'x\' (1010)
        // and \'y\' (0101)

        // x now becomes 15 (1111)
        x = x ^ y;

        // y becomes 10 (1010)
        y = x ^ y;

        // x becomes 5 (0101)
        x = x ^ y;

        Console.WriteLine("After swap: x = " + x + ", y = " + y);
    }
}

// This code is contributed by ajit

````

JavaScript

````
<script>

// Javascript code to swap using XOR

let x = 10, y = 5;

// Code to swap \'x\' (1010) and \'y\' (0101)
x = x ^ y; // x now becomes 15 (1111)
y = x ^ y; // y becomes 10 (1010)
x = x ^ y; // x becomes 5 (0101)

document.write("After Swapping: x =" +
               x + ", y=" + y);

// This code is contributed by Mayank Tyagi

</script>

````

PHP

````
<?php

// Driver Code
$x = 10;
$y = 5;

// Code to swap \'x\' (1010)
// and \'y\' (0101)

// x now becomes 15 (1111)
$x = $x ^ $y;

// y becomes 10 (1010)
$y = $x ^ $y;

// x becomes 5 (0101)
$x = $x ^ $y;

echo "After Swapping: x = ", $x,
                ", ", "y = ", $y;

// This code is contributed by aj_36
?>

````




**Output**
```
After Swapping: x =5, y=10

```

****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Problems with the above methods****



****1)****
The multiplication and division-based approach doesn’t work if one of the numbers is 0 as the product becomes 0 irrespective of the other number.



****2)****
Both Arithmetic solution may cause an arithmetic overflow. If x and y are too large, addition and multiplication may go out of the integer range.



****3)****
When we use pointers to variable and make a function swap, all the above methods fail when both pointers point to the same variable. Let’s take a look at what will happen in this case if both are pointing to the same variable.


// Bitwise XOR based method



x = x ^ x; // x becomes 0



x = x ^ x; // x remains 0



x = x ^ x; // x remains 0



// Arithmetic based method



x = x + x; // x becomes 2x



x = x – x; // x becomes 0



x = x – x; // x remains 0


Let us see the following program.



C++

````
#include <bits/stdc++.h>
using namespace std;
void swap(int* xp, int* yp)
{
    *xp = *xp ^ *yp;
    *yp = *xp ^ *yp;
    *xp = *xp ^ *yp;
}

// Driver code
int main()
{
    int x = 10;
    swap(&x, &x);
    cout << "After swap(&x, &x): x = " << x;
    return 0;
}

// This code is contributed by rathbhupendra

````

C

````
#include <stdio.h>
void swap(int* xp, int* yp)
{
    *xp = *xp ^ *yp;
    *yp = *xp ^ *yp;
    *xp = *xp ^ *yp;
}

int main()
{
    int x = 10;
    swap(&x, &x);
    printf("After swap(&x, &x): x = %d", x);
    return 0;
}

````

Java

````
class GFG {
    static void swap(int[] xp, int[] yp)
    {
        xp[0] = xp[0] ^ yp[0];
        yp[0] = xp[0] ^ yp[0];
        xp[0] = xp[0] ^ yp[0];
    }

    // Driver code
    public static void main(String[] args)
    {
        int[] x = { 10 };
        swap(x, x);
        System.out.println("After swap(&x, &x): x = " + x[0]);
    }
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

Python

````
def swap(xp, yp):

    xp[0] = xp[0] ^ yp[0]
    yp[0] = xp[0] ^ yp[0]
    xp[0] = xp[0] ^ yp[0]


# Driver code
x = [10]
swap(x, x)
print("After swap(&x, &x): x = ", x[0])

# This code is contributed by SHUBHAMSINGH10

````

C#

````
// C# program to implement
// the above approach
using System;
class GFG {

    static void swap(int[] xp, int[] yp)
    {
        xp[0] = xp[0] ^ yp[0];
        yp[0] = xp[0] ^ yp[0];
        xp[0] = xp[0] ^ yp[0];
    }

    // Driver code
    static void Main()
    {
        int[] x = { 10 };
        swap(x, x);
        Console.WriteLine("After swap(&x,"
                          + "&x): x = " + x[0]);
    }
}

// This code is contributed by divyeshrabadiya07

````

JavaScript

````
<script>

    function swap(xp,yp)
    {
        xp[0] = xp[0] ^ yp[0];
        yp[0] = xp[0] ^ yp[0];
        xp[0] = xp[0] ^ yp[0];
    }

    // Driver code

    let x=[10];
    swap(x, x);
    document.write("After swap(&x, &x): x = "
                           + x[0]);


    // This code is contributed by unknown2108

</script>

````

PHP

````
<?php
function swap(&$xp, &$yp)
{
    $xp = $xp ^ $yp;
    $yp = $xp ^ $yp;
    $xp = $xp ^ $yp;
}

// Driver Code
$x = 10;
swap($x, $x);
print("After swap(&x, &x): x = " . $x);

// This code is contributed
// by chandan_jnu
?>

````




**Output**
```
After swap(&x, &x): x = 0

```

****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


Swapping a variable with itself may be needed in many standard algorithms. The above problem can be avoided by putting a condition before swapping.


C++

````
#include <bits/stdc++.h>
using namespace std;
void swap(int* xp, int* yp)
{

    // Check if the two addresses are same
    if (xp == yp)
        return;
    *xp = *xp + *yp;
    *yp = *xp - *yp;
    *xp = *xp - *yp;
}

// Driver Code
int main()
{
    int x = 10;
    swap(&x, &x);
    cout << "After swap(&x, &x): x = " << x;
    return 0;
}

// This code is contributed by rathbhupendra

````

C

````
#include <stdio.h>
void swap(int* xp, int* yp)
{
    if (xp == yp) // Check if the two addresses are same
        return;
    *xp = *xp + *yp;
    *yp = *xp - *yp;
    *xp = *xp - *yp;
}
int main()
{
    int x = 10;
    swap(&x, &x);
    printf("After swap(&x, &x): x = %d", x);
    return 0;
}

````

Java

````
// Java program of above approach
class GFG {

    static void swap(int xp, int yp)
    {
        if (xp == yp) // Check if the two addresses are same
            return;
        xp = xp + yp;
        yp = xp - yp;
        xp = xp - yp;
    }

    // Driver code
    public static void main(String[] args)
    {
        int x = 10;
        swap(x, x);
        System.out.println("After swap(&x, &x): x = " + x);
    }
}

// This code is Contributed by Code_Mech.

````

Python

````
# Python3 program of above approach
def swap(xp, yp):

    # Check if the two addresses are same
    if (xp[0] == yp[0]):
        return
    xp[0] = xp[0] + yp[0]
    yp[0] = xp[0] - yp[0]
    xp[0] = xp[0] - yp[0]


# Driver Code
x = [10]
swap(x, x)
print("After swap(&x, &x): x = ", x[0])

# This code is contributed by SHUBHAMSINGH10

````

C#

````
// C# program of above approach
using System;
class GFG {

    static void swap(int xp, int yp)
    {
        if (xp == yp) // Check if the two addresses are same
            return;
        xp = xp + yp;
        yp = xp - yp;
        xp = xp - yp;
    }

    // Driver code
    public static void Main()
    {
        int x = 10;
        swap(x, x);
        Console.WriteLine("After swap(&x, &x): x = " + x);
    }
}

// This code is Contributed by Code_Mech.

````

JavaScript

````
<script>
   function swap(xp, yp)
{

    // Check if the two addresses are same
    if (xp == yp)
        return;
    xp[0] = xp[0] + yp[0];
    yp[0] = xp[0] - yp[0];
    xp[0]= xp[0] - yp[0];
}

// Driver Code
     x = 10;
    swap(x, x);
    document.write("After swap(&x , &x) : x = " + x);
//This code is contributed by simranarora5sos
</script>

````

PHP

````
<?php
function swap($xp, $yp)
{
    // Check if the two addresses
    // are same
    if ($xp == $yp)
        return;
    $xp = $xp + $yp;
    $yp = $xp - $yp;
    $xp = $xp - $yp;
}

// Driver Code
$x = 10;
swap($x, $x);
echo("After swap(&x, &x): x = " . $x);
return 0;

// This code is contributed
// by Code_Mech.

````




**Output**
```
After swap(&x, &x): x = 10

```

****Time Complexity:****
O(1).



****Auxiliary Space:****
O(1).


****Method 4 (A mixture of bitwise operators and arithmetic operators)****



The idea is the same as discussed in

****Method 1****
but uses Bitwise addition and subtraction for swapping.


Below is the implementation of the above approach.


C++

````
// C++ program to swap two numbers
#include <bits/stdc++.h>
using namespace std;

// Function to swap the numbers.
void swap(int& a, int& b)
{
    // same as a = a + b
    a = (a & b) + (a | b);
    // same as b = a - b
    b = a + (~b) + 1;
    // same as a = a - b
    a = a + (~b) + 1;
}

// Driver Code
int main()
{
    int a = 5, b = 10;
    // Function Call
    swap(a, b);
    cout << "After swapping: a = " << a << ", b = " << b;
    return 0;
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

C

````
// C program to swap two numbers
#include <stdio.h>

// Function to swap the numbers.
void swap(int a, int b)
{
    // same as a = a + b
    a = (a & b) + (a | b);
    // same as b = a - b
    b = a + (~b) + 1;
    // same as a = a - b
    a = a + (~b) + 1;
      printf("After swapping: a = %d , b = %d ",a,b);
}

// Driver Code
int main()
{
    int a = 5, b = 10;
    // Function Call
    swap(a, b);
    return 0;
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

Java

````
// Java program to swap two numbers
import java.io.*;

class GFG {
    public static void swap(int a, int b)
    {
        // same as a = a + b
        a = (a & b) + (a | b);
        // same as b = a - b
        b = a + (~b) + 1;
        // same as a = a - b
        a = a + (~b) + 1;
        System.out.print("After swapping: a = " + a + ", b = " + b);
    }
    public static void main(String[] args)
    {
        int a = 5, b = 10;
        // Function Call
        swap(a, b);
    }
}

// This code is contributed by Aditya Kumar (adityakumar129)

````

Python

````
# Python3 program to swap two numbers

# Function to swap the numbers


def swap(a, b):

    # Same as a = a + b
    a = (a & b) + (a | b)

    # Same as b = a - b
    b = a + (~b) + 1

    # Same as a = a - b
    a = a + (~b) + 1

    print("After Swapping: a = ", a, ", b = ", b)


# Driver code
a = 5
b = 10

# Function call
swap(a, b)

# This code is contributed by bunnyram19

````

C#

````
// C# program to swap two numbers
using System;
class GFG {

    static void swap(int a, int b)
    {
        // same as a = a + b
        a = (a & b) + (a | b);

        // same as b = a - b
        b = a + (~b) + 1;

        // same as a = a - b
        a = a + (~b) + 1;

        Console.Write("After swapping: a = " + a
                      + ", b = " + b);
    }

    static void Main()
    {
        int a = 5, b = 10;

        // Function Call
        swap(a, b);
    }
}

// This code is contributed by divyesh072019

````

JavaScript

````
<script>
    // Javascript program to swap two numbers

    function swap(a, b)
    {
        // same as a = a + b
        a = (a & b) + (a | b);

        // same as b = a - b
        b = a + (~b) + 1;

        // same as a = a - b
        a = a + (~b) + 1;

        document.write("After swapping: a = " + a + ", b = " + b);
    }

    let a = 5, b = 10;

    // Function Call
    swap(a, b);

    // This code is contributed by suresh07.
</script>

````

PHP

````
<?php


// Driver Code
$a = 5;
$b = 10;

echo("Before swap(a and b) " . $a . "and". $b."<br>");
// same as a = a + b
    $a = ($a & $b) + ($a | $b);

    // same as b = a - b
    $b = $a + (~$b) + 1;

    // same as a = a - b
    $a = $a + (~$b) + 1;

echo("After swap(a and b) " . $a. "and". $b);
return 0;

?>

````




**Output**
```
After swapping: a = 10, b = 5

```

****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1), since no extra space has been taken.


****Method 5 (One Line Expression)****


We can write only one line to swap two numbers.


* x = x ^ y ^ (y = x);
* x = x + y – (y = x);
* x = (x \\* y) / (y = x);
* x , y = y, x (In Python)

C++

````
#include <iostream>
using namespace std;

int main(){
    int x = 10, y = 5;
    x = (x * y) / (y = x);
    cout << x << " " << y;
    return 0;
}

// This code is contributed by isha307

````

C

````
#include <stdio.h>

int main() {
    int x = 10, y = 5;
    x = (x * y) / (y = x);
    printf("After Swapping: x = %d, y = %d", x, y);
    return 0;
}

// This code is contributed by isha307

````

Java

````
/*package whatever //do not write package name here */
import java.io.*;

class GFG {
    public static void main(String[] args)
    {
        int x = 10;
        int y = 5;
        x = (x * y) / (y = x);
        System.out.println("After swapping:"
                           + " x = " + x + ", y = " + y);
    }
}

// This code is contributed by isha307

````

Python

````
# Python3 program to swap two numbers

# Function to swap the numbers
def swap(x, y):
  x , y = y, x
  print("After Swapping: x = ", x, ", y = ", y)

# Driver code
x = 10
y = 5

# Function call
swap(x, y)

# This code is contributed by kothavvsaakash

````

C#

````
// C# program to swap two numbers

using System;

public class GFG
{
    static public void Main ()
    {
        int x = 10;
        int y = 5;
        x = (x * y) / (y = x);
        Console.Write("After swapping:"  + " x = " + x + ", y = " + y);
    }
}

// This code is contributed by kothavvsaakash

````

JavaScript

````
<script>

// Javascript program to swap two
// numbers without using temporary
// variable

let x = 10, y = 5;

// Code to swap \'x\' and \'y\'
x = (x * y)/(x = y);

document.write("After Swapping: x =" + x + ", y=" + y);

// This code is contributed by Abhijeet Kumar(abhijeet19403)

</script>

````




**Output**
```
5 10

```

****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1)
', '', 'How to swap two numbers without using a temporary variable?', 17, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('52069685-2d95-4f5f-9678-294844ede87b', e'
Given a number n, find the sum of the first natural numbers.


****Examples :****


> ****Input:****
> n = 3
>
>
>
> ****Output:****
> 6
>
>
>
> ****Explanation****
> : Note that 1 + 2 + 3 = 6
>
>
>
>
>
> ****Input****
> : 5
>
>
>
> ****Output****
> : 15
>
>
>
> ****Explanation****
> : Note that 1 + 2 + 3 + 4 + 5 = 15

### Naive Solution – O(n) Time and O(1) Space


Calculate the sum of all integers from 1 to

`n`
by iterating through a loop.


C++

````
// CPP program to find sum of first
// n natural numbers.
#include <iostream>
using namespace std;

int findSum(int n)
{
    int sum = 0;
    for (int x = 1; x <= n; x++)
        sum = sum + x;
    return sum;
}

// Driver code
int main()
{
    int n = 5;
    cout << findSum(n);
    return 0;
}

````

C

````
// C program to find sum of first
// n natural numbers.
#include <stdio.h>

int findSum(int n)
{
    int sum = 0;
    for (int x = 1; x <= n; x++)
        sum = sum + x;
    return sum;
}

// Driver code
int main()
{
    int n = 5;
    printf("%d", findSum(n));
    return 0;
}

````

Java

````
// JAVA program to find sum of first
// n natural numbers.
import java.io.*;

class GfG{
    static int findSum(int n)
    {
        int sum = 0;
        for (int x = 1; x <= n; x++)
            sum = sum + x;
        return sum;
    }

    // Driver code
    public static void main(String args[])
    {
        int n = 5;
        System.out.println(findSum(n));
    }
}

// This code is contributed by Nikita Tiwari.

````

Python

````
# PYTHON program to find sum of first
# n natural numbers.

def findSum(n):
    sum = 0
    x = 1
    while x <= n:
        sum = sum + x
        x = x + 1
    return sum


# Driver code
n = 5
print findSum(n)

````

C#

````
// C# program to find sum of first
// n natural numbers.
using System;

class GfG{

    static int findSum(int n)
    {
        int sum = 0;
        for (int x = 1; x <= n; x++)
            sum = sum + x;
        return sum;
    }

    // Driver code
    public static void Main()
    {
        int n = 5;
        Console.Write(findSum(n));
    }
}

````

JavaScript

````
// Javascript program to find sum of first n natural numbers.

function findSum(n)
{
   let sum = 0;
   for (let x = 1; x <= n; x++)
     sum = sum + x;
   return sum;
}

let n = 5;
console.log(findSum(n));

````

PHP

````
<?php
// PHP program to find sum of first
// n natural numbers.

function findSum($n)
{
$sum = 0;
for ($x = 1; $x <= $n; $x++)
    $sum = $sum + $x;
return $sum;
}

// Driver code
$n = 5;
echo findSum($n);

?>

````




**Output**
```
15
```
### Expected Approach – O(1) Time and O(1) Space


An

****efficient solution****
is to use the below formula.


> ****Sum of first n natural numbers = (n \\* (n+1)) / 2****
>
>
> For example: n = 5
>
>
>
> Sum = (5 \\* (5 + 1)) / 2 = (5 \\* 6) / 2 = 30 / 2 = 15

****How does this work?****

> ****We can prove this formula using induction.****
>
>
>
>
> It is true for n = 1 and n = 2
>
>
>
> For n = 1, sum = 1 \\* (1 + 1)/2 = 1
>
>
>
> For n = 2, sum = 2 \\* (2 + 1)/2 = 3
>
>
>
>
>
> Let it be true for k = n-1.
>
>
>
>
>
> Sum of k numbers = (k \\* (k+1))/2
>
>
>
> Putting k = n-1, we get
>
>
>
> Sum of k numbers = ((n-1) \\* (n-1+1))/2
>
>
>
> = (n – 1) \\* n / 2
>
>
>
>
>
> If we add n, we get,
>
>
>
> Sum of n numbers = n + (n – 1) \\* n / 2
>
>
>
> = (2n + n
>
> 2
> – n)/2
>
>
>
> = n \\* (n + 1)/2

C++

````
// Efficient CPP program to find sum of first
// n natural numbers.
#include<iostream>
using namespace std;

int findSum(int n)
{
   return n * (n + 1) / 2;
}

// Driver code
int main()
{
  int n = 5;
  cout << findSum(n);
  return 0;
}

````

C

````
// Efficient C program to find
// sum of first n natural numbers.
#include<stdio.h>

int findSum(int n)
{
   return n * (n + 1) / 2;
}

// Driver code
int main()
{
  int n = 5;
  printf("%d", findSum(n));
  return 0;
}

````

Java

````
// Efficient JAVA program to find sum
// of first n natural numbers.
import java.io.*;

class GfG{

    static int findSum(int n)
    {
        return n * (n + 1) / 2;
    }

    // Driver code
    public static void main(String args[])
    {
        int n = 5;
        System.out.println(findSum(n));
    }
}

````

Python

````
# Efficient CPP program to find sum
# of first n natural numbers.

def findSum(n) :
    return n * (n + 1) / 2

# Driver code
n = 5
print findSum(n)

````

C#

````
// Efficient C# program to find sum
// of first n natural numbers.
using System;

class GFG{

    static int findSum(int n)
    {
        return n * (n + 1) / 2;
    }

    // Driver code
    public static void Main()
    {
        int n = 5;
        Console.Write(findSum(n));
    }
}

````

JavaScript

````
// javascript Program to find the average
// of sum of first n natural numbers

function findSum(n)
{
    return n * (n + 1) / 2;
}
var n = 5;
console.log(findSum(n));

````

php

````
<?php
// Efficient PHP program to find sum
// of first n natural numbers.

function findSum($n)
{
    return ($n * ($n + 1) / 2);
}

// Driver code
$n = 5;
echo findSum($n);

?>

````




**Output**
```
15
```

****Note:****
The above program causes

****overflow,****
even if the

****result****
is not beyond the

****integer limit****
. We can avoid overflow up to some extent by

****dividing first****
.


C++

````
// n natural numbers that avoids overflow if
// result is going to be within limits.
#include<iostream>
using namespace std;

int findSum(int n)
{
   if (n % 2 == 0)

      // Here multiplying by 1LL help to
      // perform calculations in long long,
      // so that answer should not be overflowed
      return (n / 2) * 1LL * (n + 1);

   // If n is odd, (n+1) must be even
   else

      // Here multiplying by 1LL help to
      // perform calculations in long long,
      // so that answer should not be overflowed
      return  ((n + 1) / 2) * 1LL * n;
}

// Driver code
int main()
{
  int n = 5;
  cout << findSum(n);
  return 0;
}

````

C

````
// Efficient C program to find
// sum of first n natural numbers
// that avoids overflow if result
// is going to be within limits.
#include<stdio.h>

int findSum(int n)
{
   if (n % 2 == 0)

      // Here multiplying by 1LL help to
      // perform calculations in long long,
      // so that answer should not be overflowed
      return (n / 2) * 1LL * (n + 1);

   // If n is odd, (n+1) must be even
   else

      // Here multiplying by 1LL help to
      // perform calculations in long long,
      // so that answer should not be overflowed
      return  ((n + 1) / 2) * 1LL * n;
}

// Driver code
int main()
{
  int n = 5;
  printf("%d", findSum(n));
  return 0;
}

````

Java

````
// n natural numbers that avoids overflow if
// result is going to be within limits.
import java.io.*;

class GfG{

    // Returns sum of first n natural
    // numbers
    static int findSum(int n)
    {
        if (n % 2 == 0)
            return (n / 2) * (n + 1);

        // If n is odd, (n+1) must be even
        else
            return ((n + 1) / 2) * n;
    }

    // Driver code
    public static void main(String args[])
    {
        int n = 5;
        System.out.println(findSum(n));
    }
}

````

Python

````
# Efficient Python program to find the sum
# of first n natural numbers that avoid
# overflow if the result is going to be
# within limits.

# Returns sum of first n natural
# numbers
def findSum(n):
    if (n % 2 == 0):
        return (n / 2) * (n + 1)

   # If n is odd, (n+1) must be even
    else:
        return ((n + 1) / 2) * n


# Driver code
n = 5
print findSum(n)

````

C#

````
// Efficient C# program to find the sum of first
// n natural numbers that avoid overflow if
// result is going to be within limits.
using System;

class GfG{

    static int findSum(int n)
    {
        if (n % 2 == 0)
            return (n / 2) * (n + 1);

        // If n is odd, (n+1) must be even
        else
            return ((n + 1) / 2) * n;
    }

    // Driver code
    public static void Main()
    {
        int n = 5;
        Console.Write(findSum(n));
    }
}

````

JavaScript

````
//efficient approach using  javascript to find the average
// of sum of first n natural numbers

// Return the average of sum
// of first n even numbers
function findSum(n)
{
    if (n % 2 == 0)
        return (n / 2) * (n + 1)

// If n is odd, (n+1) must be even
    else
    return ((n + 1) / 2) * n

}
var n = 5;
console.log(findSum(n));

````

PHP

````
<?php
// Efficient php program to find sum of first
// n natural numbers that avoids overflow if
// result is going to be within limits.

function findSum($n)
{
    if ($n % 2 == 0)
        return ($n / 2) *
               ($n + 1);

    // If n is odd, (n+1) must be even
    else
        return (($n + 1) / 2) * $n;
}

// Driver code
$n = 5;
echo findSum($n);
?>

````




**Output**
```
15
```
', '', 'Program to find sum of first n natural numbers', 18, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('0aeea379-45ac-4886-bc6e-ebee7abcae78', e'![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/Recursive-Functions-in-c.png)

# Need of Recursive Function:

A recursive function is a function that solves a problem by solving smaller instances of the same problem. This technique is often used in programming to solve problems that can be broken down into simpler, similar subproblems.

## 1. Solving complex tasks:

Recursive functions break complex problems into smaller instances of the same problem, resulting in compact and readable code.

## 2. Divide and Conquer:

Recursive functions are suitable for divide-and-conquer algorithms such as merge sort and quicksort, breaking problems into smaller subproblems, solving them recursively, and merging the solutions with the original problem.

## 3. Backtracking:

Recursive backtracking is ideal for exploring and solving problems like N-Queens and Sudoku.

## 4. Dynamic programming:

Recursive functions efficiently solve dynamic programming problems by solving subproblems and combining their solutions into a complete solution.

## 5. Tree and graph structures:

Recursive functions are great for working with tree and graph structures, simplifying traversal and pattern recognition tasks****.****

# How to write a Recursive Function:

## Components of a recursive function:

**Base case:** Every recursive function must have a base case. The base case is the simplest scenario that does not require further recursion. This is a termination condition that prevents the function from calling itself indefinitely. Without a proper base case, a recursive function can lead to infinite recursion.

**Recursive case:** In the recursive case, the function calls itself with the modified arguments. This is the essence of recursion - solving a larger problem by breaking it down into smaller instances of the same problem. The recursive case should move closer to the base case with each iteration.

Let\'s consider the example of [factorial of number](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/):

In this example, the base case is when **n** is **0**, and the function returns **1**. The recursive case multiplies **n** with the result of the function called with parameter **n - 1**. The process continues until the base case is reached.

It\'s essential to ensure that the recursive function has a correct base case and that the recursive calls lead to the base case, otherwise, the procedure might run indefinitely, leading to a stack overflow (exceeding the available memory allocated for function calls).

Below is the implementation of factorial of a number:

```cpp
#include <iostream>
using namespace std;

// Recursive Function to calculate Factorial of a number
int factorial(int n)
{
    // Base case
    if (n == 0) {
        return 1;
    }

    // Recursive case
    return n * factorial(n - 1);
}

// Driver Code

int main()
{
    int n = 4;

    cout << "Factorial of " << n
         << " is:" << factorial(n);
    return 0;
}
```
```java
import java.util.Scanner;

public class Factorial {
    // Recursive Function to calculate the factorial of a number
    static int factorial(int n) {
        // Base case: If n is 0, the factorial is 1.
        if (n == 0) {
            return 1;
        }

        // Recursive case: Calculate the factorial by multiplying n with the factorial of (n - 1).
        return n * factorial(n - 1);
    }

    public static void main(String[] args) {
        int n = 4;

        // Calculate and print the factorial of n.
        int result = factorial(n);
        System.out.println("Factorial of " + n + " is: " + result);
    }
}
```
```python
# Recursive Function to calculate Factorial of a number
def factorial(n):
    # Base case
    if n == 0:
        return 1

    # Recursive case
    return n * factorial(n - 1)

# Driver Code
if __name__ == "__main__":
    n = 4

    print("Factorial of", n, "is:", factorial(n))
```
```csharp
using System;

class Program
{
    // Recursive Function to calculate Factorial of a number
    static int Factorial(int n)
    {
        // Base case
        if (n == 0)
        {
            return 1;
        }

        // Recursive case
        return n * Factorial(n - 1);
    }

    // Driver Code
    static void Main()
    {
        int n = 4;

        Console.WriteLine("Factorial of " + n + " is: " + Factorial(n));
    }
}
```
```javascript
// Function to calculate the factorial of a number using recursion
function factorial(n) {
    // Base case: If n is 0, the factorial is 1.
    if (n === 0) {
        return 1;
    }

    // Recursive case: Calculate the factorial by multiplying n with the factorial of (n - 1).
    return n * factorial(n - 1);
}

// Main function
function main() {
    // Given number
    let n = 4;

    // Calculate the factorial of n.
    let result = factorial(n);

    // Print the result
    console.log("Factorial of " + n + " is: " + result);
}

// Call the main function
main();
```


```output
Factorial of 4 is:24
```

**Time Complexity:** O(n)  
**Auxiliary Space:** O(n)', 'A Recursive function can be defined as a routine that calls itself directly or indirectly.', 'Recursive Function', 3, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('3fa17c75-63b5-4d32-bd5c-6ecd0d534a06', e'# Basic Operations on BST (additional)

## Traversals – Inorder, Preorder, Post Order
Given a [Binary Search Tree](https://www.geeksforgeeks.org/binary-search-tree-data-structure/), The task is to print the elements in inorder, preorder, and postorder traversal of the Binary Search Tree. 

**Input:** 

![](https://media.geeksforgeeks.org/wp-content/uploads/20220730030128/Screenshot20220730at30104AM-660x431.png)

A Binary Search Tree

**Output:**    Inorder Traversal: 10 20 30 100 150 200 300   Preorder Traversal: 100 20 10 30 200 150 300   Postorder Traversal: 10 30 20 150 300 200 100

**Input:** 

![](https://media.geeksforgeeks.org/wp-content/uploads/20220920155301/BST-300x172.png)

Binary Search Tree

**Output:**    Inorder Traversal: 8 12 20 22 25 30 40   Preorder Traversal: 22 12 8 20 30 25 40   Postorder Traversal: 8 20 12 25 40 30 22

### Inorder Traversal

Below is the idea to solve the problem:

> At first traverse **left subtree** then visit the **root** and then traverse the **right subtree**.

Follow the below steps to implement the idea:

-   Traverse left subtree
-   Visit the root and print the data.
-   Traverse the right subtree

The [**inorder traversal**](https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/) of the BST gives the values of the nodes in sorted order. To get the decreasing order visit the right, root, and left subtree.

Below is the implementation of the inorder traversal.

```cpp
// C++ code to implement the approach

#include <bits/stdc++.h>
using namespace std;

// Class describing a node of tree
class Node {
public:
    int data;
    Node* left;
    Node* right;
    Node(int v)
    {
        this->data = v;
        this->left = this->right = NULL;
    }
};

// Inorder Traversal
void printInorder(Node* node)
{
    if (node == NULL)
        return;

    // Traverse left subtree
    printInorder(node->left);

    // Visit node
    cout << node->data << " ";

    // Traverse right subtree
    printInorder(node->right);
}

// Driver code
int main()
{
    // Build the tree
    Node* root = new Node(100);
    root->left = new Node(20);
    root->right = new Node(200);
    root->left->left = new Node(10);
    root->left->right = new Node(30);
    root->right->left = new Node(150);
    root->right->right = new Node(300);

    // Function call
    cout << "Inorder Traversal: ";
    printInorder(root);
    return 0;
}
```
```java
// Java code to implement the approach
import java.io.*;

// Class describing a node of tree
class Node {

    int data;
    Node left;
    Node right;
    Node(int v)
    {
        this.data = v;
        this.left = this.right = null;
    }
}

class GFG {
    // Inorder Traversal
    public static void printInorder(Node node)
    {
        if (node == null)
            return;

        // Traverse left subtree
        printInorder(node.left);

        // Visit node
        System.out.print(node.data + " ");

        // Traverse right subtree
        printInorder(node.right);
    }
    // Driver Code
    public static void main(String[] args)
    {
        // Build the tree
        Node root = new Node(100);
        root.left = new Node(20);
        root.right = new Node(200);
        root.left.left = new Node(10);
        root.left.right = new Node(30);
        root.right.left = new Node(150);
        root.right.right = new Node(300);

        // Function call
        System.out.print("Inorder Traversal: ");
        printInorder(root);
    }
}

// This code is contributed by Rohit Pradhan
```
```python
# Python3 code to implement the approach

# Class describing a node of tree
class Node:
    def __init__(self, v):
        self.left = None
        self.right = None
        self.data = v

# Inorder Traversal
def printInorder(root):
    if root:
        # Traverse left subtree
        printInorder(root.left)
        
        # Visit node
        print(root.data,end=" ")
        
        # Traverse right subtree
        printInorder(root.right)

# Driver code
if __name__ == "__main__":
    # Build the tree
    root = Node(100)
    root.left = Node(20)
    root.right = Node(200)
    root.left.left = Node(10)
    root.left.right = Node(30)
    root.right.left = Node(150)
    root.right.right = Node(300)

    # Function call
    print("Inorder Traversal:",end=" ")
    printInorder(root)

    # This code is contributed by ajaymakvana.
```
```csharp
// Include namespace system
using System;


// Class describing a node of tree
public class Node
{
    public int data;
    public Node left;
    public Node right;
    public Node(int v)
    {
        this.data = v;
        this.left = this.right = null;
    }
}
public class GFG
{
    // Inorder Traversal
    public static void printInorder(Node node)
    {
        if (node == null)
        {
            return;
        }
        // Traverse left subtree
        GFG.printInorder(node.left);
        // Visit node
        Console.Write(node.data.ToString() + " ");
        // Traverse right subtree
        GFG.printInorder(node.right);
    }
    // Driver Code
    public static void Main(String[] args)
    {
        // Build the tree
        var root = new Node(100);
        root.left = new Node(20);
        root.right = new Node(200);
        root.left.left = new Node(10);
        root.left.right = new Node(30);
        root.right.left = new Node(150);
        root.right.right = new Node(300);
        // Function call
        Console.Write("Inorder Traversal: ");
        GFG.printInorder(root);
    }
}
```
```javascript
// JavaScript code to implement the approach
class Node {
constructor(v) {
this.left = null;
this.right = null;
this.data = v;
}
}

// Inorder Traversal
function printInorder(root) 
{
if (root) 
{

// Traverse left subtree
printInorder(root.left);

// Visit node
console.log(root.data);

// Traverse right subtree
printInorder(root.right);
}
}

// Driver code
if (true)
{

// Build the tree
let root = new Node(100);
root.left = new Node(20);
root.right = new Node(200);
root.left.left = new Node(10);
root.left.right = new Node(30);
root.right.left = new Node(150);
root.right.right = new Node(300);

// Function call
console.log("Inorder Traversal:");
printInorder(root);
}

// This code is contributed by akashish__
```

```Output
Inorder Traversal: 10 20 30 100 150 200 300 
```

**Time complexity:** O(N), Where N is the number of nodes.  
**Auxiliary Space:** O(h), Where h is the height of tree

### Preorder Traversal
Below is the idea to solve the problem:

> At first visit the **root** then traverse **left subtree** and then traverse the **right subtree**.

Follow the below steps to implement the idea:

-   Visit the root and print the data.
-   Traverse left subtree
-   Traverse the right subtree

Below is the implementation of the preorder traversal.

```cpp
// C++ code to implement the approach

#include <bits/stdc++.h>
using namespace std;

// Class describing a node of tree
class Node {
public:
    int data;
    Node* left;
    Node* right;
    Node(int v)
    {
        this->data = v;
        this->left = this->right = NULL;
    }
};

// Preorder Traversal
void printPreOrder(Node* node)
{
    if (node == NULL)
        return;

    // Visit Node
    cout << node->data << " ";

    // Traverse left subtree
    printPreOrder(node->left);

    // Traverse right subtree
    printPreOrder(node->right);
}

// Driver code
int main()
{
    // Build the tree
    Node* root = new Node(100);
    root->left = new Node(20);
    root->right = new Node(200);
    root->left->left = new Node(10);
    root->left->right = new Node(30);
    root->right->left = new Node(150);
    root->right->right = new Node(300);

    // Function call
    cout << "Preorder Traversal: ";
    printPreOrder(root);
    return 0;
}
```
```java
// Java code to implement the approach
import java.io.*;

// Class describing a node of tree
class Node {

  int data;
  Node left;
  Node right;
  Node(int v)
  {
    this.data = v;
    this.left = this.right = null;
  }
}

class GFG {

  // Preorder Traversal
  public static void printPreorder(Node node)
  {
    if (node == null)
      return;

    // Visit node
    System.out.print(node.data + " ");

    // Traverse left subtree
    printPreorder(node.left);

    // Traverse right subtree
    printPreorder(node.right);
  }

  public static void main(String[] args)
  {
    // Build the tree
    Node root = new Node(100);
    root.left = new Node(20);
    root.right = new Node(200);
    root.left.left = new Node(10);
    root.left.right = new Node(30);
    root.right.left = new Node(150);
    root.right.right = new Node(300);

    // Function call
    System.out.print("Preorder Traversal: ");
    printPreorder(root);
  }
}

// This code is contributed by lokeshmvs21.
```
```python
class Node:
    def __init__(self, v):
        self.data = v
        self.left = None
        self.right = None

# Preorder Traversal
def printPreOrder(node):
    if node is None:
        return
    # Visit Node
    print(node.data, end = " ")

    # Traverse left subtree
    printPreOrder(node.left)

    # Traverse right subtree
    printPreOrder(node.right)

# Driver code
if __name__ == "__main__":
    # Build the tree
    root = Node(100)
    root.left = Node(20)
    root.right = Node(200)
    root.left.left = Node(10)
    root.left.right = Node(30)
    root.right.left = Node(150)
    root.right.right = Node(300)

    # Function call
    print("Preorder Traversal: ", end = "")
    printPreOrder(root)
```
```csharp
// Include namespace system
using System;


// Class describing a node of tree
public class Node
{
    public int data;
    public Node left;
    public Node right;
    public Node(int v)
    {
        this.data = v;
        this.left = this.right = null;
    }
}
public class GFG
{
    // Preorder Traversal
    public static void printPreorder(Node node)
    {
        if (node == null)
        {
            return;
        }
        // Visit node
        Console.Write(node.data.ToString() + " ");
        // Traverse left subtree
        GFG.printPreorder(node.left);
        // Traverse right subtree
        GFG.printPreorder(node.right);
    }
    public static void Main(String[] args)
    {
        // Build the tree
        var root = new Node(100);
        root.left = new Node(20);
        root.right = new Node(200);
        root.left.left = new Node(10);
        root.left.right = new Node(30);
        root.right.left = new Node(150);
        root.right.right = new Node(300);
        // Function call
        Console.Write("Preorder Traversal: ");
        GFG.printPreorder(root);
    }
}
```
```javascript
class Node {
  constructor(v) {
    this.data = v;
    this.left = this.right = null;
  }
}

function printPreOrder(node) {
  if (node == null) return;

  console.log(node.data + " ");

  printPreOrder(node.left);
  printPreOrder(node.right);
}

// Build the tree
let root = new Node(100);
root.left = new Node(20);
root.right = new Node(200);
root.left.left = new Node(10);
root.left.right = new Node(30);
root.right.left = new Node(150);
root.right.right = new Node(300);

console.log("Preorder Traversal: ");
printPreOrder(root);

// This code is contributed by akashish__
```

```Output
Preorder Traversal: 100 20 10 30 200 150 300 
```

**Time complexity:** O(N), Where N is the number of nodes.  
**Auxiliary Space:** O(H), Where H is the height of the tree

### Postorder Traversal
Below is the idea to solve the problem:

> At first traverse **left subtree** then traverse the **right subtree** and then visit the **root**.

Follow the below steps to implement the idea:

-   Traverse left subtree
-   Traverse the right subtree
-   Visit the root and print the data.

Below is the implementation of the postorder traversal:

```cpp
// C++ code to implement the approach

#include <bits/stdc++.h>
using namespace std;

// Class to define structure of a node
class Node {
public:
    int data;
    Node* left;
    Node* right;
    Node(int v)
    {
        this->data = v;
        this->left = this->right = NULL;
    }
};

// PostOrder Traversal
void printPostOrder(Node* node)
{
    if (node == NULL)
        return;

    // Traverse left subtree
    printPostOrder(node->left);

    // Traverse right subtree
    printPostOrder(node->right);

    // Visit node
    cout << node->data << " ";
}

// Driver code
int main()
{
    Node* root = new Node(100);
    root->left = new Node(20);
    root->right = new Node(200);
    root->left->left = new Node(10);
    root->left->right = new Node(30);
    root->right->left = new Node(150);
    root->right->right = new Node(300);

    // Function call
    cout << "PostOrder Traversal: ";
    printPostOrder(root);
    cout << "\\n";

    return 0;
}
```
```java
// Java code to implement the approach
import java.io.*;

// Class describing a node of tree

class GFG {
  
 static class Node {

  int data;
  Node left;
  Node right;
  Node(int v)
  {
    this.data = v;
    this.left = this.right = null;
  }
}

  // Preorder Traversal
  public static void printPostOrder(Node node)
  {
    if (node == null)
      return;

    // Traverse left subtree
    printPostOrder(node.left);

    // Traverse right subtree
    printPostOrder(node.right);
    
      // Visit node
    System.out.print(node.data + " ");
  }

  public static void main(String[] args)
  {
    // Build the tree
    Node root = new Node(100);
    root.left = new Node(20);
    root.right = new Node(200);
    root.left.left = new Node(10);
    root.left.right = new Node(30);
    root.right.left = new Node(150);
    root.right.right = new Node(300);

    // Function call
    System.out.print("PostOrder Traversal: ");
    printPostOrder(root);
  }
}
```
```python
class Node:
    def __init__(self, v):
        self.data = v
        self.left = None
        self.right = None

# Preorder Traversal
def printPostOrder(node):
    if node is None:
        return

    # Traverse left subtree
    printPostOrder(node.left)

    # Traverse right subtree
    printPostOrder(node.right)
    
    # Visit Node
    print(node.data, end = " ")

# Driver code
if __name__ == "__main__":
    # Build the tree
    root = Node(100)
    root.left = Node(20)
    root.right = Node(200)
    root.left.left = Node(10)
    root.left.right = Node(30)
    root.right.left = Node(150)
    root.right.right = Node(300)

    # Function call
    print("Postorder Traversal: ", end = "")
    printPostOrder(root)
```
```csharp
// Include namespace system
using System;


// Class describing a node of tree
public class Node
{
    public int data;
    public Node left;
    public Node right;
    public Node(int v)
    {
        this.data = v;
        this.left = this.right = null;
    }
}
public class GFG
{
    // Preorder Traversal
    public static void printPostOrder(Node node)
    {
        if (node == null)
        {
            return;
        }
        // Traverse left subtree
        GFG.printPostOrder(node.left);
        // Traverse right subtree
        GFG.printPostOrder(node.right);
        // Visit node
        Console.Write(node.data.ToString() + " ");
    }
    public static void Main(String[] args)
    {
        // Build the tree
        var root = new Node(100);
        root.left = new Node(20);
        root.right = new Node(200);
        root.left.left = new Node(10);
        root.left.right = new Node(30);
        root.right.left = new Node(150);
        root.right.right = new Node(300);
        // Function call
        Console.Write("PostOrder Traversal: ");
        GFG.printPostOrder(root);
    }
}
```
```javascript
class Node {
  constructor(v) {
    this.data = v;
    this.left = null;
    this.right = null;
  }
}

// Preorder Traversal
function printPostOrder(node) {
  if (node === null) {
    return;
  }

  // Traverse left subtree
  printPostOrder(node.left);

  // Traverse right subtree
  printPostOrder(node.right);

  // Visit Node
  console.log(node.data, end = " ");
}

// Driver code
// Build the tree
let root = new Node(100);
root.left = new Node(20);
root.right = new Node(200);
root.left.left = new Node(10);
root.left.right = new Node(30);
root.right.left = new Node(150);
root.right.right = new Node(300);

// Function call
console.log("Postorder Traversal: ", end = "");
printPostOrder(root);

// This code is contributed by akashish__
```


```Output
PostOrder Traversal: 10 30 20 150 300 200 100 
```

**Time complexity:** O(N), Where N is the number of nodes.  
**Auxiliary Space:** O(H), Where H is the height of the tree.
> Continue in the following lesson,', 'Traversal Operation in Binary Search Tree', 'Binary Search Tree Part 4: Traversal Operation', 10, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('fdb3b2c3-4d6a-412e-a62b-760b1c20bf05', e'# Basic Operations on BST (additional)

## Minimum and Maximum in BST.
*"In a Binary Search Tree (BST), the node with the  **minimum value**  is always the  **leftmost leaf node**, while the node with the  **maximum value**  is the  **rightmost leaf node**. This property holds because BSTs enforce the invariant that left children are smaller and right children are larger than their parent nodes."*

### Minimum
Given the root of a **Binary Search Tree**. The task is to find the **minimum** valued element in this given **BST**.

**Example:** 

**Input:**

![ex-1](https://media.geeksforgeeks.org/wp-content/uploads/20240924170437/ex-1.webp)

**Output:** **1**  
**Explanation:** **The minimum element in the given BST is 1.**

**Input**:

![ex-2](https://media.geeksforgeeks.org/wp-content/uploads/20240924170436/ex-2.webp)

**Output:** 2  
**Explanation:** The minimum element in the given BST is 2

#### [Naive Approach] Using Inorder Traversal - O(n) Time and O(n) Space

> The idea is to use the property of **BST** which says [inorder traversal of a binary search tree](https://www.geeksforgeeks.org/binary-search-tree-traversal-inorder-preorder-post-order/) always returns the value of nodes in **sorted** order. So the **1st value** in the sorted vector will be the **minimum** value which is the answer.

Below is the implementation of the above approach:

```cpp
// C++ code to find minimum value in BST
// using inorder traversal
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node *left, *right;

    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

// Recursive function to solve and store elements 
// in a vector
void inorder(Node* root, vector<int>& sortedInorder) {
  
    // Base Case
    if (root == nullptr) return;

    // Traverse left subtree
    inorder(root->left, sortedInorder);

    // Store the current node\'s data
    sortedInorder.push_back(root->data);

    // Traverse right subtree
    inorder(root->right, sortedInorder);
}

// Function to find the minimum value in BST
int minValue(Node* root) {
    if (root == nullptr) {
        return -1;
    }
    
    vector<int> sortedInorder;
    
    // Call the recursive inorder function
    inorder(root, sortedInorder);
    
    // Return the first element, which is the minimum
    return sortedInorder[0];
}

int main() {

    // Representation of input binary search tree
    //        5
    //       / \\
    //      4   6
    //     /     \\
    //    3       7
    //   / 
    //  1
    Node* root = new Node(5);
    root->left = new Node(4);
    root->right = new Node(6);
    root->left->left = new Node(3);
    root->right->right = new Node(7);
    root->left->left->left = new Node(1);

    cout << minValue(root) << "\\n";

    return 0;
}
```
```c
// C code to find minimum value in BST
// using inorder traversal
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Recursive function to traverse the tree 
// and store elements in a vector
void inorder(struct Node* root, int *sortedInorder, 
                                          int *index) {
  
    // Base Case
    if (root == NULL) return;

    // Traverse left subtree
    inorder(root->left, sortedInorder, index);

    // Store the current node\'s data
    sortedInorder[(*index)++] = root->data;

    // Traverse right subtree
    inorder(root->right, sortedInorder, index);
}

// Function to find the minimum value in a BST
int minValue(struct Node* root) {
    if (root == NULL) {
        return -1;
    }
    
    // Create an array to hold inorder elements
    int sortedInorder[20000];  
    int index = 0;
    
    // Call the recursive inorder function
    inorder(root, sortedInorder, &index);
    
    // Return the first element, which is the minimum
    return sortedInorder[0];
}

struct Node* createNode(int val) {
    struct Node* node
      = (struct Node*)malloc(sizeof(struct Node));
    node->data = val;
    node->left = node->right = NULL;
    return node;
}

int main() {

    // Representation of input binary search tree
    //        5
    //       / \\
    //      4   6
    //     /     \\
    //    3       7
    //   /
    //  1
    struct Node* root = createNode(5);
    root->left = createNode(4);
    root->right = createNode(6);
    root->left->left = createNode(3);
    root->right->right = createNode(7);
    root->left->left->left = createNode(1);

    printf("%d\\n", minValue(root));

    return 0;
}
```
```java
// Java code to find minimum value in BST
// using inorder traversal
import java.util.ArrayList;

class Node {
    int data;
    Node left, right;

    Node(int val) {
        data = val;
        left = right = null;
    }
}

class GfG {

    static void inorder(Node root, 
                     ArrayList<Integer> sortedInorder) {
      
        // Base Case
        if (root == null) return;

        // Traverse left subtree
        inorder(root.left, sortedInorder);

        // Store the current node\'s data
        sortedInorder.add(root.data);

        // Traverse right subtree
        inorder(root.right, sortedInorder);
    }

    static int minValue(Node root) {
      
        if (root == null) {
            return -1;
        }

        // Create an ArrayList to hold inorder elements
        ArrayList<Integer> sortedInorder 
                                 = new ArrayList<>();

        // Call the recursive inorder function
        inorder(root, sortedInorder);

        // Return the first element, which is the minimum
        return sortedInorder.get(0);
    }

    public static void main(String[] args) {

        // Representation of input binary search tree
        //        5
        //       / \\
        //      4   6
        //     /     \\
        //    3       7
        //   /
        //  1
        Node root = new Node(5);
        root.left = new Node(4);
        root.right = new Node(6);
        root.left.left = new Node(3);
        root.right.right = new Node(7);
        root.left.left.left = new Node(1);

        System.out.println(minValue(root));
    }
}
```
```python
# Python code to find minimum value in BST
# using inorder traversal

class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def inorder(root, sorted_inorder):
  
    # Base Case
    if root is None:
        return

    # Traverse left subtree
    inorder(root.left, sorted_inorder)

    # Store the current node\'s data
    sorted_inorder.append(root.data)

    # Traverse right subtree
    inorder(root.right, sorted_inorder)

def minValue(root):
    if root is None:
        return -1

    # Using a list to hold inorder elements
    sorted_inorder = []  

    # Call the recursive inorder function
    inorder(root, sorted_inorder)

    # Return the first element, which is the minimum
    return sorted_inorder[0]

if __name__ == "__main__":
  
    # Representation of input binary search tree
    #        5
    #       / \\
    #      4   6
    #     /     \\
    #    3       7
    #   /
    #  1
    root = Node(5)
    root.left = Node(4)
    root.right = Node(6)
    root.left.left = Node(3)
    root.right.right = Node(7)
    root.left.left.left = Node(1)

    print(minValue(root))
```
```csharp
// C# code to find minimum value in BST
// using inorder traversal
using System;
using System.Collections.Generic;

class Node {
    public int data;
    public Node left, right;

    public Node(int val) {
        data = val;
        left = right = null;
    }
}

class GfG {

    static void Inorder(Node root, List<int> sortedInorder) {
      
        // Base Case
        if (root == null) return;

        // Traverse left subtree
        Inorder(root.left, sortedInorder);

        // Store the current node\'s data
        sortedInorder.Add(root.data);

        // Traverse right subtree
        Inorder(root.right, sortedInorder);
    }

    static int MinValue(Node root) {
        if (root == null) {
            return -1;
        }

        // Create a list to hold inorder elements
        List<int> sortedInorder = new List<int>();

        // Call the recursive inorder function
        Inorder(root, sortedInorder);

        // Return the first element, which is the minimum
        return sortedInorder[0];
    }

    static void Main(string[] args) {

        // Representation of input binary search tree
        //        5
        //       / \\
        //      4   6
        //     /     \\
        //    3       7
        //   /
        //  1
        Node root = new Node(5);
        root.left = new Node(4);
        root.right = new Node(6);
        root.left.left = new Node(3);
        root.right.right = new Node(7);
        root.left.left.left = new Node(1);

        Console.WriteLine(MinValue(root));
    }
}
```
```javascript
// JavaScript code to find minimum value in BST
// using inorder traversal

class Node {
    constructor(data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
}

function inorder(root, sortedInorder) {
  
    // Base case
    if (root === null) return;

    // Traverse left subtree
    inorder(root.left, sortedInorder);

    // Store the current node\'s data
    sortedInorder.push(root.data);

    // Traverse right subtree
    inorder(root.right, sortedInorder);
}

function minValue(root) {
    if (root === null) {
        return -1;
    }

    // Create an array to hold inorder elements
    let sortedInorder = []; 

    // Call the recursive inorder function
    inorder(root, sortedInorder);

    // Return the first element, which is the minimum
    return sortedInorder[0];
}

// Representation of input binary search tree
//        5
//       / \\
//      4   6
//     /     \\
//    3       7
//   /
//  1
let root = new Node(5);
root.left = new Node(4);
root.right = new Node(6);
root.left.left = new Node(3);
root.right.right = new Node(7);
root.left.left.left = new Node(1);

console.log(minValue(root));
```
**Time Complexity:** O(n), since we traversed through all the elements in a BST.  
**Auxiliary Space:** O(n), we are storing all the n nodes in an array.

#### [Alternate Approach] Using Recursion- O(n) Time and O(n) Space

> The idea is to just traverse the node from **root to left** [recursively](https://www.geeksforgeeks.org/introduction-to-recursion-2/) until left is **NULL**. The **node** whose **left** is **NULL** is the node with the **minimum value.** Please refer to [Find the node with minimum value in a Binary Search Tree using recursion](https://www.geeksforgeeks.org/find-the-node-with-minimum-value-in-a-binary-search-tree-using-recursion/) for implementation.

#### [Expected Approach] Traversing Only Left Edges - O(h) Time and O(1) Space

> The idea is that in a Binary Search Tree **(BST)**, the left child of a node is always smaller than the root. This ensures that the node whose left pointer is **NULL** must hold the **minimum** value in the tree. The leftmost node will always contain the smallest element.

Below is the implementation of the above approach:

```cpp
// C++ code to find minimum value in BST
// using iteration
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node *left, *right;

    Node(int val) {
        data = val;
        left = right = nullptr;
    }
};

int minValue(Node* root) {
  
    // base case
    if (root == nullptr) {
        return -1;
    }

    Node* curr = root;

    // leftmost node is minimum so we move in BST till
    // left node is not nullptr
    while (curr->left != nullptr) {
        curr = curr->left;
    }

    // returning the data at the leftmost node
    return curr->data;
}

int main() {

    // Representation of input binary search tree
    //        5
    //       / \\
    //      4   6
    //     /     \\
    //    3       7
    //   / 
    //  1
    Node* root = new Node(5);
    root->left = new Node(4);
    root->right = new Node(6);
    root->left->left = new Node(3);
    root->right->right = new Node(7);
    root->left->left->left = new Node(1);

    cout << minValue(root) << "\\n";

    return 0;
}
```
```c
// C code to find minimum value in BST
// using iteration
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to find minimum value in BST
int minValue(struct Node* root) {
  
    // base case
    if (root == NULL) {
        return -1;
    }

    struct Node* curr = root;

    // leftmost node is minimum, so move 
    // till left is not NULL
    while (curr->left != NULL) {
        curr = curr->left;
    }

    // returning the data at the leftmost node
    return curr->data;
}

struct Node* createNode(int val) {
    struct Node* node 
            = (struct Node*)malloc(sizeof(struct Node));
    node->data = val;
    node->left = node->right = NULL;
    return node;
}

int main() {

    // Representation of input binary search tree
    //        5
    //       / \\
    //      4   6
    //     /     \\
    //    3       7
    //   /
    //  1
    struct Node* root = createNode(5);
    root->left = createNode(4);
    root->right = createNode(6);
    root->left->left = createNode(3);
    root->right->right = createNode(7);
    root->left->left->left = createNode(1);

    printf("%d\\n", minValue(root));

    return 0;
}
```
```java
// Java code to find minimum value in BST
// using iteration
class Node {
    int data;
    Node left, right;

    Node(int val) {
        data = val;
        left = right = null;
    }
}

public class GfG {

    public static int minValue(Node root) {
      
       // base case
        if (root == null) {
            return -1;
        }

        Node curr = root;

        // leftmost node is minimum, so move till 
        // left is not null
        while (curr.left != null) {
            curr = curr.left;
        }

        // returning the data at the leftmost node
        return curr.data;
    }

    public static void main(String[] args) {

        // Representation of input binary search tree
        //        5
        //       / \\
        //      4   6
        //     /     \\
        //    3       7
        //   /
        //  1
        Node root = new Node(5);
        root.left = new Node(4);
        root.right = new Node(6);
        root.left.left = new Node(3);
        root.right.right = new Node(7);
        root.left.left.left = new Node(1);

        System.out.println(minValue(root));
    }
}
```
```python
# Python code to find minimum value in BST
# using using iterationl
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


# Function to find the minimum value in BST
def minValue(root):
    # base case
    if root is None:
        return -1

    curr = root

    # leftmost node is minimum, so move 
    # till left is not None
    while curr.left is not None:
        curr = curr.left

    # returning the data at the leftmost node
    return curr.data

if __name__ == "__main__":
  
    # Representation of input binary search tree
    #        5
    #       / \\
    #      4   6
    #     /     \\
    #    3       7
    #   /
    #  1
    root = Node(5)
    root.left = Node(4)
    root.right = Node(6)
    root.left.left = Node(3)
    root.right.right = Node(7)
    root.left.left.left = Node(1)

    print(minValue(root))
```
```javascript
// Javascript code to find minimum value in BST
// using iteration
class Node {
    constructor(data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
}

// Function to find the minimum value in BST
function minValue(root) {

    // base case
    if (root === null) {
        return -1;
    }

    let curr = root;

    // leftmost node is minimum, so move till 
    // left is not null
    while (curr.left !== null) {
        curr = curr.left;
    }

    // returning the data at the leftmost node
    return curr.data;
}

// Representation of input binary search tree
//        5
//       / \\
//      4   6
//     /     \\
//    3       7
//   /
//  1
let root = new Node(5);
root.left = new Node(4);
root.right = new Node(6);
root.left.left = new Node(3);
root.right.right = new Node(7);
root.left.left.left = new Node(1);

// Output the minimum value in the BST
console.log(minValue(root));
```
**Time Complexity:** O(h), where **h** is the height of the BST. Worst case happens for left skewed trees, in that case complexity becomes O(n).  
**Auxiliary Space:** O(1), we are not using any extra memory.

### Maximum
*To find the  **maximum value**  in a Binary Search Tree (BST), apply the  **reverse logic**  of finding the minimum: start at the root and traverse  **right**  recursively until reaching a node with no right child. This works because BSTs maintain the invariant that every right subtree contains values greater than the parent node.*

# Application of BST
[Binary Search Tree](https://www.geeksforgeeks.org/binary-search-tree-data-structure/) (BST) is a data structure that is commonly used to implement efficient searching, insertion, and deletion operations along with maintaining sorted sequence of data. Please remember the following properties of BSTs before moving forward.

-   The left subtree of a node contains only nodes with keys lesser than the node\'s key.
-   The right subtree of a node contains only nodes with keys greater than the node\'s key.
-   The left and right subtree each must also be a binary search tree. There must be no duplicate nodes.

![](https://media.geeksforgeeks.org/wp-content/uploads/20230304161652/Untitled.png)


A BST supports operations like search, insert, delete, maximum, minimum, floor, ceil, greater, smaller, etc in O(h) time where h is height of the BST. To keep height less, self balancing BSTs (like [AVL](https://www.geeksforgeeks.org/avl-tree-set-1-insertion/) and [Red Black Trees](https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/)) are used in practice. These Self-Balancing BSTs maintain the height as O(Log n). Therefore all of the above mentioned operations become O(Log n). Together with these, BST also allows sorted order traversal of data in O(n) time.

1.  A Self-Balancing Binary Search Tree is used to maintain sorted stream of data. For example, suppose we are getting online orders placed and we want to maintain the live data (in RAM) in sorted order of prices. For example, we wish to know number of items purchased at cost below a given cost at any moment. Or we wish to know number of items purchased at higher cost than given cost.
2.  A Self-Balancing Binary Search Tree is used to implement [doubly ended priority queue](https://www.geeksforgeeks.org/double-ended-priority-queue/). With a Binary Heap, we can either implement a priority queue with support of extractMin() or with extractMax(). If we wish to support both the operations, we use a Self-Balancing Binary Search Tree to do both in O(Log n)
3.  There are many more algorithm problems where a Self-Balancing BST is the best suited data structure, like [count smaller elements on right](https://www.geeksforgeeks.org/count-smaller-elements-on-right-side/), [Smallest Greater Element on Right Side](https://www.geeksforgeeks.org/smallest-greater-element-on-right-side/), etc.
4.   A BST can be used to sort a large dataset. By inserting the elements of the dataset into a BST and then performing an in-order traversal, the elements will be returned in sorted order. When compared to normal sorting algorithms, the advantage here is, we can later insert / delete items in O(Log n) time.
5.  Variations of BST like B Tree and B+ Tree are used in Database indexing.
6.  **TreeMap** and **TreeSet** in Java, and set and map in C++ are internally implemented using self-balancing BSTs, more formally a Red-Black Tree.
  ', 'Min max Operation and Applications of Binary Search Tree', 'Binary Search Tree Part 5: Find min max, Applications.', 11, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('cf6c4c53-96e5-4a53-a7fe-00e3bb80b35a', e'# What is AVL Tree

An ****AVL tree**** defined as a self-balancing [Binary Search Tree (BST)](https://www.geeksforgeeks.org/binary-search-tree-data-structure/) where the difference between heights of left and right subtrees for any node cannot be more than one.

-   The absolute difference between the heights of the left subtree and the right subtree for any node is known as the ****balance factor**** of the node. The balance factor for all nodes must be less than or equal to 1.
-   Every AVL tree is also a Binary Search Tree (Left subtree values Smaller and Right subtree values greater for every node), but every BST is not AVL Tree. For example, the second diagram below is not an AVL Tree.
-   The main advantage of an AVL Tree is, the time complexities of all operations (search, insert and delete, max, min, floor and ceiling) become O(Log n). This happens because height of an AVL tree is bounded by O(Log n). In case of a normal BST, the height can go up to O(n).
-   An AVL tree maintains its height by doing some extra work during insert and delete operations. It mainly uses rotations to maintain both BST properties and height balance.
-   There exist other self-balancing BSTs also like [Red Black Tree](https://www.geeksforgeeks.org/introduction-to-red-black-tree/). Red Black tree is more complex, but used more in practice as it is less restrictive in terms of left and right subtree height differences.

## Example of an AVL Tree:

The balance factors for different nodes are : 12 :1, 8:1, 18:1, 5:1, 11:0, 17:0 and 4:0. Since all differences are less than or equal to 1, the tree is an AVL tree.

![AVL tree](https://media.geeksforgeeks.org/wp-content/uploads/20221229121830/avl.png)


## Example of a BST which is NOT AVL:

The Below Tree is ****NOT an AVL Tree**** as ****t****he balance factor for nodes 8, 4 and 7 is more than 1.

![BST-Unbalanced](https://media.geeksforgeeks.org/wp-content/uploads/20250222105934276392/BST-Unbalanced.png)

## Characteristics of AVL Tree:

-   It follows the general properties of a Binary Search Tree.
-   Each subtree of the tree is balanced, i.e., the difference between the height of the left and right subtrees is at most 1.
-   The tree balances itself when a new node is inserted. Therefore, the insertion operation is time-consuming

### Maximum & Minimum number of Nodes

**Maximum number of nodes $= 2^{H+1} - 1$**

**Minimum number of nodes of height H = min no of nodes of height $(H-1)$ + min no of nodes of height $(H-2) + 1$**

where $H(0)=1$
$H(1)=2$

## Operations on an AVL Tree:

-   ****Searching**** : It is same as normal Binary Search Tree (BST) as an AVL Tree is always a BST. So we can use the same implementation as BST. The advantage here is time complexity is O(Log n)
-   ****Insertion**** : It does rotations along with normal BST insertion to make sure that the balance factor of the impacted nodes is less than or equal to 1 after insertion
-   ****Deletion**** : It also does rotations along with normal BST deletion to make sure that the balance factor of the impacted nodes is less than or equal to 1 after deletion.

Please refer [Insertion in AVL Tree](https://www.geeksforgeeks.org/insertion-in-an-avl-tree/) and [Deletion in AVL Tree](https://www.geeksforgeeks.org/deletion-in-an-avl-tree/) for details.

## Rotating the subtrees (Used in Insertion and Deletion)

An AVL tree may rotate in one of the following four ways to keep itself balanced while making sure that the BST properties are maintained.

**Left Rotation**

When a node is added into the right subtree of the right subtree, if the tree gets out of balance, we do a single left rotation.

![](https://media.geeksforgeeks.org/wp-content/uploads/20221229131815/avl11-(1)-768.png)


**Right Rotation**

If a node is added to the left subtree of the left subtree, the AVL tree may get out of balance, we do a single right rotation.

![avl-tree](https://media.geeksforgeeks.org/wp-content/uploads/20231102165654/avl-tree.jpg)


**Left-Right Rotation**

A left-right rotation is a combination in which first left rotation takes place after that right rotation executes.

![](https://media.geeksforgeeks.org/wp-content/uploads/20221229131629/avl33-(1)-768.png)


**Right-Left Rotation**

A right-left rotation is a combination in which first right rotation takes place after that left rotation executes.

![](https://media.geeksforgeeks.org/wp-content/uploads/20221229131517/avl44-(1)-768.png)


# Advantages of AVL Tree:

1.  AVL trees can self-balance themselves and therefore provides time complexity as O(Log n) for search, insert and delete.
2.  It is a BST only (with balancing), so items can be traversed in sorted order.
3.  Since the balancing rules are strict compared to [Red Black Tree](https://www.geeksforgeeks.org/introduction-to-red-black-tree/), AVL trees in general have relatively less height and hence the search is faster.
4.  AVL tree is relatively less complex to understand and implement compared to Red Black Trees.

# Disadvantages of AVL Tree:

1.  It is difficult to implement compared to normal BST and easier compared to Red Black
2.  Less used compared to Red-Black trees. Due to its rather strict balance, AVL trees provide complicated insertion and removal operations as more rotations are performed.

# Applications of AVL Tree:

1.  AVL Tree is used as a first example self balancing BST in teaching DSA as it is easier to understand and implement compared to Red Black
2.  Applications, where insertions and deletions are less common but frequent data lookups along with other operations of BST like sorted traversal, floor, ceil, min and max.
3.  Red Black tree is more commonly implemented in language libraries like [map in C++](https://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl/), [set in C++](https://www.geeksforgeeks.org/set-in-cpp-stl/), [TreeMap in Java](https://www.geeksforgeeks.org/treemap-in-java/) and [TreeSet in Java](https://www.geeksforgeeks.org/treeset-in-java-with-examples/).
4.  AVL Trees can be used in a real time environment where predictable and consistent performance is required.
', 'An AVL tree defined as a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees for any node cannot be more than one.', 'AVL Tree Data Structure', 12, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('877da884-998e-4993-974f-b776c33ea748', e'# Delete Operation
**Delete Operation:** The deletion procedure is similar to that of a normal AVL tree without a parent pointer, but in this case, the references to the parent pointers need to be updated with every deletion and rotation accordingly. Follow the steps below to perform the delete operation:

-   [Perform the delete procedure as in a normal BST](https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/).
-   From the node that has been deleted, move towards the root.
-   At each node on the path, update the height of the node.
-   Check for AVL conditions at each node. Let there be 3 nodes: **w, x, y** where **w** is the current node, **x** is the root of the subtree of **w** which has greater height and **y** is the root of the subtree of **x** which has greater height.
-   If the node **w** is unbalanced, there exists one of the following 4 cases:
    -   Left Left Case (**x** is left child of **w** and **y** is left child of **x**)
    -   Left Right Case (**x** is left child of **w** and **y** is right child of **x**)
    -   Right Left Case (**x** is right child of **w** and **y** is left child of **x**)
    -   Right Right Case (**x** is right child of **w** and **y** is right child of **x**)

Below is the implementation of the above approach:

```cpp
// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;

// AVL tree node
struct AVLwithparent {
    struct AVLwithparent* left;
    struct AVLwithparent* right;
    int key;
    struct AVLwithparent* par;
    int height;
};

// Function to print the preorder
// traversal of the AVL tree
void printpreorder(struct AVLwithparent* root)
{
    // Print the node\'s value along
    // with its parent value
    cout << "Node: " << root->key
         << ", Parent Node: ";

    if (root->par != NULL)
        cout << root->par->key << endl;
    else
        cout << "NULL" << endl;

    // Recur to the left subtree
    if (root->left != NULL) {
        printpreorder(root->left);
    }

    // Recur to the right subtree
    if (root->right != NULL) {
        printpreorder(root->right);
    }
}

// Function to update the height of
// a node according to its children\'s
// node\'s heights
void Updateheight(
    struct AVLwithparent* root)
{
    if (root != NULL) {

        // Store the height of the
        // current node
        int val = 1;

        // Store the height of the left
        // and right subtree
        if (root->left != NULL)
            val = root->left->height + 1;

        if (root->right != NULL)
            val = max(
                val, root->right->height + 1);

        // Update the height of the
        // current node
        root->height = val;
    }
}

// Function to handle Left Left Case
struct AVLwithparent* LLR(
    struct AVLwithparent* root)
{
    // Create a reference to the
    // left child
    struct AVLwithparent* tmpnode = root->left;

    // Update the left child of the
    // root to the right child of the
    // current left child of the root
    root->left = tmpnode->right;

    // Update parent pointer of left
    // child of the root node
    if (tmpnode->right != NULL)
        tmpnode->right->par = root;

    // Update the right child of
    // tmpnode to root
    tmpnode->right = root;

    // Update parent pointer of tmpnode
    tmpnode->par = root->par;

    // Update the parent pointer of root
    root->par = tmpnode;

    // Update tmpnode as the left or
    // the right child of its parent
    // pointer according to its key value
    if (tmpnode->par != NULL
        && root->key < tmpnode->par->key) {
        tmpnode->par->left = tmpnode;
    }
    else {
        if (tmpnode->par != NULL)
            tmpnode->par->right = tmpnode;
    }

    // Make tmpnode as the new root
    root = tmpnode;

    // Update the heights
    Updateheight(root->left);
    Updateheight(root->right);
    Updateheight(root);
    Updateheight(root->par);

    // Return the root node
    return root;
}

// Function to handle Right Right Case
struct AVLwithparent* RRR(
    struct AVLwithparent* root)
{
    // Create a reference to the
    // right child
    struct AVLwithparent* tmpnode = root->right;

    // Update the right child of the
    // root as the left child of the
    // current right child of the root
    root->right = tmpnode->left;

    // Update parent pointer of the
    // right child of the root node
    if (tmpnode->left != NULL)
        tmpnode->left->par = root;

    // Update the left child of the
    // tmpnode to root
    tmpnode->left = root;

    // Update parent pointer of tmpnode
    tmpnode->par = root->par;

    // Update the parent pointer of root
    root->par = tmpnode;

    // Update tmpnode as the left or
    // the right child of its parent
    // pointer according to its key value
    if (tmpnode->par != NULL
        && root->key < tmpnode->par->key) {
        tmpnode->par->left = tmpnode;
    }
    else {
        if (tmpnode->par != NULL)
            tmpnode->par->right = tmpnode;
    }

    // Make tmpnode as the new root
    root = tmpnode;

    // Update the heights
    Updateheight(root->left);
    Updateheight(root->right);
    Updateheight(root);
    Updateheight(root->par);

    // Return the root node
    return root;
}

// Function to handle Left Right Case
struct AVLwithparent* LRR(
    struct AVLwithparent* root)
{
    root->left = RRR(root->left);
    return LLR(root);
}

// Function to handle right left case
struct AVLwithparent* RLR(
    struct AVLwithparent* root)
{
    root->right = LLR(root->right);
    return RRR(root);
}

// Function to balance the tree after
// deletion of a node
struct AVLwithparent* Balance(
    struct AVLwithparent* root)
{
    // Store the current height of
    // the left and right subtree
    int firstheight = 0;
    int secondheight = 0;

    if (root->left != NULL)
        firstheight = root->left->height;

    if (root->right != NULL)
        secondheight = root->right->height;

    // If current node is not balanced
    if (abs(firstheight - secondheight) == 2) {
        if (firstheight < secondheight) {

            // Store the height of the
            // left and right subtree
            // of the current node\'s
            // right subtree
            int rightheight1 = 0;
            int rightheight2 = 0;
            if (root->right->right != NULL)
                rightheight2 = root->right->right->height;

            if (root->right->left != NULL)
                rightheight1 = root->right->left->height;

            if (rightheight1 > rightheight2) {

                // Right Left Case
                root = RLR(root);
            }
            else {

                // Right Right Case
                root = RRR(root);
            }
        }
        else {

            // Store the height of the
            // left and right subtree
            // of the current node\'s
            // left subtree
            int leftheight1 = 0;
            int leftheight2 = 0;
            if (root->left->right != NULL)
                leftheight2 = root->left->right->height;

            if (root->left->left != NULL)
                leftheight1 = root->left->left->height;

            if (leftheight1 > leftheight2) {

                // Left Left Case
                root = LLR(root);
            }
            else {

                // Left Right Case
                root = LRR(root);
            }
        }
    }

    // Return the root node
    return root;
}

// Function to insert a node in
// the AVL tree
struct AVLwithparent* Insert(
    struct AVLwithparent* root,
    struct AVLwithparent* parent,
    int key)
{

    if (root == NULL) {

        // Create and assign values
        // to a new node
        root = new struct AVLwithparent;
        if (root == NULL)
            cout << "Error in memory" << endl;
        else {
            root->height = 1;
            root->left = NULL;
            root->right = NULL;
            root->par = parent;
            root->key = key;
        }
    }

    else if (root->key > key) {

        // Recur to the left subtree
        // to insert the node
        root->left = Insert(root->left,
                            root, key);

        // Store the heights of the
        // left and right subtree
        int firstheight = 0;
        int secondheight = 0;

        if (root->left != NULL)
            firstheight = root->left->height;

        if (root->right != NULL)
            secondheight = root->right->height;

        // Balance the tree if the
        // current node is not balanced
        if (abs(firstheight
                - secondheight)
            == 2) {

            if (root->left != NULL
                && key < root->left->key) {

                // Left Left Case
                root = LLR(root);
            }
            else {

                // Left Right Case
                root = LRR(root);
            }
        }
    }

    else if (root->key < key) {

        // Recur to the right subtree
        // to insert the node
        root->right = Insert(root->right,
                             root, key);

        // Store the heights of the left
        // and right subtree
        int firstheight = 0;
        int secondheight = 0;

        if (root->left != NULL)
            firstheight = root->left->height;

        if (root->right != NULL)
            secondheight = root->right->height;

        // Balance the tree if the
        // current node is not balanced
        if (abs(firstheight - secondheight) == 2) {
            if (root->right != NULL
                && key < root->right->key) {

                // Right Left Case
                root = RLR(root);
            }
            else {

                // Right Right Case
                root = RRR(root);
            }
        }
    }

    // Case when given key is
    // already in tree
    else {
    }

    // Update the height of the
    // root node
    Updateheight(root);

    // Return the root node
    return root;
}

// Function to delete a node from
// the AVL tree
struct AVLwithparent* Delete(
    struct AVLwithparent* root,
    int key)
{
    if (root != NULL) {

        // If the node is found
        if (root->key == key) {

            // Replace root with its
            // left child
            if (root->right == NULL
                && root->left != NULL) {
                if (root->par != NULL) {
                    if (root->par->key
                        < root->key)
                        root->par->right = root->left;
                    else
                        root->par->left = root->left;

                    // Update the height
                    // of root\'s parent
                    Updateheight(root->par);
                }

                root->left->par = root->par;

                // Balance the node
                // after deletion
                root->left = Balance(
                    root->left);

                return root->left;
            }

            // Replace root with its
            // right child
            else if (root->left == NULL
                     && root->right != NULL) {
                if (root->par != NULL) {
                    if (root->par->key
                        < root->key)
                        root->par->right = root->right;
                    else
                        root->par->left = root->right;

                    // Update the height
                    // of the root\'s parent
                    Updateheight(root->par);
                }

                root->right->par = root->par;

                // Balance the node after
                // deletion
                root->right = Balance(root->right);
                return root->right;
            }

            // Remove the references of
            // the current node
            else if (root->left == NULL
                     && root->right == NULL) {
                if (root->par->key < root->key) {
                    root->par->right = NULL;
                }
                else {
                    root->par->left = NULL;
                }

                if (root->par != NULL)
                    Updateheight(root->par);

                root = NULL;
                return NULL;
            }

            // Otherwise, replace the
            // current node with its
            // successor and then
            // recursively call Delete()
            else {
                struct AVLwithparent* tmpnode = root;
                tmpnode = tmpnode->right;
                while (tmpnode->left != NULL) {
                    tmpnode = tmpnode->left;
                }

                int val = tmpnode->key;

                root->right
                    = Delete(root->right, tmpnode->key);

                root->key = val;

                // Balance the node
                // after deletion
                root = Balance(root);
            }
        }

        // Recur to the right subtree to
        // delete the current node
        else if (root->key < key) {
            root->right = Delete(root->right, key);

            root = Balance(root);
        }

        // Recur into the right subtree
        // to delete the current node
        else if (root->key > key) {
            root->left = Delete(root->left, key);

            root = Balance(root);
        }

        // Update height of the root
        if (root != NULL) {
            Updateheight(root);
        }
    }

    // Handle the case when the key to be
    // deleted could not be found
    else {
        cout << "Key to be deleted "
             << "could not be found\\n";
    }

    // Return the root node
    return root;
}

// Driver Code
int main()
{
    struct AVLwithparent* root;
    root = NULL;

    // Function call to insert the nodes
    root = Insert(root, NULL, 9);
    root = Insert(root, NULL, 5);
    root = Insert(root, NULL, 10);
    root = Insert(root, NULL, 0);
    root = Insert(root, NULL, 6);

    // Print the tree before deleting node
    cout << "Before deletion:\\n";
    printpreorder(root);

    // Function Call to delete node 10
    root = Delete(root, 10);

    // Print the tree after deleting node
    cout << "After deletion:\\n";
    printpreorder(root);
}
```
```java
// Java program for the above approach
class AVLwithparent {
    AVLwithparent left, right, par;
    int key, height;

    AVLwithparent(int item) {
        key = item;
        height = 1;
    }
}

public class AVLTreeWithParent {

    // Function to print the preorder
    // traversal of the AVL tree
    static void printPreorder(AVLwithparent root) {
        if (root != null) {
            // Print the node\'s value along
            // with its parent value
            System.out.print("Node: " + root.key + ", Parent Node: ");

            if (root.par != null)
                System.out.println(root.par.key);
            else
                System.out.println("NULL");

            // Recur to the left subtree
            printPreorder(root.left);

            // Recur to the right subtree
            printPreorder(root.right);
        }
    }

    // Function to update the height of
    // a node according to its children\'s
    // node\'s heights
    static void updateHeight(AVLwithparent root) {
        if (root != null) {
            // Store the height of the
            // current node
            int val = 1;

            // Store the height of the left
            // and right subtree
            if (root.left != null)
                val = root.left.height + 1;

            if (root.right != null)
                val = Math.max(val, root.right.height + 1);

            // Update the height of the
            // current node
            root.height = val;
        }
    }

    // Function to handle Left Left Case
    static AVLwithparent LLR(AVLwithparent root) {
        // Create a reference to the
        // left child
        AVLwithparent tmpnode = root.left;

        // Update the left child of the
        // root to the right child of the
        // current left child of the root
        root.left = tmpnode.right;

        // Update parent pointer of left
        // child of the root node
        if (tmpnode.right != null)
            tmpnode.right.par = root;

        // Update the right child of
        // tmpnode to root
        tmpnode.right = root;

        // Update parent pointer of tmpnode
        tmpnode.par = root.par;

        // Update the parent pointer of root
        if (tmpnode.par != null && root.key < tmpnode.par.key)
            tmpnode.par.left = tmpnode;
        else {
            if (tmpnode.par != null)
                tmpnode.par.right = tmpnode;
        }

        // Make tmpnode as the new root
        root = tmpnode;

        // Update the heights
        updateHeight(root.left);
        updateHeight(root.right);
        updateHeight(root);
        updateHeight(root.par);

        // Return the root node
        return root;
    }

    // Function to handle Right Right Case
    static AVLwithparent RRR(AVLwithparent root) {
        // Create a reference to the
        // right child
        AVLwithparent tmpnode = root.right;

        // Update the right child of the
        // root as the left child of the
        // current right child of the root
        root.right = tmpnode.left;

        // Update parent pointer of the
        // right child of the root node
        if (tmpnode.left != null)
            tmpnode.left.par = root;

        // Update the left child of the
        // tmpnode to root
        tmpnode.left = root;

        // Update parent pointer of tmpnode
        tmpnode.par = root.par;

        // Update the parent pointer of root
        if (tmpnode.par != null && root.key < tmpnode.par.key)
            tmpnode.par.left = tmpnode;
        else {
            if (tmpnode.par != null)
                tmpnode.par.right = tmpnode;
        }

        // Make tmpnode as the new root
        root = tmpnode;

        // Update the heights
        updateHeight(root.left);
        updateHeight(root.right);
        updateHeight(root);
        updateHeight(root.par);

        // Return the root node
        return root;
    }

    // Function to handle Left Right Case
    static AVLwithparent LRR(AVLwithparent root) {
        root.left = RRR(root.left);
        return LLR(root);
    }

    // Function to handle right left case
    static AVLwithparent RLR(AVLwithparent root) {
        root.right = LLR(root.right);
        return RRR(root);
    }

    // Function to balance the tree after
    // deletion of a node
    static AVLwithparent balance(AVLwithparent root) {
        // Store the current height of
        // the left and right subtree
        int firstheight = 0;
        int secondheight = 0;

        if (root.left != null)
            firstheight = root.left.height;

        if (root.right != null)
            secondheight = root.right.height;

        // If current node is not balanced
        if (Math.abs(firstheight - secondheight) == 2) {
            if (firstheight < secondheight) {
                // Store the height of the
                // left and right subtree
                // of the current node\'s
                // right subtree
                int rightheight1 = 0;
                int rightheight2 = 0;
                if (root.right.right != null)
                    rightheight2 = root.right.right.height;

                if (root.right.left != null)
                    rightheight1 = root.right.left.height;

                if (rightheight1 > rightheight2) {
                    // Right Left Case
                    root = RLR(root);
                } else {
                    // Right Right Case
                    root = RRR(root);
                }
            } else {
                // Store the height of the
                // left and right subtree
                // of the current node\'s
                // left subtree
                int leftheight1 = 0;
                int leftheight2 = 0;
                if (root.left.right != null)
                    leftheight2 = root.left.right.height;

                if (root.left.left != null)
                    leftheight1 = root.left.left.height;

                if (leftheight1 > leftheight2) {
                    // Left Left Case
                    root = LLR(root);
                } else {
                    // Left Right Case
                    root = LRR(root);
                }
            }
        }

        // Return the root node
        return root;
    }

    // Function to insert a node in
    // the AVL tree
    static AVLwithparent insert(AVLwithparent root, AVLwithparent parent, int key) {
        if (root == null) {
            // Create and assign values
            // to a new node
            root = new AVLwithparent(key);
            if (root == null)
                System.out.println("Error in memory");
            else {
                root.height = 1;
                root.left = null;
                root.right = null;
                root.par = parent;
            }
        } else if (root.key > key) {
            // Recur to the left subtree
            // to insert the node
            root.left = insert(root.left, root, key);

            // Store the heights of the
            // left and right subtree
            int firstheight = 0;
            int secondheight = 0;

            if (root.left != null)
                firstheight = root.left.height;

            if (root.right != null)
                secondheight = root.right.height;

            // Balance the tree if the
            // current node is not balanced
            if (Math.abs(firstheight - secondheight) == 2) {
                if (root.left != null && key < root.left.key) {
                    // Left Left Case
                    root = LLR(root);
                } else {
                    // Left Right Case
                    root = LRR(root);
                }
            }
        } else if (root.key < key) {
            // Recur to the right subtree
            // to insert the node
            root.right = insert(root.right, root, key);

            // Store the heights of the left
            // and right subtree
            int firstheight = 0;
            int secondheight = 0;

            if (root.left != null)
                firstheight = root.left.height;

            if (root.right != null)
                secondheight = root.right.height;

            // Balance the tree if the
            // current node is not balanced
            if (Math.abs(firstheight - secondheight) == 2) {
                if (root.right != null && key < root.right.key) {
                    // Right Left Case
                    root = RLR(root);
                } else {
                    // Right Right Case
                    root = RRR(root);
                }
            }
        }

        // Case when given key is
        // already in tree
        // Do nothing

        // Update the height of the
        // root node
        updateHeight(root);

        // Return the root node
        return root;
    }

    // Function to delete a node from
    // the AVL tree
    static AVLwithparent delete(AVLwithparent root, int key) {
        if (root != null) {
            // If the node is found
            if (root.key == key) {
                // Replace root with its
                // left child
                if (root.right == null && root.left != null) {
                    if (root.par != null) {
                        if (root.par.key < root.key)
                            root.par.right = root.left;
                        else
                            root.par.left = root.left;

                        // Update the height
                        // of root\'s parent
                        updateHeight(root.par);
                    }

                    root.left.par = root.par;

                    // Balance the node
                    // after deletion
                    root.left = balance(root.left);
                    return root.left;
                }
                // Replace root with its
                // right child
                else if (root.left == null && root.right != null) {
                    if (root.par != null) {
                        if (root.par.key < root.key)
                            root.par.right = root.right;
                        else
                            root.par.left = root.right;

                        // Update the height
                        // of the root\'s parent
                        updateHeight(root.par);
                    }

                    root.right.par = root.par;

                    // Balance the node after
                    // deletion
                    root.right = balance(root.right);
                    return root.right;
                }
                // Remove the references of
                // the current node
                else if (root.left == null && root.right == null) {
                    if (root.par.key < root.key) {
                        root.par.right = null;
                    } else {
                        root.par.left = null;
                    }

                    if (root.par != null)
                        updateHeight(root.par);

                    root = null;
                    return null;
                }
                // Otherwise, replace the
                // current node with its
                // successor and then
                // recursively call delete()
                else {
                    AVLwithparent tmpnode = root;
                    tmpnode = tmpnode.right;
                    while (tmpnode.left != null) {
                        tmpnode = tmpnode.left;
                    }

                    int val = tmpnode.key;

                    root.right = delete(root.right, tmpnode.key);

                    root.key = val;

                    // Balance the node
                    // after deletion
                    root = balance(root);
                }
            }

            // Recur to the right subtree to
            // delete the current node
            else if (root.key < key) {
                root.right = delete(root.right, key);

                root = balance(root);
            }

            // Recur into the right subtree
            // to delete the current node
            else if (root.key > key) {
                root.left = delete(root.left, key);

                root = balance(root);
            }

            // Update height of the root
            if (root != null) {
                updateHeight(root);
            }
        }

        // Handle the case when the key to be
        // deleted could not be found
        else {
            System.out.println("Key to be deleted could not be found");
        }

        // Return the root node
        return root;
    }

    // Driver Code
    public static void main(String[] args) {
        AVLwithparent root = null;

        // Function call to insert the nodes
        root = insert(root, null, 9);
        root = insert(root, null, 5);
        root = insert(root, null, 10);
        root = insert(root, null, 0);
        root = insert(root, null, 6);

        // Print the tree before deleting node
        System.out.println("Before deletion:");
        printPreorder(root);

        // Function Call to delete node 10
        root = delete(root, 10);

        // Print the tree after deleting node
        System.out.println("After deletion:");
        printPreorder(root);
    }
}
```
```python
class AVLwithparent:
    def __init__(self, key, parent=None):
        self.left = None
        self.right = None
        self.key = key
        self.par = parent
        self.height = 1


def print_preorder(root):
    if root:
        print("Node:", root.key, ", Parent Node:", root.par.key if root.par else "NULL")
        print_preorder(root.left)
        print_preorder(root.right)


def update_height(root):
    if root:
        val = 1
        if root.left:
            val = root.left.height + 1
        if root.right:
            val = max(val, root.right.height + 1)
        root.height = val


def llr(root):
    tmp_node = root.left
    root.left = tmp_node.right
    if tmp_node.right:
        tmp_node.right.par = root
    tmp_node.right = root
    tmp_node.par = root.par
    root.par = tmp_node
    if tmp_node.par and root.key < tmp_node.par.key:
        tmp_node.par.left = tmp_node
    elif tmp_node.par:
        tmp_node.par.right = tmp_node
    root = tmp_node
    update_height(root.left)
    update_height(root.right)
    update_height(root)
    update_height(root.par)
    return root


def rrr(root):
    tmp_node = root.right
    root.right = tmp_node.left
    if tmp_node.left:
        tmp_node.left.par = root
    tmp_node.left = root
    tmp_node.par = root.par
    root.par = tmp_node
    if tmp_node.par and root.key < tmp_node.par.key:
        tmp_node.par.left = tmp_node
    elif tmp_node.par:
        tmp_node.par.right = tmp_node
    root = tmp_node
    update_height(root.left)
    update_height(root.right)
    update_height(root)
    update_height(root.par)
    return root


def lrr(root):
    root.left = rrr(root.left)
    return llr(root)


def rlr(root):
    root.right = llr(root.right)
    return rrr(root)


def balance(root):
    first_height = 0
    second_height = 0
    if root.left:
        first_height = root.left.height
    if root.right:
        second_height = root.right.height
    if abs(first_height - second_height) == 2:
        if first_height < second_height:
            rightheight1 = 0
            rightheight2 = 0
            if root.right.right:
                rightheight2 = root.right.right.height
            if root.right.left:
                rightheight1 = root.right.left.height
            if rightheight1 > rightheight2:
                root = rlr(root)
            else:
                root = rrr(root)
        else:
            leftheight1 = 0
            leftheight2 = 0
            if root.left.right:
                leftheight2 = root.left.right.height
            if root.left.left:
                leftheight1 = root.left.left.height
            if leftheight1 > leftheight2:
                root = llr(root)
            else:
                root = lrr(root)
    return root


def insert(root, parent, key):
    if root is None:
        root = AVLwithparent(key, parent)
    elif root.key > key:
        root.left = insert(root.left, root, key)
        first_height = 0
        second_height = 0
        if root.left:
            first_height = root.left.height
        if root.right:
            second_height = root.right.height
        if abs(first_height - second_height) == 2:
            if root.left and key < root.left.key:
                root = llr(root)
            else:
                root = lrr(root)
    elif root.key < key:
        root.right = insert(root.right, root, key)
        first_height = 0
        second_height = 0
        if root.left:
            first_height = root.left.height
        if root.right:
            second_height = root.right.height
        if abs(first_height - second_height) == 2:
            if root.right and key < root.right.key:
                root = rlr(root)
            else:
                root = rrr(root)
    update_height(root)
    return root


def delete(root, key):
    if root:
        if root.key == key:
            if root.right is None and root.left is not None:
                if root.par:
                    if root.par.key < root.key:
                        root.par.right = root.left
                    else:
                        root.par.left = root.left
                    update_height(root.par)
                root.left.par = root.par
                root.left = balance(root.left)
                return root.left
            elif root.left is None and root.right is not None:
                if root.par:
                    if root.par.key < root.key:
                        root.par.right = root.right
                    else:
                        root.par.left = root.right
                    update_height(root.par)
                root.right.par = root.par
                root.right = balance(root.right)
                return root.right
            elif root.left is None and root.right is None:
                if root.par:
                    if root.par.key < root.key:
                        root.par.right = None
                    else:
                        root.par.left = None
                    update_height(root.par)
                root = None
                return None
            else:
                tmp_node = root
                tmp_node = tmp_node.right
                while tmp_node.left:
                    tmp_node = tmp_node.left
                val = tmp_node.key
                root.right = delete(root.right, tmp_node.key)
                root.key = val
                root = balance(root)
        elif root.key < key:
            root.right = delete(root.right, key)
            root = balance(root)
        elif root.key > key:
            root.left = delete(root.left, key)
            root = balance(root)
        update_height(root)
    return root


# Driver Code
if __name__ == "__main__":
    root = None

    # Function call to insert the nodes
    root = insert(root, None, 9)
    root = insert(root, None, 5)
    root = insert(root, None, 10)
    root = insert(root, None, 0)
    root = insert(root, None, 6)

    # Print the tree before deleting node
    print("Before deletion:")
    print_preorder(root)

    # Function Call to delete node 10
    root = delete(root, 10)

    # Print the tree after deleting node
    print("After deletion:")
    print_preorder(root)
```
```csharp
using System;

// AVL tree node
public class AVLwithparent
{
    public AVLwithparent left;
    public AVLwithparent right;
    public AVLwithparent par;
    public int key;
    public int height;

    public AVLwithparent(int key)
    {
        this.key = key;
        this.height = 1;
    }
}

public class AVLTreeWithParent
{
    // Function to print the preorder traversal of the AVL tree
    public static void PrintPreorder(AVLwithparent root)
    {
        if (root != null)
        {
            // Print the node\'s value along with its parent value
            Console.Write("Node: " + root.key + ", Parent Node: ");
            if (root.par != null)
                Console.WriteLine(root.par.key);
            else
                Console.WriteLine("NULL");

            // Recur to the left subtree
            PrintPreorder(root.left);

            // Recur to the right subtree
            PrintPreorder(root.right);
        }
    }

    // Function to update the height of a node according to its children\'s node\'s heights
    public static void UpdateHeight(AVLwithparent root)
    {
        if (root != null)
        {
            // Store the height of the current node
            int val = 1;

            // Store the height of the left and right subtree
            if (root.left != null)
                val = root.left.height + 1;
            if (root.right != null)
                val = Math.Max(val, root.right.height + 1);

            // Update the height of the current node
            root.height = val;
        }
    }

    // Function to handle Left Left Case
    public static AVLwithparent LLR(AVLwithparent root)
    {
        AVLwithparent tmpnode = root.left;

        root.left = tmpnode.right;
        if (tmpnode.right != null)
            tmpnode.right.par = root;

        tmpnode.right = root;
        tmpnode.par = root.par;

        if (tmpnode.par != null && root.key < tmpnode.par.key)
            tmpnode.par.left = tmpnode;
        else
        {
            if (tmpnode.par != null)
                tmpnode.par.right = tmpnode;
        }

        root.par = tmpnode;

        root = tmpnode;

        UpdateHeight(root.left);
        UpdateHeight(root.right);
        UpdateHeight(root);
        UpdateHeight(root.par);

        return root;
    }

    // Function to handle Right Right Case
    public static AVLwithparent RRR(AVLwithparent root)
    {
        AVLwithparent tmpnode = root.right;

        root.right = tmpnode.left;
        if (tmpnode.left != null)
            tmpnode.left.par = root;

        tmpnode.left = root;
        tmpnode.par = root.par;

        if (tmpnode.par != null && root.key < tmpnode.par.key)
            tmpnode.par.left = tmpnode;
        else
        {
            if (tmpnode.par != null)
                tmpnode.par.right = tmpnode;
        }

        root.par = tmpnode;

        root = tmpnode;

        UpdateHeight(root.left);
        UpdateHeight(root.right);
        UpdateHeight(root);
        UpdateHeight(root.par);

        return root;
    }

    // Function to handle Left Right Case
    public static AVLwithparent LRR(AVLwithparent root)
    {
        root.left = RRR(root.left);
        return LLR(root);
    }

    // Function to handle right left case
    public static AVLwithparent RLR(AVLwithparent root)
    {
        root.right = LLR(root.right);
        return RRR(root);
    }

    // Function to balance the tree after deletion of a node
    public static AVLwithparent Balance(AVLwithparent root)
    {
        int firstheight = 0;
        int secondheight = 0;

        if (root.left != null)
            firstheight = root.left.height;

        if (root.right != null)
            secondheight = root.right.height;

        if (Math.Abs(firstheight - secondheight) == 2)
        {
            if (firstheight < secondheight)
            {
                int rightheight1 = 0;
                int rightheight2 = 0;
                if (root.right.right != null)
                    rightheight2 = root.right.right.height;

                if (root.right.left != null)
                    rightheight1 = root.right.left.height;

                if (rightheight1 > rightheight2)
                    root = RLR(root);
                else
                    root = RRR(root);
            }
            else
            {
                int leftheight1 = 0;
                int leftheight2 = 0;
                if (root.left.right != null)
                    leftheight2 = root.left.right.height;

                if (root.left.left != null)
                    leftheight1 = root.left.left.height;

                if (leftheight1 > leftheight2)
                    root = LLR(root);
                else
                    root = LRR(root);
            }
        }

        return root;
    }

    // Function to insert a node in the AVL tree
    public static AVLwithparent Insert(AVLwithparent root, AVLwithparent parent, int key)
    {
        if (root == null)
        {
            root = new AVLwithparent(key);
            root.par = parent;
        }
        else if (root.key > key)
        {
            root.left = Insert(root.left, root, key);
            if (Math.Abs((root.left != null ? root.left.height : 0) - (root.right != null ? root.right.height : 0)) == 2)
            {
                if (root.left != null && key < root.left.key)
                    root = LLR(root);
                else
                    root = LRR(root);
            }
        }
        else if (root.key < key)
        {
            root.right = Insert(root.right, root, key);
            if (Math.Abs((root.left != null ? root.left.height : 0) - (root.right != null ? root.right.height : 0)) == 2)
            {
                if (root.right != null && key < root.right.key)
                    root = RLR(root);
                else
                    root = RRR(root);
            }
        }

        UpdateHeight(root);
        return root;
    }

    // Function to delete a node from the AVL tree
    public static AVLwithparent Delete(AVLwithparent root, int key)
    {
        if (root != null)
        {
            if (root.key == key)
            {
                if (root.right == null && root.left != null)
                {
                    if (root.par != null)
                    {
                        if (root.par.key < root.key)
                            root.par.right = root.left;
                        else
                            root.par.left = root.left;

                        UpdateHeight(root.par);
                    }

                    root.left.par = root.par;
                    root.left = Balance(root.left);
                    return root.left;
                }
                else if (root.left == null && root.right != null)
                {
                    if (root.par != null)
                    {
                        if (root.par.key < root.key)
                            root.par.right = root.right;
                        else
                            root.par.left = root.right;

                        UpdateHeight(root.par);
                    }

                    root.right.par = root.par;
                    root.right = Balance(root.right);
                    return root.right;
                }
                else if (root.left == null && root.right == null)
                {
                    if (root.par != null)
                    {
                        if (root.par.key < root.key)
                            root.par.right = null;
                        else
                            root.par.left = null;

                        UpdateHeight(root.par);
                    }

                    root = null;
                    return null;
                }
                else
                {
                    AVLwithparent tmpnode = root.right;
                    while (tmpnode.left != null)
                        tmpnode = tmpnode.left;

                    int val = tmpnode.key;
                    root.right = Delete(root.right, tmpnode.key);
                    root.key = val;
                    root = Balance(root);
                }
            }
            else if (root.key < key)
            {
                root.right = Delete(root.right, key);
                root = Balance(root);
            }
            else if (root.key > key)
            {
                root.left = Delete(root.left, key);
                root = Balance(root);
            }

            UpdateHeight(root);
        }
        else
            Console.WriteLine("Key to be deleted could not be found");

        return root;
    }

    // Driver Code
    public static void Main(string[] args)
    {
        AVLwithparent root = null;

        // Function call to insert the nodes
        root = Insert(root, null, 9);
        root = Insert(root, null, 5);
        root = Insert(root, null, 10);
        root = Insert(root, null, 0);
        root = Insert(root, null, 6);

        // Print the tree before deleting node
        Console.WriteLine("Before deletion:");
        PrintPreorder(root);

        // Function Call to delete node 10
        root = Delete(root, 10);

        // Print the tree after deleting node
        Console.WriteLine("After deletion:");
        PrintPreorder(root);
    }
}
//This code is contributed by Utkarsh
```
```javascript
// AVL tree node
class AVLwithparent {
    constructor(key) {
        this.left = null;
        this.right = null;
        this.key = key;
        this.par = null;
        this.height = 1;
    }
}

// Function to print the preorder traversal of the AVL tree
function printpreorder(root) {
    if (root !== null) {
        // Print the node\'s value along with its parent value
        console.log(`Node: ${root.key}, Parent Node: ${root.par ? root.par.key : \'NULL\'}`);

        // Recur to the left subtree
        printpreorder(root.left);

        // Recur to the right subtree
        printpreorder(root.right);
    }
}

// Function to update the height of a node according to its children\'s node\'s heights
function Updateheight(root) {
    if (root !== null) {
        // Store the height of the current node
        let val = 1;

        // Store the height of the left and right subtree
        if (root.left !== null) {
            val = root.left.height + 1;
        }

        if (root.right !== null) {
            val = Math.max(val, root.right.height + 1);
        }

        // Update the height of the current node
        root.height = val;
    }
}

// Function to handle Left Left Case
function LLR(root) {
    // Create a reference to the left child
    const tmpnode = root.left;

    // Update the left child of the root to the right child of the current left child of the root
    root.left = tmpnode.right;

    // Update parent pointer of left child of the root node
    if (tmpnode.right !== null) {
        tmpnode.right.par = root;
    }

    // Update the right child of tmpnode to root
    tmpnode.right = root;

    // Update parent pointer of tmpnode
    tmpnode.par = root.par;

    // Update the parent pointer of root
    root.par = tmpnode;

    // Update tmpnode as the left or the right child of its parent pointer according to its key value
    if (tmpnode.par !== null && root.key < tmpnode.par.key) {
        tmpnode.par.left = tmpnode;
    } else {
        if (tmpnode.par !== null) {
            tmpnode.par.right = tmpnode;
        }
    }

    // Make tmpnode as the new root
    root = tmpnode;

    // Update the heights
    Updateheight(root.left);
    Updateheight(root.right);
    Updateheight(root);
    Updateheight(root.par);

    // Return the root node
    return root;
}

// Function to handle Right Right Case
function RRR(root) {
    // Create a reference to the right child
    const tmpnode = root.right;

    // Update the right child of the root as the left child of the current right child of the root
    root.right = tmpnode.left;

    // Update parent pointer of the right child of the root node
    if (tmpnode.left !== null) {
        tmpnode.left.par = root;
    }

    // Update the left child of the tmpnode to root
    tmpnode.left = root;

    // Update parent pointer of tmpnode
    tmpnode.par = root.par;

    // Update the parent pointer of root
    root.par = tmpnode;

    // Update tmpnode as the left or the right child of its parent pointer according to its key value
    if (tmpnode.par !== null && root.key < tmpnode.par.key) {
        tmpnode.par.left = tmpnode;
    } else {
        if (tmpnode.par !== null) {
            tmpnode.par.right = tmpnode;
        }
    }

    // Make tmpnode as the new root
    root = tmpnode;

    // Update the heights
    Updateheight(root.left);
    Updateheight(root.right);
    Updateheight(root);
    Updateheight(root.par);

    // Return the root node
    return root;
}

// Function to handle Left Right Case
function LRR(root) {
    root.left = RRR(root.left);
    return LLR(root);
}

// Function to handle Right Left Case
function RLR(root) {
    root.right = LLR(root.right);
    return RRR(root);
}

// Function to Balance the tree after deletion of a node
function Balance(root) {
    // Store the current height of the left and right subtree
    let firstheight = 0;
    let secondheight = 0;

    if (root.left !== null) {
        firstheight = root.left.height;
    }

    if (root.right !== null) {
        secondheight = root.right.height;
    }

    // If the current node is not Balanced
    if (Math.abs(firstheight - secondheight) === 2) {
        if (firstheight < secondheight) {
            // Store the height of the left and right subtree of the current node\'s right subtree
            let rightheight1 = 0;
            let rightheight2 = 0;
            if (root.right.right !== null) {
                rightheight2 = root.right.right.height;
            }

            if (root.right.left !== null) {
                rightheight1 = root.right.left.height;
            }

            if (rightheight1 > rightheight2) {
                // Right Left Case
                root = RLR(root);
            } else {
                // Right Right Case
                root = RRR(root);
            }
        } else {
            // Store the height of the left and right subtree of the current node\'s left subtree
            let leftheight1 = 0;
            let leftheight2 = 0;
            if (root.left.right !== null) {
                leftheight2 = root.left.right.height;
            }

            if (root.left.left !== null) {
                leftheight1 = root.left.left.height;
            }

            if (leftheight1 > leftheight2) {
                // Left Left Case
                root = LLR(root);
            } else {
                // Left Right Case
                root = LRR(root);
            }
        }
    }

    // Return the root node
    return root;
}

// Function to Insert a node in the AVL tree
function Insert(root, parent, key) {
    if (root === null) {
        // Create and assign values to a new node
        root = new AVLwithparent(key);
        if (root === null) {
            console.log("Error in memory");
        } else {
            root.par = parent;
        }
    } else if (root.key > key) {
        // Recur to the left subtree to Insert the node
        root.left = Insert(root.left, root, key);

        // Store the heights of the left and right subtree
        let firstheight = 0;
        let secondheight = 0;

        if (root.left !== null) {
            firstheight = root.left.height;
        }

        if (root.right !== null) {
            secondheight = root.right.height;
        }

        // Balance the tree if the current node is not Balanced
        if (Math.abs(firstheight - secondheight) === 2) {
            if (root.left !== null && key < root.left.key) {
                // Left Left Case
                root = LLR(root);
            } else {
                // Left Right Case
                root = LRR(root);
            }
        }
    } else if (root.key < key) {
        // Recur to the right subtree to Insert the node
        root.right = Insert(root.right, root, key);

        // Store the heights of the left and right subtree
        let firstheight = 0;
        let secondheight = 0;

        if (root.left !== null) {
            firstheight = root.left.height;
        }

        if (root.right !== null) {
            secondheight = root.right.height;
        }

        // Balance the tree if the current node is not Balanced
        if (Math.abs(firstheight - secondheight) === 2) {
            if (root.right !== null && key < root.right.key) {
                // Right Left Case
                root = RLR(root);
            } else {
                // Right Right Case
                root = RRR(root);
            }
        }
    }
    // Case when given key is already in tree
    else {
        // Do nothing
    }

    // Update the height of the root node
    Updateheight(root);

    // Return the root node
    return root;
}

// Function to delete a node from the AVL tree
function Delete(root, key) {
    if (root !== null) {
        // If the node is found
        if (root.key === key) {
            // Replace root with its left child
            if (root.right === null && root.left !== null) {
                if (root.par !== null) {
                    if (root.par.key < root.key) {
                        root.par.right = root.left;
                    } else {
                        root.par.left = root.left;
                    }

                    // Update the height of root\'s parent
                    Updateheight(root.par);
                }

                root.left.par = root.par;

                // Balance the node after deletion
                root.left = Balance(root.left);
                return root.left;
            }
            // Replace root with its right child
            else if (root.left === null && root.right !== null) {
                if (root.par !== null) {
                    if (root.par.key < root.key) {
                        root.par.right = root.right;
                    } else {
                        root.par.left = root.right;
                    }

                    // Update the height of the root\'s parent
                    Updateheight(root.par);
                }

                root.right.par = root.par;

                // Balance the node after deletion
                root.right = Balance(root.right);
                return root.right;
            }
            // Delete the references of the current node
            else if (root.left === null && root.right === null) {
                if (root.par.key < root.key) {
                    root.par.right = null;
                } else {
                    root.par.left = null;
                }

                if (root.par !== null) {
                    Updateheight(root.par);
                }

                root = null;
                return null;
            }
            // Otherwise, replace the current node with its successor and then recursively call Delete()
            else {
                let tmpnode = root;
                tmpnode = tmpnode.right;
                while (tmpnode.left !== null) {
                    tmpnode = tmpnode.left;
                }

                let val = tmpnode.key;

                root.right = Delete(root.right, tmpnode.key);

                root.key = val;

                // Balance the node after deletion
                root = Balance(root);
            }
        }
        // Recur to the right subtree to delete the current node
        else if (root.key < key) {
            root.right = Delete(root.right, key);

            root = Balance(root);
        }
        // Recur into the right subtree to delete the current node
        else if (root.key > key) {
            root.left = Delete(root.left, key);

            root = Balance(root);
        }

        // Update height of the root
        if (root !== null) {
            Updateheight(root);
        }
    }
    // Handle the case when the key to be deleted could not be found
    else {
        console.log("Key to be deleted could not be found");
    }

    // Return the root node
    return root;
}

// Driver Code
let root = null;

// Function call to Insert the nodes
root = Insert(root, null, 9);
root = Insert(root, null, 5);
root = Insert(root, null, 10);
root = Insert(root, null, 0);
root = Insert(root, null, 6);

// Print the tree before deleting node
console.log("Before deletion:");
printpreorder(root);

// Function Call to delete node 10
root = Delete(root, 10);

// Print the tree after deleting node
console.log("After deletion:");
printpreorder(root);

// This Code is contributed by Yash Agarwal(yashagarwal2852002)
```

```output
Before deletion:
Node: 9, Parent Node: NULL
Node: 5, Parent Node: 9
Node: 0, Parent Node: 5
Node: 6, Parent Node: 5
Node: 10, Parent Node: 9
After deletion:
Node: 6, Parent Node: NULL
Node: 5, Parent ...
```

**Time Complexity:** O(log N), where N is the number of nodes of the tree  
**Auxiliary Space:** O(1)', 'Implementation Delete Operation for AVL tree.', 'AVL Tree Implementation Part 3: Delete Operation', 15, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('e10c5bbf-61a2-4fb3-a7ef-242026767b46', e'# Search Operation
**Search Operation:** The search operation in an AVL tree with parent pointers is similar to the [search operation in a normal Binary Search Tree](https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/). Follow the steps below to perform search operation:

-   Start from the root node.
-   If the root node is **NULL**, return **false**.
-   Check if the current node\'s value is equal to the value of the node to be searched. If yes, return **true**.
-   If the current node\'s value is less than searched key then recur to the right subtree.
-   If the current node\'s value is greater than searched key then recur to the left subtree.

Below is the implementation of the above approach:

```cpp
// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;

// AVL tree node
struct AVLwithparent {
    struct AVLwithparent* left;
    struct AVLwithparent* right;
    int key;
    struct AVLwithparent* par;
    int height;
};

// Function to update the height of
// a node according to its children\'s
// node\'s heights
void Updateheight(struct AVLwithparent* root)
{
    if (root != NULL) {

        // Store the height of the
        // current node
        int val = 1;

        // Store the height of the left
        // and the right subtree
        if (root->left != NULL)
            val = root->left->height + 1;

        if (root->right != NULL)
            val = max(
                val, root->right->height + 1);

        // Update the height of the
        // current node
        root->height = val;
    }
}

// Function to handle Left Left Case
struct AVLwithparent* LLR(
    struct AVLwithparent* root)
{
    // Create a reference to the
    // left child
    struct AVLwithparent* tmpnode = root->left;

    // Update the left child of the
    // root to the right child of the
    // current left child of the root
    root->left = tmpnode->right;

    // Update parent pointer of the left
    // child of the root node
    if (tmpnode->right != NULL)
        tmpnode->right->par = root;

    // Update the right child of
    // tmpnode to root
    tmpnode->right = root;

    // Update parent pointer of tmpnode
    tmpnode->par = root->par;

    // Update the parent pointer of root
    root->par = tmpnode;

    // Update tmpnode as the left or
    // the right child of its parent
    // pointer according to its key value
    if (tmpnode->par != NULL
        && root->key < tmpnode->par->key) {
        tmpnode->par->left = tmpnode;
    }
    else {
        if (tmpnode->par != NULL)
            tmpnode->par->right = tmpnode;
    }

    // Make tmpnode as the new root
    root = tmpnode;

    // Update the heights
    Updateheight(root->left);
    Updateheight(root->right);
    Updateheight(root);
    Updateheight(root->par);

    // Return the root node
    return root;
}

// Function to handle Right Right Case
struct AVLwithparent* RRR(
    struct AVLwithparent* root)
{
    // Create a reference to the
    // right child
    struct AVLwithparent* tmpnode = root->right;

    // Update the right child of the
    // root as the left child of the
    // current right child of the root
    root->right = tmpnode->left;

    // Update parent pointer of the right
    // child of the root node
    if (tmpnode->left != NULL)
        tmpnode->left->par = root;

    // Update the left child of the
    // tmpnode to root
    tmpnode->left = root;

    // Update parent pointer of tmpnode
    tmpnode->par = root->par;

    // Update the parent pointer of root
    root->par = tmpnode;

    // Update tmpnode as the left or
    // the right child of its parent
    // pointer according to its key value
    if (tmpnode->par != NULL
        && root->key < tmpnode->par->key) {
        tmpnode->par->left = tmpnode;
    }
    else {
        if (tmpnode->par != NULL)
            tmpnode->par->right = tmpnode;
    }

    // Make tmpnode as the new root
    root = tmpnode;

    // Update the heights
    Updateheight(root->left);
    Updateheight(root->right);
    Updateheight(root);
    Updateheight(root->par);

    // Return the root node
    return root;
}

// Function to handle Left Right Case
struct AVLwithparent* LRR(
    struct AVLwithparent* root)
{
    root->left = RRR(root->left);
    return LLR(root);
}

// Function to handle right left case
struct AVLwithparent* RLR(
    struct AVLwithparent* root)
{
    root->right = LLR(root->right);
    return RRR(root);
}

// Function to insert a node in
// the AVL tree
struct AVLwithparent* Insert(
    struct AVLwithparent* root,
    struct AVLwithparent* parent,
    int key)
{

    if (root == NULL) {

        // Create and assign values
        // to a new node
        root = new struct AVLwithparent;
        if (root == NULL) {
            cout << "Error in memory" << endl;
        }

        // Otherwise
        else {
            root->height = 1;
            root->left = NULL;
            root->right = NULL;
            root->par = parent;
            root->key = key;
        }
    }

    else if (root->key > key) {

        // Recur to the left subtree
        // to insert the node
        root->left = Insert(root->left,
                            root, key);

        // Stores the heights of the
        // left and right subtree
        int firstheight = 0;
        int secondheight = 0;

        if (root->left != NULL)
            firstheight = root->left->height;

        if (root->right != NULL)
            secondheight = root->right->height;

        // Balance the tree if the
        // current node is not balanced
        if (abs(firstheight
                - secondheight)
            == 2) {

            if (root->left != NULL
                && key < root->left->key) {

                // Left Left Case
                root = LLR(root);
            }
            else {

                // Left Right Case
                root = LRR(root);
            }
        }
    }

    else if (root->key < key) {

        // Recur to the right subtree
        // to insert the node
        root->right = Insert(root->right, root, key);

        // Store the heights of the left
        // and right subtree
        int firstheight = 0;
        int secondheight = 0;

        if (root->left != NULL)
            firstheight = root->left->height;

        if (root->right != NULL)
            secondheight = root->right->height;

        // Balance the tree if the
        // current node is not balanced
        if (abs(firstheight
                - secondheight)
            == 2) {
            if (root->right != NULL
                && key < root->right->key) {

                // Right Left Case
                root = RLR(root);
            }
            else {

                // Right Right Case
                root = RRR(root);
            }
        }
    }

    // Case when given key is
    // already in tree
    else {
    }

    // Update the height of the
    // root node
    Updateheight(root);

    // Return the root node
    return root;
}

// Function to find a key in AVL tree
bool AVLsearch(
    struct AVLwithparent* root, int key)
{
    // If root is NULL
    if (root == NULL)
        return false;

    // If found, return true
    else if (root->key == key)
        return true;

    // Recur to the left subtree if
    // the current node\'s value is
    // greater than key
    else if (root->key > key) {
        bool val = AVLsearch(root->left, key);
        return val;
    }

    // Otherwise, recur to the
    // right subtree
    else {
        bool val = AVLsearch(root->right, key);
        return val;
    }
}

// Driver Code
int main()
{
    struct AVLwithparent* root;
    root = NULL;

    // Function call to insert the nodes
    root = Insert(root, NULL, 10);
    root = Insert(root, NULL, 20);
    root = Insert(root, NULL, 30);
    root = Insert(root, NULL, 40);
    root = Insert(root, NULL, 50);
    root = Insert(root, NULL, 25);

    // Function call to search for a node
    bool found = AVLsearch(root, 40);
    if (found)
        cout << "value found";
    else
        cout << "value not found";

    return 0;
}
```
```java
class AVLwithparent {
    AVLwithparent left, right, par;
    int key;
    int height;

    // Constructor
    public AVLwithparent(int key, AVLwithparent parent) {
        this.key = key;
        this.par = parent;
        this.height = 1;
    }
}

public class AVLTree {
    // Function to update the height of a node according to its children\'s node\'s heights
    public static void updateHeight(AVLwithparent root) {
        if (root != null) {
            int val = 1;

            if (root.left != null)
                val = root.left.height + 1;

            if (root.right != null)
                val = Math.max(val, root.right.height + 1);

            root.height = val;
        }
    }

    // Function to handle Left Left Case
    public static AVLwithparent llr(AVLwithparent root) {
        AVLwithparent tmpnode = root.left;

        root.left = tmpnode.right;

        if (tmpnode.right != null)
            tmpnode.right.par = root;

        tmpnode.right = root;

        tmpnode.par = root.par;

        if (tmpnode.par != null && root.key < tmpnode.par.key)
            tmpnode.par.left = tmpnode;
        else {
            if (tmpnode.par != null)
                tmpnode.par.right = tmpnode;
        }

        root = tmpnode;

        updateHeight(root.left);
        updateHeight(root.right);
        updateHeight(root);
        updateHeight(root.par);

        return root;
    }

    // Function to handle Right Right Case
    public static AVLwithparent rrr(AVLwithparent root) {
        AVLwithparent tmpnode = root.right;

        root.right = tmpnode.left;

        if (tmpnode.left != null)
            tmpnode.left.par = root;

        tmpnode.left = root;

        tmpnode.par = root.par;

        if (tmpnode.par != null && root.key < tmpnode.par.key)
            tmpnode.par.left = tmpnode;
        else {
            if (tmpnode.par != null)
                tmpnode.par.right = tmpnode;
        }

        root = tmpnode;

        updateHeight(root.left);
        updateHeight(root.right);
        updateHeight(root);
        updateHeight(root.par);

        return root;
    }

    // Function to handle Left Right Case
    public static AVLwithparent lrr(AVLwithparent root) {
        root.left = rrr(root.left);
        return llr(root);
    }

    // Function to handle right left case
    public static AVLwithparent rlr(AVLwithparent root) {
        root.right = llr(root.right);
        return rrr(root);
    }

    // Function to insert a node in the AVL tree
    public static AVLwithparent insert(AVLwithparent root, AVLwithparent parent, int key) {
        if (root == null) {
            root = new AVLwithparent(key, parent);
        } else if (root.key > key) {
            root.left = insert(root.left, root, key);

            int firstHeight = (root.left != null) ? root.left.height : 0;
            int secondHeight = (root.right != null) ? root.right.height : 0;

            if (Math.abs(firstHeight - secondHeight) == 2) {
                if (root.left != null && key < root.left.key)
                    root = llr(root);
                else
                    root = lrr(root);
            }
        } else if (root.key < key) {
            root.right = insert(root.right, root, key);

            int firstHeight = (root.left != null) ? root.left.height : 0;
            int secondHeight = (root.right != null) ? root.right.height : 0;

            if (Math.abs(firstHeight - secondHeight) == 2) {
                if (root.right != null && key < root.right.key)
                    root = rlr(root);
                else
                    root = rrr(root);
            }
        }

        updateHeight(root);
        return root;
    }

    // Function to find a key in AVL tree
    public static boolean avlSearch(AVLwithparent root, int key) {
        if (root == null)
            return false;
        else if (root.key == key)
            return true;
        else if (root.key > key)
            return avlSearch(root.left, key);
        else
            return avlSearch(root.right, key);
    }

    // Driver Code
    public static void main(String[] args) {
        AVLwithparent root = null;

        root = insert(root, null, 10);
        root = insert(root, null, 20);
        root = insert(root, null, 30);
        root = insert(root, null, 40);
        root = insert(root, null, 50);
        root = insert(root, null, 25);

        boolean found = avlSearch(root, 40);

        if (found)
            System.out.println("Value found");
        else
            System.out.println("Value not found");
    }
}
```
```python
# Python program for the above approach

# AVL tree node
class AVLwithparent:
    def __init__(self, key, parent=None):
        self.left = None
        self.right = None
        self.key = key
        self.par = parent
        self.height = 1

# Function to update the height of
# a node according to its children\'s
# node\'s heights
def update_height(root):
    if root is not None:

        # Store the height of the
        # current node
        val = 1

        # Store the height of the left
        # and the right subtree
        if root.left is not None:
            val = root.left.height + 1

        if root.right is not None:
            val = max(val, root.right.height + 1)

        # Update the height of the
        # current node
        root.height = val

# Function to handle Left Left Case
def llr(root):
    # Create a reference to the
    # left child
    tmp_node = root.left

    # Update the left child of the
    # root to the right child of the
    # current left child of the root
    root.left = tmp_node.right

    # Update parent pointer of the left
    # child of the root node
    if tmp_node.right is not None:
        tmp_node.right.par = root

    # Update the right child of
    # tmp_node to root
    tmp_node.right = root

    # Update parent pointer of tmp_node
    tmp_node.par = root.par

    # Update the parent pointer of root
    root.par = tmp_node

    # Update tmp_node as the left or
    # the right child of its parent
    # pointer according to its key value
    if tmp_node.par is not None and root.key < tmp_node.par.key:
        tmp_node.par.left = tmp_node
    else:
        if tmp_node.par is not None:
            tmp_node.par.right = tmp_node

    # Make tmp_node as the new root
    root = tmp_node

    # Update the heights
    update_height(root.left)
    update_height(root.right)
    update_height(root)
    update_height(root.par)

    # Return the root node
    return root

# Function to handle Right Right Case
def rrr(root):
    # Create a reference to the
    # right child
    tmp_node = root.right

    # Update the right child of the
    # root as the left child of the
    # current right child of the root
    root.right = tmp_node.left

    # Update parent pointer of the right
    # child of the root node
    if tmp_node.left is not None:
        tmp_node.left.par = root

    # Update the left child of the
    # tmp_node to root
    tmp_node.left = root

    # Update parent pointer of tmp_node
    tmp_node.par = root.par

    # Update the parent pointer of root
    root.par = tmp_node

    # Update tmp_node as the left or
    # the right child of its parent
    # pointer according to its key value
    if tmp_node.par is not None and root.key < tmp_node.par.key:
        tmp_node.par.left = tmp_node
    else:
        if tmp_node.par is not None:
            tmp_node.par.right = tmp_node

    # Make tmp_node as the new root
    root = tmp_node

    # Update the heights
    update_height(root.left)
    update_height(root.right)
    update_height(root)
    update_height(root.par)

    # Return the root node
    return root

# Function to handle Left Right Case
def lrr(root):
    root.left = rrr(root.left)
    return llr(root)

# Function to handle Right Left Case
def rlr(root):
    root.right = llr(root.right)
    return rrr(root)

# Function to insert a node in
# the AVL tree
def insert(root, parent, key):
    if root is None:

        # Create and assign values
        # to a new node
        root = AVLwithparent(key, parent)

    else:
        if root.key > key:

            # Recur to the left subtree
            # to insert the node
            root.left = insert(root.left, root, key)

            # Stores the heights of the
            # left and right subtree
            first_height = 0
            second_height = 0

            if root.left is not None:
                first_height = root.left.height

            if root.right is not None:
                second_height = root.right.height

            # Balance the tree if the
            # current node is not balanced
            if abs(first_height - second_height) == 2:

                if root.left is not None and key < root.left.key:

                    # Left Left Case
                    root = llr(root)
                else:

                    # Left Right Case
                    root = lrr(root)

        elif root.key < key:

            # Recur to the right subtree
            # to insert the node
            root.right = insert(root.right, root, key)

            # Store the heights of the left
            # and right subtree
            first_height = 0
            second_height = 0

            if root.left is not None:
                first_height = root.left.height

            if root.right is not None:
                second_height = root.right.height

            # Balance the tree if the
            # current node is not balanced
            if abs(first_height - second_height) == 2:
                if root.right is not None and key < root.right.key:

                    # Right Left Case
                    root = rlr(root)
                else:

                    # Right Right Case
                    root = rrr(root)

    # Update the height of the
    # root node
    update_height(root)

    # Return the root node
    return root

# Function to find a key in AVL tree
def avl_search(root, key):
    # If root is None
    if root is None:
        return False

    # If found, return True
    elif root.key == key:
        return True

    # Recur to the left subtree if
    # the current node\'s value is
    # greater than key
    elif root.key > key:
        return avl_search(root.left, key)

    # Otherwise, recur to the
    # right subtree
    else:
        return avl_search(root.right, key)

# Driver Code
if __name__ == "__main__":
    root = None

    # Function call to insert the nodes
    root = insert(root, None, 10)
    root = insert(root, None, 20)
    root = insert(root, None, 30)
    root = insert(root, None, 40)
    root = insert(root, None, 50)
    root = insert(root, None, 25)

    # Function call to search for a node
    found = avl_search(root, 40)
    if found:
        print("Value found")
    else:
        print("Value not found")
```

```output
value found
```

***Time Complexity:*** **O(log N), where N is the number of nodes of the tree**  
***Auxiliary Space:*** **O(1)**', 'Implementation Search Operation for AVL tree.', 'AVL Tree Implementation Part 2: Search Operation', 14, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('39944df7-8db0-4d3d-a12d-e09eebfacaaa', e'# Overview
To implement a stack using a singly linked list, we need to ensure that all operations follow the ****LIFO**** (Last In, First Out) principle. This means that the most recently added element is always the first one to be removed. In this approach, we use a singly linked list, where each node contains data and a reference (or link) to the next node.

To manage the stack, we maintain a `top` pointer that always points to the most recent (topmost) node in the stack. The key stack operations—push, pop, and peek can be performed using this `top` pointer.
![](https://media.geeksforgeeks.org/wp-content/uploads/20250320150616836732/Implement-a-stack-using-singly-linked-list-01-.webp)
![Implement-a-stack-using-singly-linked-list-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250320150645289461/Implement-a-stack-using-singly-linked-list-02-.webp)


In the stack Implementation, a stack contains a top pointer. which is the "head" of the stack where pushing and popping items happens at the head of the list. The first node has a null in the link field and second node-link has the first node address in the link field and so on and the last node address is in the "top" pointer.

The main advantage of using a linked list over arrays is that it is possible to implement a stack that can shrink or grow as much as needed. Using an array will put a restriction on the maximum capacity of the array which can lead to stack overflow. Here each new node will be dynamically allocated. so overflow is not possible.

# ****Stack Operations****

-   ****push():**** Insert a new element into the stack (i.e just insert a new element at the beginning of the linked list.)
-   ****pop():**** Return the top element of the Stack (i.e simply delete the first element from the linked list.)
-   ****peek():**** Return the top element.
-   ****display():**** Print all elements in Stack.

## Push Operation

> -   Initialise a node
> -   Update the value of that node by data i.e. ****node->data = data****
> -   Now link this node to the top of the linked list
> -   And update top pointer to the current node



## Pop Operation

> -   First Check whether there is any node present in the linked list or not, if not then return
> -   Otherwise make pointer let say ****temp**** to the top node and move forward the top node by 1 step
> -   Now free this temp node

## Peek Operation

> -   Check if there is any node present or not, if not then return.
> -   Otherwise return the value of top node of the linked list

## Display Operation

> -   Take a ****temp**** node and initialize it with top pointer 
> -   Now start traversing temp till it encounters NULL
> -   Simultaneously print the value of the temp node
## Example code
```C++
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node(int new_data) {
        this->data = new_data;
        this->next = nullptr;
    }
};

class Stack {
    Node* head;

public:
    Stack() { this->head = nullptr; }

    bool isEmpty() {
        return head == nullptr;
    }

    void push(int new_data) {
        Node* new_node = new Node(new_data);
        if (!new_node) {
            cout << "\\nStack Overflow";
        }
        new_node->next = head;
        head = new_node;
    }

    void pop() {
        if (this->isEmpty()) {
            cout << "\\nStack Underflow" << endl;
        } else {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }

    int peek() {
        if (!isEmpty())
            return head->data;
        else {
            cout << "\\nStack is empty";
            return INT_MIN;
        }
    }
};

int main() {
    Stack st;

    st.push(11);
    st.push(22);
    st.push(33);
    st.push(44);

    cout << "Top element is " << st.peek() << endl;

    cout << "Removing two elements..." << endl;
    st.pop();
    st.pop();

    cout << "Top element is " << st.peek() << endl;

    return 0;
}
``` 
```C
// C program to implement a stack using singly linked list
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

// Struct representing a node in the linked list
typedef struct Node {
    int data;
    struct Node* next;
} Node;
Node* createNode(int new_data) {
    Node* new_node = (Node*)malloc(sizeof(Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Struct to implement stack using a singly linked list
typedef struct Stack {
    Node* head;
} Stack;

// Constructor to initialize the stack
void initializeStack(Stack* stack) { stack->head = NULL; }

// Function to check if the stack is empty
int isEmpty(Stack* stack) {
  
    // If head is NULL, the stack is empty
    return stack->head == NULL;
}

// Function to push an element onto the stack
void push(Stack* stack, int new_data) {
  
    // Create a new node with given data
    Node* new_node = createNode(new_data);

    // Check if memory allocation for the new node failed
    if (!new_node) {
        printf("\\nStack Overflow");
        return;
    }

    // Link the new node to the current top node
    new_node->next = stack->head;

    // Update the top to the new node
    stack->head = new_node;
}

// Function to remove the top element from the stack
void pop(Stack* stack) {
  
    // Check for stack underflow
    if (isEmpty(stack)) {
        printf("\\nStack Underflow\\n");
        return;
    }
    else {
      
        // Assign the current top to a temporary variable
        Node* temp = stack->head;

        // Update the top to the next node
        stack->head = stack->head->next;

        // Deallocate the memory of the old top node
        free(temp);
    }
}

// Function to return the top element of the stack
int peek(Stack* stack) {
  
    // If stack is not empty, return the top element
    if (!isEmpty(stack))
        return stack->head->data;
    else {
        printf("\\nStack is empty");
        return INT_MIN;
    }
}

// Driver program to test the stack implementation
int main() {
  
    // Creating a stack
    Stack stack;
    initializeStack(&stack);

    // Push elements onto the stack
    push(&stack, 11);
    push(&stack, 22);
    push(&stack, 33);
    push(&stack, 44);

    // Print top element of the stack
    printf("Top element is %d\\n", peek(&stack));

  
  	// removing two elemements from the top
  	printf("Removing two elements...\\n");
    pop(&stack);
    pop(&stack);

    // Print top element of the stack
    printf("Top element is %d\\n", peek(&stack));

    return 0;
}
``` 
```Java
// Java program to implement a stack using singly linked
// list

// Class representing a node in the linked list
class Node {
    int data;
    Node next;
    Node(int new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // Head of the linked list
    Node head;

    // Constructor to initialize the stack
    Stack() { this.head = null; }

    // Function to check if the stack is empty
    boolean isEmpty() {
      
        // If head is null, the stack is empty
        return head == null;
    }

    // Function to push an element onto the stack
    void push(int new_data) {
      
        // Create a new node with given data
        Node new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (new_node == null) {
            System.out.println("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    void pop() {
      
        // Check for stack underflow
        if (isEmpty()) {
            System.out.println("\\nStack Underflow");
            return;
        }
        else {
          
            // Assign the current top to a temporary
            // variable
            Node temp = head;

            // Update the top to the next node
            head = head.next;

            // Deallocate the memory of the old top node
            temp = null;
        }
    }

    // Function to return the top element of the stack
    int peek() {
      
        // If stack is not empty, return the top element
        if (!isEmpty())
            return head.data;
        else {
            System.out.println("\\nStack is empty");
            return Integer.MIN_VALUE;
        }
    }
}

// Driver code
public class Main {
    public static void main(String[] args)
    {
        // Creating a stack
        Stack st = new Stack();

        // Push elements onto the stack
        st.push(11);
        st.push(22);
        st.push(33);
        st.push(44);

        // Print top element of the stack
        System.out.println("Top element is " + st.peek());

        // removing two elemements from the top
  		System.out.println("Removing two elements...");
        st.pop();
        st.pop();

        // Print top element of the stack
        System.out.println("Top element is " + st.peek());
    }
}
``` 
```Python
# Java program to implement a stack using singly linked
# list

# Class representing a node in the linked list
class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Class to implement stack using a singly linked list
class Stack:
    def __init__(self):

        # head of the linked list
        self.head = None

    # Function to check if the stack is empty
    def is_empty(self):

        # If head is None, the stack is empty
        return self.head is None

    # Function to push an element onto the stack
    def push(self, new_data):

        # Create a new node with given data
        new_node = Node(new_data)

        # Check if memory allocation for the new node failed
        if not new_node:
            print("\\nStack Overflow")
            return

        # Link the new node to the current top node
        new_node.next = self.head

        # Update the top to the new node
        self.head = new_node

    # Function to remove the top element from the stack
    def pop(self):

        # Check for stack underflow
        if self.is_empty():
            print("\\nStack Underflow")
        else:

            # Assign the current top to a temporary variable
            temp = self.head

            # Update the top to the next node
            self.head = self.head.next

            # Deallocate the memory of the old top node
            del temp

    # Function to return the top element of the stack
    def peek(self):

        # If stack is not empty, return the top element
        if not self.is_empty():
            return self.head.data
        else:
            print("\\nStack is empty")
            return float(\'-inf\')


# Creating a stack
st = Stack()

# Push elements onto the stack
st.push(11)
st.push(22)
st.push(33)
st.push(44)

# Print top element of the stack
print("Top element is", st.peek())

# removing two elemements from the top
print("Removing two elements...");
st.pop()
st.pop()

# Print top element of the stack
print("Top element is", st.peek())
```
```C#
// C# program to implement a stack using singly linked list
using System;

// Class representing a node in the linked list
class Node {
    public int data;
    public Node next;
    public Node(int new_data)
    {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // head of the linked list
    private Node head;

    // Constructor to initialize the stack
    public Stack() { this.head = null; }

    // Function to check if the stack is empty
    public bool isEmpty()
    {

        // If head is null, the stack is empty
        return head == null;
    }

    // Function to push an element onto the stack
    public void push(int new_data)
    {

        // Create a new node with given data
        Node new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (new_node == null) {
            Console.WriteLine("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    public void pop()
    {

        // Check for stack underflow
        if (this.isEmpty()) {
            Console.WriteLine("\\nStack Underflow");
        }
        else {

            // Update the top to the next node
            head = head.next;
            /* No need to manually free the memory of the
             * old head in C# */
        }
    }

    // Function to return the top element of the stack
    public int peek()
    {

        // If stack is not empty, return the top element
        if (!isEmpty())
            return head.data;
        else {
            Console.WriteLine("\\nStack is empty");
            return int.MinValue;
        }
    }
}

// Driver program to test the stack implementation
class GfG {
    static void Main(string[] args)
    {

        // Creating a stack
        Stack st = new Stack();

        // Push elements onto the stack
        st.push(11);
        st.push(22);
        st.push(33);
        st.push(44);

        // Print top element of the stack
        Console.WriteLine("Top element is " + st.peek());

        // removing two elemements from the top
  		Console.WriteLine("Removing two elements...");
        st.pop();
        st.pop();

        // Print top element of the stack
        Console.WriteLine("Top element is " + st.peek());
    }
}
``` 
```JavaScript
// Javascript program to implement a stack using singly
// linked list

// Class representing a node in the linked list
class Node {
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // Constructor to initialize the stack
    constructor() { this.head = null; }

    // Function to check if the stack is empty
    isEmpty() {
    
        // If head is null, the stack is empty
        return this.head === null;
    }

    // Function to push an element onto the stack
    push(new_data) {
    
        // Create a new node with given data
        const new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (!new_node) {
            console.log("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = this.head;

        // Update the top to the new node
        this.head = new_node;
    }

    // Function to remove the top element from the stack
    pop() {
    
        // Check for stack underflow
        if (this.isEmpty()) {
            console.log("\\nStack Underflow");
        }
        else {
        
            // Assign the current top to a temporary
            // variable
            let temp = this.head;

            // Update the top to the next node
            this.head = this.head.next;

            // Deallocate the memory of the old top node
            temp = null;
        }
    }

    // Function to return the top element of the stack
    peek() {
    
        // If stack is not empty, return the top element
        if (!this.isEmpty())
            return this.head.data;
        else {
            console.log("\\nStack is empty");
            return Number.MIN_VALUE;
        }
    }
}

// Driver program to test the stack implementation
const st = new Stack();

// Push elements onto the stack
st.push(11);
st.push(22);
st.push(33);
st.push(44);

// Print top element of the stack
console.log("Top element is " + st.peek());

// removing two elemements from the top
console.log("Removing two elements...");
st.pop();
st.pop();

// Print top element of the stack
console.log("Top element is " + st.peek());
```

```output
Top element is 44
Removing two elements...
Top element is 22
```

****Time Complexity:**** O(1), for all push(), pop(), and peek(), as we are not performing any kind of traversal over the list.  
****Auxiliary Space:**** O(n), where n is the size of the stack

# Benefits of implementing a stack using a singly linked list

-   ****Dynamic memory allocation****: The size of the stack can be increased or decreased dynamically by adding or removing nodes from the linked list, without the need to allocate a fixed amount of memory for the stack upfront.
-   ****Efficient memory usage:**** Since nodes in a singly linked list only have a next pointer and not a prev pointer, they use less memory than nodes in a doubly linked list.
-   ****Easy implementation****: Implementing a stack using a singly linked list is straightforward and can be done using just a few lines of code.
-   ****Versatile****: Singly linked lists can be used to implement other data structures such as queues, linked lists, and trees.

# Real time examples of stack

Stacks are used in various real-world scenarios where a last-in, first-out (LIFO) data structure is required. Here are some examples of real-time applications of stacks:

-   ****Function Call Stack:**** When a function is called, its return address and parameters are pushed onto the stack. The stack ensures functions execute and return in reverse order..
-   ****Undo/Redo Operations:**** In apps like text or image editors, actions are pushed onto a stack. Undo removes the last action, while redo restores it.
-   ****Browser History:**** Browsers use stacks to track visited pages. Visiting a page pushes its URL onto the stack, and the "Back" button pops the last URL to go to the previous page.
-   ****Expression Evaluation:**** In compilers, expressions are converted to postfix notation and evaluated using a stack.
-   ****Call Stack in Recursion:**** Recursive function calls are pushed onto the stack. Once recursion ends, the stack is popped to return to the previous function call.', 'We are going to implement a stack using a singly linked list.', 'Implement a stack using singly linked list', 13, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('86b60543-2809-4779-a1f3-bb6d01a8db8b', e'
Given a matrix of size n X m, find the transpose of the matrix.

[Transpose of a matrix](https://www.geeksforgeeks.org/transpose-of-a-matrix/)
is obtained by changing rows to columns and columns to rows. In other words, transpose of mat[n][m] is obtained by changing mat[i][j] to mat[j][i].


****Example:****

> ![matrix-transpose](https://media.geeksforgeeks.org/wp-content/cdn-uploads/matrix-transpose.jpg)


Follow the given steps to solve the problem:


* Run a nested loop using two integer pointers i and j for 0 <= i < n and 0 <= j < m
* Set mat[i][j] equal to mat[j][i]


Below is the implementation of the above approach:


C++

````
#include <iostream>
#include <vector>
using namespace std;

// Function to store the transpose of mat in res
void transpose(vector<vector<int>>& mat, vector<vector<int>>& res) {
    int rows = mat.size();
    int cols = mat[0].size();

    // Resize res to have dimensions swapped
    res.resize(cols, vector<int>(rows));

    // Fill res with transposed values of mat
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            res[j][i] = mat[i][j];
        }
    }
}

// Driver code
int main() {
    vector<vector<int>> mat = {
        { 1, 2, 3 },
        { 4, 5, 6 }
    };

    // Create a result matrix for the transpose
    vector<vector<int>> res;

    // Function call to calculate the transpose
    transpose(mat, res);

    // Print the result matrix
    cout << "Result matrix is:\\n";
    for (auto& row : res) {
        for (auto& elem : row) {
            cout << " " << elem;
        }
        cout << "\\n";
    }

    return 0;
}

````

C

````
// Import necessary libraries
#include <stdio.h>

// Define macros for matrix dimensions
#define M 2  // Number of rows in the original matrix
#define N 3  // Number of columns in the original matrix

// Function to store the transpose of mat in res
void transpose(int mat[M][N], int res[N][M]) {

    // Fill res with transposed values of mat
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            res[j][i] = mat[i][j];
        }
    }
}

// Driver code
int main() {
    int mat[M][N] = {
        { 1, 2, 3 },
        { 4, 5, 6 }
    };

    // Create a result matrix for the transpose
    int res[N][M];

    // Function call to calculate the transpose
    transpose(mat, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            printf("%d ", res[i][j]);
        }
        printf("\\n");
    }
    return 0;
}

````

Java

````
// Import necessary classes
import java.util.Arrays;
import java.util.Scanner;

public class TransposeMatrix {

    // Function to store the transpose of mat in res
    public static void transpose(int[][] mat, int[][] res) {
        int rows = mat.length;
        int cols = mat[0].length;

        // Fill res with transposed values of mat
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                res[j][i] = mat[i][j];
            }
        }
    }

    // Driver code
    public static void main(String[] args) {
        int[][] mat = {
            { 1, 2, 3 },
            { 4, 5, 6 }
        };

        // Create a result matrix for the transpose
        int[][] res = new int[mat[0].length][mat.length];

        // Function call to calculate the transpose
        transpose(mat, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            System.out.println(Arrays.toString(row));
        }
    }
}

````

Python

````
# Function to store the transpose of mat in res
def transpose(mat):

    # Fill res with transposed values of mat
    return [[mat[j][i] for j in range(len(mat))] for i in range(len(mat[0]))]

# Driver code
if __name__ == \'__main__\':
    mat = [
        [1, 2, 3],
        [4, 5, 6]
    ]

    # Function call to calculate the transpose
    res = transpose(mat)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(" ".join(map(str, row)))

````

C#

````
// Function to store the transpose of mat in res
void Transpose(int[][] mat, out int[][] res) {
    int rows = mat.Length;
    int cols = mat[0].Length;

    // Resize res to have dimensions swapped
    res = new int[cols][];
    for (int i = 0; i < cols; i++) {
        res[i] = new int[rows];
    }

    // Fill res with transposed values of mat
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            res[j][i] = mat[i][j];
        }
    }
}

// Driver code
public static void Main() {
    int[][] mat = {
        new int[] { 1, 2, 3 },
        new int[] { 4, 5, 6 }
    };

    // Create a result matrix for the transpose
    int[][] res;

    // Function call to calculate the transpose
    Transpose(mat, out res);

    // Print the result matrix
    Console.WriteLine("Result matrix is:");
    foreach (var row in res) {
        foreach (var elem in row) {
            Console.Write(" " + elem);
        }
        Console.WriteLine();
    }
}

````

JavaScript

````
// Function to store the transpose of mat in res
function transpose(mat) {
    let rows = mat.length;
    let cols = mat[0].length;

    // Create a result matrix for the transpose
    let res = Array.from({ length: cols }, () => new Array(rows));

    // Fill res with transposed values of mat
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[j][i] = mat[i][j];
        }
    }
    return res;
}

// Driver code
let mat = [
    [ 1, 2, 3 ],
    [ 4, 5, 6 ]
];

// Function call to calculate the transpose
let res = transpose(mat);

// Print the result matrix
console.log("Result matrix is:");
for (let row of res) {
    console.log(" "+ row.join(\' \'));
}

````




**Output**
```
Result matrix is
 1 2 3 4
 1 2 3 4
 1 2 3 4
 1 2 3 4

```

****Time complexity:****
O(m x n).



****Auxiliary Space:****
O(m x n)


### ****Approach using constant space for Square Matrix****

**This approach works only for square matrices (i.e., – where no. of rows are equal to the number of columns). This algorithm is also known as an “in-place” algorithm as it uses no extra space to solve the problem.**


Follow the given steps to solve the problem:


* Run a nested loop using two integer pointers i and j for 0 <= i < N and i+1 <= j < N
* Swap mat[i][j] with mat[j][i]


Below is the implementation of the above approach:


C++

````
#include <iostream>
#include <vector>
using namespace std;

// Function to convert mat to its transpose
void transpose(vector<vector<int>>& mat) {
    int n = mat.size();
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(mat[i][j], mat[j][i]);
        }
    }
}

// Driver code
int main() {
    vector<vector<int>> mat = {
        { 1, 1, 1, 1 },
        { 2, 2, 2, 2 },
        { 3, 3, 3, 3 },
        { 4, 4, 4, 4 }
    };

    transpose(mat);

    cout << "Modified matrix is:" << endl;
    for (const auto& row : mat) {
        for (int elem : row) {
            cout << elem << " ";
        }
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#define N 4

// Function to convert mat to its transpose
void transpose(int mat[N][N]) {
    for (int i = 0; i < N; i++) {
        for (int j = i + 1; j < N; j++) {
            int temp = mat[i][j];
            mat[i][j] = mat[j][i];
            mat[j][i] = temp;
        }
    }
}

// Driver code
int main() {
    int mat[N][N] = {
        { 1, 1, 1, 1 },
        { 2, 2, 2, 2 },
        { 3, 3, 3, 3 },
        { 4, 4, 4, 4 }
    };

    transpose(mat);

    printf("Modified matrix is:\\n");
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%d ", mat[i][j]);
        }
        printf("\\n");
    }

    return 0;
}

````

Java

````
import java.util.Arrays;

public class GfG {
    static void transpose(int[][] mat) {
        int n = mat.length;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = mat[i][j];
                mat[i][j] = mat[j][i];
                mat[j][i] = temp;
            }
        }
    }

    // Driver code
    public static void main(String[] args) {
        int[][] mat = {
            { 1, 1, 1, 1 },
            { 2, 2, 2, 2 },
            { 3, 3, 3, 3 },
            { 4, 4, 4, 4 }
        };

        transpose(mat);

        System.out.println("Modified matrix is:");
        for (int[] row : mat) {
            System.out.println(Arrays.toString(row));
        }
    }
}

````

Python

````
# Function to convert mat to its transpose

def transpose(mat):
    n = len(mat)
    for i in range(n):
        for j in range(i + 1, n):
            mat[i][j], mat[j][i] = mat[j][i], mat[i][j]

# Driver code
if __name__ == \'__main__\':
    mat = [
        [1, 1, 1, 1],
        [2, 2, 2, 2],
        [3, 3, 3, 3],
        [4, 4, 4, 4]
    ]

    transpose(mat)

    print("Modified matrix is:")
    for row in mat:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;

class Program {

    // Function to convert mat to its transpose
    static void Transpose(int[,] mat) {
        int n = mat.GetLength(0);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = mat[i, j];
                mat[i, j] = mat[j, i];
                mat[j, i] = temp;
            }
        }
    }

    // Driver code
    static void Main() {
        int[,] mat = {
            { 1, 1, 1, 1 },
            { 2, 2, 2, 2 },
            { 3, 3, 3, 3 },
            { 4, 4, 4, 4 }
        };

        Transpose(mat);

        Console.WriteLine("Modified matrix is:");
        for (int i = 0; i < mat.GetLength(0); i++) {
            for (int j = 0; j < mat.GetLength(1); j++) {
                Console.Write(mat[i, j] + " ");
            }
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// Function to convert mat to its transpose
function transpose(mat) {
    let n = mat.length;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            [mat[i][j], mat[j][i]] = [mat[j][i], mat[i][j]];
        }
    }
}

// Driver code
const mat = [
    [1, 1, 1, 1],
    [2, 2, 2, 2],
    [3, 3, 3, 3],
    [4, 4, 4, 4]
];

transpose(mat);

console.log("Modified matrix is:");
mat.forEach(row => {
    console.log(row.join(\' \'));
});

````




**Output**
```
Modified matrix is
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4

```

****Time complexity:****
O(n

2
).



****Auxiliary Space:****
O(1)
', '', 'Program to find transpose of a matrix', 9, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('ea4cc83e-26cf-46c3-84f6-5b4086825afb', e'
****Determinant of 2 x 2 Matrix:****
------------------------------------

![](https://media.geeksforgeeks.org/wp-content/uploads/20220822110357/2x2.png)

Determinant of 2 x 2 matrix

****Determinant of 3 x 3 Matrix:****
------------------------------------

![](https://media.geeksforgeeks.org/wp-content/uploads/20220822110402/3x3.png)

Determinant of 3 x 3 matrix

****How to calculate?****
-------------------------


The value of the determinant of a matrix can be calculated by the following procedure:


* For each element of the first row or first column get the cofactor of those elements.
* Then multiply the element with the determinant of the corresponding cofactor.
* Finally, add them with alternate signs. As a base case, the value of the determinant of a 1\\*1 matrix is the single value itself.


The

****cofactor****
of an element is a matrix that we can get by removing the row and column of that element from that matrix.


C++

````
#include <iostream>
#include <vector>
using namespace std;

// Function for finding the determinant of a matrix.
int getDet(vector<vector<int>>& mat, int n) {

    // Base case: if the matrix is 1x1
    if (n == 1) {
        return mat[0][0];
    }

    // Base case for 2x2 matrix
    if (n == 2) {
        return mat[0][0] * mat[1][1] -
               mat[0][1] * mat[1][0];
    }

    // Recursive case for larger matrices
    int res = 0;
    for (int col = 0; col < n; ++col) {

        // Create a submatrix by removing the first
        // row and the current column
        vector<vector<int>> sub(n - 1, vector<int>(n - 1));
        for (int i = 1; i < n; ++i) {
            int subcol = 0;
            for (int j = 0; j < n; ++j) {

                // Skip the current column
                if (j == col) continue;

                // Fill the submatrix
                sub[i - 1][subcol++] = mat[i][j];
            }
        }

        // Cofactor expansion
        int sign = (col % 2 == 0) ? 1 : -1;
        res += sign * mat[0][col] * getDet(sub, n - 1);
    }

    return res;
}

// Driver program to test the above function
int main() {
    vector<vector<int>> mat = { { 1, 0, 2, -1 },
                                 { 3, 0, 0, 5 },
                                 { 2, 1, 4, -3 },
                                 { 1, 0, 5, 0 } };
    cout << getDet(mat, mat.size()) << endl;
    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define N 4

// Function for finding the determinant of a matrix.
int getDet(int mat[N][N], int n) {

    // Base case: if the matrix is 1x1
    if (n == 1) {
        return mat[0][0];
    }

    // Base case for 2x2 matrix
    if (n == 2) {
        return mat[0][0] * mat[1][1] -
               mat[0][1] * mat[1][0];
    }

    // Recursive case for larger matrices
    int res = 0;
    for (int col = 0; col < n; ++col) {

        // Create a submatrix by removing the
        // first row and the current column
        int sub[N][N]; // Submatrix
        for (int i = 1; i < n; ++i) {
            int subcol = 0;
            for (int j = 0; j < n; ++j) {

                // Skip the current column
                if (j == col) continue;

                // Fill the submatrix
                sub[i - 1][subcol++] = mat[i][j];
            }
        }

        // Cofactor expansion
        int sign = (col % 2 == 0) ? 1 : -1;
        res += sign * mat[0][col] * getDet(sub, n - 1);
    }

    return res;
}

// Driver program to test the above function
int main() {
    int mat[N][N] = { { 1, 0, 2, -1 },
                      { 3, 0, 0, 5 },
                      { 2, 1, 4, -3 },
                      { 1, 0, 5, 0 } };
    printf("%d\\n", getDet(mat, N));
    return 0;
}

````

Java

````
// Function for finding the determinant of a matrix.
public class GfG {
    public static int getDet(int[][] mat, int n) {

        // Base case: if the matrix is 1x1
        if (n == 1) {
            return mat[0][0];
        }

        // Base case for 2x2 matrix
        if (n == 2) {
            return mat[0][0] * mat[1][1] -
                   mat[0][1] * mat[1][0];
        }

        // Recursive case for larger matrices
        int res = 0;
        for (int col = 0; col < n; ++col) {

            // Create a submatrix by removing the first
            // row and the current column
            int[][] sub = new int[n - 1][n - 1];
            for (int i = 1; i < n; ++i) {
                int subcol = 0;
                for (int j = 0; j < n; ++j) {

                    // Skip the current column
                    if (j == col) continue;

                    // Fill the submatrix
                    sub[i - 1][subcol++] = mat[i][j];
                }
            }

            // Cofactor expansion
            int sign = (col % 2 == 0) ? 1 : -1;
            res += sign * mat[0][col] * getDet(sub, n - 1);
        }

        return res;
    }

    // Driver program to test the above function
    public static void main(String[] args) {
        int[][] mat = { { 1, 0, 2, -1 },
                         { 3, 0, 0, 5 },
                         { 2, 1, 4, -3 },
                         { 1, 0, 5, 0 } };
        System.out.println(getDet(mat, mat.length));
    }
}

````

Python

````
# Function for finding the determinant of a matrix.
def getDet(mat, n):

    # Base case: if the matrix is 1x1
    if n == 1:
        return mat[0][0]

    # Base case for 2x2 matrix
    if n == 2:
        return mat[0][0] * mat[1][1] - \\
               mat[0][1] * mat[1][0]

    # Recursive case for larger matrices
    res = 0
    for col in range(n):

        # Create a submatrix by removing the first
        # row and the current column
        sub = [[0] * (n - 1) for _ in range(n - 1)]
        for i in range(1, n):
            subcol = 0
            for j in range(n):

                # Skip the current column
                if j == col:
                    continue

                # Fill the submatrix
                sub[i - 1][subcol] = mat[i][j]
                subcol += 1

        # Cofactor expansion
        sign = 1 if col % 2 == 0 else -1
        res += sign * mat[0][col] * getDet(sub, n - 1)

    return res

# Driver program to test the above function
mat = [[1, 0, 2, -1],
       [3, 0, 0, 5],
       [2, 1, 4, -3],
       [1, 0, 5, 0]]
print(getDet(mat, len(mat)))

````

C#

````
// Function for finding the determinant of a matrix.
using System;
using System.Linq;

class Determinant {
    public static int GetDet(int[,] mat, int n) {

        // Base case: if the matrix is 1x1
        if (n == 1) {
            return mat[0, 0];
        }

        // Base case for 2x2 matrix
        if (n == 2) {
            return mat[0, 0] * mat[1, 1] -
                   mat[0, 1] * mat[1, 0];
        }

        // Recursive case for larger matrices
        int res = 0;
        for (int col = 0; col < n; col++) {

            // Create a submatrix by removing the first
            // row and the current column
            int[,] sub = new int[n - 1, n - 1];
            for (int i = 1; i < n; i++) {
                int subcol = 0;
                for (int j = 0; j < n; j++) {

                    // Skip the current column
                    if (j == col) continue;

                    // Fill the submatrix
                    sub[i - 1, subcol++] = mat[i, j];
                }
            }

            // Cofactor expansion
            int sign = (col % 2 == 0) ? 1 : -1;
            res += sign * mat[0, col] * GetDet(sub, n - 1);
        }

        return res;
    }

    // Driver program to test the above function
    static void Main() {
        int[,] mat = { { 1, 0, 2, -1 },
                        { 3, 0, 0, 5 },
                        { 2, 1, 4, -3 },
                        { 1, 0, 5, 0 } };
        Console.WriteLine(GetDet(mat, mat.GetLength(0)));
    }
}

````

JavaScript

````
// Function for finding the determinant of a matrix.
function getDet(mat, n) {

    // Base case: if the matrix is 1x1
    if (n === 1) {
        return mat[0][0];
    }

    // Base case for 2x2 matrix
    if (n === 2) {
        return mat[0][0] * mat[1][1] -
               mat[0][1] * mat[1][0];
    }

    // Recursive case for larger matrices
    let res = 0;
    for (let col = 0; col < n; col++) {

        // Create a submatrix by removing the first
        // row and the current column
        let sub = Array.from({ length: n - 1 }, () => new Array(n - 1));
        for (let i = 1; i < n; i++) {
            let subcol = 0;
            for (let j = 0; j < n; j++) {

                // Skip the current column
                if (j === col) continue;

                // Fill the submatrix
                sub[i - 1][subcol++] = mat[i][j];
            }
        }

        // Cofactor expansion
        let sign = (col % 2 === 0) ? 1 : -1;
        res += sign * mat[0][col] * getDet(sub, n - 1);
    }

    return res;
}

// Driver program to test the above function
let mat = [ [ 1, 0, 2, -1 ],
            [ 3, 0, 0, 5 ],
            [ 2, 1, 4, -3 ],
            [ 1, 0, 5, 0 ] ];
console.log(getDet(mat, mat.length));

````






**Output**
```
Determinant of the matrix is : 30
```

****Time Complexity:****
O(n

4
)



****Space Complexity:****
O(n

2
), Auxiliary space used for storing cofactors.


****Note:****
In the above recursive approach when the size of the matrix is large it consumes more stack size.


Determinant of a Matrix using Determinant properties:
-----------------------------------------------------


We calculates the determinant of an

`N x N`
matrix using Gaussian elimination and a series of transformations that reduce the matrix to upper triangular form.



> * Converting the given matrix into an
>
>   ****upper triangular matrix****
>   using determinant properties
> * The determinant of the upper triangular matrix is the product of all diagonal elements.
> * Iterating every diagonal element and making all the elements down the diagonal as zero using determinant properties
> * If the diagonal element is zero then search for the next non-zero element in the same column.


There exist two cases:


* ****Case 1:****
  If there is no non-zero element. In this case, the determinant of a matrix is zero
* ****Case 2:****
  If there exists a non-zero element there exist two cases
  + ****Case A:****
    If the index is with a respective diagonal row element. Using the determinant properties make all the column elements down to it zero
  + ****Case B:****
    Swap the row with respect to the diagonal element column and continue the

    ****Case A****
    operation.


Below is the implementation of the above approach:


C++

````
#include <iostream>
#include <vector>
#include <cmath> // For pow function
using namespace std;

// Function to get determinant of a matrix
int getDet(vector<vector<int>>& mat) {

    int n = mat.size();

    int num1, num2, det = 1, index, total = 1;

    // Temporary array for storing row
    vector<int> temp(n + 1);

    // Loop for traversing the diagonal elements
    for (int i = 0; i < n; i++) {
        index = i;

        // Finding the index which has non-zero value
        while (index < n && mat[index][i] == 0) {
            index++;
        }

        if (index == n) // If there is no non-zero element
        {
            continue; // The determinant of the matrix is zero
        }
        if (index != i) {

            // Loop for swapping the diagonal element row and index row
            for (int j = 0; j < n; j++) {
                swap(mat[index][j], mat[i][j]);
            }

            // Determinant sign changes when we shift rows
            det *= pow(-1, index - i);
        }

        // Storing the values of diagonal row elements
        for (int j = 0; j < n; j++) {
            temp[j] = mat[i][j];
        }

        // Traversing every row below the diagonal element
        for (int j = i + 1; j < n; j++) {
            num1 = temp[i]; // Value of diagonal element
            num2 = mat[j][i]; // Value of next row element

            // Traversing every column of row and
            // multiplying to every row
            for (int k = 0; k < n; k++) {

                // Making the diagonal element and next row element equal
                mat[j][k] = (num1 * mat[j][k]) - (num2 * temp[k]);
            }
            total *= num1;
        }
    }

    // Multiplying the diagonal elements to get determinant
    for (int i = 0; i < n; i++) {
        det *= mat[i][i];
    }

    return (det / total); // Det(kA)/k = Det(A);
}

// Driver code
int main() {
    vector<vector<int>> mat = {
        { 1, 0, 2, -1 },
        { 3, 0, 0, 5 },
        { 2, 1, 4, -3 },
        { 1, 0, 5, 0 }
    };
    cout << getDet(mat) << endl;
    return 0;
}

````

Java

````
import java.util.Arrays;

public class GfG {

    // Function to get the determinant of a matrix
    static int getDet(int[][] mat) {
        int n = mat.length;

        int num1, num2, det = 1, index, total = 1;

        // Temporary array for storing row
        int[] temp = new int[n + 1];

        // Loop for traversing the diagonal elements
        for (int i = 0; i < n; i++) {
            index = i;

            // Finding the index which has a non-zero value
            while (index < n && mat[index][i] == 0) {
                index++;
            }
            if (index == n) { // If there is no non-zero element
                continue; // The determinant of the matrix is zero
            }
            if (index != i) {

                // Loop for swapping the diagonal element
                // row and index row
                for (int j = 0; j < n; j++) {
                    int tempSwap = mat[index][j];
                    mat[index][j] = mat[i][j];
                    mat[i][j] = tempSwap;
                }
                // Determinant sign changes when we shift rows
                det *= Math.pow(-1, index - i);
            }

            // Storing the values of diagonal row elements
            for (int j = 0; j < n; j++) {
                temp[j] = mat[i][j];
            }
            // Traversing every row below the diagonal element
            for (int j = i + 1; j < n; j++) {
                num1 = temp[i]; // Value of diagonal element
                num2 = mat[j][i]; // Value of next row element

                // Traversing every column of row and multiplying
                // to every row
                for (int k = 0; k < n; k++) {

                    // Making the diagonal element and next row
                    // element equal
                    mat[j][k] = (num1 * mat[j][k]) - (num2 * temp[k]);
                }
                total *= num1;
            }
        }

        // Multiplying the diagonal elements to get determinant
        for (int i = 0; i < n; i++) {
            det *= mat[i][i];
        }

        return (det / total); // Det(kA)/k = Det(A);
    }

    // Driver code
    public static void main(String[] args) {
        int[][] mat = {
            { 1, 0, 2, -1 },
            { 3, 0, 0, 5 },
            { 2, 1, 4, -3 },
            { 1, 0, 5, 0 }
        };
        System.out.println(getDet(mat));
    }
}

````

Python

````
# Python program to find Determinant of a matrix
def getDet(mat):

    n  = len(mat)
    temp = [0]*n  # temporary array for storing row
    total = 1
    det = 1  # initialize result

    # loop for traversing the diagonal elements
    for i in range(0, n):
        index = i  # initialize the index

        # finding the index which has non zero value
        while(index < n and mat[index][i] == 0):
            index += 1

        if(index == n):  # if there is non zero element
            # the determinant of matrix as zero
            continue

        if(index != i):

            # loop for swapping the diagonal element
            # row and index row
            for j in range(0, n):
                mat[index][j], mat[i][j] = mat[i][j], mat[index][j]

            # determinant sign changes when we shift rows
            # go through determinant properties
            det = det*int(pow(-1, index-i))

        # storing the values of diagonal row elements
        for j in range(0, n):
            temp[j] = mat[i][j]

        # traversing every row below the diagonal element
        for j in range(i+1, n):
            num1 = temp[i]     # value of diagonal element
            num2 = mat[j][i]   # value of next row element

            # traversing every column of row
            # and multiplying to every row
            for k in range(0, n):

                # multiplying to make the diagonal
                # element and next row element equal
                mat[j][k] = (num1*mat[j][k]) - (num2*temp[k])

            total = total * num1  # Det(kA)=kDet(A);

    # multiplying the diagonal elements to get determinant
    for i in range(0, n):
        det = det*mat[i][i]

    return int(det/total)  # Det(kA)/k=Det(A);


# Drivers code
if __name__ == "__main__":
    # mat=[[6 1 1][4 -2 5][2 8 7]]

    mat = [[1, 0, 2, -1], [3, 0, 0, 5], [2, 1, 4, -3], [1, 0, 5, 0]]

    print(getDet(mat))

````

C#

````
using System;

class MatrixDeterminant
{
    // Function to get the determinant of a matrix
    static int getDet(int[,] mat)
    {
        int n = mat.GetLength(0);

        int num1, num2, det = 1, index, total = 1;

        // Temporary array for storing row
        int[] temp = new int[n + 1];

        // Loop for traversing the diagonal elements
        for (int i = 0; i < n; i++)
        {
            index = i;

            // Finding the index which has a non-zero value
            while (index < n && mat[index, i] == 0)
            {
                index++;
            }

             // If there is no non-zero element
            if (index == n)
            {
                // The determinant of the matrix is zero
                continue;
            }
            if (index != i)
            {
                // Loop for swapping the diagonal element
                // row and index row
                for (int j = 0; j < n; j++)
                {
                    int tempSwap = mat[index, j];
                    mat[index, j] = mat[i, j];
                    mat[i, j] = tempSwap;
                }

                // Determinant sign changes when we shift rows
                det *= (int)Math.Pow(-1, index - i);
            }

            // Storing the values of diagonal row elements
            for (int j = 0; j < n; j++)
            {
                temp[j] = mat[i, j];
            }

            // Traversing every row below the diagonal element
            for (int j = i + 1; j < n; j++)
            {
                num1 = temp[i]; // Value of diagonal element
                num2 = mat[j, i]; // Value of next row element

                // Traversing every column of row and multiplying
                // to every row
                for (int k = 0; k < n; k++)
                {
                    // Making the diagonal element and next row
                    // element equal
                    mat[j, k] = (num1 * mat[j, k]) - (num2 * temp[k]);
                }
                total *= num1;
            }
        }

        // Multiplying the diagonal elements to get determinant
        for (int i = 0; i < n; i++)
        {
            det *= mat[i, i];
        }

        return (det / total); // Det(kA)/k = Det(A);
    }

    // Driver code
    static void Main()
    {
        int[,] mat = {
            { 1, 0, 2, -1 },
            { 3, 0, 0, 5 },
            { 2, 1, 4, -3 },
            { 1, 0, 5, 0 }
        };
        Console.WriteLine(getDet(mat));
    }
}

````

JavaScript

````
// Function to get the determinant of a matrix
function determinantOfMatrix(mat) {
    const n = mat.length;
    let det = 1;
    let total = 1;

    // Temporary array for storing row
    const temp = new Array(n + 1).fill(0);

    // Loop for traversing the diagonal elements
    for (let i = 0; i < n; i++) {
        let index = i;

        // Finding the index which has a non-zero value
        while (index < n && mat[index][i] === 0) {
            index++;
        }
        if (index === n) {
            continue; // The determinant of the matrix is zero
        }
        if (index !== i) {

            // Swapping the diagonal element row and index row
            for (let j = 0; j < n; j++) {
                [mat[index][j], mat[i][j]] = [mat[i][j], mat[index][j]];
            }

            // Determinant sign changes when we shift rows
            det *= Math.pow(-1, index - i);
        }

        // Storing the values of diagonal row elements
        for (let j = 0; j < n; j++) {
            temp[j] = mat[i][j];
        }

        // Traversing every row below the diagonal element
        for (let j = i + 1; j < n; j++) {
            const num1 = temp[i]; // Value of diagonal element
            const num2 = mat[j][i]; // Value of next row element

            // Traversing every column of row and multiplying
            // to every row
            for (let k = 0; k < n; k++) {

                // Making the diagonal element and next row
                // element equal
                mat[j][k] = (num1 * mat[j][k]) - (num2 * temp[k]);
            }
            total *= num1;
        }
    }

    // Multiplying the diagonal elements to get determinant
    for (let i = 0; i < n; i++) {
        det *= mat[i][i];
    }

    return (det / total); // Det(kA)/k = Det(A);
}

// Driver code
const mat = [
    [1, 0, 2, -1],
    [3, 0, 0, 5],
    [2, 1, 4, -3],
    [1, 0, 5, 0]
];
console.log(determinantOfMatrix(mat));

````




**Output**
```
Determinant of the matrix is : 30
```

****Time complexity:****
O(n

3
)



****Auxiliary Space:****
O(n), Space used for storing row.





****Determinant of a Matrix****
-------------------------------


There is a built-in function or method in

****linalg****
module of

****NumPy****
package in python. It can be called

****numpy.linalg.det(mat)****
which returns the determinant value of the matrix mat passed in the argument.


Python

````
# importing the numpy package
# as np
import numpy as np

def determinant(mat):

    # calling the det() method
    det = np.linalg.det(mat)
    return round(det)

# Driver Code
# declaring the matrix
mat = [[1, 0, 2, -1],
       [3, 0, 0, 5],
       [2, 1, 4, -3],
       [1, 0, 5, 0]]

# Function call
print(\'Determinant of the matrix is:\',
      determinant(mat))

````

****Output:****

```
Determinant of the matrix is: 30
```

****Time Complexity:****
O(n

3
), as the time complexity of np.linalg.det is O(n

3
) for an n x n order matrix.



****Auxiliary Space:****
O(1)
', 'The determinant of a Matrix is defined as a special number that is defined only for square matrices (matrices that have the same number of rows and columns). A determinant is used in many places in calculus and other matrices related to algebra, it actually represents the matrix in terms of a real number which can be used in solving a system of a linear equation and finding the inverse of a matrix.', 'Program to find Determinant of a Matrix', 10, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('9d98daa6-0e42-485d-be16-d4ef0b03c5c6', e'Given a square matrix, find the adjoint and

[inverse](https://www.geeksforgeeks.org/inverse-of-matrix/)
of the matrix. We strongly recommend you to refer

[determinant of matrix](https://www.geeksforgeeks.org/determinant-of-a-matrix/)
as a prerequisite for this.


****Adjoint****
(or Adjugate) of a matrix is the matrix obtained by taking the transpose of the cofactor matrix of a given square matrix is called its Adjoint or Adjugate matrix. The Adjoint of any square matrix ‘A’ (say) is represented as Adj(A).


****Example:****


```
5  -2  2  7
1   0  0  3
-3  1  5  0
3  -1 -9  4
For instance, the cofactor of the top left corner \'5\' is
 + |0   0   3|
...|1   5   0| = 3(1 * -9 - (-1) * 5) = -12.
...|-1 -9   4|
(The minor matrix is formed by deleting the row
 and column of the given entry.)
As another sample, the cofactor of the top row corner \'-2\' is
  -|1   0  3|
...|-3  5  0| = - [1 (20 - 0) - 0 + 3 (27 - 15)] = -56.
...|3  -9  4|
Proceeding like this, we obtain the matrix
[-12  -56   4   4]
[76   208   4   4]
[-60  -82  -2  20]
[-36  -58  -10 12]
Finally, to get the adjoint, just take the previous
matrix\'s transpose:
[-12   76 -60  -36]
[-56  208 -82  -58]
[4     4   -2  -10]
[4     4   20   12]
```

****Important properties:****


Product of a square matrix A with its adjoint yields a diagonal matrix, where each diagonal entry is equal to determinant of A.



i.e.


```
A.adj(A) = det(A).I
I  => Identity matrix of same order as of A.
det(A) => Determinant value of A
```


A non-zero square matrix ‘A’ of order n is said to be

****invertible****
if there exists a unique square matrix ‘B’ of order n such that,


```
A.B = B.A = I
The matrix \'B\' is said to be inverse of \'A\'.
i.e.,  B = A-1
    ```

* adj(AB) = (adj B).(adj A)
* adj( k A) = k

  n-1
  adj(A)
* A

  -1
  = (adj A) / |A|
* (A

  -1
  )

  -1
  = A
* (AB)

  -1
  = B

  -1
  A

  -1

****How to find Adjoint?****



We follow the definition given above.


```
Let A[N][N] be input matrix.
1) Create a matrix adj[N][N] store the adjoint matrix.
2) For every entry A[i][j] in input matrix where 0 <= i < N
                                             and 0 <= j < N.
    a) Find cofactor of A[i][j]
    b) Find sign of entry.  Sign is + if (i+j) is even else
    sign is odd.
    c) Place the cofactor at adj[j][i]
    ```

    ****How to find Inverse?****


    Inverse of a matrix exists only if the matrix is non-singular i.e., determinant should not be 0.



    Using determinant and adjoint, we can easily find the inverse of a square matrix using the below formula,


    ```
    If det(A) != 0
    A-1 = adj(A)/det(A)
    Else
    "Inverse doesn\'t exist"
    ```


    Inverse is used to find the solution to a system of linear equations.


    Below are implementations for finding adjoint and inverse of a matrix.


    C++

    ````
    #include <iostream>
    #include <vector>
    using namespace std;

    // Function to get cofactor of mat[p][q] in cof[][]. n is
    // current dimension of mat[][]
    void getCof(vector<vector<int>>& mat, vector<vector<int>>& cof,
                                            int p, int q, int n) {
        int i = 0, j = 0;
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                if (row != p && col != q) {
                    cof[i][j++] = mat[row][col];
                    if (j == n - 1) {
                        j = 0;
                        i++;
                    }
                }
            }
        }
    }

    // Recursive function for finding determinant
    // of matrix mat of dimension n
    int getDet(vector<vector<int>>& mat, int n) {
        if (n == 1) return mat[0][0];

        int det = 0;

        // To store cofactors
        vector<vector<int>> cof(mat.size(), vector<int>(mat.size()));

        int sign = 1;
        for (int f = 0; f < n; f++) {
            getCof(mat, cof, 0, f, n);
            det += sign * mat[0][f] * getDet(cof, n - 1);
            sign = -sign;
        }
        return det;
    }

    // Function to get adjoint of mat in adj
    void adjoint(vector<vector<int>>& mat, vector<vector<int>>& adj) {
        int n = mat.size();
        if (n == 1) {
            adj[0][0] = 1;
            return;
        }

        int sign = 1;
        vector<vector<int>> cof(n, vector<int>(n));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                getCof(mat, cof, i, j, n);
                sign = ((i + j) % 2 == 0) ? 1 : -1;
                adj[j][i] = sign * getDet(cof, n - 1);
            }
        }
    }

    // Function to calculate and store inverse, returns
    // false if matrix is singular
    bool inverse(vector<vector<int>>& mat, vector<vector<float>>& inv) {
        int n = mat.size();
        int det = getDet(mat, n);
        if (det == 0) {
            cout << "Singular matrix, can\'t find its inverse";
            return false;
        }

        vector<vector<int>> adj(n, vector<int>(n));
        adjoint(mat, adj);

        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                inv[i][j] = adj[i][j] / float(det);

        return true;
    }

    int main() {
        vector<vector<int>> mat = { { 5, -2, 2, 7 },
                                    { 1, 0, 0, 3 },
                                    { -3, 1, 5, 0 },
                                    { 3, -1, -9, 4 } };

        int n = mat.size();
        vector<vector<int>> adj(n, vector<int>(n)); // To store adjoint
        vector<vector<float>> inv(n, vector<float>(n)); // To store inverse

        // Print the input matrix
        cout << "Input matrix is:\\n";
        for (auto& row : mat) {
            for (int val : row) cout << val << " ";
            cout << endl;
        }

        // Print the adjoint matrix
        cout << "\\nThe Adjoint is:\\n";
        adjoint(mat, adj);
        for (auto& row : adj) {
            for (int val : row) cout << val << " ";
            cout << endl;
        }

        // Print the inverse matrix if it exists
        cout << "\\nThe Inverse is:\\n";
        if (inverse(mat, inv)) {
            for (auto& row : inv) {
                for (float val : row) cout << val << " ";
                cout << endl;
            }
        }

        return 0;
    }

    ````

    C

    ````
    #include <stdio.h>

    #define N 4

    // Function to get cofactor of mat[p][q] in cof[][]. n is
    // current dimension of mat[][]
    void getCof(int mat[N][N], int cof[N][N], int p, int q, int n) {
        int i = 0, j = 0;
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                if (row != p && col != q) {
                    cof[i][j++] = mat[row][col];
                    if (j == n - 1) {
                        j = 0;
                        i++;
                    }
                }
            }
        }
    }

    // Recursive function for finding determinant of matrix mat of dimension n
    int getDet(int mat[N][N], int n) {
        if (n == 1) return mat[0][0];
        int det = 0;

        int cof[N][N];
        int sign = 1;
        for (int f = 0; f < n; f++) {
            getCof(mat, cof, 0, f, n);
            det += sign * mat[0][f] * getDet(cof, n - 1);
            sign = -sign;
        }
        return det;
    }

    // Function to get adjoint of mat in adj
    void adjoint(int mat[N][N], double adj[N][N]) {
        if (N == 1) {
            adj[0][0] = 1;
            return;
        }

        int sign = 1;
        int cof[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                getCof(mat, cof, i, j, N);
                sign = ((i + j) % 2 == 0) ? 1 : -1;
                adj[j][i] = sign * getDet(cof, N - 1);
            }
        }
    }

    // Function to calculate and store inverse, returns 0 if matrix is singular
    int inverse(int mat[N][N], double inv[N][N]) {
        int det = getDet(mat, N);
        if (det == 0) {
            printf("Singular matrix, can\'t find its inverse\\n");
            return 0;
        }

        double adj[N][N];
        adjoint(mat, adj);

        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                inv[i][j] = adj[i][j] / det;

        return 1;
    }

    int main() {
        int mat[N][N] = { { 5, -2, 2, 7 },
                          { 1, 0, 0, 3 },
                          { -3, 1, 5, 0 },
                          { 3, -1, -9, 4 } };

        double adj[N][N];
        double inv[N][N];

        // Print the input matrix
        printf("Input matrix is:\\n");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                printf("%d ", mat[i][j]);
            }
            printf("\\n");
        }

        // Print the adjoint matrix
        printf("\\nThe Adjoint is:\\n");
        adjoint(mat, adj);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                printf("%lf ", adj[i][j]);
            }
            printf("\\n");
        }

        // Print the inverse matrix if it exists
        printf("\\nThe Inverse is:\\n");
        if (inverse(mat, inv)) {
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    printf("%lf ", inv[i][j]);
                }
                printf("\\n");
            }
        }
        return 0;
    }

    ````

    Java

    ````
    // Importing required classes
    import java.util.Arrays;
    import java.util.Scanner;

    public class GfG {

        // Function to get cofactor of mat[p][q] in cof[][]
        static void getCof(int[][] mat, int[][] cof, int p, int q, int n) {
            int i = 0, j = 0;
            for (int row = 0; row < n; row++) {
                for (int col = 0; col < n; col++) {
                    if (row != p && col != q) {
                        cof[i][j++] = mat[row][col];
                        if (j == n - 1) {
                            j = 0;
                            i++;
                        }
                    }
                }
            }
        }

        // Recursive function for finding determinant of
        // matrix mat of dimension n
        static int getDet(int[][] mat, int n) {
            if (n == 1) return mat[0][0];
            int det = 0;
            int[][] cof = new int[n][n];
            int sign = 1;
            for (int f = 0; f < n; f++) {
                getCof(mat, cof, 0, f, n);
                det += sign * mat[0][f] * getDet(cof, n - 1);
                sign = -sign;
            }
            return det;
        }

        // Function to get adjoint of mat in adj
        static void adjoint(int[][] mat, int[][] adj) {
            int n = mat.length;
            if (n == 1) {
                adj[0][0] = 1;
                return;
            }
            int sign;
            int[][] cof = new int[n][n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    getCof(mat, cof, i, j, n);
                    sign = ((i + j) % 2 == 0) ? 1 : -1;
                    adj[j][i] = sign * getDet(cof, n - 1);
                }
            }
        }

        // Function to calculate and store inverse, returns
        // false if matrix is singular
        static boolean inverse(int[][] mat, float[][] inv) {
            int n = mat.length;
            int det = getDet(mat, n);
            if (det == 0) {
                System.out.println("Singular matrix, can\'t find its inverse");
                return false;
            }
            int[][] adj = new int[n][n];
            adjoint(mat, adj);
            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    inv[i][j] = (float) adj[i][j] / det;
            return true;
        }

        public static void main(String[] args) {
            int[][] mat = { { 5, -2, 2, 7 }, { 1, 0, 0, 3 },
                            { -3, 1, 5, 0 }, { 3, -1, -9, 4 } };
            int n = mat.length;
            int[][] adj = new int[n][n]; // To store adjoint
            float[][] inv = new float[n][n]; // To store inverse

            // Print the input matrix
            System.out.println("Input matrix is:");
            for (int[] row : mat) {
                System.out.println(Arrays.toString(row));
            }

            // Print the adjoint matrix
            System.out.println("\\nThe Adjoint is:");
            adjoint(mat, adj);
            for (int[] row : adj) {
                System.out.println(Arrays.toString(row));
            }

            // Print the inverse matrix if it exists
            System.out.println("\\nThe Inverse is:");
            if (inverse(mat, inv)) {
                for (float[] row : inv) {
                    System.out.println(Arrays.toString(row));
                }
            }
        }
    }

    ````

    Python

    ````
    # Function to get cofactor of mat[p][q] in cof[][]
    def get_cof(mat, cof, p, q, n):
        i = 0
        j = 0
        for row in range(n):
            for col in range(n):
                if row != p and col != q:
                    cof[i][j] = mat[row][col]
                    j += 1
                    if j == n - 1:
                        j = 0
                        i += 1

    # Recursive function for finding determinant
    # of matrix mat of dimension n
    def get_det(mat, n):
        if n == 1:
            return mat[0][0]
        det = 0
        cof = [[0] * n for _ in range(n)]  # To store cofactors
        sign = 1
        for f in range(n):
            get_cof(mat, cof, 0, f, n)
            det += sign * mat[0][f] * get_det(cof, n - 1)
            sign = -sign
        return det

    # Function to get adjoint of mat in adj
    def adjoint(mat, adj):
        n = len(mat)
        if n == 1:
            adj[0][0] = 1
            return
        sign = 1
        cof = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(n):
                get_cof(mat, cof, i, j, n)
                sign = 1 if (i + j) % 2 == 0 else -1
                adj[j][i] = sign * get_det(cof, n - 1)

    # Function to calculate and store inverse, returns
    # false if matrix is singular
    def inverse(mat):
        n = len(mat)
        det = get_det(mat, n)
        if det == 0:
            print("Singular matrix, can\'t find its inverse")
            return None
        adj = [[0] * n for _ in range(n)]
        adjoint(mat, adj)
        inv = [[adj[i][j] / det for j in range(n)] for i in range(n)]
        return inv

    if __name__ == \'__main__\':
        mat = [[5, -2, 2, 7], [1, 0, 0, 3], [-3, 1, 5, 0], [3, -1, -9, 4]]
        n = len(mat)
        adj = [[0] * n for _ in range(n)]  # To store adjoint

        # Print the input matrix
        print("Input matrix is:")
        for row in mat:
            print(row)

        # Print the adjoint matrix
        print("\\nThe Adjoint is:")
        adjoint(mat, adj)
        for row in adj:
            print(row)

        # Print the inverse matrix if it exists
        print("\\nThe Inverse is:")
        inv = inverse(mat)
        if inv:
            for row in inv:
                print(row)

    ````

    C#

    ````
    using System;

    class MatrixOperations {

        // Function to get cofactor of mat[p][q] in cof[][]. n is
        // current dimension of mat[][]
        static void GetCof(int[,] mat, int[,] cof, int p, int q, int n) {
            int i = 0, j = 0;
            for (int row = 0; row < n; row++) {
                for (int col = 0; col < n; col++) {
                    if (row != p && col != q) {
                        cof[i, j++] = mat[row, col];
                        if (j == n - 1) {
                            j = 0;
                            i++;
                        }
                    }
                }
            }
        }

        // Recursive function for finding determinant of matrix mat of dimension n
        static int GetDet(int[,] mat, int n) {
            if (n == 1) return mat[0, 0];
            int det = 0;

            // To store cofactors
            int[,] cof = new int[n, n];

            int sign = 1;
            for (int f = 0; f < n; f++) {
                GetCof(mat, cof, 0, f, n);
                det += sign * mat[0, f] * GetDet(cof, n - 1);
                sign = -sign;
            }
            return det;
        }

        // Function to get adjoint of mat in adj
        static void Adjoint(int[,] mat, double[,] adj) {
            int n = mat.GetLength(0);
            if (n == 1) {
                adj[0, 0] = 1;
                return;
            }

            int sign = 1;
            int[,] cof = new int[n, n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    GetCof(mat, cof, i, j, n);
                    sign = ((i + j) % 2 == 0) ? 1 : -1;
                    adj[j, i] = sign * GetDet(cof, n - 1);
                }
            }
        }

        // Function to calculate and store inverse, returns false if matrix is singular
        static bool Inverse(int[,] mat, double[,] inv) {
            int n = mat.GetLength(0);
            int det = GetDet(mat, n);
            if (det == 0) {
                Console.WriteLine("Singular matrix, can\'t find its inverse");
                return false;
            }

            double[,] adj = new double[n, n];
            Adjoint(mat, adj);

            for (int i = 0; i < n; i++)
                for (int j = 0; j < n; j++)
                    inv[i, j] = adj[i, j] / det;

            return true;
        }

        static void Main() {
            int[,] mat = new int[,] { { 5, -2, 2, 7 },
                                       { 1, 0, 0, 3 },
                                       { -3, 1, 5, 0 },
                                       { 3, -1, -9, 4 } };
            int n = mat.GetLength(0);
            double[,] adj = new double[n, n]; // To store adjoint
            double[,] inv = new double[n, n]; // To store inverse

            // Print the input matrix
            Console.WriteLine("Input matrix is:");
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    Console.Write(mat[i, j] + " ");
                }
                Console.WriteLine();
            }

            // Print the adjoint matrix
            Console.WriteLine("\\nThe Adjoint is:");
            Adjoint(mat, adj);
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    Console.Write(adj[i, j] + " ");
                }
                Console.WriteLine();
            }

            // Print the inverse matrix if it exists
            Console.WriteLine("\\nThe Inverse is:");
            if (Inverse(mat, inv)) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        Console.Write(inv[i, j] + " ");
                    }
                    Console.WriteLine();
                }
            }
        }
    }

    ````

    JavaScript

    ````
    // Function to get cofactor of mat[p][q] in cof[][]. n is
    // current dimension of mat[][]
    function getCof(mat, cof, p, q, n) {
        let i = 0, j = 0;
        for (let row = 0; row < n; row++) {
            for (let col = 0; col < n; col++) {
                if (row !== p && col !== q) {
                    cof[i][j++] = mat[row][col];
                    if (j === n - 1) {
                        j = 0;
                        i++;
                    }
                }
            }
        }
    }

    // Recursive function for finding determinant
    // of matrix mat of dimension n
    function getDet(mat, n) {
        if (n === 1) return mat[0][0];
        let det = 0;

        // To store cofactors
        let cof = Array.from({ length: mat.length }, () => Array(mat.length).fill(0));

        let sign = 1;
        for (let f = 0; f < n; f++) {
            getCof(mat, cof, 0, f, n);
            det += sign * mat[0][f] * getDet(cof, n - 1);
            sign = -sign;
        }
        return det;
    }

    // Function to get adjoint of mat in adj
    function adjoint(mat, adj) {
        let n = mat.length;
        if (n === 1) {
            adj[0][0] = 1;
            return;
        }

        let sign = 1;
        let cof = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                getCof(mat, cof, i, j, n);
                sign = ((i + j) % 2 === 0) ? 1 : -1;
                adj[j][i] = sign * getDet(cof, n - 1);
            }
        }
    }

    // Function to calculate and store inverse, returns
    // false if matrix is singular
    function inverse(mat, inv) {
        let n = mat.length;
        let det = getDet(mat, n);
        if (det === 0) {
            console.log("Singular matrix, can\'t find its inverse");
            return false;
        }

        let adj = Array.from({ length: n }, () => Array(n).fill(0));
        adjoint(mat, adj);

        for (let i = 0; i < n; i++)
            for (let j = 0; j < n; j++)
                inv[i][j] = adj[i][j] / det;

        return true;
    }

    let mat = [ [ 5, -2, 2, 7 ],
                [ 1, 0, 0, 3 ],
                [ -3, 1, 5, 0 ],
                [ 3, -1, -9, 4 ] ];

    let n = mat.length;
    let adj = Array.from({ length: n }, () => Array(n).fill(0)); // To store adjoint
    let inv = Array.from({ length: n }, () => Array(n).fill(0)); // To store inverse

    // Print the input matrix
    console.log("Input matrix is:");
    mat.forEach(row => {
        console.log(row.join(\' \'));
    });

    // Print the adjoint matrix
    console.log("\\nThe Adjoint is:");
    adjoint(mat, adj);
    adj.forEach(row => {
        console.log(row.join(\' \'));
    });

    // Print the inverse matrix if it exists
    console.log("\\nThe Inverse is:");
    if (inverse(mat, inv)) {
        inv.forEach(row => {
            console.log(row.join(\' \'));
        });
    }

    ````




    **Output**
    ```
    Input matrix is:
    5 -2 2 7
    1 0 0 3
    -3 1 5 0
    3 -1 -9 4

    The Adjoint is:
    -12 76 -60 -36
    -56 208 -82 -58
    4 4 -2 -10
    4 4 20 12

    The Inverse is:
    -0.136364 0.863636 -0.681818 -0.409091
    -0.636364 2.36364 -0.931818 -0.659091
    0.0454545 0.0454545 -0.0227273 -0.113636
    0.0454545 0.0454545 0.227273 0.136364

    ```
    ', '', 'Adjoint and Inverse of a Matrix', 11, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('6477db8f-1fdf-4441-80b4-09122d290265', e'
[Factorial](https://www.geeksforgeeks.org/factorial/)
of a number

****n****
is defined as the product of all the

****positive****
numbers less than n. In other words, Factorial of a number

****n****
can be calculated as:

****n × (n – 1) × (n – 2) × … × 1.****
Factorial of a number n is denoted as

****n!****
. It is widely used in Combinatorics and Algebra to find the number of ways to arrange or select items.


****Examples:****

> ****0!****
> = 1
>
>
> ****1!****
> = 1
>
>
> ****3!****
> = 3 x 2 x 1 = 6


Here is a list of problems based on Factorial.


* [Factorial of a Number](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/)
* [Check Factorial](https://www.geeksforgeeks.org/check-if-a-given-number-is-factorial-of-any-number/)
* [Factorial of Large number](https://www.geeksforgeeks.org/factorial-large-number/)
* [Count trailing zeroes](https://www.geeksforgeeks.org/count-trailing-zeroes-factorial-number/)
* [Sum of Digits](https://www.geeksforgeeks.org/find-sum-digits-factorial-number/)
* [Double Factorial](https://www.geeksforgeeks.org/double-factorial/)
* [Last Non-Zero digit](https://www.geeksforgeeks.org/last-non-zero-digit-factorial/)
* [Check Strong Number](https://www.geeksforgeeks.org/program-to-check-strong-number/)
* [Factorial without Multiplication](https://www.geeksforgeeks.org/factorial-of-a-number-without-using-multiplication/)
* [Length of factorial](https://www.geeksforgeeks.org/find-the-length-of-factorial-of-a-number-in-any-given-base/)
* [Sum of Factorials till N (1! + 2! + 3! + … + N!)](https://www.geeksforgeeks.org/find-sum-of-factorials-till-n-factorial-1-2-3-n/)
* [Smallest number at least n trailing zeroes](https://www.geeksforgeeks.org/smallest-number-least-n-trailing-zeroes-factorial/)
* [Factorial of an Array](https://www.geeksforgeeks.org/factorial-of-an-array-of-integers/)
* [K-th Prime Factor](https://www.geeksforgeeks.org/k-th-prime-factor-given-number/)
* [nCr](https://www.geeksforgeeks.org/program-calculate-value-ncr/)
* [Ways to go from one point to another](https://www.geeksforgeeks.org/number-of-ways-to-go-from-one-point-to-another-in-a-grid/)
* [Check Krishnamurthy Number](https://www.geeksforgeeks.org/check-if-a-number-is-a-krishnamurthy-number-or-not-2/)
* [nCr using Fermat Little Theorem](https://www.geeksforgeeks.org/compute-ncrp-using-fermat-little-theorem/)
* [Ways to arrange K different objects](https://www.geeksforgeeks.org/number-of-ways-to-arrange-k-different-objects-taking-n-objects-at-a-time/)

> Recommended Links
>
>
> * [Factorial Formula](https://www.geeksforgeeks.org/factorial-formula/)
> * [Interesting Facts about Factorial](https://www.geeksforgeeks.org/interesting-facts-about-factorial/)
', '', 'Factorial Coding Problems', 21, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('e87fc291-5b1a-497b-ad5b-54a15743ed1f', e'
[Prime Numbers](https://www.geeksforgeeks.org/prime-numbers/)
are natural numbers greater than 1 and can be divided by itself and 1 only. For instance, numbers 2, 3, 5, 7, and 11 are the prime numbers since they can only be divided by 1 and themselves, there is no other number that can fully divide them Since it is manually very difficult to check if a number is prime (no direct formula) and find prime factors, problems related to prime become really interesting coding problems.


Here is a list of example problems based on prime.


* [Check for Prime Number](https://www.geeksforgeeks.org/check-for-prime-number/)
* [All Prime Factors](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)
* [Largest Prime Factor](https://www.geeksforgeeks.org/find-largest-prime-factor-number/)
* [Check for Co-Prime](https://www.geeksforgeeks.org/count-number-of-primes-in-an-array/)
* [Primes in an Array](https://www.geeksforgeeks.org/find-two-prime-numbers-with-given-sum/)
* [Primes with Given Sum](https://www.geeksforgeeks.org/pair-of-prime-numbers-with-a-given-sum-and-minimum-absolute-difference/)
* [Pair of Primes with Given Sum and Min Diff](https://www.geeksforgeeks.org/pair-of-prime-numbers-with-a-given-sum-and-minimum-absolute-difference/)
* [Prime Number Gap](https://www.geeksforgeeks.org/minimum-difference-between-any-two-primes-from-the-given-range/)
* [Find the next prime](https://www.geeksforgeeks.org/program-to-find-the-next-prime-number/)
* [Check for Strong Prime](https://www.geeksforgeeks.org/check-if-n-is-strong-prime/)
* [Closest Prime](https://www.geeksforgeeks.org/count-of-n-digit-numbers-which-contains-all-single-digit-primes/)
* [N Digit Numbers with Prime Digits](https://www.geeksforgeeks.org/count-of-n-digit-numbers-which-contains-all-single-digit-primes/)
* [Sieve of Eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)
* [Nth Prime Number](https://www.geeksforgeeks.org/program-to-find-the-nth-prime-number/)
* [Program to print prime numbers from 1 to N.](https://www.geeksforgeeks.org/program-to-print-first-n-prime-numbers/)
* [Segmented Sieve](https://www.geeksforgeeks.org/segmented-sieve/)', '', 'Prime Number Coding Problems', 22, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('28f5205e-a507-4ef7-aaf7-73b013044326', e'
### ****Mathematical Concepts:****

* [Numbers](https://www.geeksforgeeks.org/numbers-aptitude-questions-and-answers/)
* [Prime Numbers](https://www.geeksforgeeks.org/prime-numbers/)
* [Arithmetic Progression](https://www.geeksforgeeks.org/what-is-arithmetic-progression/)
* [Geometric Progression](https://www.geeksforgeeks.org/what-is-geometric-progression/)
* [GCD](https://www.geeksforgeeks.org/greatest-common-divisor-gcd/)
  and

  [LCM](https://www.geeksforgeeks.org/lcm-least-common-multiple/)
* [Factorial](https://www.geeksforgeeks.org/factorial/)
* [Permutation](https://www.geeksforgeeks.org/permutation/)
  and

  [Combination](https://www.geeksforgeeks.org/combinations/)
* [Catalan Number](https://www.geeksforgeeks.org/catalan-numbers/)
* [Modular Arithmetic](https://www.geeksforgeeks.org/modular-arithmetic/)

### ****Basic Problems****

* [Sum of Naturals](https://www.geeksforgeeks.org/program-find-sum-first-n-natural-numbers/)
* [Sum of Squares of Naturals](https://www.geeksforgeeks.org/sum-of-squares-of-first-n-natural-numbers/)
* [Nth Term of AP](https://www.geeksforgeeks.org/program-n-th-term-arithmetic-progression-series/)
* [Nth Term of GP](https://www.geeksforgeeks.org/find-nth-term-geometric-progression-series/)
* [Nth Triangular Number](https://www.geeksforgeeks.org/triangular-numbers/)
* [Sum of Sums of Natural Numbers](https://www.geeksforgeeks.org/sum-of-first-n-natural-numbers/)
* [Count Digits](https://www.geeksforgeeks.org/program-count-digits-integer-3-different-methods/)
* [Sum of Digits](https://www.geeksforgeeks.org/program-for-sum-of-the-digits-of-a-given-number/)
* [Reverse Digits](https://www.geeksforgeeks.org/write-a-program-to-reverse-digits-of-a-number/)
* [K-th Digit in a^b](https://www.geeksforgeeks.org/k-th-digit-raised-power-b/)
* [Palindrome Number](https://www.geeksforgeeks.org/check-if-a-number-is-palindrome/)
* [GCD of Two Numbers](https://www.geeksforgeeks.org/program-to-find-lcm-of-two-numbers/)
* [LCM of Two Numbers](https://www.geeksforgeeks.org/program-to-find-lcm-of-two-numbers/)
* [Add two fractions](https://www.geeksforgeeks.org/program-to-add-two-fractions/)
* [Check for Co-Prime](https://www.geeksforgeeks.org/check-two-numbers-co-prime-not/)
* [Factorial of a Number](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/)
* [GCD of more than 2](https://www.geeksforgeeks.org/gcd-two-array-numbers/)
* [LCM of more than 2](https://www.geeksforgeeks.org/lcm-of-given-array-elements/)
* [Padovan Sequence](https://www.geeksforgeeks.org/padovan-sequence/)

### ****Easy Problems****

* [Pair Cube Count](https://www.geeksforgeeks.org/count-pairs-a-b-whose-sum-of-cubes-is-n-a3-b3-n/)
* [Sum of 2, 22, 222, ………](https://www.geeksforgeeks.org/sum-sequence-2-22-222/)
* [Sum of 1^2 + 3^2 + 5^2 + . . . + (2\\*n – 1)^2](https://www.geeksforgeeks.org/sum-series-12-32-52-2n-12/)
* [Sum of 0.6, 0.06, 0.006, 0.0006, …to n terms](https://www.geeksforgeeks.org/sum-series-0-6-0-06-0-006-0-0006-n-terms/)
* [n-th term of 2, 12, 36, 80, 150….](https://www.geeksforgeeks.org/n-th-term-series-2-12-36-80-150/)
* [Digit Root](https://www.geeksforgeeks.org/digital-rootrepeated-digital-sum-given-integer/)
* [Fibonacci Numbers](https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/)
* [Lucas Number](https://www.geeksforgeeks.org/lucas-numbers/)
* [Check for Power](https://www.geeksforgeeks.org/check-if-a-number-is-power-of-another-number/)
* [Three Divisors](https://www.geeksforgeeks.org/numbers-exactly-3-divisors/)
* [Square Root](https://www.geeksforgeeks.org/square-root-of-an-integer/)
* [Binomial Coefficient](https://www.geeksforgeeks.org/binomial-coefficient-dp-9/)
* [Pascal Triangle](https://www.geeksforgeeks.org/pascal-triangle/)
* [nth Row of the Pascal Triangle](https://www.geeksforgeeks.org/find-the-nth-row-in-pascals-triangle/)
* [Armstrong Numbers](https://www.geeksforgeeks.org/program-for-armstrong-numbers/)
* [Determinant of a Matrix](https://www.geeksforgeeks.org/determinant-of-a-matrix/)
* [Modular Exponentiation](https://www.geeksforgeeks.org/modular-exponentiation-power-in-modular-arithmetic/)
* [Check for Perfect Squares](https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/)
* [Divisibility by 3](https://www.geeksforgeeks.org/check-large-number-divisible-3-not/)
* [Divisibility by 4](https://www.geeksforgeeks.org/check-large-number-divisible-4-not/)
* [Divisibility by 7](https://www.geeksforgeeks.org/divisibility-by-7/)
* [Divisibility by 11](https://origin.geeksforgeeks.org/check-large-number-divisible-11-not/)
* [Divisibility by 13](https://www.geeksforgeeks.org/check-large-number-divisible-13-not/)
* [Divisibility by 29](https://www.geeksforgeeks.org/number-is-divisible-by-29-or-not/)

### ****Medium Problems****

* [Linear Diophantine Equations](https://www.geeksforgeeks.org/eulers-totient-function/)
* [Euler\'s Totient Function](https://www.geeksforgeeks.org/eulers-totient-function/)
* [Sieve of Eratosthenes](https://www.geeksforgeeks.org/find-all-factors-of-a-natural-number/)
* [All Divisors](https://www.geeksforgeeks.org/prime-factor/)
* [Prime Factorization](https://www.geeksforgeeks.org/find-largest-prime-factor-number/)
* [Largest Prime Factor](https://www.geeksforgeeks.org/factorial-large-number/)
* [Factorial of a Large Number](https://www.geeksforgeeks.org/factorial-large-number/)
* [Largest Power Divisible in Factorial](https://www.geeksforgeeks.org/largest-power-k-n-factorial-k-may-not-prime/)
* [Last Non-zero Digit of Factorial](https://www.geeksforgeeks.org/last-non-zero-digit-factorial/)
* [Power Set](https://www.geeksforgeeks.org/power-set/)
* [Add Two Polynomials](https://www.geeksforgeeks.org/program-add-two-polynomials/)
* [All Permutations of a String](https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/)
* [Next Permutation](https://www.geeksforgeeks.org/next-permutation/)
* [Check for Carmichael Numbers](https://www.geeksforgeeks.org/carmichael-numbers/)
* [Collatz sequence](https://www.geeksforgeeks.org/program-to-print-collatz-sequence/)
* [Grid Unique Paths](https://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/)
* [Nth Even Fibonacci Number](https://www.geeksforgeeks.org/nth-even-fibonacci-number/)
* [Last 2 Digits of Nth Fibonacci](https://www.geeksforgeeks.org/program-find-last-two-digits-nth-fibonacci-number/)

### ****Hard Problems****

* [Josephus Problem](https://www.geeksforgeeks.org/josephus-problem/)
* [Water Jug Tutorial](https://www.geeksforgeeks.org/water-jug-problem-complete-tutorial/)
* [Segmented Sieve](https://www.geeksforgeeks.org/segmented-sieve/)
* [k-th prime factor](https://www.geeksforgeeks.org/k-th-prime-factor-given-number/)
* [N-th Root](https://www.geeksforgeeks.org/n-th-root-number/)
* [Sum of Digits in Factorial](https://www.geeksforgeeks.org/find-sum-digits-factorial-number/)
* [Egg Dropping](https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/)
* [Next String](https://www.geeksforgeeks.org/lexicographically-next-string/)', e'The following is the list of mathematical concepts and related coding problems. The coding problems are ordered according to difficulty level. Please refer
Mathematical Algorithms (Topic Wise) for the topic wise list of problems.', 'Mathematical Algorithms (Difficulty Wise)', 23, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('c08fa70f-b522-438e-a134-46e4a754c0c8', e'
Given a fraction, find a recurring sequence of digits if it exists, otherwise, print “No recurring sequence”.

                                                                                                                                    **Examples:**

                                                                                                                                    ```
                                                                                                                                    Input  : Numerator = 8, Denominator = 3
                                                                                                                                    Output : Recurring sequence is 6
                                                                                                                                    Explanation : 8/3 = 2.66666666.......

                                                                                                                                    Input : Numerator = 50, Denominator = 22
                                                                                                                                    Output : Recurring sequence is 27
                                                                                                                                    Explanation : 50/22 = 2.272727272.....

                                                                                                                                    Input : Numerator = 11, Denominator = 2
                                                                                                                                    Output : No recurring sequence
                                                                                                                                    Explanation : 11/2 = 5.5
                                                                                                                                    ```

                                                                                                                                       [We strongly recommend that you click here and practice it, before moving on to the solution.](https://www.geeksforgeeks.org/problems/a-simple-fraction0921/1)
--------------------------------------------------------------------------------------------------------------------------------------------------------------

**When does the fractional part repeat?**


Let us simulate the process of converting fractions to decimals. Let us look at the part where we have already figured out the integer part, which is floor(numerator/denominator). Now we are left with ( remainder = numerator%denominator ) / denominator.

If you remember the process of converting to decimal, at each step we do the following :

                                                                                                                                    1. Multiply the remainder by 10.
                                                                                                                                    2. Append the remainder/denominator to the result.
                                                                                                                                    3. Remainder = remainder % denominator.

                                                                                                                                    At any moment, if the remainder becomes 0, we are done.


However, when there is a recurring sequence, the remainder never becomes 0. For example, if you look at 1/3, the remainder never becomes 0.

Below is one important observation :


If we start with the remainder ‘rem’ and if the remainder repeats at any point in time, the digits between the two occurrences of ‘rem’ keep repeating.


So the idea is to store seen remainders in a map. Whenever a remainder repeats, we return the sequence before the next occurrence.

Below is the implementation of the above idea.

C++
---

















```
// C++ program to find repeating
// sequence in a fraction
#include <bits/stdc++.h>
using namespace std;

// This function returns repeating sequence of
// a fraction.  If repeating sequence doesn\'t
// exist, then returns empty string
string fractionToDecimal( int numr, int denr)
{
string res; // Initialize result

// Create a map to store already
// seen remainders, remainder is used
// as key and its position in
// result is stored as value.
// Note that we need
// position for cases like 1/6.
// In this case,the recurring sequence
// doesn\'t start from first
// remainder.
map< int , int > mp;
mp.clear();

// Find first remainder
int rem = numr % denr;

// Keep finding remainder until either remainder
// becomes 0 or repeats
while ((rem != 0)
&& (mp.find(rem) == mp.end()))
{
// Store this remainder
mp[rem] = res.length();

// Multiply remainder with 10
rem = rem * 10;

// Append rem / denr to result
int res_part = rem / denr;
res += to_string(res_part);

// Update remainder
rem = rem % denr;
}

return (rem == 0) ? "" : res.substr(mp[rem]);
}

// Driver code
int main()
{
int numr = 50, denr = 22;
string res = fractionToDecimal(numr, denr);
if (res == "" )
cout << "No recurring sequence" ;
else
cout << "Recurring sequence is " << res;
return 0;
}
```





Java
----

















```
// Java program to find
// repeating sequence
// in a fraction
import java.util.*;
class GFG {

// This function returns repeating
// sequence of a fraction. If
// repeating sequence doesn\'t
// exist, then returns empty String
static String fractionToDecimal( int numr, int denr)
{
// Initialize result
String res = "" ;

// Create a map to store already
// seen remainders. Remainder is
// used as key and its position in
// result is stored as value.
// Note that we need position for
// cases like 1/6.  In this case,
// the recurring sequence doesn\'t
// start from first remainder.
HashMap<Integer, Integer> mp = new HashMap<>();
mp.clear();

// Find first remainder
int rem = numr % denr;

// Keep finding remainder until
//  either remainder becomes 0 or repeats
while ((rem != 0 ) && (!mp.containsKey(rem)))
{
// Store this remainder
mp.put(rem, res.length());

// Multiply remainder with 10
rem = rem * 10 ;

// Append rem / denr to result
int res_part = rem / denr;
res += String.valueOf(res_part);

// Update remainder
rem = rem % denr;
}

if (rem == 0 )
return "" ;
else if (mp.containsKey(rem))
return res.substring(mp.get(rem));

return "" ;
}

// Driver code
public static void main(String[] args)
{
int numr = 50 , denr = 22 ;
String res = fractionToDecimal(numr, denr);
if (res == "" )
System.out.print( "No recurring sequence" );
else
System.out.print( "Recurring sequence is "
+ res);
}
}

// This code is contributed by gauravrajput1
```





Python3
-------

















```
# Python3 program to find repeating
# sequence in a fraction

# This function returns repeating sequence
# of a fraction.If repeating sequence doesn\'t
# exist, then returns empty string


def fractionToDecimal(numr, denr):

# Initialize result
res = ""

# Create a map to store already seen
# remainders. Remainder is used as key
# and its position in result is stored
# as value. Note that we need position
# for cases like 1/6.  In this case,
# the recurring sequence doesn\'t start
# from first remainder.
mp = {}

# Find first remainder
rem = numr % denr

# Keep finding remainder until either
# remainder becomes 0 or repeats
while ((rem ! = 0 ) and (rem not in mp)):

# Store this remainder
mp[rem] = len (res)

# Multiply remainder with 10
rem = rem * 10

# Append rem / denr to result
res_part = rem / / denr
res + = str (res_part)

# Update remainder
rem = rem % denr

if (rem = = 0 ):
return ""
else :
return res[mp[rem]:]


# Driver code
numr, denr = 50 , 22
res = fractionToDecimal(numr, denr)

if (res = = ""):
print ( "No recurring sequence" )
else :
print ( "Recurring sequence is" , res)

# This code is contributed by divyeshrabadiya07
```





C#
--

















```
// C# program to find repeating sequence
// in a fraction
using System;
using System.Collections.Generic;

class GFG {

// This function returns repeating
// sequence of a fraction. If
// repeating sequence doesn\'t
// exist, then returns empty String
static string fractionToDecimal( int numr, int denr)
{
// Initialize result
string res = "" ;

// Create a map to store already
// seen remainders. Remainder is
// used as key and its position in
// result is stored as value.
// Note that we need position for
// cases like 1/6.  In this case,
// the recurring sequence doesn\'t
// start from first remainder.
Dictionary< int , int > mp
= new Dictionary< int , int >();

// Find first remainder
int rem = numr % denr;

// Keep finding remainder until
// either remainder becomes 0
// or repeats
while ((rem != 0) && (!mp.ContainsKey(rem)))
{

// Store this remainder
mp[rem] = res.Length;

// Multiply remainder with 10
rem = rem * 10;

// Append rem / denr to result
int res_part = rem / denr;
res += res_part.ToString();

// Update remainder
rem = rem % denr;
}

if (rem == 0)
return "" ;
else if (mp.ContainsKey(rem))
return res.Substring(mp[rem]);

return "" ;
}

// Driver code
public static void Main( string [] args)
{
int numr = 50, denr = 22;
string res = fractionToDecimal(numr, denr);

if (res == "" )
Console.Write( "No recurring sequence" );
else
Console.Write( "Recurring sequence is " + res);
}
}

// This code is contributed by rutvik_56
```





Javascript
----------

















```
<script>

// Javascript program to find
// repeating sequence
// in a fraction

// This function returns repeating
// sequence of a fraction. If
// repeating sequence doesn\'t
// exist, then returns empty String
function fractionToDecimal(numr, denr)
{
// Initialize result
let res = "" ;

// Create a map to store already
// seen remainders. Remainder is
// used as key and its position in
// result is stored as value.
// Note that we need position for
// cases like 1/6.  In this case,
// the recurring sequence doesn\'t
// start from first remainder.
let mp = new Map();
mp.clear();

// Find first remainder
let rem = numr % denr;

// Keep finding remainder until
//  either remainder becomes 0 or repeats
while ((rem != 0) && (!mp.has(rem)))
{
// Store this remainder
mp.set(rem, res.length);

// Multiply remainder with 10
rem = rem * 10;

// Append rem / denr to result
let res_part = Math.floor(rem / denr);
res += res_part.toString();

// Update remainder
rem = rem % denr;
}

if (rem == 0)
return "" ;
else if (mp.has(rem))
return res.substr(mp.get(rem));

return "" ;
}

// Driver program

let numr = 50, denr = 22;
let res = fractionToDecimal(numr, denr);
if (res == "" )
document.write( "No recurring sequence" );
else
document.write( "Recurring sequence is "
+ res);

</script>
```







**Output**
```
Recurring sequence is 27
```

**Time Complexity : O(N)**

**Auxiliary Space : O(N) ,**
                                                                                                                                        as we use map as extra space.
                                                                                                                                        ', '', 'Find Recurring Sequence in a Fraction', 24, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('f6b69eae-bbcf-44ad-9b2d-18253be9e546', e'![Searching-algorithm](https://media.geeksforgeeks.org/wp-content/uploads/20230928105033/Searching-algorithm.png)

# Introduction to Searching - Data Structure and Algorithm Tutorial

  
The primary objective of searching is to determine whether the desired element exists within the data, and if so, to identify its precise location or retrieve it. It plays an important role in various computational tasks and real-world applications, including information retrieval, data analysis, decision-making processes, and more.

# Importance of Searching in DSA

-   ****Efficiency:**** Efficient searching algorithms improve program performance.
-   ****Data Retrieval:**** Quickly find and retrieve specific data from large datasets.
-   ****Database Systems:**** Enables fast querying of databases.
-   ****Problem Solving:**** Used in a wide range of problem-solving tasks.

# Characteristics of Searching

Understanding the characteristics of searching in data structures and algorithms is crucial for designing efficient algorithms and making informed decisions about which searching technique to employ. Here, we explore key aspects and characteristics associated with searching:

## 1. Target Element:

In searching, there is always a specific target element or item that you want to find within the data collection. This target could be a value, a record, a key, or any other data entity of interest.

## 2. Search Space:

The search space refers to the entire collection of data within which you are looking for the target element. Depending on the data structure used, the search space may vary in size and organization.

## 3. Complexity:

Searching can have different levels of complexity depending on the data structure and the algorithm used. The complexity is often measured in terms of time and space requirements.

## 4. Deterministic vs Non-deterministic:

Some searching algorithms, like [binary search](https://www.geeksforgeeks.org/binary-search/), are deterministic, meaning they follow a clear and systematic approach. Others, such as linear search, are non-deterministic, as they may need to examine the entire search space in the worst case.

# Applications of Searching:

Searching algorithms have numerous applications across various fields. Here are some common applications:

-   ****Information Retrieval:**** Search engines like Google, Bing, and Yahoo use sophisticated searching algorithms to retrieve relevant information from vast amounts of data on the web.
-   ****Database Systems:**** Searching is fundamental in database systems for retrieving specific data records based on user queries, improving efficiency in data retrieval.
-   ****E-commerce:**** Searching is crucial in e-commerce platforms for users to find products quickly based on their preferences, specifications, or keywords.
-   ****Networking:**** In networking, searching algorithms are used for routing packets efficiently through networks, finding optimal paths, and managing network resources.
-   ****Artificial Intelligence:**** Searching algorithms play a vital role in AI applications, such as problem-solving, game playing (e.g., chess), and decision-making processes
-   ****Pattern Recognition:**** Searching algorithms are used in pattern matching tasks, such as image recognition, speech recognition, and handwriting recognition.

# Searching Algorithms

Searching Algorithms are designed to check for an element or retrieve an element from any data structure where it is stored.


## 1. Linear Search. 

Linear Search, also known as Sequential Search, is one of the simplest and most straightforward searching algorithms. It works by sequentially examining each element in a collection of data(array or list) until a match is found or the entire collection has been traversed.

![Linear-Search](https://media.geeksforgeeks.org/wp-content/uploads/20240416171353/Linear-Search.webp)


#### **Algorithm of Linear Search:**

-   The Algorithm examines each element, one by one, in the collection, treating each element as a potential match for the key you\'re searching for.
-   If it finds any element that is exactly the same as the key you\'re looking for, the search is successful, and it returns the index of key.
-   If it goes through all the elements and none of them matches the key, then that means "No match is Found".

#### **Illustration of Linear Search:**

Consider the array ****arr[] = {10, 50, 30, 70, 80, 20, 90, 40}**** and ****key = 30****

Start from the first element (index 0) and compare key with each element (arr[i]). Comparing key with first element arr[0]. Since not equal, the iterator moves to the next element as a potential match.

![Linear-Search-Algorithm-1](https://media.geeksforgeeks.org/wp-content/uploads/20240416171448/Linear-Search-Algorithm-1.webp)

Comparing key with next element arr[1]. Since not equal, the iterator moves to the next element as a potential match.

![Linear-Search-Algorithm-2](https://media.geeksforgeeks.org/wp-content/uploads/20240416171553/Linear-Search-Algorithm-2.webp)

Now when comparing arr[2] with key, the value matches. So the Linear Search Algorithm will yield a successful message and return the index of the element when key is found.


![Linear-Search-Algorithm-3](https://media.geeksforgeeks.org/wp-content/uploads/20240416171724/Linear-Search-Algorithm-3.webp)

#### **Pseudo Code for Linear Search:**

```pseudo-code
LinearSearch(collection, key):
	for each element in collection:
		if element is equal to key: 
		return the index of the element
	return "Not found"
```

#### **Complexity Analysis of Linear Search:**

-   ****Time Complexity:****
    -   ****Best Case****: In the best case, the key might be present at the first index. So the best case complexity is O(1)
    -   ****Worst Case:**** In the worst case, the key might be present at the last index i.e., opposite to the end from which the search has started in the list. So the worst-case complexity is O(N) where N is the size of the list.
    -   ****Average Case:**** O(N)
-   ****Auxiliary Space:**** O(1) as except for the variable to iterate through the list, no other variable is used.

#### **When to use Linear Search:**

-   When there is small collection of data.
-   When data is unordered.
- [Click here to view more](https://www.geeksforgeeks.org/linear-search/)

## 2. Binary Search.

Binary Search is defined as a searching algorithm used in a ****sorted array**** by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to ****O(log N).****

![Binary-Seach-1](https://media.geeksforgeeks.org/wp-content/uploads/20240416182910/Binary-Seach-1.webp)


#### **Algorithm of Binary Search:**

-   Divide the search space into two halves by finding the middle index “****mid****”.
-   Compare the middle element of the search space with the ****key****.
-   If the ****key**** is found at middle element, the process is terminated.
-   If the ****key**** is not found at middle element, choose which half will be used as the next search space.
    -   If the key is smaller than the middle element, then the ****left**** side is used for next search.
    -   If the key is larger than the middle element, then the ****right**** side is used for next search.
-   This process is continued until the key is found or the total search space is exhausted.

#### **Illustration of Binary Search:**

Consider an array ****arr[]**** = ****{2, 5, 8, 12, 16, 23, 38, 56, 72, 91}****, and the ****target**** = ****23****.

-   Calculate the ****mid**** and compare the mid element with the key. If the key is less than ****mid**** element, move to ****left**** and if it is greater than the ****mid**** then move search space to the ****right****.
-   Key (i.e., 23) is greater than current ****mid**** element (i.e., 16). The search space moves to the ****right****.

![Binary-Seach-Algorithm-1](https://media.geeksforgeeks.org/wp-content/uploads/20240416183158/Binary-Seach-Algorithm-1.webp)

-   ****Key**** is less than the current mid ****56****. The search space moves to the ****left****.

![Binary-Seach-Algorithm-2](https://media.geeksforgeeks.org/wp-content/uploads/20240416183323/Binary-Seach-Algorithm-2.webp)

-   If the ****key**** matches the value of the mid element, the element is found and stop search.

![Binary-Seach-Algorithm-3](https://media.geeksforgeeks.org/wp-content/uploads/20240417101319/Binary-Seach-Algorithm-3.webp)

#### **Pseudo Code for Binary Search:**

Below is the pseudo code for implementing binary search:
```pseudo-code
binarySearch(collection, key):
	left = 0
	right = length(collection) - 1
	while left <= right:
		mid = (left + right) // 2
		if collection[mid] == key:
			return mid
		elif collection[mid] < key:
			left = mid + 1
		else:
			right = mid - 1
	return "Not found"
```

#### **Complexity Analysis of Binary Search:**

-   ****Time Complexity:****
    -   ****Best Case:**** O(1) - When the key is found at the middle element.
    -   ****Worst Case:**** O(log N) - When the key is not present, and the search space is continuously halved.
    -   ****Average Case:**** O(log N)
-   ****Auxiliary Space****: O(1)

#### **When to use Binary Search:**

-   When the data collection is monotonic (essential condition) in nature.
-   When efficiency is required, specially in case of large datasets.
- [Click here to view more](https://www.geeksforgeeks.org/binary-search/).
## 3. Ternary Search.

Ternary Search is a searching algorithm that divides the search space into ****three parts**** instead of two, as in ****Binary Search****. It is very useful in the case of [unimodal functions](https://www.geeksforgeeks.org/mathematics-unimodal-functions-bimodal-functions/).

#### **Algorithm Ternary Search:**

-   In Ternary Search, start with two midpoints, ****oneThird**** and ****twoThirds****, which divide the collection into three roughly equal parts.
-   Compare the elements at ****oneThird**** and ****twoThirds**** with the target key you\'re searching for.
-   Three Possibilities:
    -   If ****oneThird**** contains the key, you\'re done and return the index of ****oneThird****.
    -   If ****twoThirds**** contains the key, you\'re done and return the index of ****twoThirds****.
    -   If the ****key**** is less than the element at ****oneThird****, eliminate the rightmost one-third of the collection and focus on the left two-thirds.
-   If the key is greater than the element at ****twoThirds****, eliminate the leftmost one-third of the collection and focus on the right two-thirds.
-   Repeat this process iteratively until either ****key**** is found or determine that it\'s not present in the collection.

#### **Example of Ternary Search:**

Consider an array ****arr[]**** = ****{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},**** and the ****target**** = ****6****.

![Ternary-Search](https://media.geeksforgeeks.org/wp-content/uploads/20240417101938/Ternary-Search.webp)


#### **Complexity Analysis of Ternary Search:**

-   ****Time Complexity:****
    -   Best Case: O(1)
    -   Worst Case: O(log$_3$N)
    -   Average Case: O(log$_3$N)
-   ****Auxiliary Space:**** O(1)
- [Click here to view more](https://www.geeksforgeeks.org/binary-search/).
## 4. Jump Search.

> Jump Search is another searching algorithm that can be used on sorted collections (arrays or lists). The idea is to reduce the number of comparisons by jumping ahead by fixed steps or skipping some elements in place of searching all elements.

#### **Illustration of Jump Search:**

Let’s consider the following array: (0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610).

The length of the array is 16. The Jump search will find the value of 55 with the following steps assuming that the block size to be jumped is 4.

-   Jump from index 0 to index 4;
-   Jump from index 4 to index 8;
-   Jump from index 8 to index 12;
-   Since the element at index 12 is greater than 55, we will jump back a step to come to index 8.
-   Perfo
rm a linear search from index 8 to get the element 55.

#### **Time Complexity of Jump Search:**

-   ****Time Complexity: O($\\sqrt n$)****, where "n" is the number of elements in the collection. This makes it more efficient than Linear Search but generally less efficient than Binary Search for large datasets.
-   ****Auxiliary Space:**** ****O(1)****, as it uses a constant amount of additional space for variables.

#### **Performance Comparison based on Complexity:**

> ****linear search < jump search < binary search****
- [Click here to view more](https://www.geeksforgeeks.org/jump-search/).

## 5. Interpolation Search.

> ****Interpolation Search**** is an efficient searching algorithm for ****sorted**** collections of data, such as arrays or lists. It is an improvement over ****Binary Search****, particularly when the data is uniformly distributed.

- [Click here to view detail](https://www.geeksforgeeks.org/interpolation-search/)


## 6. Fibonacci Search.

> ****Fibonacci Search**** is an efficient searching algorithm used for finding a ****target**** value in a sorted collection, such as an array or list. It is similar in principle to ****Binary Search**** but uses Fibonacci numbers to determine the positions to be compared.
- [Click here to view detail](https://www.geeksforgeeks.org/fibonacci-search/)
## 7. Exponential Search.

> ****Exponential Search**** is a searching algorithm designed to find a ****target**** value in a sorted collection, such as an array or list. It combines elements of ****Binary Search**** and ****Linear Search**** to efficiently locate the target, especially when its position is near the beginning of the collection.

- [Click here to view detail](https://www.geeksforgeeks.org/exponential-search/)
', 'Searching is the fundamental process of locating a specific element or item within a collection of data.', 'Introduction to Searching', 6, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('aa9a9fdb-517e-4bec-ad2a-32a18c54993c', e'![binnary-search-](https://media.geeksforgeeks.org/wp-content/uploads/20240506155201/binnary-search-.webp)
# Conditions to apply Binary Search Algorithm in a Data Structure

To apply Binary Search algorithm:

-   The data structure must be sorted.
-   Access to any element of the data structure should take constant time.

# Binary Search Algorithm

Below is the step-by-step algorithm for Binary Search:

-   Divide the search space into two halves by ****finding the middle index "mid"****. 
-   Compare the middle element of the search space with the ****key****. 
-   If the ****key**** is found at middle element, the process is terminated.
-   If the ****key**** is not found at middle element, choose which half will be used as the next search space.
    -   If the ****key**** is smaller than the middle element, then the ****left**** side is used for next search.
    -   If the ****key**** is larger than the middle element, then the ****right**** side is used for next search.
-   This process is continued until the ****key**** is found or the total search space is exhausted.

# How does Binary Search Algorithm work?

To understand the working of binary search, consider the following illustration:

Consider an array ****arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}****, and the ****target = 23****.  

![Binary-Search-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250219155359690903/Binary-Search-1.webp)![Binary-Search-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250219155359020153/Binary-Search-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250219155358414164/Binary-Search-3.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250219155357890968/Binary-Search-4.png)

# How to Implement Binary Search Algorithm?

The ****Binary Search Algorithm**** can be implemented in the following two ways

-   Iterative Binary Search Algorithm
-   Recursive Binary Search Algorithm

## Iterative Binary Search Algorithm

> Here we use a while loop to continue the process of comparing the key and splitting the search space in two halves.

```cpp
// C++ program to implement iterative Binary Search
#include <bits/stdc++.h>
using namespace std;

// An iterative binary search function.
int binarySearch(int arr[], int low, int high, int x)
{
    while (low <= high) {
        int mid = low + (high - low) / 2;

        // Check if x is present at mid
        if (arr[mid] == x)
            return mid;

        // If x greater, ignore left half
        if (arr[mid] < x)
            low = mid + 1;

        // If x is smaller, ignore right half
        else
            high = mid - 1;
    }

    // If we reach here, then element was not present
    return -1;
}

// Driver code
int main(void)
{
    int arr[] = { 2, 3, 4, 10, 40 };
    int x = 10;
    int n = sizeof(arr) / sizeof(arr[0]);
    int result = binarySearch(arr, 0, n - 1, x);
    if(result == -1) cout << "Element is not present in array";
    else cout << "Element is present at index " << result;
    return 0;
}
```
```c
// C program to implement iterative Binary Search
#include <stdio.h>

// An iterative binary search function.
int binarySearch(int arr[], int low, int high, int x)
{
    while (low <= high) {
        int mid = low + (high - low) / 2;

        // Check if x is present at mid
        if (arr[mid] == x)
            return mid;

        // If x greater, ignore left half
        if (arr[mid] < x)
            low = mid + 1;

        // If x is smaller, ignore right half
        else
            high = mid - 1;
    }

    // If we reach here, then element was not present
    return -1;
}

// Driver code
int main(void)
{
    int arr[] = { 2, 3, 4, 10, 40 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    int result = binarySearch(arr, 0, n - 1, x);
   if(result == -1) printf("Element is not present in array");
   else printf("Element is present at index %d",result);

}
```
```java
// Java implementation of iterative Binary Search

import java.io.*;

class BinarySearch {
  
    // Returns index of x if it is present in arr[].
    int binarySearch(int arr[], int x)
    {
        int low = 0, high = arr.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;

            // Check if x is present at mid
            if (arr[mid] == x)
                return mid;

            // If x greater, ignore left half
            if (arr[mid] < x)
                low = mid + 1;

            // If x is smaller, ignore right half
            else
                high = mid - 1;
        }

        // If we reach here, then element was
        // not present
        return -1;
    }

    // Driver code
    public static void main(String args[])
    {
        BinarySearch ob = new BinarySearch();
        int arr[] = { 2, 3, 4, 10, 40 };
        int n = arr.length;
        int x = 10;
        int result = ob.binarySearch(arr, x);
        if (result == -1)
            System.out.println(
                "Element is not present in array");
        else
            System.out.println("Element is present at "
                               + "index " + result);
    }
}
```
```python
# Python3 code to implement iterative Binary
# Search.


# It returns location of x in given array arr
def binarySearch(arr, low, high, x):

    while low <= high:

        mid = low + (high - low) // 2

        # Check if x is present at mid
        if arr[mid] == x:
            return mid

        # If x is greater, ignore left half
        elif arr[mid] < x:
            low = mid + 1

        # If x is smaller, ignore right half
        else:
            high = mid - 1

    # If we reach here, then the element
    # was not present
    return -1


# Driver Code
if __name__ == \'__main__\':
    arr = [2, 3, 4, 10, 40]
    x = 10

    # Function call
    result = binarySearch(arr, 0, len(arr)-1, x)
    if result != -1:
        print("Element is present at index", result)
    else:
        print("Element is not present in array")
```
```csharp
// C# implementation of iterative Binary Search
using System;

class GFG {
    
    // Returns index of x if it is present in arr[]
    static int binarySearch(int[] arr, int x)
    {
        int low = 0, high = arr.Length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;

            // Check if x is present at mid
            if (arr[mid] == x)
                return mid;

            // If x greater, ignore left half
            if (arr[mid] < x)
                low = mid + 1;

            // If x is smaller, ignore right half
            else
                high = mid - 1;
        }

        // If we reach here, then element was
        // not present
        return -1;
    }

    // Driver code
    public static void Main()
    {
        int[] arr = { 2, 3, 4, 10, 40 };
        int n = arr.Length;
        int x = 10;
        int result = binarySearch(arr, x);
        if (result == -1)
            Console.WriteLine(
                "Element is not present in array");
        else
            Console.WriteLine("Element is present at "
                              + "index " + result);
    }
}
```
```javascript
// Program to implement iterative Binary Search

// A iterative binary search function. It returns
// location of x in given array arr[l..r] is present,
// otherwise -1

function binarySearch(arr, x)
{
    let low = 0;
    let high = arr.length - 1;
    let mid;
    while (high >= low) {
        mid = low + Math.floor((high - low) / 2);

        // If the element is present at the middle
        // itself
        if (arr[mid] == x)
            return mid;

        // If element is smaller than mid, then
        // it can only be present in left subarray
        if (arr[mid] > x)
            high = mid - 1;

        // Else the element can only be present
        // in right subarray
        else
            low = mid + 1;
    }

    // We reach here when element is not
    // present in array
    return -1;
}

arr = new Array(2, 3, 4, 10, 40);
x = 10;
n = arr.length;
result = binarySearch(arr, x);
if (result == -1)
    console.log("Element is not present in array")
    else
    {
        console.log("Element is present at index "
                    + result);
    }
```


```output
Element is present at index 3
```

****Time Complexity:**** O(log N)  
****Auxiliary Space:**** O(1)

## Recursive Binary Search Algorithm:

> Create a recursive function and compare the mid of the search space with the key. And based on the result either return the index where the key is found or call the recursive function for the next search space.

```cpp
#include <bits/stdc++.h>
using namespace std;

// A recursive binary search function. It returns
// location of x in given array arr[low..high] is present,
// otherwise -1
int binarySearch(int arr[], int low, int high, int x)
{
    if (high >= low) {
        int mid = low + (high - low) / 2;

        // If the element is present at the middle
        // itself
        if (arr[mid] == x)
            return mid;

        // If element is smaller than mid, then
        // it can only be present in left subarray
        if (arr[mid] > x)
            return binarySearch(arr, low, mid - 1, x);

        // Else the element can only be present
        // in right subarray
        return binarySearch(arr, mid + 1, high, x);
    }
  return -1;
}

// Driver code
int main()
{
    int arr[] = { 2, 3, 4, 10, 40 };
    int query = 10;
    int n = sizeof(arr) / sizeof(arr[0]);
    int result = binarySearch(arr, 0, n - 1, query);
    if (result == -1) cout << "Element is not present in array";
    else cout << "Element is present at index " << result;
    return 0;
}
```
```c
// C program to implement recursive Binary Search
#include <stdio.h>

// A recursive binary search function. It returns
// location of x in given array arr[low..high] is present,
// otherwise -1
int binarySearch(int arr[], int low, int high, int x)
{
    if (high >= low) {
        int mid = low + (high - low) / 2;

        // If the element is present at the middle
        // itself
        if (arr[mid] == x)
            return mid;

        // If element is smaller than mid, then
        // it can only be present in left subarray
        if (arr[mid] > x)
            return binarySearch(arr, low, mid - 1, x);

        // Else the element can only be present
        // in right subarray
        return binarySearch(arr, mid + 1, high, x);
    }

    // We reach here when element is not
    // present in array
    return -1;
}

// Driver code
int main()
{
    int arr[] = { 2, 3, 4, 10, 40 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    int result = binarySearch(arr, 0, n - 1, x);
    if (result == -1) printf("Element is not present in array");
    else printf("Element is present at index %d", result);
    return 0;
}
```
```java
// Java implementation of recursive Binary Search
class BinarySearch {

    // Returns index of x if it is present in arr[low..
    // high], else return -1
    int binarySearch(int arr[], int low, int high, int x)
    {
        if (high >= low) {
            int mid = low + (high - low) / 2;

            // If the element is present at the
            // middle itself
            if (arr[mid] == x)
                return mid;

            // If element is smaller than mid, then
            // it can only be present in left subarray
            if (arr[mid] > x)
                return binarySearch(arr, low, mid - 1, x);

            // Else the element can only be present
            // in right subarray
            return binarySearch(arr, mid + 1, high, x);
        }

        // We reach here when element is not present
        // in array
        return -1;
    }

    // Driver code
    public static void main(String args[])
    {
        BinarySearch ob = new BinarySearch();
        int arr[] = { 2, 3, 4, 10, 40 };
        int n = arr.length;
        int x = 10;
        int result = ob.binarySearch(arr, 0, n - 1, x);
        if (result == -1)
            System.out.println(
                "Element is not present in array");
        else
            System.out.println(
                "Element is present at index " + result);
    }
}
```
```python
# Python3 Program for recursive binary search.


# Returns index of x in arr if present, else -1
def binarySearch(arr, low, high, x):

    # Check base case
    if high >= low:

        mid = low + (high - low) // 2

        # If element is present at the middle itself
        if arr[mid] == x:
            return mid

        # If element is smaller than mid, then it
        # can only be present in left subarray
        elif arr[mid] > x:
            return binarySearch(arr, low, mid-1, x)

        # Else the element can only be present
        # in right subarray
        else:
            return binarySearch(arr, mid + 1, high, x)

    # Element is not present in the array
    else:
        return -1


# Driver Code
if __name__ == \'__main__\':
    arr = [2, 3, 4, 10, 40]
    x = 10
    
    # Function call
    result = binarySearch(arr, 0, len(arr)-1, x)
    
    if result != -1:
        print("Element is present at index", result)
    else:
        print("Element is not present in array")
```
```csharp
// C# implementation of recursive Binary Search
using System;

class GFG {

    // Returns index of x if it is present in
    // arr[low..high], else return -1
    static int binarySearch(int[] arr, int low, int high, int x)
    {
        if (high >= low) {
            int mid = low + (high - low) / 2;

            // If the element is present at the
            // middle itself
            if (arr[mid] == x)
                return mid;

            // If element is smaller than mid, then
            // it can only be present in left subarray
            if (arr[mid] > x)
                return binarySearch(arr, low, mid - 1, x);

            // Else the element can only be present
            // in right subarray
            return binarySearch(arr, mid + 1, high, x);
        }

        // We reach here when element is not present
        // in array
        return -1;
    }

    // Driver code
    public static void Main()
    {

        int[] arr = { 2, 3, 4, 10, 40 };
        int n = arr.Length;
        int x = 10;

        int result = binarySearch(arr, 0, n - 1, x);

        if (result == -1)
            Console.WriteLine(
                "Element is not present in arrau");
        else
            Console.WriteLine("Element is present at index "
                              + result);
    }
}
```
```javascript
// JavaScript program to implement recursive Binary Search

// A recursive binary search function. It returns
// location of x in given array arr[low..high] is present,
// otherwise -1
function binarySearch(arr, low, high, x)
{
    if (high >= low) {
        let mid = low + Math.floor((high - low) / 2);

        // If the element is present at the middle
        // itself
        if (arr[mid] == x)
            return mid;

        // If element is smaller than mid, then
        // it can only be present in left subarray
        if (arr[mid] > x)
            return binarySearch(arr, low, mid - 1, x);

        // Else the element can only be present
        // in right subarray
        return binarySearch(arr, mid + 1, high, x);
    }

    // We reach here when element is not
    // present in array
    return -1;
}

let arr = [ 2, 3, 4, 10, 40 ];
let x = 10;
let n = arr.length
let result = binarySearch(arr, 0, n - 1, x);
if (result == -1)
    console.log("Element is not present in array");
else
    console.log("Element is present at index " + result);
```


```output
Element is present at index 3
```

## Complexity Analysis of Binary Search Algorithm

-   ****Time Complexity:**** 
    -   Best Case: O(1)
    -   Average Case: O(log N)
    -   Worst Case: O(log N)
-   ****Auxiliary Space:**** O(1), If the recursive call stack is considered then the auxiliary space will be O(log N).

Please refer [Time and Space Complexity Analysis of Binary Search](https://www.geeksforgeeks.org/complexity-analysis-of-binary-search/) for more details.

# Applications of Binary Search Algorithm

-   Binary search can be used as a building block for more complex algorithms used in machine learning, such as algorithms for training neural networks or finding the optimal hyperparameters for a model.
-   It can be used for searching in computer graphics such as algorithms for ray tracing or texture mapping.
-   It can be used for searching a database.

', 'Binary Search Algorithm is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half.', 'Binary Search Algorithm', 8, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('192cb6e4-14cd-4265-9d7d-7cbf5bc0817f', e'![Introduction-to-Sorting-Techniques](https://media.geeksforgeeks.org/wp-content/uploads/20240520115941/Introduction-to-Sorting-Techniques.webp)

# Why Sorting Algorithms are Important

The sorting algorithm is important in Computer Science because it reduces the complexity of a problem. There is a wide range of applications for these algorithms, including searching algorithms, database algorithms, divide and conquer methods, and data structure algorithms.

In the following sections, we list some important scientific applications where sorting algorithms are used  

-   When you have hundreds of datasets you want to print, you might want to arrange them in some way.
-   Once we get the data sorted, we can get the k-th smallest and k-th largest item in O(1) time.
-   Searching any element in a huge data set becomes easy. We can use Binary search method for search if we have sorted data. So, Sorting become important here.
-   They can be used in software and in conceptual problems to solve more advanced problems.  

# Sorting Basics

-   [**In-place Sorting**](https://www.geeksforgeeks.org/in-place-algorithm/)**:** An in-place sorting algorithm uses **constant space** for producing the output (modifies the given array only. Examples: Selection Sort, Bubble Sort, Insertion Sort and Heap Sort.
-   **Internal Sorting:** Internal Sorting is when all the data is placed in the **main memory** or **internal memory**. In internal sorting, the problem cannot take input beyond allocated memory size.
-   [**External Sorting**](https://www.geeksforgeeks.org/external-sorting/) **:** External Sorting is when all the data that needs to be sorted need not to be placed in memory at a time, the sorting is called external sorting. External Sorting is used for the massive amount of data. For example Merge sort can be used in external sorting as the whole array does not have to be present all the time in memory,
-   [**Stable sorting**](https://www.geeksforgeeks.org/stable-and-unstable-sorting-algorithms/)**:** When two same items appear in the **same** **order** in sorted data as in the original array called stable sort. Examples: Merge Sort, Insertion Sort, Bubble Sort.
-   [**Hybrid Sorting**](https://www.geeksforgeeks.org/hybrid-sorting-algorithms/)**:** A sorting algorithm is called Hybrid if it uses more than one standard sorting algorithms to sort the array. The idea is to take advantages of multiple sorting algorithms. For example [IntroSort](https://www.geeksforgeeks.org/introsort-cs-sorting-weapon/) uses Insertions sort and Quick Sort.

# Types of Sorting Techniques

There are various sorting algorithms are used in data structures. The following two types of sorting algorithms can be broadly classified:

1.  **Comparison-based:** We compare the elements in a comparison-based sorting algorithm)
2.  **Non-comparison-based:** We do not compare the elements in a non-comparison-based sorting algorithm)

![Sorting algorithm](https://media.geeksforgeeks.org/wp-content/uploads/20220916131621/SortingTYPE.png)


# Some of the most common sorting algorithms are:

[Selection sort](http://www.geeksforgeeks.org/selection-sort/), [Bubble sort](http://www.geeksforgeeks.org/bubble-sort/), [Insertion Sort](http://www.geeksforgeeks.org/insertion-sort/), [Cycle Sort](https://www.geeksforgeeks.org/cycle-sort/), [Merge Sort](http://www.geeksforgeeks.org/merge-sort/), [3-way Merge Sort](https://www.geeksforgeeks.org/3-way-merge-sort/), [Quick sort](http://www.geeksforgeeks.org/quick-sort/), [Heap sort](https://www.geeksforgeeks.org/heap-sort/) and [Counting sort](https://www.geeksforgeeks.org/counting-sort/)

# Some other Sorting algorithms:

[Radix sort](https://www.geeksforgeeks.org/radix-sort/), [Bucket sort](https://www.geeksforgeeks.org/bucket-sort-2/), [Shell sort](https://www.geeksforgeeks.org/shellsort/), [Tim Sort](https://www.geeksforgeeks.org/timsort/), [Comb Sort](https://www.geeksforgeeks.org/comb-sort/), [Pigeonhole sorting](https://www.geeksforgeeks.org/pigeonhole-sort/), [Cocktail Sort](https://www.geeksforgeeks.org/cocktail-sort/), [Strand sort](https://www.geeksforgeeks.org/strand-sort/), [Bitonic Sort](https://www.geeksforgeeks.org/bitonic-sort/), [Stooge Sort](https://www.geeksforgeeks.org/stooge-sort/), [Tag Sort](https://www.geeksforgeeks.org/tag-sort/), [Tree sort](https://www.geeksforgeeks.org/tree-sort/), [Cartesian Sort](https://www.geeksforgeeks.org/cartesian-tree-sorting/), [Odd-Even Sort / Brick Sort](https://www.geeksforgeeks.org/odd-even-sort-brick-sort/), [Gnome sort](https://www.geeksforgeeks.org/gnome-sort-a-stupid-one/), [Cocktail shaker sort](https://www.geeksforgeeks.org/cocktail-sort/)

# Comparison of Complexity Analysis of Sorting Algorithms:

| Name | Best Case   | Average Case   | Worst Case  | Memory | Stable    | Method Used |
| --- | --- | --- | --- | --- | --- | --- |
| [Quick Sort](http://www.geeksforgeeks.org/quick-sort/) | nlogn | nlogn | n$^{2}$ | $log n$ | No | Partitioning |
| [Merge Sort](http://www.geeksforgeeks.org/merge-sort/) | nlogn | nlogn | nlogn | n | Yes | Merging |
| [Heap Sort](https://www.geeksforgeeks.org/heap-sort/) | nlogn | nlogn | nlogn | 1 | No | Selection |
| [Insertion Sort](http://www.geeksforgeeks.org/insertion-sort/) | n | n$^{2}$ | n$^{2}$ | 1 | Yes | Insertion |
| [Tim Sort](https://www.geeksforgeeks.org/timsort/) | n | nlogn | nlogn | n | Yes | Insertion & Merging |
| [Selection Sort](http://www.geeksforgeeks.org/selection-sort/) | n$^{2}$ | n$^{2}$ | n$^{2}$ | 1 | No | Selection |
| [Shell Sort](https://www.geeksforgeeks.org/shellsort/) | nlogn | n$^{4/3}$ | n$^{3/2}$ | 1 | No | Insertion |
| [Bubble Sort](http://www.geeksforgeeks.org/bubble-sort/) | n | n$^{2}$ | n$^{2}$ | 1 | Yes | Exchanging |
| [Tree Sort](https://www.geeksforgeeks.org/tree-sort/) | nlogn | nlogn | nlogn | n | Yes | Insertion |
| [Cycle Sort](https://www.geeksforgeeks.org/cycle-sort/) | n$^{2}$ | n$^{2}$ | n$^{2}$ | 1 | No | Selection |
| [Strand Sort](https://www.geeksforgeeks.org/strand-sort/) | n | n$^{2}$ | n$^{2}$ | n | Yes | Selection |
| [Cocktail Shaker Sort](https://www.geeksforgeeks.org/cocktail-sort/) | n | n$^{2}$ | n$^{2}$ | 1 | Yes | Exchanging |
| [Comb Sort](https://www.geeksforgeeks.org/comb-sort/) | nlogn | n$^{2}$ | n$^{2}$ | 1 | No | Exchanging |
| [Gnome Sort](https://www.geeksforgeeks.org/gnome-sort-a-stupid-one/) | n | n$^{2}$ | n$^{2}$ | 1 | Yes | Exchanging |
| [Odd–even Sort](https://www.geeksforgeeks.org/odd-even-sort-brick-sort/) | n | n$^{2}$ | n$^{2}$ | 1 | Yes | Exchanging Indexes: |', 'Sorting refers to rearrangement of a given array or list of elements according to a comparison operator on the elements.', 'Introduction to Sorting Techniques', 10, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('7106768d-cb8a-49a3-b944-1aa4e1266f10', e'# Selection sort introduction
**Selection Sort** is a comparison-based sorting algorithm. It sorts an array by repeatedly selecting the **smallest (or largest)** element from the unsorted portion and swapping it with the first unsorted element. This process continues until the entire array is sorted.

1.  First we find the smallest element and swap it with the first element. This way we get the smallest element at its correct position.
2.  Then we find the smallest among remaining elements (or second smallest) and swap it with the second element.
3.  We keep doing this until we get all elements moved to correct position.

![](https://media.geeksforgeeks.org/wp-content/uploads/20240926134343/Selection-Sort-Algorithm-1.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240926134343/Selection-Sort-Algorithm-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240926134344/Selection-Sort-Algorithm-3.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240926134345/Selection-Sort-Algorithm-4.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240926134345/Selection-Sort-Algorithm-5.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240926134346/Selection-Sort-Algorithm-6.webp)


```cpp
// C++ program to implement Selection Sort
#include <bits/stdc++.h>
using namespace std;

void selectionSort(vector<int> &arr) {
    int n = arr.size();

    for (int i = 0; i < n - 1; ++i) {

        // Assume the current position holds
        // the minimum element
        int min_idx = i;

        // Iterate through the unsorted portion
        // to find the actual minimum
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[min_idx]) {

                // Update min_idx if a smaller
                // element is found
                min_idx = j; 
            }
        }

        // Move minimum element to its
        // correct position
        swap(arr[i], arr[min_idx]);
    }
}

void printArray(vector<int> &arr) {
    for (int &val : arr) {
        cout << val << " ";
    }
    cout << endl;
}

int main() {
    vector<int> arr = {64, 25, 12, 22, 11};

    cout << "Original array: ";
    printArray(arr); 

    selectionSort(arr);

    cout << "Sorted array: ";
    printArray(arr);

    return 0;
}
```
```c
// C program for implementation of selection sort
#include <stdio.h>

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
      
        // Assume the current position holds
        // the minimum element
        int min_idx = i;
        
        // Iterate through the unsorted portion
        // to find the actual minimum
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
              
                // Update min_idx if a smaller element is found
                min_idx = j;
            }
        }
        
        // Move minimum element to its
        // correct position
        int temp = arr[i];
        arr[i] = arr[min_idx];
        arr[min_idx] = temp;
    }
}

void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\\n");
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    printf("Original array: ");
    printArray(arr, n);
    
    selectionSort(arr, n);
    
    printf("Sorted array: ");
    printArray(arr, n);
    
    return 0;
}
```
```java
// Java program for implementation of Selection Sort
import java.util.Arrays;

class GfG {

    static void selectionSort(int[] arr){
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
          
            // Assume the current position holds
            // the minimum element
            int min_idx = i;

            // Iterate through the unsorted portion
            // to find the actual minimum
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[min_idx]) {
                  
                    // Update min_idx if a smaller element
                    // is found
                    min_idx = j;
                }
            }

            // Move minimum element to its
            // correct position
            int temp = arr[i];
            arr[i] = arr[min_idx];
            arr[min_idx] = temp;           
        }
    }

    static void printArray(int[] arr){
        for (int val : arr) {
            System.out.print(val + " ");
        }
        System.out.println();
    }
  
    public static void main(String[] args){
        int[] arr = { 64, 25, 12, 22, 11 };

        System.out.print("Original array: ");
        printArray(arr);

        selectionSort(arr);

        System.out.print("Sorted array: ");
        printArray(arr);
    }
}
```
```python
# Python program for implementation of Selection
# Sort

def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
      
        # Assume the current position holds
        # the minimum element
        min_idx = i
        
        # Iterate through the unsorted portion
        # to find the actual minimum
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
              
                # Update min_idx if a smaller element is found
                min_idx = j
        
        # Move minimum element to its
        # correct position
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

def print_array(arr):
    for val in arr:
        print(val, end=" ")
    print()

if __name__ == "__main__":
    arr = [64, 25, 12, 22, 11]
    
    print("Original array: ", end="")
    print_array(arr)
    
    selection_sort(arr)
    
    print("Sorted array: ", end="")
    print_array(arr)
```
```csharp
// C# program for implementation
// of Selection Sort
using System;

class GfG {

    static void selectionSort(int[] arr){
        int n = arr.Length;
        for (int i = 0; i < n - 1; i++) {

            // Assume the current position holds
            // the minimum element
            int min_idx = i;

            // Iterate through the unsorted portion
            // to find the actual minimum
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[min_idx]) {

                    // Update min_idx if a smaller element
                    // is found
                    min_idx = j;
                }
            }

           // Move minimum element to its
           // correct position
           int temp = arr[i];
           arr[i] = arr[min_idx];
           arr[min_idx] = temp;         
        }
    }

    static void printArray(int[] arr){
        foreach(int val in arr){
            Console.Write(val + " ");
        }
        Console.WriteLine();
    }

    public static void Main(){
        int[] arr = { 64, 25, 12, 22, 11 };

        Console.Write("Original array: ");
        printArray(arr);

        selectionSort(arr);

        Console.Write("Sorted array: ");
        printArray(arr);
    }
}
```
```javascript
function selectionSort(arr) {
    let n = arr.length;
    for (let i = 0; i < n - 1; i++) {
    
        // Assume the current position holds
        // the minimum element
        let min_idx = i;
        
        // Iterate through the unsorted portion
        // to find the actual minimum
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
            
                // Update min_idx if a smaller element is found
                min_idx = j;
            }
        }
        
        // Move minimum element to its
        // correct position
        let temp = arr[i];
        arr[i] = arr[min_idx];
        arr[min_idx] = temp;
    }
}

function printArray(arr) {
    for (let val of arr) {
        process.stdout.write(val + " ");
    }
    console.log();
}

// Driver function 
const arr = [64, 25, 12, 22, 11];

console.log("Original array: ");
printArray(arr);

selectionSort(arr);

console.log("Sorted array: ");
printArray(arr);
```


```output
Original vector: 64 25 12 22 11 
Sorted vector:   11 12 22 25 64 
```

# Complexity Analysis of Selection Sort

**Time Complexity: O(n$^2$)**, as there are two nested loops:

-   One loop to select an element of Array one by one = O(n)
-   Another loop to compare that element with every other Array element = O(n)
-   Therefore overall complexity = O(n) * O(n) = O(n*n) = O(n$^2$)

**Auxiliary Space:** O(1) as the only extra memory used is for temporary variables.

# Advantages of Selection Sort

-   Easy to understand and implement, making it ideal for teaching basic sorting concepts.
-   Requires only a constant O(1) extra memory space.
-   It requires less number of swaps (or memory writes) compared to many other standard algorithms. Only [cycle sort](https://www.geeksforgeeks.org/cycle-sort/) beats it in terms of memory writes. Therefore it can be simple algorithm choice when memory writes are costly.

# Disadvantages of the Selection Sort

-   Selection sort has a time complexity of O(n^2) makes it slower compared to algorithms like [Quick Sort](https://www.geeksforgeeks.org/quick-sort-algorithm/) or [Merge Sort](https://www.geeksforgeeks.org/merge-sort/).
-   Does not maintain the relative order of equal elements which means it is not stable.

# Applications of Selection Sort

-   Perfect for teaching fundamental sorting mechanisms and algorithm design.
-   Suitable for small lists where the overhead of more complex algorithms isn\'t justified and memory writing is costly as it requires less memory writes compared to other standard sorting algorithms.
-   [Heap Sort](https://www.geeksforgeeks.org/heap-sort/) algorithm is based on Selection Sort.

**Question 1:** Is Selection Sort a stable sorting algorithm?

> **Answer:** No, Selection Sort is **not stable** as it may change the relative order of equal elements.

**Question 2:** What is the time complexity of Selection Sort?

> **Answer:** Selection Sort has a time complexity of O(n^2) in the best, average, and worst cases.

**Question 3:** Does Selection Sort require extra memory?

> **Answer:** No, Selection Sort is an in-place sorting algorithm and requires only O(1) additional space.

**Question 4:** When is it best to use Selection Sort?

> **Answer:** Selection Sort is best used for small datasets, educational purposes, or when memory usage needs to be minimal.

**Question 5:** How does Selection Sort differ from Bubble Sort?

> **Answer:** Selection Sort selects the minimum element and places it in the correct position with fewer swaps, while Bubble Sort repeatedly swaps adjacent elements to sort the array.', 'Selection Sort is a comparison-based sorting algorithm', 'Selection Sort', 11, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('63ddc11b-1888-48d8-afe0-f7153a56cc65', e'Implement Stack using Array:
----------------------------

> To implement a stack using an array, initialize an array and treat
> its end as the stack’s top. Implement ****push**** (add to end), ****pop**** (remove from end), and ****peek**** (check end) operations, handling cases for an ****empty**** or f****ull stack****.

****Step-by-step approach:****

1. ****Initialize an array**** to represent the stack.
2. Use the ****end of the array**** to represent the ****top of the stack****.
3. Implement ****push**** (add to end), ****pop**** (remove from the end), and ****peek**** (check end) operations, ensuring to handle empty and full stack
   conditions.

Implement Stack Operations using Array:
---------------------------------------


Here are the following operations of implement stack using array:

### ****Push Operation in Stack:****

Adds an item to the stack. If the stack is full, then it is said to be
an ****Overflow condition.****

****Algorithm for Push Operation:****

> * Before pushing the element to the stack, we check if the stack
>   is ****full****.
> * If the stack is full ****(top == capacity-1)****, then ****Stack Overflows****and we cannot insert the element to the stack.
> * Otherwise, we increment the value of top by 1 ****(top = top + 1)****and the new value is inserted at ****top position****.
> * The elements can be pushed into the stack till we reach
>   the ****capacity****of the stack.

![push-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)![push-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)


![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114220/push-operation-in-stack-2.webp)![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114220/push-operation-in-stack-2.webp)


![push-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114221/push-operation-in-stack-3.webp)![push-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114221/push-operation-in-stack-3.webp)


![push-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-4.webp)![push-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-4.webp)


![push-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-5.webp)![push-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114222/push-operation-in-stack-5.webp)


![push-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114223/push-operation-in-stack-6.webp)![push-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114223/push-operation-in-stack-6.webp)



Previous





Pause

Next





5 / 6

### ****Pop Operation in Stack:****

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an ****Underflow condition.****

****Algorithm for Pop Operation:****

> * Before popping the element from the stack, we check if the stack
>   is ****empty****.
> * If the stack is empty (top == -1), then ****Stack Underflows****and we cannot remove any element from the stack.
> * Otherwise, we store the value at top, decrement the value of top by
>   1 ****(top = top – 1)****and return the stored top value.

![pop-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-5.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)


![pop-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)![pop-operation-in-stack-6.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)



Previous





Play

Next





1 / 6

  


### ****Top or Peek Operation in Stack:****

Returns the top element of the stack.

****Algorithm for Top Operation:****

> * Before returning the top element from the stack, we check if the
>   stack is empty.
> * If the stack is empty (top == -1), we simply print “Stack is
>   empty”.
> * Otherwise, we return the element stored at ****index = top****.

### ****isEmpty Operation in Stack:****

Returns true if the stack is empty, else false.

****Algorithm for isEmpty Operation****:

> * Check for the value of ****top****in stack.
> * If ****(top == -1)****, then the stack is ****empty****so return ****true****.
> * Otherwise, the stack is not empty so return ****false****.

### isFull ****Operation in Stack****:

Returns true if the stack is full, else false.

****Algorithm for isFull Operation:****

> * Check for the value of ****top****in stack.
> * If ****(top == capacity-1),****then the stack is ****full****so return ****true****.
> * Otherwise, the stack is not full so return ****false.****

Below is the implementation of the above approach:

C++
````
/* C++ program to implement basic stack 
operations */
#include <bits/stdc++.h> 

using namespace std; 

#define MAX 1000 

class Stack { 
    int top; 

public: 
    int a[MAX]; // Maximum size of Stack 

    Stack() { top = -1; } 
    bool push(int x); 
    int pop(); 
    int peek(); 
    bool isEmpty(); 
}; 

bool Stack::push(int x) 
{ 
    if (top >= (MAX - 1)) { 
        cout << "Stack Overflow"; 
        return false; 
    } 
    else { 
        a[++top] = x; 
        cout << x << " pushed into stack\\n"; 
        return true; 
    } 
} 

int Stack::pop() 
{ 
    if (top < 0) { 
        cout << "Stack Underflow"; 
        return 0; 
    } 
    else { 
        int x = a[top--]; 
        return x; 
    } 
} 
int Stack::peek() 
{ 
    if (top < 0) { 
        cout << "Stack is Empty"; 
        return 0; 
    } 
    else { 
        int x = a[top]; 
        return x; 
    } 
} 

bool Stack::isEmpty() 
{ 
    return (top < 0); 
} 

// Driver program to test above functions 
int main() 
{ 
    class Stack s; 
    s.push(10); 
    s.push(20); 
    s.push(30); 
    cout << s.pop() << " Popped from stack\\n"; 
    
    //print top element of stack after popping 
    cout << "Top element is : " << s.peek() << endl; 
    
    //print all elements in stack : 
    cout <<"Elements present in stack : "; 
    while(!s.isEmpty()) 
    { 
        // print top element in stack 
        cout << s.peek() <<" "; 
        // remove top element in stack 
        s.pop(); 
    } 

    return 0; 
}

````

C
````
// C program for array implementation of stack 
#include <limits.h> 
#include <stdio.h> 
#include <stdlib.h> 

// A structure to represent a stack 
struct Stack { 
    int top; 
    unsigned capacity; 
    int* array; 
}; 

// function to create a stack of given capacity. It initializes size of 
// stack as 0 
struct Stack* createStack(unsigned capacity) 
{ 
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack)); 
    stack->capacity = capacity; 
    stack->top = -1; 
    stack->array = (int*)malloc(stack->capacity * sizeof(int)); 
    return stack; 
} 

// Stack is full when top is equal to the last index 
int isFull(struct Stack* stack) 
{ 
    return stack->top == stack->capacity - 1; 
} 

// Stack is empty when top is equal to -1 
int isEmpty(struct Stack* stack) 
{ 
    return stack->top == -1; 
} 

// Function to add an item to stack. It increases top by 1 
void push(struct Stack* stack, int item) 
{ 
    if (isFull(stack)) 
        return; 
    stack->array[++stack->top] = item; 
    printf("%d pushed to stack\\n", item); 
} 

// Function to remove an item from stack. It decreases top by 1 
int pop(struct Stack* stack) 
{ 
    if (isEmpty(stack)) 
        return INT_MIN; 
    return stack->array[stack->top--]; 
} 

// Function to return the top from stack without removing it 
int peek(struct Stack* stack) 
{ 
    if (isEmpty(stack)) 
        return INT_MIN; 
    return stack->array[stack->top]; 
} 

// Driver program to test above functions 
int main() 
{ 
    struct Stack* stack = createStack(100); 

    push(stack, 10); 
    push(stack, 20); 
    push(stack, 30); 

    printf("%d popped from stack\\n", pop(stack)); 

    return 0; 
} 

````

Java
````
/* Java program to implement basic stack 
operations */
class Stack { 
    static final int MAX = 1000; 
    int top; 
    int a[] = new int[MAX]; // Maximum size of Stack 

    boolean isEmpty() 
    { 
        return (top < 0); 
    } 
    Stack() 
    { 
        top = -1; 
    } 

    boolean push(int x) 
    { 
        if (top >= (MAX - 1)) { 
            System.out.println("Stack Overflow"); 
            return false; 
        } 
        else { 
            a[++top] = x; 
            System.out.println(x + " pushed into stack"); 
            return true; 
        } 
    } 

    int pop() 
    { 
        if (top < 0) { 
            System.out.println("Stack Underflow"); 
            return 0; 
        } 
        else { 
            int x = a[top--]; 
            return x; 
        } 
    } 

    int peek() 
    { 
        if (top < 0) { 
            System.out.println("Stack Underflow"); 
            return 0; 
        } 
        else { 
            int x = a[top]; 
            return x; 
        } 
    } 
    
    void print(){ 
    for(int i = top;i>-1;i--){ 
    System.out.print(" "+ a[i]); 
    } 
} 
} 

// Driver code 
class Main { 
    public static void main(String args[]) 
    { 
        Stack s = new Stack(); 
        s.push(10); 
        s.push(20); 
        s.push(30); 
        System.out.println(s.pop() + " Popped from stack"); 
        System.out.println("Top element is :" + s.peek()); 
        System.out.print("Elements present in stack :"); 
        s.print(); 
    } 
} 

````

Python3
````
# Python program for implementation of stack 

# import maxsize from sys module 
# Used to return -infinite when stack is empty 
from sys import maxsize 

# Function to create a stack. It initializes size of stack as 0 
def createStack(): 
    stack = [] 
    return stack 

# Stack is empty when stack size is 0 
def isEmpty(stack): 
    return len(stack) == 0

# Function to add an item to stack. It increases size by 1 
def push(stack, item): 
    stack.append(item) 
    print(item + " pushed to stack ") 
    
# Function to remove an item from stack. It decreases size by 1 
def pop(stack): 
    if (isEmpty(stack)): 
        return str(-maxsize -1) # return minus infinite 
    
    return stack.pop() 

# Function to return the top from stack without removing it 
def peek(stack): 
    if (isEmpty(stack)): 
        return str(-maxsize -1) # return minus infinite 
    return stack[len(stack) - 1] 

# Driver program to test above functions     
stack = createStack() 
push(stack, str(10)) 
push(stack, str(20)) 
push(stack, str(30)) 
print(pop(stack) + " popped from stack") 

````

C#
````
// C# program to implement basic stack 
// operations 
using System; 

namespace ImplementStack { 
class Stack { 
    private int[] ele; 
    private int top; 
    private int max; 
    public Stack(int size) 
    { 
        ele = new int[size]; // Maximum size of Stack 
        top = -1; 
        max = size; 
    } 

    public void push(int item) 
    { 
        if (top == max - 1) { 
            Console.WriteLine("Stack Overflow"); 
            return; 
        } 
        else { 
            ele[++top] = item; 
        } 
    } 

    public int pop() 
    { 
        if (top == -1) { 
            Console.WriteLine("Stack is Empty"); 
            return -1; 
        } 
        else { 
            Console.WriteLine("{0} popped from stack ", ele[top]); 
            return ele[top--]; 
        } 
    } 

    public int peek() 
    { 
        if (top == -1) { 
            Console.WriteLine("Stack is Empty"); 
            return -1; 
        } 
        else { 
            Console.WriteLine("{0} popped from stack ", ele[top]); 
            return ele[top]; 
        } 
    } 

    public void printStack() 
    { 
        if (top == -1) { 
            Console.WriteLine("Stack is Empty"); 
            return; 
        } 
        else { 
            for (int i = 0; i <= top; i++) { 
                Console.WriteLine("{0} pushed into stack", ele[i]); 
            } 
        } 
    } 
} 

// Driver program to test above functions 
class Program { 
    static void Main() 
    { 
        Stack p = new Stack(5); 

        p.push(10); 
        p.push(20); 
        p.push(30); 
        p.printStack(); 
        p.pop(); 
    } 
} 
} 

````

JavaScript
````
/* javascript program to implement basic stack 
operations 
*/
var t = -1; 
    var MAX = 1000; 
    var a = Array(MAX).fill(0); // Maximum size of Stack 

    function isEmpty() { 
        return (t < 0); 
    } 

    function push(x) { 
        if (t >= (MAX - 1)) { 
            console.log("Stack Overflow"); 
            return false; 
        } else { 
        t+=1; 
            a[t] = x; 
            
            console.log(x + " pushed into stack<br/>"); 
            return true; 
        } 
    } 

    function pop() { 
        if (t < 0) { 
            console.log("Stack Underflow"); 
            return 0; 
        } else { 
            var x = a[t]; 
            t-=1; 
            return x; 
        } 
    } 

    function peek() { 
        if (t < 0) { 
            console.log("Stack Underflow"); 
            return 0; 
        } else { 
            var x = a[t]; 
            return x; 
        } 
    } 

    function print() { 
        for (i = t; i > -1; i--) { 
            console.log(" " + a[i]); 
        } 
    } 

        push(10); 
        push(20); 
        push(30); 
        console.log(pop() + " Popped from stack"); 
        console.log("<br/>Top element is :" + peek()); 
        console.log("<br/>Elements present in stack : "); 
        print(); 

````





58





1

```
/* javascript program to implement basic stack 
```

2

```
operations 
```

3

```
*/
```

4

```
var t = -1; 
```

5

```
    var MAX = 1000; 
```

6

```
    var a = Array(MAX).fill(0); // Maximum size of Stack 
```

7

```
​
```

8

```
    function isEmpty() { 
```

9

```
        return (t < 0); 
```

10

```
    } 
```

11

```
​
```

12

```
    function push(x) { 
```

13

```
        if (t >= (MAX - 1)) { 
```

14

```
            console.log("Stack Overflow"); 
```

15

```
            return false; 
```

16

```
        } else { 
```

17

```
        t+=1; 
```

18

```
            a[t] = x; 
```

19

```
            
```

20

```
            console.log(x + " pushed into stack<br/>"); 
```

21

```
            return true; 
```

22

```
        } 
```

23

```
    } 
```

24

```
​
```

25

```
    function pop() { 
```

26

```
        if (t < 0) { 
```

27

```
            console.log("Stack Underflow"); 
```

28

```
            return 0; 
```

29

```
        } else { 
```

30

```
            var x = a[t]; 
```

31

```
            t-=1; 
```

32

```
            return x; 
```

33

```
        } 
```

34

```
    } 
```

35

```
​
```

36

```
    function peek() { 
```

37

```
        if (t < 0) { 
```

38

```
            console.log("Stack Underflow"); 
```

39

```
            return 0; 
```

40

```
        } else { 
```

41

```
            var x = a[t]; 
```

42

```
            return x; 
```

43

```
        } 
```

44

```
    } 
```

45

```
​
```

46

```
    function print() { 
```

47

```
        for (i = t; i > -1; i--) { 
```

48

```
            console.log(" " + a[i]); 
```

49

```
        } 
```

50

```
    } 
```

51

```
​
```

52

```
        push(10); 
```

53

```
        push(20); 
```

54

```
        push(30); 
```

55

```
        console.log(pop() + " Popped from stack"); 
```

56

```
        console.log("<br/>Top element is :" + peek()); 
```

57

```
        console.log("<br/>Elements present in stack : "); 
```

58

```
        print();
```









  
**Output**
```

10 pushed into stack
20 pushed into stack
30 pushed into stack
30 Popped from stack
Top element is : 20
Elements present in stack : 20 10 
```
### Complexity Analysis:

* ****Time Complexity****:
  + `push`: O(1)
  + `pop`: O(1)
  + `peek`: O(1)
  + `is_empty`: O(1)
  + is\\_full: O(1)
* ****Auxiliary Space****: O(n), where n is the number of items in the stack.

Advantages of Array Implementation:
-----------------------------------

* Easy to implement.
* Memory is saved as pointers are not involved.

Disadvantages of Array Implementation:
--------------------------------------

* It is not dynamic i.e., it doesn’t grow and shrink depending on needs
  at runtime. [But in case of dynamic sized arrays like vector in C++,
  list in Python, ArrayList in Java, stacks can grow and shrink with
  array implementation as well].
* The total size of the stack must be defined beforehand.', e'Stack is a linear data structurewhich follows LIFO principle. In this article, we will learn how to implement Stack using
Arrays. In Array-based approach, all stack-related operations are
executed using arrays. Let’s see how we can implement each operation on
the stack utilizing the Array Data Structure.', 'Implement Stack using Array', 2, null, '95713603-63d1-4b75-8a89-1acdc0977459', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('a3e9b26a-8405-4132-a638-8fa5b1a3731e', e'Applications of Stacks:
-----------------------

* ****Function calls:****
  Stacks are used to keep track of the return addresses of function
  calls, allowing the program to return to the correct location after a
  function has finished executing.
* ****Recursion:**** Stacks are used to store the local variables and return addresses of
  recursive function calls, allowing the program to keep track of the
  current state of the recursion.
* ****Expression evaluation:**** Stacks are used to evaluate expressions in postfix notation (Reverse
  Polish Notation).
* ****Syntax parsing:**** Stacks are used to check the validity of syntax in programming
  languages and other formal languages.
* ****Memory management:**** Stacks are used to allocate and manage memory in some operating
  systems and programming languages.
* Used to solve popular problems like [Next Greater](https://www.geeksforgeeks.org/next-greater-element/), [Previous Greater](https://www.geeksforgeeks.org/previous-greater-element/), [Next Smaller](https://www.geeksforgeeks.org/next-smaller-element/), [Previous Smaller](https://www.geeksforgeeks.org/find-the-nearest-smaller-numbers-on-left-side-in-an-array/), [Largest Area in a Histogram](https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-using-stack/) and [Stock Span Problems](https://www.geeksforgeeks.org/the-stock-span-problem/).

Advantages of Stacks:
---------------------

* ****Simplicity:**** Stacks are a simple and easy-to-understand data structure, making
  them suitable for a wide range of applications.
* ****Efficiency:**** Push and pop operations on a stack can be performed in constant time ****(O(1))****, providing efficient access to data.
* ****Last-in, First-out (LIFO):****
  Stacks follow the LIFO principle, ensuring that the last element added
  to the stack is the first one removed. This behavior is useful in many
  scenarios, such as function calls and expression evaluation.
* ****Limited memory usage:**** Stacks only need to store the elements that have been pushed onto
  them, making them memory-efficient compared to other data
  structures.

Disadvantages of Stacks:
------------------------

* ****Limited access:****
  Elements in a stack can only be accessed from the top, making it
  difficult to retrieve or modify elements in the middle of the
  stack.
* ****Potential for overflow:**** If more elements are pushed onto a stack than it can hold, an
  overflow error will occur, resulting in a loss of data.
* ****Not suitable for random access:**** Stacks do not allow for random access to elements, making them
  unsuitable for applications where elements need to be accessed in a
  specific order.
* ****Limited capacity:****
  Stacks have a fixed capacity, which can be a limitation if the number
  of elements that need to be stored is unknown or highly
  variable.
', e'A stack is a linear data structure
in which the insertion of a new element and removal of an existing
element takes place at the same end represented as the top of the stack.', 'Applications, Advantages and Disadvantages of Stack', 4, null, '95713603-63d1-4b75-8a89-1acdc0977459', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('6f9ef614-c469-4dec-975f-c75da2e27b91', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 22, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('8dcafb80-ba78-4e19-b5a9-cf1c0b8c51a3', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 23, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('b47a35ab-5d35-4425-a7b5-ccd2f5490278', e'# Operations on the Circular Linked list

We can do some operations on the circular linked list similar to the singly and doubly linked list which are:

**1\\. Insertion**

-   Insertion at the empty list
-   Insertion at the beginning
-   Insertion at the end
-   Insertion at the given position

**2\\. Deletion**

-   Delete the first node
-   Delete the last node
-   Delete the node from any position

**3\\. Searching**

## Insertion in the circular linked list

[Insertion](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/) is a fundamental operation in linked lists that involves adding a new node to the list. The only extra step is connecting the last node to the first one. In the circular linked list mentioned below, we can insert nodes in four ways:

#### **1. Insertion in an empty List in the circular linked list**

> To insert a node in empty circular linked list, creates a new node with the given data, sets its next pointer to point to itself, and updates the last pointer to reference this new node.

![Insertion-in-an-empty-list-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806193408/Insertion-in-an-empty-list-in-circular-linked-list.webp)


> To read more about insertion in an empty list Refer, [Insertion in an empty List in the circular linked list](https://www.geeksforgeeks.org/insertion-in-an-empty-list-in-the-circular-linked-list/)

#### **2. Insertion at the beginning in circular linked list**

> To insert a new node at the beginning of a circular linked list, we create a new node and check if the list is empty. If empty, the new node points to itself. If not, we make the new node\'s `next` pointer point to the current head (last->next) and update the last node\'s `next` to the new node, preserving the circular structure.

![Insertion-at-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150314/Insertion-at-the-beginning-of-circular-linked-list.webp)


> To read more about Insertion at the beginning Refer, [Insertion at the beginning in circular linked list](https://www.geeksforgeeks.org/insertion-at-the-beginning-in-circular-linked-list/)

#### **3. Insertion at the end in circular linked list**

> To insert a node at the end of a circular linked list, we create the new node and, if the list is empty, make it point to itself. Otherwise, we update the tail\'s `next` pointer to the new node and then set the tail to the new node, preserving the circular linkage.

![Insertion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150353/Insertion-at-the-end-of-circular-linked-list.webp)


> To read more about Insertion at the end Refer, [Insertion at the end in circular linked list](https://www.geeksforgeeks.org/insertion-at-the-end-in-circular-linked-list/)

#### **4. Insertion at specific position in circular linked list**

> To insert a node at a specific position in a circular linked list, we handle edge cases for an empty list and invalid positions. For valid positions, we traverse the list and adjust the pointers to insert the new node, updating the tail if it\'s inserted at the end.

![Insertion-at-specific-position-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150431/Insertion-at-specific-position-of-circular-linked-list.webp)


```C++
#include <iostream>
using namespace std;

struct Node{
  int data;
  Node *next;
  Node(int value) {
    data = value;
    next = nullptr;
  }
};

// Function to insert a node at a specific position in a circular linked list
Node *insertAtPosition(Node *last, int data, int pos){
  if (last == nullptr) {
    // If the list is empty
    if (pos != 1) {
      cout << "Invalid position!" << endl;
      return last;
    }
    // Create a new node and make it point to itself
    Node *newNode = new Node(data);
    last = newNode;
    last->next = last;
    return last;
  }

  // Create a new node with the given data
  Node *newNode = new Node(data);

  // curr will point to head initially
  Node *curr = last->next;

  if (pos == 1) {
    // Insert at the beginning
    newNode->next = curr;
    last->next = newNode;
    return last;
  }

  // Traverse the list to find the insertion point
  for (int i = 1; i < pos - 1; ++i) {
    curr = curr->next;

    // If position is out of bounds
    if (curr == last->next) {
      cout << "Invalid position!" << endl;
      return last;
    }
  }
  // Insert the new node at the desired position
  newNode->next = curr->next;
  curr->next = newNode;

  // Update last if the new node is inserted at the end
  if (curr == last) last = newNode;

  return last;
}

void printList(Node *last){
  if (last == NULL) return;

  Node *head = last->next;
  while (true) {
    cout << head->data << " ";
    head = head->next;
    if (head == last->next) break;
  }
  cout << endl;
}

int main(){
  // Create circular linked list: 2, 3, 4
  Node *first = new Node(2);
  first->next = new Node(3);
  first->next->next = new Node(4);

  Node *last = first->next->next;
  last->next = first;

  cout << "Original list: ";
  printList(last);

  // Insert elements at specific positions
  int data = 5, pos = 2;
  last = insertAtPosition(last, data, pos);
  cout << "List after insertions: ";
  printList(last);

  return 0;
}

```
```C
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
  int data;
  struct Node *next;
};

struct Node* createNode(int value);

// Function to insert a node at a specific position in a circular linked list
struct Node* insertAtPosition(struct Node *last, int data, int pos) {
  if (last == NULL) {
    // If the list is empty
    if (pos != 1) {
      printf("Invalid position!\\n");
      return last;
    }
    // Create a new node and make it point to itself
    struct Node *newNode = createNode(data);
    last = newNode;
    last->next = last;
    return last;
  }

  // Create a new node with the given data
  struct Node *newNode = createNode(data);

  // curr will point to head initially
  struct Node *curr = last->next;

  if (pos == 1) {
    // Insert at the beginning
    newNode->next = curr;
    last->next = newNode;
    return last;
  }

  // Traverse the list to find the insertion point
  for (int i = 1; i < pos - 1; ++i) {
    curr = curr->next;

    // If position is out of bounds
    if (curr == last->next) {
      printf("Invalid position!\\n");
      return last;
    }
  }

  // Insert the new node at the desired position
  newNode->next = curr->next;
  curr->next = newNode;

  // Update last if the new node is inserted at the end
  if (curr == last) last = newNode;

  return last;
}

// Function to print the circular linked list
void printList(struct Node *last) {
  if (last == NULL) return;

  struct Node *head = last->next;
  while (1) {
    printf("%d ", head->data);
    head = head->next;
    if (head == last->next) break;
  }
  printf("\\n");
}

// Function to create a new node
struct Node* createNode(int value) {
  struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
  newNode->data = value;
  newNode->next = NULL;
  return newNode;
}

int main() {
  // Create circular linked list: 2, 3, 4
  struct Node *first = createNode(2);
  first->next = createNode(3);
  first->next->next = createNode(4);

  struct Node *last = first->next->next;
  last->next = first;

  printf("Original list: ");
  printList(last);

  // Insert elements at specific positions
  int data = 5, pos = 2;
  last = insertAtPosition(last, data, pos);
  printf("List after insertions: ");
  printList(last);

  return 0;
}

```
```Java
class Node {
  int data;
  Node next;

  Node(int value) {
    data = value;
    next = null;
  }
}

public class GFG {
  // Function to insert a node at a specific position in a
  // circular linked list
  static Node insertAtPosition(Node last, int data, int pos) {
    if (last == null) {
      // If the list is empty
      if (pos != 1) {
        System.out.println("Invalid position!");
        return last;
      }
      // Create a new node and make it point to itself
      Node newNode = new Node(data);
      last = newNode;
      last.next = last;
      return last;
    }

    // Create a new node with the given data
    Node newNode = new Node(data);

    // curr will point to head initially
    Node curr = last.next;

    if (pos == 1) {
      // Insert at the beginning
      newNode.next = curr;
      last.next = newNode;
      return last;
    }

    // Traverse the list to find the insertion point
    for (int i = 1; i < pos - 1; ++i) {
      curr = curr.next;

      // If position is out of bounds
      if (curr == last.next) {
        System.out.println("Invalid position!");
        return last;
      }
    }

    // Insert the new node at the desired position
    newNode.next = curr.next;
    curr.next = newNode;

    // Update last if the new node is inserted at the
    // end
    if (curr == last) last = newNode;

    return last;
  }

  static void printList(Node last) {
    if (last == null) return;

    Node head = last.next;
    while (true) {
      System.out.print(head.data + " ");
      head = head.next;
      if (head == last.next) break;
    }
    System.out.println();
  }

 public
  static void main(String[] args) {
    // Create circular linked list: 2, 3, 4
    Node first = new Node(2);
    first.next = new Node(3);
    first.next.next = new Node(4);

    Node last = first.next.next;
    last.next = first;

    System.out.print("Original list: ");
    printList(last);

    // Insert elements at specific positions
    int data = 5, pos = 2;
    last = insertAtPosition(last, data, pos);
    System.out.print("List after insertions: ");
    printList(last);
  }
}

```
```Python
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

#Function to insert a node at a specific position in a circular linked list
def insertAtPosition(last, data, pos):
    if last is None:
#If the list is empty
        if pos != 1:
            print("Invalid position!")
            return last
#Create a new node and make it point to itself
        new_node = Node(data)
        last = new_node
        last.next = last
        return last

#Create a new node with the given data
    new_node = Node(data)

#curr will point to head initially
    curr = last.next

    if pos == 1:
#Insert at the beginning
        new_node.next = curr
        last.next = new_node
        return last

#Traverse the list to find the insertion point
    for i in range(1, pos - 1):
        curr = curr.next

#If position is out of bounds
        if curr == last.next:
            print("Invalid position!")
            return last

#Insert the new node at the desired position
    new_node.next = curr.next
    curr.next = new_node

#Update last if the new node is inserted at the end
    if curr == last:
        last = new_node

    return last

#Function to print the circular linked list
def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

if __name__ == "__main__":
#Create circular linked list : 2, 3, 4
    first = Node(2)
    first.next = Node(3)
    first.next.next = Node(4)

    last = first.next.next
    last.next = first

    print("Original list: ", end="")
    print_list(last)

#Insert elements at specific positions
    data = 5
    pos = 2
    last = insertAtPosition(last, data, pos)
    print("List after insertions: ", end="")
    print_list(last)

```
```JavaScript
class Node {
  constructor(value) {
    this.data = value;
    this.next = null;
  }
}

// Function to insert a node at a specific position in a
// circular linked list
function insertAtPosition(last, data, pos)
{
  if (last == = null) {
    // If the list is empty
    if (pos != = 1) {
      console.log("Invalid position!");
      return last;
    }
    // Create a new node and make it point to itself
    let newNode = new Node(data);
    last = newNode;
    last.next = last;
    return last;
  }

  // Create a new node with the given data
  let newNode = new Node(data);

  // curr will point to head initially
  let curr = last.next;

  if (pos == = 1) {
    // Insert at the beginning
    newNode.next = curr;
    last.next = newNode;
    return last;
  }

  // Traverse the list to find the insertion point
  for (let i = 1; i < pos - 1; ++i) {
    curr = curr.next;

    // If position is out of bounds
    if (curr == = last.next) {
      console.log("Invalid position!");
      return last;
    }
  }

  // Insert the new node at the desired position
  newNode.next = curr.next;
  curr.next = newNode;

  // Update last if the new node is inserted at the end
  if (curr == = last) last = newNode;

  return last;
}

// Function to print the circular linked list
function printList(last){
  if (last == = null) return;

  let head = last.next;
  while (true) {
    console.log(head.data + " ");
    head = head.next;
    if (head == = last.next) break;
  }
  console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Insert elements at specific positions
let data = 5;
let pos = 2;
last = insertAtPosition(last, data, pos);
console.log("List after insertions: ");
printList(last);

```

```output
Original list: 2 3 4 
List after insertions: 2 5 3 4 
```


## Searching in Circular Linked list

Searching in a circular linked list is similar to searching in a regular linked list. We start at a given node and traverse the list until you either find the target value or return to the starting node. Since the list is circular, make sure to keep track of where you started to avoid an infinite loop.

> To read more about searching Refer, [Searching in Circular Linked list](https://www.geeksforgeeks.org/searching-in-circular-linked-list/)

> Continue in the following lesson.
', 'Implementation  Insert, Search Operations on Linked List', 'Operation in Circular Linked List Part 1: Insert and Search Implementation.', 9, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('df10630d-515d-40e5-9918-bfe72d5a16d4', e'# What is Big O Notation?
**Big O notation** is a powerful tool used in computer science to describe the time complexity or space complexity of algorithms. **Big-O** is a way to express the **upper bound** of an algorithm’s time or space complexity.

-   Describes the asymptotic behavior (order of growth of time or space in terms of input size) of a function, not its exact value.
-   Can be used to compare the efficiency of different algorithms or data structures.
-   It provides an **upper limit** on the time taken by an algorithm in terms of the size of the input. We mainly consider the worst case scenario of the algorithm to find its time complexity in terms of Big O
-   It’s denoted as **O(f(n))**, where **f(n)** is a function that represents the number of operations (steps) that an algorithm performs to solve a problem of size **n**.

![big-o-analysis-banner](https://media.geeksforgeeks.org/wp-content/uploads/20240329121436/big-o-analysis-banner.webp)


# Big O Definition

Given two functions $f(n)$ and $g(n)$, we say that $f(n)$ is $O(g(n))$ if there exist constants $c > 0$ and $n_0 >= 0$ such that $f(n) <= c * g(n)$ for all $n >= n_0$.

In simpler terms, $f(n)$ is $O(g(n))$ if $f(n)$ grows no faster than $c*g(n)$ for all $n >= n_0$ where $c$ and $n_0$ are constants.

![big-o-image](https://media.geeksforgeeks.org/wp-content/uploads/20240329121512/big-o-image.webp)

# Importance of Big O Notation

Big O notation is a mathematical notation used to find an upper bound on time taken by an algorithm or data structure. It provides a way to compare the performance of different algorithms and data structures, and to predict how they will behave as the input size increases.

Big O notation is important for several reasons:

-   Big O Notation is important because it helps analyze the efficiency of algorithms.
-   It provides a way to describe how the **runtime** or **space requirements** of an algorithm grow as the input size increases.
-   Allows programmers to compare different algorithms and choose the most efficient one for a specific problem.
-   Helps in understanding the scalability of algorithms and predicting how they will perform as the input size grows.
-   Enables developers to optimize code and improve overall performance.

# A Quick Way to find Big O of an Expression

-   Ignore the lower order terms and consider only highest order term.
-   Ignore the constant associated with the highest order term**.**

> **Example 1**: $f(n) = 3n^2 + 2n + 1000Logn + 5000$
> - After ignoring lower order terms, we get the highest order term as $3n^2$
> - After ignoring the constant 3, we get $n^2$  
> - Therefore the Big O value of this expression is $O(n^2)$
> 
> **Example 2 :** $f(n) = 3n^3 + 2n^2 + 5n + 1$
> - Dominant Term: $3n^3a$  
> - Order of Growth: Cubic ($n^3$)  
> - Big O Notation: $O(n^3)$

# Properties of Big O Notation

Below are some important [Properties of Big O Notation](https://www.geeksforgeeks.org/properties-of-asymptotic-notations/):

#### **1. Reflexivity**

For any function $f(n), f(n) = O(f(n))$.

**Example:**
>$f(n) = n^2,$ then $f(n) = O(n^2).$
#### **2. Transitivity**

If $f(n) = O(g(n))$ and $g(n) = O(h(n)),$ then $f(n) = O(h(n))$.

**Example:**

> If $f(n) = n^2, g(n) = n^3,$ and $h(n) = n^4,$ then $f(n) = O(g(n))$ and $g(n) = O(h(n))$.  
> Therefore, by transitivity, $f(n) = O(h(n))$.

#### **3. Constant Factor**

For any constant $c > 0$ and functions $f(n)$ and $g(n)$, if $f(n) = O(g(n))$, then $cf(n) = O(g(n))$.

**Example:**

>$f(n) = n, g(n) = n^2$.  
> 
>Then $f(n) = O(g(n))$. 
>
>Therefore, $2f(n) = O(g(n))$.

#### **4. Sum Rule**

If $f(n) = O(g(n))$ and $h(n) = O(k(n))$, then $f(n) + h(n) = O(max( g(n), k(n) )$ When combining complexities, only the largest term dominates.

**Example:**

> $f(n) = n^2, h(n) = n^3$.
>
>  Then , $f(n) + h(n) = O(max(n^2 + n^3) = O ( n^3)$

#### **5. Product Rule**


If $f(n) = O(g(n))$ and $h(n) = O(k(n))$, then $f(n) * h(n) = O(g(n) * k(n))$.

**Example:**

> $f(n) = n, g(n) = n^2$, $h(n) = n^3$, $k(n) = n^4$. 
> 
>Then $f(n) = O(g(n))$ and $h(n) = O(k(n))$. 
> 
>Therefore, $f(n)* h(n) = O(g(n) * k(n)) = O(n^6)$.

#### **6. Composition Rule**

If $f(n) = O(g(n))$ and $g(n) = O(h(n))$, then $f(g(n)) = O(h(n))$.

**Example:**

> $f(n) = n^2$, $g(n) = n, h(n) = n^3$. 
>
> Then $f(n) = O(g(n))$ and $g(n) = O(h(n))$. 
>
> Therefore, $f(g(n)) = O(h(n)) = O(n^3)$.

# Common Big-O Notations

Big-O notation is a way to measure the time and space complexity of an algorithm. It describes the upper bound of the complexity in the worst-case scenario. Let’s look into the different types of time complexities:

## 1. Linear Time Complexity: Big O(n) Complexity

Linear time complexity means that the running time of an algorithm grows linearly with the size of the input.

For example, consider an algorithm that [traverses through an array to find a specific element](https://www.geeksforgeeks.org/linear-search/):
```cpp
bool findElement(int arr[], int n, int key)
{
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) {
            return true;
        }
    }
    return false;
}
```

## 2. Logarithmic Time Complexity: Big O(log n) Complexity

Logarithmic time complexity means that the running time of an algorithm is proportional to the logarithm of the input size.

For example, a [binary search algorithm](https://www.geeksforgeeks.org/binary-search/) has a logarithmic time complexity:
```cpp
int binarySearch(int arr[], int l, int r, int x)
{
    if (r >= l) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] > x)
            return binarySearch(arr, l, mid - 1, x);
        return binarySearch(arr, mid + 1, r, x);
    }
    return -1;
}
```

## 3. Quadratic Time Complexity: Big O(n$^2$) Complexity

Quadratic time complexity means that the running time of an algorithm is proportional to the square of the input size.

For example, a simple [bubble sort algorithm](https://www.geeksforgeeks.org/bubble-sort/) has a quadratic time complexity:
```cpp
void bubbleSort(int arr[], int n)
{
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(&arr[j], &arr[j + 1]);
            }
        }
    }
}
```

## 4. Cubic Time Complexity: Big O(n$^3$)  Complexity

Cubic time complexity means that the running time of an algorithm is proportional to the cube of the input size.

For example, a naive [matrix multiplication algorithm](https://www.geeksforgeeks.org/matrix-multiplication/) has a cubic time complexity:
```cpp
void multiply(int mat1[][N], int mat2[][N], int res[][N])
{
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            res[i][j] = 0;
            for (int k = 0; k < N; k++)
                res[i][j] += mat1[i][k] * mat2[k][j];
        }
    }
}
```

## 5. Polynomial Time Complexity: Big O(n$^k$) Complexity

Polynomial time complexity refers to the time complexity of an algorithm that can be expressed as a polynomial function of the input size **n**. In Big **O** notation, an algorithm is said to have polynomial time complexity if its time complexity is **O(n$^k$)**, where **k** is a constant and represents the degree of the polynomial.

Algorithms with polynomial time complexity are generally considered efficient, as the running time grows at a reasonable rate as the input size increases. Common examples of algorithms with polynomial time complexity include **linear time complexity O(n)**, **quadratic time complexity O(n$^2$)**, and **cubic time complexity O(n$^3$)**.

## 6. Exponential Time Complexity: Big O(2$^n$) Complexity

Exponential time complexity means that the running time of an algorithm doubles with each addition to the input data set.

For example, the problem of [generating all subsets of a set](https://www.geeksforgeeks.org/backtracking-to-find-all-subsets/) is of exponential time complexity:
```cpp
void generateSubsets(int arr[], int n)
{
    for (int i = 0; i < (1 << n); i++) {
        for (int j = 0; j < n; j++) {
            if (i & (1 << j)) {
                cout << arr[j] << " ";
            }
        }
        cout << endl;
    }
}
```

## 7. Factorial Time Complexity: Big O(n!) Complexity

Factorial time complexity means that the running time of an algorithm grows factorially with the size of the input. This is often seen in algorithms that generate all permutations of a set of data.

Here’s an example of a factorial time complexity algorithm, which generates all permutations of an array:
```cpp
void permute(int* a, int l, int r)
{
    if (l == r) {
        for (int i = 0; i <= r; i++) {
            cout << a[i] << " ";
        }
        cout << endl;
    }
    else {
        for (int i = l; i <= r; i++) {
            swap(a[l], a[i]);
            permute(a, l + 1, r);
            swap(a[l], a[i]); // backtrack
        }
    }
}
```


If we plot the most common Big O notation examples, we would have graph like this:

![asymtotic-analysis](https://media.geeksforgeeks.org/wp-content/cdn-uploads/mypic.png)

# Mathematical Examples of Runtime Analysis

Below table illustrates the runtime analysis of different orders of algorithms as the input size (n) increases.

| n | log(n) | n | n * log(n) | n$^2$ | 2$^n$ | n! |
| --- | --- | --- | --- | --- | --- | --- |
| 10 | 1 | 10 | 10 | 100 | 1024 | 3628800 |
| 20 | 2.996 | 20 | 59.9 | 400 | 1048576 | 2.432902e+1818 |

## Algorithmic Examples of Runtime Analysis

Below table categorizes algorithms based on their runtime complexity and provides examples for each type.

| Type | Notation | Example Algorithms |
| --- | --- | --- |
| Logarithmic | O(log n) | Binary Search |
| Linear | O(n) | Linear Search |
| Superlinear | O(n log n) | Heap Sort, Merge Sort |
| Polynomial | O(n$^c$) | Strassen’s Matrix Multiplication, Bubble Sort, Selection Sort, Insertion Sort, Bucket Sort |
| Exponential | O(c$^n$) | Tower of Hanoi |
| Factorial | O(n!) | Determinant Expansion by Minors, Brute force Search algorithm for Traveling Salesman Problem |

# Algorithm Classes with Number of Operations

Below are the classes of algorithms and their number of operations assuming that there are no constants.

| Big O Notation Classes| f(n)| Big O Analysis (number of operations) for n = 10 |
| --- | --- | --- |
| constant | O(1) | 1 |
| logarithmic | O(logn) | 3.32 |
| linear | O(n) | 10 |
| O(nlogn) | O(nlogn)| 33.2 |
| quadratic | O(n$^2$) | 10$^2$ |
| cubic| O(n$^3$)| 10$^3$ |
| exponential | O(2$^n$) | 1024 |
| factorial |O(n!) | 10! |

# Comparison of Big O Notation, Big $\\Omega$ (Omega) Notation, and Big $\\theta$ (Theta) Notation

Below is a table comparing Big O notation, $\\Omega$ (Omega) notation, and $\\theta$ (Theta) notation:

| Notation | Definition | Explanation |
| --- | --- | --- |
| Big O (O) | $f(n) \\le C * g(n) \\forall n \\ge n^0$ | Describes the upper bound of the algorithm\'s running time. Used most of the time. |
| $\\Omega(Omega)$ | $f(n) \\ge C * g(n) \\forall n \\ge n^0$ | Describes the lower bound of the algorithm\'s running time . Used less |
| $\\theta$ (Theta) | C$^1$ * g(n) $\\le$ f(n) $\\le$ C$^2$ * g(n) $\\forall$ n $\\ge$ n$^0$ | Describes both the upper and lower bounds of the algorithm\'s **running time**. Also used a lot more and preferred over Big O if we can find an exact bound. |

In each notation:

-   **f(n)** represents the function being analyzed, typically the algorithm\'s time complexity.
-   **g(n)** represents a specific function that bounds **f(n)**.
-   **C, C1,** and **C2** are constants.
-   ***n***$_0$ is the minimum input size beyond which the inequality holds.

These notations are used to analyze algorithms based on their **worst-case (Big O)**, **best-case ($\\Omega$)**, and **average-case ($\\theta$)** scenarios.
', 'Big O notation is a powerful tool used in computer science to describe the time complexity or space complexity of algorithms. Big-O is a way to express the upper bound of an algorithm’s time or space complexity.', 'Big O Notation Tutorial - A Guide to Big O Analysis', 3, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('ec26f50a-f134-4978-b817-3084496c9feb', e'# Basic terminologies of Array

-   **Array Index:** In an array, elements are identified by their indexes. Array index starts from 0.
-   **Array element:** Elements are items stored in an array and can be accessed by their index.
-   **Array Length:** The length of an array is determined by the number of elements it can contain. 

# Memory representation of Array

In an array, all the elements are stored in contiguous memory locations. So, if we initialize an array, the elements will be allocated sequentially in memory. This allows for efficient access and manipulation of elements.

![3-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250224182515919065/1-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250224182515574059/2-.webp)![3-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250224182515285430/3-.webp)


## Declaration of Array

Arrays can be declared in various ways in different languages. For better illustration, below are some language-specific array declarations:

```cpp
// This array will store integer type element
int arr[5];      

// This array will store char type element
char arr[10];   

// This array will store float type element
float arr[20];
```
```c
// This array will store integer type element
int arr[5];      

// This array will store char type element
char arr[10];   

// This array will store float type element
float arr[20];
```
```java
// This array will store integer type element
int arr[];     

// This array will store char type element
char arr[];   

// This array will store float type element
float arr[];
```
```python
# In Python, all types of lists are created same way
arr = []
```
```csharp
// This array will store integer type element
int[] arr;

// This array will store char type element
char[] arr2;

// This array will store float type element
float[] arr3;
```
```javascript
// JS code
let arr = []
```


## Initialization of Array

Arrays can be initialized in different ways in different languages. Below are some language-specific array initializations:



```cpp
int arr[] = { 1, 2, 3, 4, 5 };
char arr[5] = { \'a\', \'b\', \'c\', \'d\', \'e\' };
float arr[10] = { 1.4, 2.0, 24, 5.0, 0.0 };
```
```c
int arr[] = { 1, 2, 3, 4, 5 };
char arr[5] = { \'a\', \'b\', \'c\', \'d\', \'e\' };
float arr[10] = { 1.4, 2.0, 24, 5.0, 0.0 };
```
```java
int arr[] = { 1, 2, 3, 4, 5 };
char arr[] = { \'a\', \'b\', \'c\', \'d\', \'e\' };
float arr[] = { 1.4f, 2.0f, 24f, 5.0f, 0.0f };
```
```python
# This list will store integer type elements
arr = [1, 2, 3, 4, 5]

# This list will store character type elements (strings in Python)
arr = [\'a\', \'b\', \'c\', \'d\', \'e\']

# This list will store float type elements
arr = [1.4, 2.0, 24.0, 5.0, 0.0]  # All float values
```
```csharp
int[] arr = { 1, 2, 3, 4, 5 };
char[] arr = { \'a\', \'b\', \'c\', \'d\', \'e\' };
float[] arr = { 1.4f, 2.0f, 24f, 5.0f, 0.0f };
```
```javascript
let arr = [ 1, 2, 3, 4, 5 ];
let arr = [ \'a\', \'b\', \'c\', \'d\', \'e\' ];
let arr = [ 1.4, 2.0, 24, 5.0, 0.0 ];
```

# Why do we Need Arrays?

Assume there is a class of five students and if we have to keep records of their marks in examination then, we can do this by declaring five variables individual and keeping track of records but what if the number of students becomes very large, it would be challenging to manipulate and maintain the data.

What it means is that, we can use normal variables (v1, v2, v3, ..) when we have a small number of objects. But if we want to store a large number of instances, it becomes difficult to manage them with normal variables.

> The idea of an array is to represent many instances in one variable.

![Importance-of-Array](https://media.geeksforgeeks.org/wp-content/uploads/20240405123859/Importance-of-Array.webp)

# Types of Arrays

Arrays can be classified in two ways:

-   On the basis of Size
-   On the basis of Dimensions

![Types-of-Arrays](https://media.geeksforgeeks.org/wp-content/uploads/20240731124259/Types-of-Arrays.webp)

## Types of Arrays on the basis of Size

**1\\. Fixed Sized Arrays**

We cannot alter or update the size of this array. Here only a fixed size (i,e. the size that is mentioned in square brackets **\\[\\]**) of memory will be allocated for storage. In case, we don’t know the size of the array then if we declare a larger size and store a lesser number of elements will result in a wastage of memory or we declare a lesser size than the number of elements then we won’t get enough memory to store all the elements. In such cases, static memory allocation is not preferred.


```cpp
// Method 1 to create a fixed sized array. 
// Here the memory is allocated at compile time.
int arr[5]; 
// Another way (creation and initialization both)
int arr2[5] = {1, 2, 3, 4, 5}; 

// Method 2 to create a fixed sized array
// Here memory is allocated at run time (Also
// known as dynamically allocated arrays)
int *arr = new int[5];
```
```c
// Method 1 to create a fixed sized array. 
// Here the memory is allocated at compile time.
int arr1[5];
// Another way (creation and initialization both)
int arr2[5] = {1, 2, 3, 4, 5}; 


// Method 2 to create a fixed sized array
// Here memory is allocated at run time (Also
// known as dynamically allocated arrays)
int *arr = (int*)malloc(n * sizeof(int));
```
```java
// Fixed sized array examples
int[] arr1 = new int [5];

// Another way (Array creation and 
// initialization both)
int[] arr2 = {1, 2, 3, 4, 5};
```
```python
# Create a fixed-size list of length 5, 
# initialized with zeros
arr = [0] * 5

# Output the fixed-size list
print(arr)
```
```csharp
// Fixed sized array examples
int[] arr1 = new int [5];

// Another way (Array creation and 
// initialization both)
int[] arr2 = {1, 2, 3, 4, 5};
```

**2\\. Dynamic Sized Arrays**

The size of the array changes as per user requirements during execution of code so the coders do not have to worry about sizes. They can add and removed the elements as per the need. The memory is mostly dynamically allocated and de-allocated in these arrays.


```cpp
// This array will store integer type element
#include<vector>

// Dynamic Integer Array
vector<int> v;
```
```c
// C does not seem to support
// dynamic sized arrays as of now
```
```java
// Dynamic Integer Array
ArrayList<Integer> arr = new ArrayList<>();
```
```python
# Dynamic Array
arr = []
```
```csharp
// Similar to Java
ArrayList myList = new ArrayList();
```
```javascript
// Dynamic Sized Array
let arr = new Array();
```

## Types of Arrays on the basis of Dimensions

**1\\. One-dimensional Array(1-D Array):** You can imagine a 1d array as a row, where elements are stored one after another.

![One-Dimensional-Array(1-D-Array)](https://media.geeksforgeeks.org/wp-content/uploads/20240405123929/One-Dimensional-Array(1-D-Array).webp)

**2\\. Multi-dimensional Array:** A multi-dimensional array is an array with more than one dimension. We can use multidimensional array to store complex data in the form of tables, etc. We can have 2-D arrays, 3-D arrays, 4-D arrays and so on.

-   **Two-Dimensional Array(2-D Array or Matrix):** 2-D Multidimensional arrays can be considered as an array of arrays or as a matrix consisting of rows and columns.

> To read more about Matrix Refer, [Matrix Data Structure](https://www.geeksforgeeks.org/matrix/)

![Two-Dimensional-Array(2-D-Array-or-Matrix)](https://media.geeksforgeeks.org/wp-content/uploads/20240408165401/Two-Dimensional-Array(2-D-Array-or-Matrix).webp)

-   **Three-Dimensional Array(3-D Array):** A 3-D Multidimensional array contains three dimensions, so it can be considered an array of two-dimensional arrays.

> To read more about Multidimensional Array Refer, [Multidimensional Arrays in C – 2D and 3D Arrays](https://www.geeksforgeeks.org/multidimensional-arrays-in-c/)

![Three-Dimensional-Array(3-D-Array)](https://media.geeksforgeeks.org/wp-content/uploads/20240408165421/Three-Dimensional-Array(3-D-Array).webp)

# Operations on Array 

#### **1\\. Array Traversal**

Array traversal refers to the process of accessing and processing each element of an array sequentially. This is one of the most fundamental operations in programming, as arrays are widely used data structures for storing multiple elements in a single variable.

**How Array Traversal Works?**

When an array is created, it occupies a contiguous block of memory where elements are stored in an indexed manner. Each element can be accessed using its index, which starts from `0` in most programming languages.

For example, consider an array containing five integers:

>`arr = [10, 20, 30, 40, 50]`

Here:

-   The first element (`10`) is at **index 0**.
-   The second element (`20`) is at **index 1**.
-   The last element (`50`) is at **index 4**.

Array traversal means accessing each element from start to end (or sometimes in reverse order), usually by using a loop.

**Types of Array Traversal**

Array traversal can be done in multiple ways based on the requirement:

1.  **Sequential (Linear) Traversal**
    -   This is the most common way of traversing an array.
    -   It involves iterating through the array one element at a time from the first index to the last.
    -   Used for printing elements, searching, or performing calculations (such as sum or average).
2.  **Reverse Traversal**
    -   Instead of starting from index `0`, the traversal begins from the last element and moves towards the first.
    -   This is useful in cases where we need to process elements from the end.

> To read more about Array Traversal Refer, [Traversal in Array](https://www.geeksforgeeks.org/traversal-in-array/)

#### **2\\. Insertion in Array**

Insertion in an array refers to the process of adding a new element at a specific position while maintaining the order of the existing elements. Since arrays have a fixed size in static implementations, inserting an element often requires shifting existing elements to make space.

**How Insertion Works in an Array?**

Arrays are stored in contiguous memory locations, meaning elements are arranged in a sequential block. When inserting a new element, the following happens:

1.  **Identify the Position**: Determine where the new element should be inserted.
2.  **Shift Elements**: Move the existing elements one position forward to create space for the new element.
3.  **Insert the New Element**: Place the new value in the correct position.
4.  **Update the Size (if applicable)**: If the array is dynamic, its size is increased.

For example, if we have the array:

> `arr = [10, 20, 30, 40, 50]`

and we want to insert `25` at index `2`, the new array will be:

> `arr = [10, 20, 25, 30, 40, 50]`

Here, elements `30`, `40`, and `50` have shifted right to make space.

**Types of Insertion**

**1\\. Insertion at the Beginning (Index 0)**

-   Every element must shift one position right.
-   This is the least efficient case for large arrays as it affects all elements.

**2\\. Insertion at a Specific Index**

-   Elements after the index shift right.
-   If the index is in the middle, half of the array moves.

**3\\. Insertion at the End**

-   The simplest case since no shifting is required.
-   Used in dynamic arrays where size increases automatically (e.g., Python lists, Java `ArrayList`).

> To read more about Insertion in Array Refer, [Inserting Elements in an Array – Array Operations](https://www.geeksforgeeks.org/inserting-elements-in-an-array-array-operations/)

#### **3\\. Deletion in Array**

Deletion in an array refers to the process of removing an element from a specific position while maintaining the order of the remaining elements. Unlike linked lists, where deletion is efficient, removing an element from an array requires shifting elements to fill the gap.

**How Deletion Works in an Array?**

Since arrays have contiguous memory allocation, deleting an element does not reduce the allocated memory size. Instead, it involves:

1.  **Identify the Position**: Find the index of the element to be deleted.
2.  **Shift Elements**: Move the elements after the deleted element one position to the left.
3.  **Update the Size (if applicable)**: If using a dynamic array, the size might be reduced.

For example, consider the array:

> `arr = [10, 20, 30, 40, 50]`

If we delete the element `30` (index `2`), the new array will be:

> `arr = [10, 20, 40, 50]`

Here, elements `40` and `50` shifted left to fill the gap.

**Types of Deletion**

**1\\. Deletion at the Beginning (Index 0)**

-   Every element shifts left by one position.
-   This is the most expensive case as it affects all elements.

**2\\. Deletion at a Specific Index**

-   Only elements after the index shift left.
-   If the index is in the middle, half of the array moves.

**3\\. Deletion at the End**

-   The simplest case since no shifting is required.
-   The size of the array is reduced (in dynamic arrays).

> To read more about Deletion in Array Refer, [Deleting Elements in an Array – Array Operations](https://www.geeksforgeeks.org/deleting-elements-in-an-array-array-operations/)

**4\\. Searching in Array**

Searching in an array refers to the process of finding a specific element in a given list of elements. The goal is to determine whether the element exists in the array and, if so, find its index (position).

Searching is a fundamental operation in programming, as it is used in data retrieval, filtering, and processing.

#### **Types of Searching in an Array**

There are two main types of searching techniques in an array:

**1\\. Linear Search (Sequential Search)**

-   This is the simplest search algorithm.
-   It traverses the array one element at a time and compares each element with the target value.
-   If a match is found, it returns the index of the element.
-   If the element is not found, the search continues until the end of the array.

##### **Example:**

Consider an array:

> `arr = [10, 20, 30, 40, 50]`

If we search for `30`, the algorithm will:

1.  Compare `10` with `30` → No match.
2.  Compare `20` with `30` → No match.
3.  Compare `30` with `30` → **Match found at index** **`**2**`****.**

**2\\. Binary Search (Efficient Search for Sorted Arrays)**

-   Works only on sorted arrays (in increasing or decreasing order).
-   Uses a divide and conquer approach.
-   It repeatedly divides the search space in half until the target element is found.

##### **How Binary Search Works?**

1.  Find the middle element of the array.
2.  If the target is equal to the middle element, return its index.
3.  If the target is less than the middle element, search the left half.
4.  If the target is greater than the middle element, search the right half.
5.  Repeat until the element is found or the search space is empty.

##### **Example:**

Consider a sorted array:

> `arr = [10, 20, 30, 40, 50]`

If we search for `30`:

1.  Middle element = `30` → Match found!
2.  The search ends in just one step, making it much faster than linear search.
> To read more about Searching in Array Refer, [Searching Elements in Array](https://www.geeksforgeeks.org/searching-elements-in-an-array-array-operations/)


', 'Array is a collection of items of the same variable type that are stored at contiguous memory locations. It is one of the most popular and simple data structures used in programming.', e'Getting Started with Array Data Structure
', 4, '73c532f9-4d55-4737-ae19-3006e02864cc', 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('dfada5ab-a189-4507-8c06-78c269c52440', e'# Understanding Node Structure

In a singly linked list, each node consists of two parts: data and a pointer to the next node. This structure allows nodes to be dynamically linked together, forming a chain-like sequence.

![Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240917161540/Singly-Linked-List.webp)

```cpp
// Definition of a Node in a singly linked list
class Node {
    constructor(data) {
    // Data part of the node
        this.data = data;   
        this.next = null;   
    }
}
```
```c
// Definition of a Node in a singly linked list
struct Node {
    int data;          
    struct Node* next;
};

// Function to create a new Node
struct Node* newNode(int data) {
    struct Node* temp = 
      (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}
```
```java
// Definition of a Node in a singly linked list
public class Node {
    int data;
    Node next;

    // Constructor to initialize the node with data
    public Node(int data)
    {
        this.data = data;
        this.next = null;
    }
}
```
```python
# Definition of a Node in a singly linked list
class Node:
    def __init__(self, data):
       # Data part of the node
        self.data = data   
        self.next = None
```
```javacript
// Definition of a Node in a singly linked list
class Node {
    constructor(data) {
    // Data part of the node
        this.data = data;   
        this.next = null;   
    }
}
```
In this example, the Node class contains an integer data field (****data****) to store the information and a pointer to another Node (****next****) to establish the link to the next node in the list.

## 1. Traversal of Singly Linked List

Traversal in a linked list means visiting each node and performing operations like printing or processing data.

****Step-by-step approach:****

1.  ****Initialize a pointer**** (`current`) to the head of the list.
2.  ****Loop through the list**** using a `while` loop until `current` becomes `NULL`.
3.  ****Process each node**** (e.g., print its data).
4.  ****Move to the next node**** by updating `current = current->next`.

> To read more about Traversal Operation in linked list Refer, [Traversal of Singly Linked List](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)

## 2. Searching in Singly Linked List

Searching in a Singly Linked List refers to the process of looking for a specific element or value within the elements of the linked list.

****Step-by-step approach:****

1.  ****Start from the head**** of the linked list.
2.  ****Check each node’s data****:
    -   If it matches the target value, ****r****eturn true (element found).
    -   Otherwise, move to the next node.
3.  ****Repeat until**** the end (`NULL`) is reached.
4.  If no match is found, ****return false****.

> To read more about Searching Operation in linked list Refer, [Search an element in a Linked List](https://www.geeksforgeeks.org/search-an-element-in-a-linked-list-iterative-and-recursive/)

## 3. Length of Singly Linked List

Finding the length of a ****Singly Linked List**** means counting the total number of nodes.

****Step-by-step approach:****

1.  ****Initialize**** a counter (`length = 0`).
2.  ****Start from the head****, assign it to `current`.
3.  ****Traverse the list****:
    -   ****Increment**** **`**length**`** for each node.
    -   ****Move to the next node**** (`current = current->next`).
4.  ****Return the final**** **`**length**`** when `current` becomes `NULL`.

> To read more about Finding Length of linked list Refer, [Find Length of a Linked List](https://www.geeksforgeeks.org/find-length-of-a-linked-list-iterative-and-recursive/)

## 4. Insertion in Singly Linked List

[Insertion](https://www.geeksforgeeks.org/insertion-in-linked-list/) is a fundamental operation in linked lists that involves adding a new node to the list. There are several scenarios for insertion:

****a. Insertion at the Beginning of Singly Linked List:**** Insertion at the beginning involves adding a new node before the current head, making it the new head.

![Insertion-at-the-Beginning-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163445386036/Insertion-at-the-Beginning-of-Singly-Linked-List.webp)

Insert a Node at the Front/Beginning of Linked List

****Step-by-step approach:****

-   Create a new node with the given value.
-   Set the ****next**** pointer of the new node to the current head.
-   Move the head to point to the new node.
-   Return the new head of the linked list.

> To read more about Insertion at the Beginning of linked list Refer, [Insert a Node at Front/Beginning of a Linked List](https://www.geeksforgeeks.org/insert-a-node-at-front-beginning-of-a-linked-list/)

****b. Insertion at the End of Singly Linked List:**** To insert a node at the end of the list, traverse the list until the last node is reached, and then link the new node to the current last node

![Insertion-at-the-End-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163601409037/Insertion-at-the-End-of-Singly-Linked-List.webp)

Insertion at end of Linked List

****Step-by-step approach:****

-   Create a new node with the given value.
-   Check if the list is empty:
    -   If it is, make the new node the head and return.
-   Traverse the list until the last node is reached.
-   Link the new node to the current last node by setting the last node\'s next pointer to the new node.

> To read more about Insertion at the end of linked list Refer, [Insert Node at the End of a Linked List](https://www.geeksforgeeks.org/insert-node-at-the-end-of-a-linked-list/)

****c. Insertion at a Specific Position of the Singly Linked List:**** To insert a node at a specific position, traverse the list to the desired position, link the new node to the next node, and update the links accordingly.

![Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20241022163649252002/Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy.webp)

****Step-by-step approach:****

-   ****Create a new node**** and assign it a value.
-   ****If inserting at the beginning**** (position = 1):
    -   Point the new node’s `next` to the current head.
    -   Update the head to the new node.
    -   ****Return**** (Insertion done).
-   ****Otherwise, traverse the list****:
    -   Start from the head and move to the `(position - 1)ᵗʰ` node (just before the desired position).
    -   If the position is beyond the list length, ****return an error or append at the end****.
-   ****Insert the new node****:
    -   Point the new node’s `next` to the next node of the current position.
    -   Update the previous node’s `next` to the new node.
-   ****Return the updated list.****

> To read more about Insertion at the specific position of linked list Refer, [Insert a node at a specific position in a linked list](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-a-linked-list/)

## 5. Deletion in Singly Linked List

[Deletion](https://www.geeksforgeeks.org/deletion-in-linked-list/) involves removing a node from the linked list. Similar to insertion, there are different scenarios for deletion:

****a. Deletion at the Beginning of Singly Linked List:**** To delete the first node, update the head to point to the second node in the list.

![Deletion-at-beginning-](https://media.geeksforgeeks.org/wp-content/uploads/20241022163937663413/Deletion-at-beginning-.webp)

Deletion at beginning in a Linked List

****Steps-by-step approach:****

-   Check if the head is ****NULL****.
    -   If it is, return ****NULL**** (the list is empty).
-   Store the current head node in a temporary variable ****temp****.
-   Move the head pointer to the next node.
-   Delete the temporary node.
-   Return the new head of the linked list.

> To read more about Deletion at the beginning in linked list Refer, [Deletion at beginning (Removal of first node) in a Linked List](https://www.geeksforgeeks.org/remove-first-node-of-the-linked-list/)

****b. Deletion at the End of Singly Linked List:**** To delete the last node, traverse the list until the second-to-last node and update its next field to None.

![Deletion-At-End](https://media.geeksforgeeks.org/wp-content/uploads/20241022164030481275/Deletion-At-End.webp)

Deletion at the end of linked list

****Step-by-step approach:****

-   Check if the head is ****NULL****.
    -   If it is, return NULL (the list is empty).
-   Check if the head\'s ****next**** is ****NULL**** (only one node in the list).
    -   If true, delete the head and return ****NULL****.
-   Traverse the list to find the second last node (****second\\_last****).
-   Delete the last node (the node after ****second\\_last****).
-   Set the ****next**** pointer of the second last node to ****NULL****.
-   Return the head of the linked list.

> To read more about Deletion at the end in linked list Refer, [Deletion at end (Removal of last node) in a Linked List](https://www.geeksforgeeks.org/remove-last-node-of-the-linked-list/)

****c. Deletion at a Specific Position of Singly Linked List:**** To delete a node at a specific position, traverse the list to the desired position, update the links to bypass the node to be deleted.

![Deletion-specific-At-End--](https://media.geeksforgeeks.org/wp-content/uploads/20241022164248836160/Deletion-specific-At-End--.webp)

Delete a Linked List node at a given position

****Step-by-step approach:****

-   Check if the list is empty or the position is invalid, return if so.
-   If the head needs to be deleted, update the head and delete the node.
-   Traverse to the node before the position to be deleted.
-   If the position is out of range, return.
-   Store the node to be deleted.
-   Update the links to bypass the node.
-   Delete the stored node.

> To read more about Deletion at the specific position in linked list Refer, [Delete a Linked List node at a given position](https://www.geeksforgeeks.org/delete-a-linked-list-node-at-a-given-position/)

## 6. Modify a Singly Linked List

Updating in a Singly Linked List means modifying the value of a node at a given position.

****Step-by-step approach:****

-   ****Start from the head**** of the list.
-   ****Traverse to the required position**** (move `current` node to `position`).
-   ****Check if the position is valid****:
    -   If the position is out of bounds, ****return an error****.
-   ****Update the node’s data**** with the new value.
-   ****Return the modified list.****

> To read more about Updation Operation in Linked List Refer, [Modify contents of Linked List](https://www.geeksforgeeks.org/modify-contents-linked-list/)

## 7. Reversing a Singly Linked List

Reversing a singly linked list means changing the direction of pointers so that the last node becomes the new head.

****Step-by-step approach:****

-   ****Initialize three pointers:****
    -   `prev = NULL` (to track the previous node)
    -   `current = head` (starting point)
    -   `next = NULL` (to store the next node temporarily)
-   ****Iterate through the list:****
    -   Store `next = current->next` (save next node).
    -   Reverse the link: `current->next = prev`.
    -   Move `prev` and `current` forward (`prev = current`, `current = next`).
-   ****Update**** **`**head**`** ****to**** **`**prev**`** (new head is the last node).

> To read more about Reversal Operation in Linked List Refer, [Reverse a Linked List](https://www.geeksforgeeks.org/reverse-a-linked-list/)

', 'A singly linked list is a fundamental data structure, it consists of nodes where each node contains a data field and a reference to the next node in the linked list.', e'Singly Linked List Data Structure
', 6, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('54b848db-7d95-4a37-ac24-3976e9e5d829', e'## Deletion from a Circular Linked List

[Deletion](https://www.geeksforgeeks.org/deletion-circular-linked-list/) involves removing a node from the linked list. The main difference is that we need to ensure the list remains circular after the deletion. We can delete a node in a circular linked list in three ways:

#### **1. Delete the first node in circular linked list**

> To delete the first node of a circular linked list, we check if the list is empty or has only one node. If so, we handle those cases by deleting the node and updating the last pointer. For multiple nodes, we update the last node’s `next` pointer to skip the head and free the head node, returning the updated last pointer.

![Deletion-from-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150500/Deletion-from-the-beginning-of-circular-linked-list.webp)
```C++
#include <iostream>
using namespace std;

struct Node {
  int data;
  Node* next;
  Node(int value) {
    data = value;
    next = nullptr;
  }
};

// Function to delete the first node of the circular linked list
Node* deleteFirstNode(Node* last) {
  if (last == nullptr) {
    // If the list is empty
    cout << "List is empty" << endl;
    return nullptr;
  }

  Node* head = last->next;

  if (head == last) {
    // If there is only one node in the list
    delete head;
    last = nullptr;
  } else {
    // More than one node in the list
    last->next = head->next;
    delete head;
  }

  return last;
}

void printList(Node* last) {
  if (last == NULL) return;

  Node* head = last->next;
  while (true) {
    cout << head->data << " ";
    head = head->next;
    if (head == last->next) break;
  }
  cout << endl;
}

int main() {
  // Create circular linked list: 2, 3, 4
  Node* first = new Node(2);
  first->next = new Node(3);
  first->next->next = new Node(4);

  Node* last = first->next->next;
  last->next = first;

  cout << "Original list: ";
  printList(last);

  // Delete the first node
  last = deleteFirstNode(last);

  cout << "List after deleting first node: ";
  printList(last);

  return 0;
}

```
```Java
 class Node {
  int data;
  Node next;

  Node(int value) {
    data = value;
    next = null;
  }
}

public class GFG {
 public
  static Node deleteFirstNode(Node last) {
    if (last == null) {
      // If the list is empty
      System.out.println("List is empty");
      return null;
    }

    Node head = last.next;

    if (head == last) {
      // If there is only one node in the list
      last = null;
    } else {
      // More than one node in the list
      last.next = head.next;
    }

    return last;
  }

 public
  static void printList(Node last) {
    if (last == null) return;

    Node head = last.next;
    while (true) {
      System.out.print(head.data + " ");
      head = head.next;
      if (head == last.next) break;
    }
    System.out.println();
  }

 public
  static void main(String[] args) {
    // Create circular linked list: 2, 3, 4
    Node first = new Node(2);
    first.next = new Node(3);
    first.next.next = new Node(4);

    Node last = first.next.next;
    last.next = first;

    System.out.print("Original list: ");
    printList(last);

    // Delete the first node
    last = deleteFirstNode(last);

    System.out.print("List after deleting first node: ");
    printList(last);
  }
}

```
```Python
 class Node : def
                   __init__(self, data)
    : self.data = data self.next = None

    def deleteFirstNode(last)
    : if last is None :
#If the list is empty
    print("List is empty") return None

    head = last.next

           if head
           == last :
#If there is only one node in the list
    last = None else :
#More than one node in the list
    last.next = head.next

                return last

                def print_list(last)
    : if last is None : return

                        head =
               last.next while True : print(head.data, end = " ") head =
                   head.next if head == last.next : break print()

#Create circular linked list : 2, 3, 4
                                                        first =
                       Node(2) first.next = Node(3) first.next.next = Node(4)

                           last = first.next.next last.next = first

    print("Original list: ", end = "") print_list(last)

#Delete the first node
        last = deleteFirstNode(last)

            print("List after deleting first node: ", end = "") print_list(last)

```
```JavaScript
 class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

function
deleteFirstNode(last) {
  if (last == = null) {
    // If the list is empty
    console.log("List is empty");
    return null;
  }

  let head = last.next;

  if (head == = last) {
    // If there is only one node in the list
    last = null;
  } else {
    // More than one node in the list
    last.next = head.next;
  }

  return last;
}

function printList(last) {
  if (last == = null) return;

  let head = last.next;
  while (true) {
    console.log(head.data + " ");
    head = head.next;
    if (head == = last.next) break;
  }
  console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete the first node
last = deleteFirstNode(last);

console.log("List after deleting first node: ");
printList(last);

```

```Output
Original list: 2 3 4 
List after deleting first node: 3 4 
```

#### **2. Delete a specific node in circular linked list**

> To delete a specific node from a circular linked list, we handle empty list and single node cases. For other nodes, we use two pointers to find the node, update the previous node’s `next` pointer to skip the target, and delete it, updating the last pointer if needed.

![Delete-a-specific-node-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150531/Delete-a-specific-node-in-circular-linked-list.webp)

```C++
#include <iostream>
using namespace std;

struct Node {
  int data;
  Node* next;
  Node(int value) {
    data = value;
    next = nullptr;
  }
};

// Function to delete a specific node in the circular linked list
Node* deleteSpecificNode(Node* last, int key) {
  if (last == nullptr) {
    // If the list is empty
    cout << "List is empty, nothing to delete." << endl;
    return nullptr;
  }

  Node* curr = last->next;
  Node* prev = last;

  // If the node to be deleted is the only node in the list
  if (curr == last && curr->data == key) {
    delete curr;
    last = nullptr;
    return last;
  }

  // If the node to be deleted is the first node
  if (curr->data == key) {
    last->next = curr->next;
    delete curr;
    return last;
  }

  // Traverse the list to find the node to be deleted
  while (curr != last && curr->data != key) {
    prev = curr;
    curr = curr->next;
  }

  // If the node to be deleted is found
  if (curr->data == key) {
    prev->next = curr->next;
    if (curr == last) {
      last = prev;
    }
    delete curr;
  } else {
    // If the node to be deleted is not found
    cout << "Node with data " << key << " not found." << endl;
  }

  return last;
}

// Function to print the circular linked list
void printList(Node* last) {
  if (last == NULL) {
    cout << "List is Empty";
    return;
  }

  Node* head = last->next;
  while (true) {
    cout << head->data << " ";
    head = head->next;
    if (head == last->next) break;
  }
  cout << endl;
}

int main() {
  // Create circular linked list: 2, 3, 4
  Node* first = new Node(2);
  first->next = new Node(3);
  first->next->next = new Node(4);

  Node* last = first->next->next;
  last->next = first;

  cout << "Original list: ";
  printList(last);

  // Delete a specific node
  int key = 3;
  last = deleteSpecificNode(last, key);

  cout << "List after deleting node " << key << ": ";
  printList(last);

  return 0;
}

```
```Java
 class Node {
  int data;
  Node next;
  Node(int value) {
    data = value;
    next = null;
  }
}

public class GFG {
 public
  static Node deleteSpecificNode(Node last, int key) {
    if (last == null) {
      // If the list is empty
      System.out.println("List is empty, nothing to delete.");
      return null;
    }
    Node curr = last.next;
    Node prev = last;

    // If the node to be deleted is the only node in the
    // list
    if (curr == last && curr.data == key) {
      last = null;
      return last;
    }

    // If the node to be deleted is the first node
    if (curr.data == key) {
      last.next = curr.next;
      return last;
    }

    // Traverse the list to find the node to be deleted
    while (curr != last && curr.data != key) {
      prev = curr;
      curr = curr.next;
    }

    // If the node to be deleted is found
    if (curr.data == key) {
      prev.next = curr.next;
      if (curr == last) {
        last = prev;
      }
    } else {
      // If the node to be deleted is not found
      System.out.println("Node with data " + key + " not found.");
    }
    return last;
  }

 public
  static void printList(Node last) {
    if (last == null) {
      System.out.println("List is Empty");
      return;
    }

    Node head = last.next;
    while (true) {
      System.out.print(head.data + " ");
      head = head.next;
      if (head == last.next) break;
    }
    System.out.println();
  }

 public
  static void main(String[] args) {
    // Create circular linked list: 2, 3, 4
    Node first = new Node(2);
    first.next = new Node(3);
    first.next.next = new Node(4);

    Node last = first.next.next;
    last.next = first;

    System.out.print("Original list: ");
    printList(last);

    // Delete a specific node
    int key = 3;
    last = deleteSpecificNode(last, key);

    System.out.print("List after deleting node " + key + ": ");
    printList(last);
  }
}

```
```Python
 class Node : def
                   __init__(self, data)
    : self.data = data self.next = None

    def deleteSpecificNode(last, key)
    : if last is None :
#If the list is empty
    print("List is empty, nothing to delete.") return None

    curr = last.next prev = last

#If the node to be deleted is the only node in the list
                            if curr
                            == last and curr.data == key : last =
                                None return last

#If the node to be deleted is the first node
                                if curr.data
                                == key
    : last.next = curr.next return last

#Traverse the list to find the node to be deleted
                  while curr
                  != last and curr.data != key : prev = curr curr = curr.next

#If the node to be deleted is found
                                                                    if curr.data
                                                                    == key
    : prev.next = curr.next if curr == last : last = prev else :
#If the node to be deleted is not found
    print(f "Node with data {key} not found.")

        return last

    def printList(last)
    : if last is None
    : print("List is Empty") return

      head = last.next while True : print(head.data, end = " ") head =
          head.next if head == last.next : break print()

#Create circular linked list : 2, 3, 4
                                               first = Node(2) first.next =
              Node(3) first.next.next = Node(4)

                  last = first.next.next last.next = first

      print("Original list: ", end = "") printList(last)

#Delete a specific node
          key = 3 last = deleteSpecificNode(last, key)

              print(f "List after deleting node {key}: ", end = "")
                  printList(last)

```
```JavaScript
 class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

function
deleteSpecificNode(last, key) {
  if (last == = null) {
    // If the list is empty
    console.log("List is empty, nothing to delete.");
    return null;
  }

  let curr = last.next;
  let prev = last;

  // If the node to be deleted is the only node in the list
  if (curr == = last&& curr.data == = key) {
    last = null;
    return last;
  }

  // If the node to be deleted is the first node
  if (curr.data == = key) {
    last.next = curr.next;
    return last;
  }

  // Traverse the list to find the node to be deleted
  while (curr != = last&& curr.data != = key) {
    prev = curr;
    curr = curr.next;
  }

  // If the node to be deleted is found
  if (curr.data == = key) {
    prev.next = curr.next;
    if (curr == = last) {
      last = prev;
    }
  } else {
    // If the node to be deleted is not found
    console.log("Node with data " + key + " not found.");
  }

  return last;
}

function printList(last) {
  if (last == = null) {
    console.log("List is Empty");
    return;
  }

  let head = last.next;
  while (true) {
    console.log(head.data + " ");
    head = head.next;
    if (head == = last.next) break;
  }
  console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete a specific node
let key = 3;
last = deleteSpecificNode(last, key);

console.log("List after deleting node " + key + ": ");
printList(last);

```

```Output
Original list: 2 3 4 
List after deleting node 3: 2 4 
```

#### **3. Deletion at the end of Circular linked list**

> To delete the last node in a circular linked list, we handle the empty and single node cases. For multiple nodes, we traverse to find the second last node, update its `next` pointer to the head, delete the last node, and return the updated last pointer.

![Deletion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150601/Deletion-at-the-end-of-circular-linked-list.webp)

```C++
#include <iostream>
using namespace std;

struct Node {
  int data;
  Node* next;
  Node(int value) {
    data = value;
    next = nullptr;
  }
};

// Function to delete the last node in the circular linked list
Node* deleteLastNode(Node* last) {
  if (last == nullptr) {
    // If the list is empty
    cout << "List is empty, nothing to delete." << endl;
    return nullptr;
  }
  Node* head = last->next;

  // If there is only one node in the list
  if (head == last) {
    delete last;
    last = nullptr;
    return last;
  }
  // Traverse the list to find the second last node
  Node* curr = head;
  while (curr->next != last) {
    curr = curr->next;
  }
  // Update the second last node\'s next pointer
  // to point to head
  curr->next = head;
  delete last;
  last = curr;

  return last;
}

void printList(Node* last) {
  if (last == NULL) return;

  Node* head = last->next;
  while (true) {
    cout << head->data << " ";
    head = head->next;
    if (head == last->next) break;
  }
  cout << endl;
}

int main() {
  // Create circular linked list: 2, 3, 4
  Node* first = new Node(2);
  first->next = new Node(3);
  first->next->next = new Node(4);

  Node* last = first->next->next;
  last->next = first;

  cout << "Original list: ";
  printList(last);

  // Delete the last node
  last = deleteLastNode(last);

  cout << "List after deleting last node: ";
  printList(last);

  return 0;
}

```
```Java
 class Node {
  int data;
  Node next;

  Node(int value) {
    data = value;
    next = null;
  }
}

public class GFG {
 public
  static Node deleteLastNode(Node last) {
    if (last == null) {
      // If the list is empty
      System.out.println("List is empty, nothing to delete.");
      return null;
    }
    Node head = last.next;

    // If there is only one node in the list
    if (head == last) {
      last = null;
      return last;
    }
    // Traverse the list to find the second last node
    Node curr = head;
    while (curr.next != last) {
      curr = curr.next;
    }
    // Update the second last node\'s next pointer to
    // point to head
    curr.next = head;
    last = curr;

    return last;
  }

 public
  static void printList(Node last) {
    if (last == null) return;

    Node head = last.next;
    while (true) {
      System.out.print(head.data + " ");
      head = head.next;
      if (head == last.next) break;
    }
    System.out.println();
  }

 public
  static void main(String[] args) {
    // Create circular linked list: 2, 3, 4
    Node first = new Node(2);
    first.next = new Node(3);
    first.next.next = new Node(4);

    Node last = first.next.next;
    last.next = first;

    System.out.print("Original list: ");
    printList(last);

    // Delete the last node
    last = deleteLastNode(last);

    System.out.print("List after deleting last node: ");
    printList(last);
  }
}

```
```Python
 class Node : def __init__(self, data)
    : self.data = data self.next = None

    def deleteLastNode(last)
    : if last is None :
#If the list is empty
    print("List is empty, nothing to delete.") return None

    head = last.next

#If there is only one node in the list
           if head
           == last : last = None return last

#Traverse the list to find the second last node
    curr = head while curr.next != last : curr = curr.next

#Update the second last node\'s next pointer to point to head
                                                 curr.next = head last = curr

    return last

    def printList(last)
    : if last is None
    : return

      head = last.next while True : print(head.data, end = " ") head =
          head.next if head == last.next : break print()

#Create circular linked list : 2, 3, 4
                                               first = Node(2) first.next =
              Node(3) first.next.next = Node(4)

                  last = first.next.next last.next = first

      print("Original list: ", end = "") printList(last)

#Delete the last node
          last = deleteLastNode(last)

              print("List after deleting last node: ", end = "") printList(last)

```
```JavaScript
 class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

function
deleteLastNode(last) {
  if (last == = null) {
    // If the list is empty
    console.log("List is empty, nothing to delete.");
    return null;
  }
  let head = last.next;

  // If there is only one node in the list
  if (head == = last) {
    last = null;
    return last;
  }
  // Traverse the list to find the second last node
  let curr = head;
  while (curr.next != = last) {
    curr = curr.next;
  }
  // Update the second last node\'s next pointer to point to head
  curr.next = head;
  last = curr;

  return last;
}

function printList(last) {
  if (last == = null) return;

  let head = last.next;
  while (true) {
    process.stdout.write(head.data + " ");
    head = head.next;
    if (head == = last.next) break;
  }
  console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete the last node
last = deleteLastNode(last);

console.log("List after deleting last node: ");
printList(last);

```

```Output
Original list: 2 3 4 
List after deleting last node: 2 3 
```
', 'Implementation Delete Operations on Linked List', 'Operation in Circular Linked List Part 2: Delete Implementation.', 10, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('1c9888f0-5d92-4cf6-b41a-deff87b117b1', e'![binnary-search-](https://media.geeksforgeeks.org/wp-content/uploads/20240506155201/binnary-search-.webp)
# Conditions to apply Binary Search Algorithm in a Data Structure

To apply Binary Search algorithm:

-   The data structure must be sorted.
-   Access to any element of the data structure should take constant time.

# Binary Search Algorithm

Below is the step-by-step algorithm for Binary Search:

-   Divide the search space into two halves by **finding the middle index "mid"**. 
-   Compare the middle element of the search space with the **key**. 
-   If the **key** is found at middle element, the process is terminated.
-   If the **key** is not found at middle element, choose which half will be used as the next search space.
    -   If the **key** is smaller than the middle element, then the **left** side is used for next search.
    -   If the **key** is larger than the middle element, then the **right** side is used for next search.
-   This process is continued until the **key** is found or the total search space is exhausted.

# How does Binary Search Algorithm work?

To understand the working of binary search, consider the following illustration:

Consider an array **`arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}`**, and the **`target = 23`**.  

![Binary-Search-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250219155359690903/Binary-Search-1.webp)![Binary-Search-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250219155359020153/Binary-Search-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250219155358414164/Binary-Search-3.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250219155357890968/Binary-Search-4.png)

# How to Implement Binary Search Algorithm?

The **Binary Search Algorithm** can be implemented in the following two ways

-   Iterative Binary Search Algorithm
-   Recursive Binary Search Algorithm

## Iterative Binary Search Algorithm

> Here we use a while loop to continue the process of comparing the key and splitting the search space in two halves.

```cpp
// C++ program to implement iterative Binary Search
#include <bits/stdc++.h>
using namespace std;

// An iterative binary search function.
int binarySearch(int arr[], int low, int high, int x)
{
    while (low <= high) {
        int mid = low + (high - low) / 2;

        // Check if x is present at mid
        if (arr[mid] == x)
            return mid;

        // If x greater, ignore left half
        if (arr[mid] < x)
            low = mid + 1;

        // If x is smaller, ignore right half
        else
            high = mid - 1;
    }

    // If we reach here, then element was not present
    return -1;
}

// Driver code
int main(void)
{
    int arr[] = { 2, 3, 4, 10, 40 };
    int x = 10;
    int n = sizeof(arr) / sizeof(arr[0]);
    int result = binarySearch(arr, 0, n - 1, x);
    if(result == -1) cout << "Element is not present in array";
    else cout << "Element is present at index " << result;
    return 0;
}
```
```c
// C program to implement iterative Binary Search
#include <stdio.h>

// An iterative binary search function.
int binarySearch(int arr[], int low, int high, int x)
{
    while (low <= high) {
        int mid = low + (high - low) / 2;

        // Check if x is present at mid
        if (arr[mid] == x)
            return mid;

        // If x greater, ignore left half
        if (arr[mid] < x)
            low = mid + 1;

        // If x is smaller, ignore right half
        else
            high = mid - 1;
    }

    // If we reach here, then element was not present
    return -1;
}

// Driver code
int main(void)
{
    int arr[] = { 2, 3, 4, 10, 40 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    int result = binarySearch(arr, 0, n - 1, x);
   if(result == -1) printf("Element is not present in array");
   else printf("Element is present at index %d",result);

}
```
```java
// Java implementation of iterative Binary Search

import java.io.*;

class BinarySearch {
  
    // Returns index of x if it is present in arr[].
    int binarySearch(int arr[], int x)
    {
        int low = 0, high = arr.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;

            // Check if x is present at mid
            if (arr[mid] == x)
                return mid;

            // If x greater, ignore left half
            if (arr[mid] < x)
                low = mid + 1;

            // If x is smaller, ignore right half
            else
                high = mid - 1;
        }

        // If we reach here, then element was
        // not present
        return -1;
    }

    // Driver code
    public static void main(String args[])
    {
        BinarySearch ob = new BinarySearch();
        int arr[] = { 2, 3, 4, 10, 40 };
        int n = arr.length;
        int x = 10;
        int result = ob.binarySearch(arr, x);
        if (result == -1)
            System.out.println(
                "Element is not present in array");
        else
            System.out.println("Element is present at "
                               + "index " + result);
    }
}
```
```python
# Python3 code to implement iterative Binary
# Search.


# It returns location of x in given array arr
def binarySearch(arr, low, high, x):

    while low <= high:

        mid = low + (high - low) // 2

        # Check if x is present at mid
        if arr[mid] == x:
            return mid

        # If x is greater, ignore left half
        elif arr[mid] < x:
            low = mid + 1

        # If x is smaller, ignore right half
        else:
            high = mid - 1

    # If we reach here, then the element
    # was not present
    return -1


# Driver Code
if __name__ == \'__main__\':
    arr = [2, 3, 4, 10, 40]
    x = 10

    # Function call
    result = binarySearch(arr, 0, len(arr)-1, x)
    if result != -1:
        print("Element is present at index", result)
    else:
        print("Element is not present in array")
```
```csharp
// C# implementation of iterative Binary Search
using System;

class GFG {
    
    // Returns index of x if it is present in arr[]
    static int binarySearch(int[] arr, int x)
    {
        int low = 0, high = arr.Length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;

            // Check if x is present at mid
            if (arr[mid] == x)
                return mid;

            // If x greater, ignore left half
            if (arr[mid] < x)
                low = mid + 1;

            // If x is smaller, ignore right half
            else
                high = mid - 1;
        }

        // If we reach here, then element was
        // not present
        return -1;
    }

    // Driver code
    public static void Main()
    {
        int[] arr = { 2, 3, 4, 10, 40 };
        int n = arr.Length;
        int x = 10;
        int result = binarySearch(arr, x);
        if (result == -1)
            Console.WriteLine(
                "Element is not present in array");
        else
            Console.WriteLine("Element is present at "
                              + "index " + result);
    }
}
```
```javascript
// Program to implement iterative Binary Search

// A iterative binary search function. It returns
// location of x in given array arr[l..r] is present,
// otherwise -1

function binarySearch(arr, x)
{
    let low = 0;
    let high = arr.length - 1;
    let mid;
    while (high >= low) {
        mid = low + Math.floor((high - low) / 2);

        // If the element is present at the middle
        // itself
        if (arr[mid] == x)
            return mid;

        // If element is smaller than mid, then
        // it can only be present in left subarray
        if (arr[mid] > x)
            high = mid - 1;

        // Else the element can only be present
        // in right subarray
        else
            low = mid + 1;
    }

    // We reach here when element is not
    // present in array
    return -1;
}

arr = new Array(2, 3, 4, 10, 40);
x = 10;
n = arr.length;
result = binarySearch(arr, x);
if (result == -1)
    console.log("Element is not present in array")
    else
    {
        console.log("Element is present at index "
                    + result);
    }
```


```output
Element is present at index 3
```

**Time Complexity:** O(log N)  
**Auxiliary Space:** O(1)

## Recursive Binary Search Algorithm:

> Create a recursive function and compare the mid of the search space with the key. And based on the result either return the index where the key is found or call the recursive function for the next search space.

```cpp
#include <bits/stdc++.h>
using namespace std;

// A recursive binary search function. It returns
// location of x in given array arr[low..high] is present,
// otherwise -1
int binarySearch(int arr[], int low, int high, int x)
{
    if (high >= low) {
        int mid = low + (high - low) / 2;

        // If the element is present at the middle
        // itself
        if (arr[mid] == x)
            return mid;

        // If element is smaller than mid, then
        // it can only be present in left subarray
        if (arr[mid] > x)
            return binarySearch(arr, low, mid - 1, x);

        // Else the element can only be present
        // in right subarray
        return binarySearch(arr, mid + 1, high, x);
    }
  return -1;
}

// Driver code
int main()
{
    int arr[] = { 2, 3, 4, 10, 40 };
    int query = 10;
    int n = sizeof(arr) / sizeof(arr[0]);
    int result = binarySearch(arr, 0, n - 1, query);
    if (result == -1) cout << "Element is not present in array";
    else cout << "Element is present at index " << result;
    return 0;
}
```
```c
// C program to implement recursive Binary Search
#include <stdio.h>

// A recursive binary search function. It returns
// location of x in given array arr[low..high] is present,
// otherwise -1
int binarySearch(int arr[], int low, int high, int x)
{
    if (high >= low) {
        int mid = low + (high - low) / 2;

        // If the element is present at the middle
        // itself
        if (arr[mid] == x)
            return mid;

        // If element is smaller than mid, then
        // it can only be present in left subarray
        if (arr[mid] > x)
            return binarySearch(arr, low, mid - 1, x);

        // Else the element can only be present
        // in right subarray
        return binarySearch(arr, mid + 1, high, x);
    }

    // We reach here when element is not
    // present in array
    return -1;
}

// Driver code
int main()
{
    int arr[] = { 2, 3, 4, 10, 40 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int x = 10;
    int result = binarySearch(arr, 0, n - 1, x);
    if (result == -1) printf("Element is not present in array");
    else printf("Element is present at index %d", result);
    return 0;
}
```
```java
// Java implementation of recursive Binary Search
class BinarySearch {

    // Returns index of x if it is present in arr[low..
    // high], else return -1
    int binarySearch(int arr[], int low, int high, int x)
    {
        if (high >= low) {
            int mid = low + (high - low) / 2;

            // If the element is present at the
            // middle itself
            if (arr[mid] == x)
                return mid;

            // If element is smaller than mid, then
            // it can only be present in left subarray
            if (arr[mid] > x)
                return binarySearch(arr, low, mid - 1, x);

            // Else the element can only be present
            // in right subarray
            return binarySearch(arr, mid + 1, high, x);
        }

        // We reach here when element is not present
        // in array
        return -1;
    }

    // Driver code
    public static void main(String args[])
    {
        BinarySearch ob = new BinarySearch();
        int arr[] = { 2, 3, 4, 10, 40 };
        int n = arr.length;
        int x = 10;
        int result = ob.binarySearch(arr, 0, n - 1, x);
        if (result == -1)
            System.out.println(
                "Element is not present in array");
        else
            System.out.println(
                "Element is present at index " + result);
    }
}
```
```python
# Python3 Program for recursive binary search.


# Returns index of x in arr if present, else -1
def binarySearch(arr, low, high, x):

    # Check base case
    if high >= low:

        mid = low + (high - low) // 2

        # If element is present at the middle itself
        if arr[mid] == x:
            return mid

        # If element is smaller than mid, then it
        # can only be present in left subarray
        elif arr[mid] > x:
            return binarySearch(arr, low, mid-1, x)

        # Else the element can only be present
        # in right subarray
        else:
            return binarySearch(arr, mid + 1, high, x)

    # Element is not present in the array
    else:
        return -1


# Driver Code
if __name__ == \'__main__\':
    arr = [2, 3, 4, 10, 40]
    x = 10
    
    # Function call
    result = binarySearch(arr, 0, len(arr)-1, x)
    
    if result != -1:
        print("Element is present at index", result)
    else:
        print("Element is not present in array")
```
```csharp
// C# implementation of recursive Binary Search
using System;

class GFG {

    // Returns index of x if it is present in
    // arr[low..high], else return -1
    static int binarySearch(int[] arr, int low, int high, int x)
    {
        if (high >= low) {
            int mid = low + (high - low) / 2;

            // If the element is present at the
            // middle itself
            if (arr[mid] == x)
                return mid;

            // If element is smaller than mid, then
            // it can only be present in left subarray
            if (arr[mid] > x)
                return binarySearch(arr, low, mid - 1, x);

            // Else the element can only be present
            // in right subarray
            return binarySearch(arr, mid + 1, high, x);
        }

        // We reach here when element is not present
        // in array
        return -1;
    }

    // Driver code
    public static void Main()
    {

        int[] arr = { 2, 3, 4, 10, 40 };
        int n = arr.Length;
        int x = 10;

        int result = binarySearch(arr, 0, n - 1, x);

        if (result == -1)
            Console.WriteLine(
                "Element is not present in arrau");
        else
            Console.WriteLine("Element is present at index "
                              + result);
    }
}
```
```javascript
// JavaScript program to implement recursive Binary Search

// A recursive binary search function. It returns
// location of x in given array arr[low..high] is present,
// otherwise -1
function binarySearch(arr, low, high, x)
{
    if (high >= low) {
        let mid = low + Math.floor((high - low) / 2);

        // If the element is present at the middle
        // itself
        if (arr[mid] == x)
            return mid;

        // If element is smaller than mid, then
        // it can only be present in left subarray
        if (arr[mid] > x)
            return binarySearch(arr, low, mid - 1, x);

        // Else the element can only be present
        // in right subarray
        return binarySearch(arr, mid + 1, high, x);
    }

    // We reach here when element is not
    // present in array
    return -1;
}

let arr = [ 2, 3, 4, 10, 40 ];
let x = 10;
let n = arr.length
let result = binarySearch(arr, 0, n - 1, x);
if (result == -1)
    console.log("Element is not present in array");
else
    console.log("Element is present at index " + result);
```


```output
Element is present at index 3
```

## Complexity Analysis of Binary Search Algorithm

-   **Time Complexity:** 
    -   Best Case: O(1)
    -   Average Case: O(log N)
    -   Worst Case: O(log N)
-   **Auxiliary Space:** O(1), If the recursive call stack is considered then the auxiliary space will be O(log N).

Please refer [Time and Space Complexity Analysis of Binary Search](https://www.geeksforgeeks.org/complexity-analysis-of-binary-search/) for more details.

# Applications of Binary Search Algorithm

-   Binary search can be used as a building block for more complex algorithms used in machine learning, such as algorithms for training neural networks or finding the optimal hyperparameters for a model.
-   It can be used for searching in computer graphics such as algorithms for ray tracing or texture mapping.
-   It can be used for searching a database.

', 'Understand when should we use Linear Search or Binary Search', 'Linear Search vs Binary Search', 9, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('06284d7e-1a52-4006-a7f2-65ef4c1b2931', '', 'Test', 'Test Put mapping', 24, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('237c88d5-987b-4fc0-8bd1-d27a07cd1aa9', e'Understanding Node Structure
----------------------------

In a singly linked list, each node consists of two parts: data and a
pointer to the next node. This structure allows nodes to be dynamically
linked together, forming a chain-like sequence.


![Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240917161540/Singly-Linked-List.webp)

Singly Linked List



C++
````
// Definition of a Node in a singly linked list
struct Node {

    // Data part of the node
    int data;

    // Pointer to the next node in the list
    Node* next;

    // Constructor to initialize the node with data
    Node(int data)
    {
        this->data = data;
        this->next = nullptr;
    }
};

````

C
````
// Definition of a Node in a singly linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new Node
struct Node* newNode(int data) {
    struct Node* temp =
      (struct Node*)malloc(sizeof(struct Node));
    temp->data = data;
    temp->next = NULL;
    return temp;
}

````

Java
````
// Definition of a Node in a singly linked list
public class Node {
    int data;
    Node next;

    // Constructor to initialize the node with data
    public Node(int data)
    {
        this.data = data;
        this.next = null;
    }
}

````

Python
````
# Definition of a Node in a singly linked list
class Node:
    def __init__(self, data):
       # Data part of the node
        self.data = data
        self.next = None

````

JavaScript
````
// Definition of a Node in a singly linked list
class Node {
    constructor(data) {
    // Data part of the node
        this.data = data;
        this.next = null;
    }
}

````



In this example, the Node class contains an integer data field (****data****) to store the information and a pointer to another Node (****next****) to establish the link to the next node in the list.

Operations on Singly Linked List
--------------------------------

* ****Traversal****
* ****Searching****
* ****Length****
* ****Insertion:****
  + Insert at the beginning
  + Insert at the end
  + Insert at a specific position
* ****Deletion:****
  + Delete from the beginning
  + Delete from the end
  + Delete a specific node

Let\'s go through each of the operations mentioned above, one by
one.

[****Traversal**** of Singly Linked List](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)
---------------------------------------------------------------------------------------------------------

Traversal involves visiting each node in the linked list and performing
some operation on the data. A simple traversal function would print or
process the data of each node.

Step-by-step approach:

* Initialize a pointer current to the head of the list.
* Use a while loop to iterate through the list until the current
  pointer reaches NULL.
* Inside the loop, print the data of the current node and move the
  current pointer to the next node.

Below is the function for traversal in singly Linked List:

C++
````
// C++ Function to traverse and print the elements of the linked
// list
void traverseLinkedList(Node* head)
{
    // Start from the head of the linked list
    Node* current = head;

    // Traverse the linked list until reaching the end
    // (nullptr)
    while (current != nullptr) {

        // Print the data of the current node
        cout << current->data << " ";

        // Move to the next node
        current = current->next;
    }

    cout << std::endl;
}

````

C
````
// Function to traverse and print the elements
// of the linked list
void traverseLinkedList(struct Node* head)
{
    // Start from the head of the linked list
    struct Node* current = head;

    // Traverse the linked list until reaching the end (NULL)
    while (current != NULL) {

        // Print the data of the current node
        printf("%d ", current->data);

        // Move to the next node
        current = current->next;
    }

    printf("\\n");
}

````

Java
````
// Java Function to traverse and print the elements of the
// linked list
public static void traverseLinkedList(Node head)
{
    // Start from the head of the linked list
    Node current = head;

    // Traverse the linked list until reaching the end
    // (null)
    while (current != null) {

        // Print the data of the current node
        System.out.print(current.data + " ");

        // Move to the next node
        current = current.next;
    }

    System.out.println();
}

````

Python
````
# Python Function to traverse and print the elements of the linked list
def traverse_linked_list(head):
    # Start from the head of the linked list
    current = head

    # Traverse the linked list until reaching the end (None)
    while current is not None:

        # Print the data of the current node followed by a space
        print(current.data),

        # Move to the next node
        current = current.next

    print()  # Print a new line after traversing the linked list

````

JavaScript
````
// Javascript Function to traverse and print the elements
// of the linked list
function traverseLinkedList(head) {

    // Start from the head of the linked list
    let current = head;

    // Traverse the linked list until reaching the
    // end (null)
    while (current !== null) {

        // Print the data of the current node
        console.log(current.data + " ");

        // Move to the next node
        current = current.next;
    }

    console.log();
}

````

**Output**
```

1 2 3

```

[Searching in Singly Linked List](https://www.geeksforgeeks.org/search-an-element-in-a-linked-list-iterative-and-recursive/)
----------------------------------------------------------------------------------------------------------------------------

Searching in a Singly Linked List refers to the process of looking for
a specific element or value within the elements of the linked list.


Step-by-step approach:

1. Traverse the Linked List starting from the head.
2. Check if the current node\'s data matches the target value.
   * If a match is found, return ****true****.
3. Otherwise, Move to the next node and repeat steps 2.
4. If the end of the list is reached without finding a match, return ****false****.

Below is the function for searching in singly linked list:

C++
````
// Function to search for a value in the Linked List
bool searchLinkedList(struct Node* head, int target)
{
    // Traverse the Linked List
    while (head != nullptr) {

        // Check if the current node\'s
        // data matches the target value
        if (head->data == target) {
            return true; // Value found
        }

        // Move to the next node
        head = head->next;
    }

    return false; // Value not found
}

````

C
````
// Function to search for a value in the Linked List
bool searchLinkedList(struct Node* head, int target)
{
    // Traverse the Linked List
    while (head != NULL) {

        // Check if the current node\'s
        // data matches the target value
        if (head->data == target) {
            return true; // Value found
        }

        // Move to the next node
        head = head->next;
    }

    return false; // Value not found
}

````

Java
````
// Java function to search for a value in the Linked List
public boolean searchLinkedList(Node head, int target)
{
    // Traverse the Linked List
    while (head != null) {

        // Check if the current node\'s data matches the
        // target value
        if (head.data == target) {

            // Value found
            return true;
        }

        // Move to the next node
        head = head.next;
    }

    // Value not found
    return false;
}

````

Python
````
# Python function to search for a value in the Linked List
def search_linked_list(head, target):

    # Traverse the Linked List
    while head is not None:

        # Check if the current node\'s data matches the target value
        if head.data == target:

            return True  # Value found
        # Move to the next node
        head = head.next

    return False  # Value not found

````

JavaScript
````
// Javascript function to search for a value in the Linked List
function searchLinkedList(head, target) {

    // Traverse the Linked List
    while (head !== null) {

        // Check if the current node\'s data matches the target value
        if (head.data === target) {
            return true;  // Value found
        }

        // Move to the next node
        head = head.next;
    }

    return false;  // Value not found
}

````



[Length of Singly Linked List](https://www.geeksforgeeks.org/find-length-of-a-linked-list-iterative-and-recursive)
------------------------------------------------------------------------------------------------------------------

Finding Length in Singly Linked List refers to the process of
determining the total number of nodes in a singly linked list.

Step-by-step approach:

* Initialize a counter ****length**** to 0.
* Start from the head of the list, assign it to current.
* Traverse the list:
  + Increment ****length**** for each node.
  + Move to the next node (****current = current->next****).
* Return the final value of ****length****.

Below is the function for finding length in Singly Linked List:

C++
````
// C++ function to find the length of the linked list
int findLength(Node* head)
{
    // Initialize a counter for the length
    int length = 0;

    // Start from the head of the list
    Node* current = head;

    // Traverse the list and increment the length for each
    // node
    while (current != nullptr) {
        length++;
        current = current->next;
    }

    // Return the final length of the linked list
    return length;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Definition of a Node in a singly linked list
struct Node {
    int data;          // Data part of the node
    struct Node* next; // Pointer to the next node in the list
};

// Function to find the length of the linked list
int findLength(struct Node* head)
{
    // Initialize a counter for the length
    int length = 0;

    // Start from the head of the list
    struct Node* curr = head;

    // Traverse the list and increment
    // the length for each node
    while (curr != NULL) {
        length++;
        curr = curr->next;
    }

    // Return the final length of the linked list
    return length;
}

````

Java
````
// Java function to find the length of the linked list
public int findLength(Node head) {

    // Initialize a counter for the length
    int length = 0;

    // Start from the head of the list
    Node current = head;

    // Traverse the list and increment the length for each
    // node
    while (current != null) {
        length++;
        current = current.next;
    }

    // Return the final length of the linked list
    return length;
}

````

Python
````
# Python function to find the length of the linked list
def find_length(head):

    # Initialize a counter for the length
    length = 0

    # Start from the head of the list
    current = head

    # Traverse the list and increment the length for each
    # node
    while current is not None:
        length += 1
        current = current.next

    # Return the final length of the linked list
    return length

````

JavaScript
````
// Javascript function to find the length of the linked list
function findLength(head) {

    // Initialize a counter for the length
    let length = 0;

    // Start from the head of the list
    let current = head;

    // Traverse the list and increment the length for each
    // node
    while (current !== null) {
        length++;
        current = current.next;
    }

    // Return the final length of the linked list
    return length;
}

````




[Insertion in Singly Linked List](https://www.geeksforgeeks.org/insertion-in-linked-list)
-----------------------------------------------------------------------------------------

Insertion is a fundamental operation in linked lists that involves
adding a new node to the list. There are several scenarios for
insertion:

### a. [Insertion at the Beginning of Singly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-front-beginning-of-a-linked-list):

![Insertion-at-the-Beginning-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163445386036/Insertion-at-the-Beginning-of-Singly-Linked-List.webp)


Insert a Node at the Front/Beginning of Linked List



Step-by-step approach:

* Create a new node with the given value.
* Set the ****next**** pointer of the new node to the current head.
* Move the head to point to the new node.
* Return the new head of the linked list.

Below is the function for insertion at the beginning of singly linked
list:

C++
````
// C++ function to insert a new node at the beginning of the
// linked list
Node* insertAtBeginning(Node* head, int value)
{
    // Create a new node with the given value
    Node* newNode = new Node(value);

    // Set the next pointer of the new node to the current
    // head
    newNode->next = head;

    // Move the head to point to the new node
    head = newNode;

    // Return the new head of the linked list
    return head;
}

````

C
````
// Function to insert a new node at the beginning of the linked list
struct Node* insertAtBeginning(struct Node* head, int value)
{
    // Create a new node with the given value
    struct Node* new_node = newNode(value);

    // Set the next pointer of the new node to the current head
    new_node->next = head;

    // Move the head to point to the new node
    head = new_node;

    // Return the new head of the linked list
    return head;
}

````

Java
````
// Java function to insert a new node at the beginning of the
// linked list
public Node insertAtBeginning(Node head, int value) {
    // Create a new node with the given value
    Node newNode = new Node(value);

    // Set the next pointer of the new node to the current
    // head
    newNode.next = head;

    // Move the head to point to the new node
    head = newNode;

    // Return the new head of the linked list
    return head;
}

````

Python
````
# Python function to insert a new node at the beginning of the
# linked list
def insert_at_beginning(head, value):

    # Create a new node with the given value
    new_node = Node(value)

    # Set the next pointer of the new node to the current
    # head
    new_node.next = head

    # Move the head to point to the new node
    head = new_node

    # Return the new head of the linked list
    return head

````

JavaScript
````
// Javascript function to insert a new node at the beginning of the
// linked list
function insertAtBeginning(head, value) {

    // Create a new node with the given value
    let newNode = new Node(value);

    // Set the next pointer of the new node to the current
    // head
    newNode.next = head;

    // Move the head to point to the new node
    head = newNode;

    // Return the new head of the linked list
    return head;
}

````


### b. [Insertion at the End of Singly Linked List:](https://www.geeksforgeeks.org/insert-node-at-the-end-of-a-linked-list)

To insert a node at the end of the list, traverse the list until the
last node is reached, and then link the new node to the current last
node-

![Insertion-at-the-End-of-Singly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20241022163601409037/Insertion-at-the-End-of-Singly-Linked-List.webp)

Insertion at end of Linked List


Step-by-step approach:

* Create a new node with the given value.
* Check if the list is empty:
  + If it is, make the new node the head and return.
* Traverse the list until the last node is reached.
* Link the new node to the current last node by setting the last node\'s
  next pointer to the new node.

Below is the function for insertion at the end of singly linked
list:

C++
````
// C++ Function to insert a node at the end of the linked
// list
Node* insertAtEnd(Node* head, int value)
{
    // Create a new node with the given value
    Node* newNode = new Node(value);

    // If the list is empty, make the new node the head
    if (head == nullptr)
        return newNode;

    // Traverse the list until the last node is reached
    Node* curr = head;
    while (curr->next != nullptr) {
        curr = curr->next;
    }

    // Link the new node to the current last node
    curr->next = newNode;
    return head;
}

````

C
````
// Function to insert a node at the end of the linked list
struct Node* insertAtEnd(struct Node* head, int value)
{
    // Create a new node with the given value
    struct Node* new_node = newNode(value);

    // If the list is empty, make the new node the head
    if (head == NULL)
        return new_node;

    // Traverse the list until the last node is reached
    struct Node* curr = head;
    while (curr->next != NULL) {
        curr = curr->next;
    }

    // Link the new node to the current last node
    curr->next = new_node;

    return head;
}

````

Java
````
// Function to insert a node at the end of the linked list
public static Node insertAtEnd(Node head, int value)
{
    // Create a new node with the given value
    Node newNode = new Node(value);

    // If the list is empty, make the new node the head
    if (head == null)
        return newNode;

    // Traverse the list until the last node is reached
    Node curr = head;
    while (curr.next != null) {
        curr = curr.next;
    }

    // Link the new node to the current last node
    curr.next = newNode;

    return head;
}

````

Python
````
# Python function to insert a node at the end of the linked
# list
def insert_at_end(head, value):

    # Create a new node with the given value
    new_node = Node(value)

    # If the list is empty, make the new node the head
    if head is None:
        return new_node

    # Traverse the list until the last node is reached
    current = head
    while current.next is not None:
        current = current.next

    # Link the new node to the current last node
    current.next = new_node

    return head

````

JavaScript
````
// Javascript function to insert a node at the end of the linked
// list
function insertAtEnd(head, value) {

    // Create a new node with the given value
    let newNode = new Node(value);

    // If the list is empty, make the new node the head
    if (head === null) {
        return newNode;
    }

    // Traverse the list until the last node is reached
    let current = head;
    while (current.next !== null) {
        current = current.next;
    }

    // Link the new node to the current last node
    current.next = newNode;

    return head;
}

````





### c. [Insertion at a Specific Position of the Singly Linked List:](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-a-linked-list)

To insert a node at a specific position, traverse the list to the
desired position, link the new node to the next node, and update the
links accordingly.

![Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20241022163649252002/Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy.webp)




We mainly find the node after which we need to insert the new node. If
we encounter a NULL before reaching that node, it means that the given
position is invalid.

Below is the function for insertion at a specific position of the
singly linked list:

C++
````
// Function to insert a Node at a specified position
// without using a double pointer
Node* insertPos(Node* head, int pos, int data)
{
    if (pos < 1) {
        cout << "Invalid position!" << endl;
        return head;
    }

    // Special case for inserting at the head
    if (pos == 1) {
        Node* temp = new Node(data);
        temp->next = head;
        return temp;
    }

    // Traverse the list to find the node
    // before the insertion point
    Node* prev = head;
    int count = 1;
    while (count < pos - 1 && prev != nullptr) {
        prev = prev->next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev == nullptr) {
        cout << "Invalid position!" << endl;
        return head;
    }

    // Insert the new node at the specified position
    Node* temp = new Node(data);
    temp->next = prev->next;
    prev->next = temp;

    return head;
}

````

C
````
// Function to insert a node at a specified position
struct Node* insertPos(struct Node* head, int pos, int data) {
    if (pos < 1) {
        printf("Invalid position!\\n");
        return head;
    }

    // Special case for inserting at the head
    if (pos == 1) {
        struct Node* temp = getNode(data);
        temp->next = head;
        return temp;
    }

    // Traverse the list to find the node
    // before the insertion point
    struct Node* prev = head;
    int count = 1;
    while (count < pos - 1 && prev != NULL) {
        prev = prev->next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev == NULL) {
        printf("Invalid position!\\n");
        return head;
    }

    // Insert the new node at the specified position
    struct Node* temp = getNode(data);
    temp->next = prev->next;
    prev->next = temp;

    return head;
}

````

Java
````
public static Node insertPos(Node head, int pos, int data)
{
    if (pos < 1) {
        System.out.println("Invalid position!");
        return head;
    }

    // Special case for inserting at the head
    if (pos == 1) {
        Node temp = new Node(data);
        temp.next = head;
        return temp;
    }

    // Traverse the list to find the node before the
    // insertion point
    Node prev = head;
    int count = 1;
    while (count < pos - 1 && prev != null) {
        prev = prev.next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev == null) {
        System.out.println("Invalid position!");
        return head;
    }

    // Insert the new node at the specified position
    Node temp = new Node(data);
    temp.next = prev.next;
    prev.next = temp;

    return head;
}

````

Python
````
# Function to insert a node at a specified position
def insertPos(head, pos, data):
    if pos < 1:
        print("Invalid position!")
        return head

    # Special case for inserting at the head
    if pos == 1:
        new_node = Node(data)
        new_node.next = head
        return new_node

    # Traverse the list to find the node before
    # the insertion point
    prev = head
    count = 1
    while count < pos - 1 and prev is not None:
        prev = prev.next
        count += 1

    # If position is greater than the number of nodes
    if prev is None:
        print("Invalid position!")
        return head

    # Insert the new node at the specified position
    new_node = Node(data)
    new_node.next = prev.next
    prev.next = new_node

    return head

````

JavaScript
````
// Function to insert a node at a specified position
function insertPos(head, pos, data) {
    if (pos < 1) {
        console.log("Invalid position!");
        return head;
    }

    // Special case for inserting at the head
    if (pos === 1) {
        const newNode = new Node(data);
        newNode.next = head;
        return newNode;
    }

    // Traverse the list to find the node
    // before the insertion point
    let prev = head;
    let count = 1;
    while (count < pos - 1 && prev !== null) {
        prev = prev.next;
        count++;
    }

    // If position is greater than the number of nodes
    if (prev === null) {
        console.log("Invalid position!");
        return head;
    }

    // Insert the new node at the specified position
    const newNode = new Node(data);
    newNode.next = prev.next;
    prev.next = newNode;

    return head;
}

````








[Deletion in Singly Linked List](https://www.geeksforgeeks.org/deletion-in-linked-list)
---------------------------------------------------------------------------------------

Deletion involves removing a node from the linked list. Similar to
insertion, there are different scenarios for deletion:

### a. [****Deletion at the Beginning of**** Singly Linked List****:****](https://www.geeksforgeeks.org/remove-first-node-of-the-linked-list)

To delete the first node, update the head to point to the second node
in the list.

![Deletion-at-beginning-](https://media.geeksforgeeks.org/wp-content/uploads/20241022163937663413/Deletion-at-beginning-.webp)

Deletion at beginning in a Linked List


Steps-by-step approach:

* Check if the head is ****NULL****.
  + If it is, return ****NULL**** (the list is empty).
* Store the current head node in a temporary variable ****temp****.
* Move the head pointer to the next node.
* Delete the temporary node.
* Return the new head of the linked list.

Below is the function for deletion at the beginning of singly linked
list:

C++
````
// C++ Function to remove the first node of the linked
// list
Node* removeFirstNode(Node* head)
{
    if (head == nullptr)
        return nullptr;

    // Move the head pointer to the next node
    Node* temp = head;
    head = head->next;

    delete temp;

    return head;
}

````

C
````
// Function to remove the first node of the linked list
struct Node* removeFirstNode(struct Node* head)
{
    if (head == NULL)
        return NULL;

    // Move the head pointer to the next node
    struct Node* temp = head;
    head = head->next;

    // Free the memory of the old head
    free(temp);

    return head;
}

````

Java
````
// Java Function to remove the first node
// of the linked list
static Node removeFirstNode(Node head)
{
    if (head == null)
        return null;

    // Move the head pointer to the next node
    Node temp = head;
    head = head.next;

    return head;
}

````

Python
````
# Python Function to remove the first node
# of the linked list
def removeFirstNode(head):
    if not head:
        return None
    temp = head

    # Move the head pointer to the next node
    head = head.next
    temp = None
    return head

````

JavaScript
````
// Javascript Function to remove the first node
// of the linked list /
function removeFirstNode(head) {
  if (head == null) return null;

  // Move the head pointer to the next node
  temp = head;
  head = head.next;

  return head;
}

````


### b. [Deletion at the End of Singly Linked List:](https://www.geeksforgeeks.org/remove-last-node-of-the-linked-list)

To delete the last node, traverse the list until the second-to-last
node and update its next field to None.

![Deletion-At-End](https://media.geeksforgeeks.org/wp-content/uploads/20241022164030481275/Deletion-At-End.webp)

Deletion at the end of linked list


Step-by-step approach:

* Check if the head is ****NULL****.
  + If it is, return NULL (the list is empty).
* Check if the head\'s ****next**** is ****NULL**** (only one node in the list).
  + If true, delete the head and return ****NULL****.
* Traverse the list to find the second last node (****second\\_last****).
* Delete the last node (the node after ****second\\_last****).
* Set the ****next**** pointer of the second last node to ****NULL****.
* Return the head of the linked list.

Below is the function for deletion at the end of singly linked
list:

C++
````
// C++ Function to remove the last node of the linked list
Node* removeLastNode(Node* head)
{
    if (head == nullptr)
        return nullptr;

    if (head->next == nullptr) {
        delete head;
        return nullptr;
    }

    // Find the second last node
    Node* second_last = head;
    while (second_last->next->next != nullptr)
        second_last = second_last->next;

    // Delete last node
    delete (second_last->next);

    // Change next of second last
    second_last->next = nullptr;

    return head;
}

````

C
````
// Function to remove the last node of the linked list
struct Node* removeLastNode(struct Node* head)
{
    if (head == NULL)
        return NULL;

    if (head->next == NULL) {
        free(head);
        return NULL;
    }

    // Find the second last node
    struct Node* second_last = head;
    while (second_last->next->next != NULL)
        second_last = second_last->next;

    // Delete last node
    free(second_last->next);

    // Change next of second last
    second_last->next = NULL;

    return head;
}

````

Java
````
// Java Function to remove the last node of the linked list
Node removeLastNode(Node head)
{
    // If the list is empty, return null
    if (head == null)
        return null;

    // If the list has only one node, delete it and return
    // null
    if (head.next == null) {
        head = null;
        return null;
    }

    // Find the second last node
    Node second_last = head;
    while (second_last.next.next != null)
        second_last = second_last.next;

    // Remove the last node
    second_last.next = null;

    // Return the modified list
    return head;
}

````

Python
````
# Python Function to remove the last node of the linked list
def removeLastNode(head):
    # If the list is empty, return None
    if head is None:
        return None

    # If the list has only one node, delete it and return None
    if head.next is None:
        head = None
        return None

    # Find the second last node
    second_last = head
    while second_last.next.next is not None:
        second_last = second_last.next

    # Remove the last node
    second_last.next = None

    # Return the modified list
    return head

````

JavaScript
````
// Javascript Function to remove the last node of the linked list
function removeLastNode(head) {
    // If the list is empty, return null
    if (head === null)
        return null;

    // If the list has only one node, delete it
    // and return null
    if (head.next === null) {
        head = null;
        return null;
    }

    // Find the second last node
    let second_last = head;
    while (second_last.next.next !== null)
        second_last = second_last.next;

    // Remove the last node
    second_last.next = null;

    // Return the modified list
    return head;
}

````




### c. [Deletion at a Specific Position of Singly Linked List:](https://www.geeksforgeeks.org/delete-a-linked-list-node-at-a-given-position)

To delete a node at a specific position, traverse the list to the
desired position, update the links to bypass the node to be
deleted.

![Deletion-specific-At-End--](https://media.geeksforgeeks.org/wp-content/uploads/20241022164248836160/Deletion-specific-At-End--.webp)

Delete a Linked List node at a given position


Step-by-step approach:

* Check if the list is empty or the position is invalid, return if
  so.
* If the head needs to be deleted, update the head and delete the
  node.
* Traverse to the node before the position to be deleted.
* If the position is out of range, return.
* Store the node to be deleted.
* Update the links to bypass the node.
* Delete the stored node.

Below is the function for deletion at a specific position of singly
linked list:

C++
````
// C++ function to delete a node at a specific position
Node* deleteAtPosition(Node* head, int position)
{
    // If the list is empty or the position is invalid
    if (head == nullptr || position < 1) {
        return head;
    }

    // If the head needs to be deleted
    if (position == 1) {
        Node* temp = head;
        head = head->next;
        delete temp;
        return head;
    }

    // Traverse to the node before the position to be
    // deleted
    Node* current = head;
    for (int i = 1; i < position - 1 && current != nullptr;
         i++) {
        current = current->next;
    }

    // If the position is out of range
    if (current == NULL || current->next == nullptr) {
        return;
    }

    // Store the node to be deleted
    Node* temp = current->next;

    // Update the links to bypass the node to be deleted
    current->next = current->next->next;

    // Delete the node
    delete temp;

    return head;
}

````

C
````
// Function to delete a node at a specific position
struct Node* deleteAtPosition(struct Node* head, int position)
{
    // If the list is empty or the position is invalid
    if (head == NULL || position < 1) {
        return head;
    }

    // If the head needs to be deleted
    if (position == 1) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return head;
    }

    // Traverse to the node before the position to be deleted
    struct Node* curr = head;
    for (int i = 1; i < position - 1 && curr != NULL; i++) {
        curr = curr->next;
    }

    // If the position is out of range
    if (curr == NULL || curr->next == NULL) {
        return head;
    }

    // Store the node to be deleted
    struct Node* temp = curr->next;

    // Update the links to bypass the node to be deleted
    curr->next = curr->next->next;

    // Delete the node
    free(temp);

    return head;
}

````

Java
````
// Java function to delete a node at a specific position
public void deleteAtPosition(Node head, int position)
{
    // If the list is empty or the position is invalid
    if (head == null || position < 1) {
        return;
    }

    // If the head needs to be deleted
    if (position == 1) {
        Node temp = head;
        head = head.next;
        temp = null;
        return;
    }

    // Traverse to the node before the position to be
    // deleted
    Node current = head;
    for (int i = 1; i < position - 1 && current != null;
         i++) {
        current = current.next;
    }

    // If the position is out of range
    if (current == null || current.next == null) {
        return;
    }

    // Store the node to be deleted
    Node temp = current.next;

    // Update the links to bypass the node to be deleted
    current.next = current.next.next;

    // Delete the node
    temp = null;
}

````

Python
````
# Python function to delete a node at a specific position
def delete_at_position(head, position):
    # If the list is empty or the position is invalid
    if head is None or position < 1:
        return head

    # If the head needs to be deleted
    if position == 1:
        temp = head
        head = head.next
        temp = None
        return head

    # Traverse to the node before the position to be deleted
    current = head
    for i in range(1, position - 1):
        if current is not None:
            current = current.next

    # If the position is out of range
    if current is None or current.next is None:
        return head

    # Store the node to be deleted
    temp = current.next

    # Update the links to bypass the node to be deleted
    current.next = current.next.next

    # Delete the node
    temp = None
    return head

````

JavaScript
````
// Javascript function to delete a node at a specific position
function deleteAtPosition(head, position) {
    // If the list is empty or the position is invalid
    if (head === null || position < 1) {
        return head;
    }

    // If the head needs to be deleted
    if (position === 1) {
        let temp = head;
        head = head.next;
        temp = null;
        return head;
    }

    // Traverse to the node before the position to be deleted
    let current = head;
    for (let i = 1; i < position - 1 && current !== null; i++) {
        current = current.next;
    }

    // If the position is out of range
    if (current === null || current.next === null) {
        return head;
    }

    // Store the node to be deleted
    let temp = current.next;

    // Update the links to bypass the node to be deleted
    current.next = current.next.next;

    // Delete the node
    temp = null;
    return head;
}

````


', 'A singly linked list is a fundamental data structure, it consists of nodes where each node contains a data field and a reference to the next node in the linked list. The next of the last node is null, indicating the end of the list. Linked Lists support efficient insertion and deletion operations.', 'Singly Linked List Tutorial', 1, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('2250b823-d1c9-4781-9d3d-71a989d37c49', e'What is a Doubly Linked List?
-----------------------------

A ****doubly linked list****
is a data structure that consists of a set of nodes, each of which
contains a ****value**** and ****two pointers****, one pointing to the ****previous node**** in the list and one pointing to the ****next node****
in the list. This allows for efficient traversal of the list in ****both directions****, making it suitable for applications where frequent ****insertions**** and ****deletions**** are required.

![Insertion-at-the-End-in-Doubly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20240809123741/Insertion-at-the-End-in-Doubly-Linked-List-copy.webp)

Doubly Linked List


Representation of Doubly Linked List in Data Structure
------------------------------------------------------

In a data structure, a doubly linked list is represented using nodes
that have three fields:

1. Data
2. A pointer to the next node (****next****)
3. A pointer to the previous node (****prev****)

![Node-Structure-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124907/Node-Structure-of-Doubly-Linked-List.webp)

Node Structure of Doubly Linked List


Node Definition
---------------

Here is how a node in a Doubly Linked List is typically
represented:

[Try it on GfG Practice
![redirect icon](https://media.geeksforgeeks.org/auth-dashboard-uploads/Group-arrow.svg)](https://www.geeksforgeeks.org/problems/display-doubly-linked-list--154650/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card)
C++
````
struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;

    // Constructor
    Node(int d) {
       data = d;
       prev = next = nullptr;
    }
};

````

C
````
struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;
};

// Function to create a new node
struct Node *createNode(int new_data) {
    struct Node *new_node = (struct Node *)
    malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}

````

Java
````
class Node {

    // To store the Value or data.
    int data;

    // Reference to the Previous Node
    Node prev;

    // Reference to the next Node
    Node next;

    // Constructor
    Node(int d) {
       data = d;
       prev = next = null;
    }
};

````

Python
````
class Node:

    def __init__(self, data):
        # To store the value or data.
        self.data = data

        # Reference to the previous node
        self.prev = None

        # Reference to the next node
        self.next = None

````

C#
````
class Node
{
  	// To store the value or data
    public int Data;

  	// Pointer to the next node
    public Node Next;

  	// Pointer to the previous node
    public Node Prev;

    // Constructor
    public Node(int d)
    {
        Data = d;
        Prev = Next = null;
    }
}

````

JavaScript
````
class Node {
    constructor(data)
    {
        // To store the value or data.
        this.data = data;

        // Reference to the previous node
        this.prev = null;

        // Reference to the next node
        this.next = null;
    }
}

````

Each node in a ****Doubly Linked List**** contains the ****data**** it holds, a pointer to the ****next**** node in the list, and a pointer to the ****previous****
node in the list. By linking these nodes together through the ****next**** and ****prev****
pointers, we can traverse the list in both directions (forward and
backward), which is a key feature of a Doubly Linked List.

[Operations on Doubly Linked List](https://www.geeksforgeeks.org/doubly-linked-list-tutorial)
---------------------------------------------------------------------------------------------

* ****Traversal in Doubly Linked List****
* ****Searching in Doubly Linked List****
* ****Finding Length of Doubly Linked List****
* [****Insertion in Doubly Linked List****:](https://www.geeksforgeeks.org/introduction-and-insertion-in-a-doubly-linked-list)
  + Insertion at the beginning of Doubly Linked List
  + Insertion at the end of the Doubly Linked List
  + Insertion at a specific position in Doubly Linked List
* [****Deletion in Doubly Linked List****:](https://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list)
  + Deletion of a node at the beginning of Doubly Linked List
  + Deletion of a node at the end of Doubly Linked List
  + Deletion of a node at a specific position in Doubly Linked
    List

Let\'s go through each of the operations mentioned above, one by
one.

[Traversal in Doubly Linked List](https://www.geeksforgeeks.org/traversal-in-doubly-linked-list/)
-------------------------------------------------------------------------------------------------

To Traverse the doubly list, we can use the following steps:

****a. Forward Traversal:****

* Initialize a pointer to the head of the linked list.
* While the pointer is not null:
  + Visit the data at the current node.
  + Move the pointer to the next node.

****b. Backward Traversal:****

* Initialize a pointer to the tail of the linked list.
* While the pointer is not null:
  + Visit the data at the current node.
  + Move the pointer to the previous node.

Below are the implementation of the above approach:

C++
````
#include <iostream>
using namespace std;

// Define the Node structure
struct Node {
    int data;
    Node* next;
    Node* prev;

// Constructor to initialize Node with data
    Node(int data) : data(data), next(nullptr),
  	prev(nullptr) {}
};

// Function to traverse the doubly linked list
// in forward direction
void forwardTraversal(Node* head) {

    // Start traversal from the head of the list
    Node* curr = head;

// Continue until current node is not null
    // (end of list)
    while (curr != nullptr) {

        // Output data of the current node
        cout << curr->data << " ";

// Move to the next node
        curr = curr->next;
}

    // Print newline after traversal
    cout << endl;
}

// Function to traverse the doubly linked list
// in backward direction
void backwardTraversal(Node* tail) {

    // Start traversal from the tail of the list
    Node* curr = tail;

// Continue until current node is not null
    // (end of list)
    while (curr != nullptr) {

        // Output data of the current node
        cout << curr->data << " ";

// Move to the previous node
        curr = curr->prev;
}

    // Print newline after traversal
    cout << endl;
}

int main() {

    // Sample usage of the doubly linked list and
    // traversal functions
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    cout << "Forward Traversal:" << endl;
    forwardTraversal(head);

    cout << "Backward Traversal:" << endl;
    backwardTraversal(third);

return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data; // Data stored in the node
    struct Node* next; // Pointer to the next node
    struct Node* prev; // Pointer to the previous node
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode =
      (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
return newNode;
}

// Function to traverse the doubly linked list
// in forward direction
void forwardTraversal(struct Node* head) {

    // Start traversal from the head of the list
    struct Node* curr = head;

// Continue until the current node is not
    // null (end of list)
    while (curr != NULL) {

        // Output data of the current node
        printf("%d ", curr->data);

// Move to the next node
        curr = curr->next;
}

    // Print newline after traversal
    printf("\\n");
}

// Function to traverse the doubly linked list
// in backward direction
void backwardTraversal(struct Node* tail) {

    // Start traversal from the tail of the list
    struct Node* curr = tail;

// Continue until the current node is not
    // null (end of list)
    while (curr != NULL) {

        // Output data of the current node
        printf("%d ", curr->data);

// Move to the previous node
        curr = curr->prev;
}

    // Print newline after traversal
    printf("\\n");
}

int main() {

    // Sample usage of the doubly linked list and
    // traversal functions
    struct Node* head = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    printf("Forward Traversal:\\n");
    forwardTraversal(head);

    printf("Backward Traversal:\\n");
    backwardTraversal(third);

// Free memory allocated for nodes
    free(head);
    free(second);
    free(third);

return 0;
}

````

Java
````
// Define the Node class
class Node {
    int data; // Data stored in the node
    Node next; // Pointer to the next node
    Node prev; // Pointer to the previous node

    // Constructor to initialize the node with data
    public Node(int data) {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

// Class to manage the doubly linked list
class GfG {

    // Function to traverse the doubly linked list
    // in forward direction
    static void forwardTraversal(Node head) {

        // Start traversal from the head of the list
        Node curr = head;

// Continue until the current node is
        // null (end of the list)
        while (curr != null) {

            // Output data of the current node
            System.out.print(curr.data + " ");

// Move to the next node
            curr = curr.next;
}

        // Print newline after traversal
        System.out.println();
}

    // Function to traverse the doubly linked list
  	//in backward direction
    static void backwardTraversal(Node tail) {

        // Start traversal from the tail of the list
        Node curr = tail;

// Continue until the current node is
        // null (end of the list)
        while (curr != null) {

            // Output data of the current node
            System.out.print(curr.data + " ");

// Move to the previous node
            curr = curr.prev;
}

        // Print newline after traversal
        System.out.println();
}

    public static void main(String[] args) {

        // Sample usage of the doubly linked
        // list and traversal functions
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        System.out.println("Forward Traversal:");
        forwardTraversal(head);

        System.out.println("Backward Traversal:");
        backwardTraversal(third);
}
}

````

Python
````
# Define the Node class
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Function to traverse the doubly linked list
# in forward direction
def forward_traversal(head):

    # Start traversal from the head of the list
    curr = head

    # Continue until the current node is
    # null (end of the list)
    while curr is not None:

        # Output data of the current node
        print(curr.data, end=" ")

        # Move to the next node
        curr = curr.next

    # Print newline after traversal
    print()

# Function to traverse the doubly linked
# list in backward direction
def backward_traversal(tail):

    # Start traversal from the tail of the list
    curr = tail

    # Continue until the current node
    # is null (end of the list)
    while curr is not None:

        # Output data of the current node
        print(curr.data, end=" ")

        # Move to the previous node
        curr = curr.prev

    # Print newline after traversal
    print()

# Sample usage of the doubly linked list
# and traversal functions
if __name__ == "__main__":

    # Create a doubly linked list with 3 nodes
    head = Node(1)
    second = Node(2)
    third = Node(3)

    head.next = second
    second.prev = head
    second.next = third
    third.prev = second

    print("Forward Traversal:")
    forward_traversal(head)

    print("Backward Traversal:")
    backward_traversal(third)

````

C#
````
using System;

// Define the Node class
class Node
{
    public int Data; // Data stored in the node
    public Node Next; // Pointer to the next node
    public Node Prev; // Pointer to the previous node

    // Constructor to initialize the node with data
    public Node(int data)
    {
        Data = data;
Next = null;
        Prev = null;
}
}

// Class to manage the doubly linked list
class GfG
{
    // Function to traverse the doubly linked list
  	//in forward direction
    static void ForwardTraversal(Node head)
    {
        // Start traversal from the head of the list
        Node curr = head;

// Continue until the current node is null
      	//(end of the list)
        while (curr != null)
        {
            // Output data of the current node
            Console.Write(curr.Data + " ");

// Move to the next node
            curr = curr.Next;
}

        // Print newline after traversal
        Console.WriteLine();
}

    // Function to traverse the doubly linked list
  	//in backward direction
    static void BackwardTraversal(Node tail)
    {
        // Start traversal from the tail of the list
        Node curr = tail;

// Continue until the current node is null
      	//(end of the list)
        while (curr != null)
        {
            // Output data of the current node
            Console.Write(curr.Data + " ");

// Move to the previous node
            curr = curr.Prev;
}

        // Print newline after traversal
        Console.WriteLine();
}

    public static void Main()
    {
        // Sample usage of the doubly linked list
      	//and traversal functions
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.Next = second;
second.Prev = head;
second.Next = third;
        third.Prev = second;

        Console.WriteLine("Forward Traversal:");
        ForwardTraversal(head);

        Console.WriteLine("Backward Traversal:");
        BackwardTraversal(third);
}
}

````

JavaScript
````
// Define the Node class
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Function to traverse the doubly linked list
// in forward direction
function forwardTraversal(head) {

    // Start traversal from the head of the list
    let curr = head;

// Continue until the current node is null
    // (end of the list)
    while (curr !== null) {

        // Output data of the current node
        console.log(curr.data + " ");

// Move to the next node
        curr = curr.next;
}

    // Print newline after traversal
    console.log();
}

// Function to traverse the doubly linked list
// in backward direction
function backwardTraversal(tail) {

    // Start traversal from the tail of the list
    let curr = tail;

// Continue until the current node is null
    // (end of the list)
    while (curr !== null) {

        // Output data of the current node
        console.log(curr.data + " ");

// Move to the previous node
        curr = curr.prev;
}

    // Print newline after traversal
    console.log();
}

// Sample usage of the doubly linked list
//and traversal functions
// Create a doubly linked list with 3 nodes
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);

head.next = second;
second.prev = head;
second.next = third;
third.prev = second;

console.log("Forward Traversal:");
forwardTraversal(head);

console.log("Backward Traversal:");
backwardTraversal(third);

````



**Output**
```

Forward Traversal:
1 2 3
Backward Traversal:
3 2 1

```

[Finding Length of Doubly Linked List](https://www.geeksforgeeks.org/program-find-size-doubly-linked-list/)
-----------------------------------------------------------------------------------------------------------

To find the length of doubly list, we can use the following
steps:

* Start at the head of the list.
* Traverse through the list, counting each node visited.
* Return the total count of nodes as the length of the list.

Below are the implementation of the above approach:

C++
````
#include <iostream>

using namespace std;

// Node structure for doubly linked list
struct Node {
    int data;
    Node * prev;
    Node * next;

    Node(int val) {
        data = val;
        prev = next = nullptr;
}
};

// Function to find the length of a doubly
//linked list
int findLength(Node * head) {
    int count = 0;
for (Node * cur = head; cur != nullptr; cur = cur -> next)
        count++;
return count;
}

int main() {

    // Create a DLL with 3 nodes
    Node * head = new Node(1);
    Node * second = new Node(2);
    Node * third = new Node(3);
    head -> next = second;
second -> prev = head;
second -> next = third;
    third -> prev = second;

    cout << "Length of the doubly linked list: " <<
        findLength(head) << endl;

return 0;
}

````

C
````
#include <stdio.h>
#include <stdlib.h>

// Node structure for doubly linked list
struct Node {
    int data; // Data stored in the node
    struct Node* prev; // Pointer to the previous node
    struct Node* next; // Pointer to the next node
};

// Constructor function to create a new node
struct Node* createNode(int val) {
    struct Node* newNode =
         (struct Node*)malloc(sizeof(struct Node));
    newNode->data = val;
    newNode->prev = NULL;
    newNode->next = NULL;
return newNode;
}

// Function to find the length of a doubly linked list
int findLength(struct Node* head) {
    int count = 0;
for (struct Node* cur = head; cur != NULL; cur = cur->next)
        count++;
return count;
}

int main() {
    // Create a DLL with 3 nodes
    struct Node* head = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    head->next = second;
second->prev = head;
second->next = third;
    third->prev = second;

    printf("Length of the doubly linked list: %d\\n",
           findLength(head));

return 0;
}

````

Java
````
class Node {
    int data;
    Node prev;
    Node next;

// Constructor
    public Node(int val) {
        data = val;
        prev = null;
next = null;
}
}

class GfG {

    // Function to find the length of
    // a doubly linked list
    static int FindLength(Node head) {
        int count = 0;
for (Node cur = head; cur != null; cur = cur.next)
            count++;
return count;
}

    // Driver code
    public static void main(String[] args) {

        // Create a doubly linked list
        // with 3 nodes
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        System.out.println("Length of doubly linked list: "
                           + FindLength(head));
}
}

````

Python
````
class Node:
    def __init__(self, val):
        self.data = val
        self.prev = None
        self.next = None

# Function to find the length of
# a doubly linked list
def find_length(head):
    count = 0
    cur = head
    while cur is not None:
        count += 1
        cur = cur.next
    return count

# Driver code
if __name__ == "__main__":

    # Create a doubly linked list
    # with 3 nodes
    head = Node(1)
    second = Node(2)
    third = Node(3)

    head.next = second
    second.prev = head
    second.next = third
    third.prev = second

    print("Length of the doubly linked list: " +
          str(find_length(head)))

````

C#
````
using System;

class Node {
    public int data;
public Node prev;
public Node next;

// Constructor
    public Node(int val) {
        data = val;
        prev = null;
next = null;
}
}

public class GfG {

    // Function to find the length of
    // a doubly linked list
    static int FindLength(Node head) {
        int count = 0;
for (Node cur = head; cur != null; cur = cur.next)
            count++;
return count;
}

    // Driver code
    public static void Main(string[] args) {

        // Create a doubly linked list
        // with 3 nodes
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);

        head.next = second;
second.prev = head;
second.next = third;
        third.prev = second;

        Console.WriteLine("Length of doubly linked list: "
                                 + FindLength(head));
}
}

````

JavaScript
````
class Node {
    constructor(val) {
        this.data = val;
        this.prev = null;
        this.next = null;
}
}

// Function to find the length of
// a doubly linked list
function findLength(head) {
    let count = 0;
    let cur = head;
    while (cur !== null) {
        count++;
        cur = cur.next;
}
    return count;
}

// Create a doubly linked list with 3 nodes
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);

head.next = second;
second.prev = head;
second.next = third;
third.prev = second;

console.log("Length of the doubly linked list: " +
            findLength(head));

````





**Output**
```

Length of the doubly linked list: 3

```

[Insertion at the Beginning in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-frontbeginning-of-doubly-linked-list/)
----------------------------------------------------------------------------------------------------------------------------------------

![Insertion-at-the-Beginning-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809123903/Insertion-at-the-Beginning-in-Doubly-Linked-List.webp)

Insertion at the Beginning in Doubly Linked List


To insert a new node at the beginning of the doubly list, we can use
the following steps:

* Create a new node, say ****new\\_node****with the given data and set its previous pointer to null, ****new\\_node->prev =**** ****NULL****.
* Set the next pointer of new\\_node to current head, ****new\\_node->next = head.****
* If the linked list is not empty, update the previous pointer of the
                                                                                                                                                                                                                current head to new\\_node, ****head->prev = new\\_node****.
                                                                                                                                                                                                                * Return new\\_node as the head of the updated linked list.

                                                                                                                                                                                                                Below are the implementation of the above approach:

                                                                                                                                                                                                                C++
                                                                                                                                                                                                                ````
                                                                                                                                                                                                                // C++ Program to insert a new node at the
                                   // beginning of doubly linked list

                                   #include <iostream>
                                   using namespace std;

// Node structure for the doubly linked list
struct Node {
    int data;
    Node* prev;
    Node* next;

    Node(int d) {
      data = d;
      prev = next = NULL;
}
};

// Insert a node at the beginning
Node* insertBegin(Node* head, int data) {

    // Create a new node
    Node* new_node = new Node(data);

// Make next of it as head
    new_node->next = head;

// Set previous of head as new node
    if (head != NULL) {
        head->prev = new_node;
}

    // Return new node as new head
    return new_node;
}

void printList(Node* head) {
    Node* curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
  	cout << "\\n";
}

int main() {

    // Create a hardcoded linked list:
  	// 2 <-> 3 <-> 4
    Node* head = new Node(2);
    Node* temp1 = new Node(3);
    Node* temp2 = new Node(4);
    head->next = temp1;
    temp1->prev = head;
    temp1->next = temp2;
    temp2->prev = temp1;

// Print the original list
    cout << "Original Linked List: ";
    printList(head);

// Insert a new node at the front of the list
    head = insertBegin(head, 1);

// Print the updated list
  	cout << "After inserting Node 1 at the front: ";
    printList(head);

return 0;
}

````

C
````
// C Program to insert a node at the beginning
//of doubly linked list


#include <stdio.h>

// Node structure for the doubly linked list
struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

// Create a new node
struct Node* createNode(int data) {
    struct Node* new_node =
      (struct Node*)malloc(sizeof(struct Node));
    new_node->data = data;
    new_node->prev = NULL;
    new_node->next = NULL;
return new_node;
}

// Insert a node at the beginning
struct Node* insertBegin(struct Node* head, int data) {

    // Create a new node
    struct Node* new_node = createNode(data);

// Make next of it as head
    new_node->next = head;

// Set previous of head as new node
    if (head != NULL) {
        head->prev = new_node;
}

    // Return new node as new head
    return new_node;
}

// Print the doubly linked list
void printList(struct Node* head) {
    struct Node* curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
}
  	printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 2 <-> 3 <-> 4
    struct Node *head = createNode(2);
    head->next = createNode(3);
    head->next->prev = head;
    head->next->next = createNode(4);
    head->next->next->prev = head->next;

// Print the original list
    printf("Original Linked List: ");
    printList(head);

// Insert a new node at the front of the list
    head = insertBegin(head, 1);

// Print the updated list
  	printf("After inserting Node 1 at the front: ");
    printList(head);

return 0;
}

````

Java
````
// Java Program to insert a node at the beginning of a
// doubly linked list

class Node {
    int data;
    Node prev, next;

// Node structure for the doubly linked list
    Node(int d) {
        data = d;
        prev = null;
next = null;
}
}

class GfG {

    // Insert a node at the beginning
    static Node insertBegin(Node head, int data) {

        // Create a new node
        Node new_node = new Node(data);

// Make next of it as head
        new_node.next = head;

// Set previous of head as new node
        if (head != null) {
            head.prev = new_node;
}

        // Return new node as new head
        return new_node;
}

    // Print the doubly linked list
    static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
      	System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 2 <-> 3 <-> 4
        Node head = new Node(2);
        head.next = new Node(3);
        head.next.prev = head;
        head.next.next = new Node(4);
        head.next.next.prev = head.next;

// Print the original list
        System.out.print("Original Linked List: ");
        printList(head);

// Insert a new node at the front of the list
        head = insertBegin(head, 1);

// Print the updated list
      	System.out.print(
            "After inserting Node 1 at the front: ");
        printList(head);
}
}

````

Python
````
# Python Program to insert a node at the beginning
#of doubly linked list

# Node structure for the doubly linked list
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Insert a node at the beginning
def insertBegin(head, data):

    # Create a new node
    new_node = Node(data)

    # Make next of it as head
    new_node.next = head

    # Set previous of head as new node
    if head is not None:
        head.prev = new_node

    # Return new node as new head
    return new_node

# Print the doubly linked list
def printList(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 2 <-> 3 <-> 4
    head = Node(2)
    head.next = Node(3)
    head.next.prev = head
    head.next.next = Node(4)
    head.next.next.prev = head.next

    # Print the original list
    print("Original Linked List:", end=\' \')
    printList(head)

    # Insert a new node at the front of the list
    head = insertBegin(head, 1)

    # Print the updated list
    print("After inserting Node 1 at the front:", end=\' \')
    printList(head)

````

C#
````
// C# Program to insert a node at the beginning of a
// doubly linked list

using System;

// Node structure for the doubly linked list
class Node {
    public int data;
public Node prev, next;

// Constructor for creating a new node
    public Node(int d) {
        data = d;
        prev = null;
next = null;
}
}

class GfG {

    // Insert a node at the beginning
    public static
    Node insertBegin(Node head, int data) {

        // Create a new node
        Node new_node = new Node(data);

// Make next of it as head
        new_node.next = head;

// Set previous of head as new node
        if (head != null) {
            head.prev = new_node;
}

        // Return new node as new head
        return new_node;
}

    // Print the doubly linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.data + " ");
            curr = curr.next;
}
      	Console.WriteLine();
}

    public static void Main(string[] args) {

        // Create a hardcoded doubly linked list:
        // 2 <-> 3 <-> 4
        Node head = new Node(2);
        head.next = new Node(3);
        head.next.prev = head;
        head.next.next = new Node(4);
        head.next.next.prev = head.next;

// Print the original list
        Console.Write("Original Linked List: ");
        printList(head);

// Insert a new node at the front of the list
        head = insertBegin(head, 1);

// Print the updated list
      	Console.Write
        ("After inserting Node 1 at the front: ");
        printList(head);
}
}

````

JavaScript
````
// JavaScript Program to insert a node at the
//beginning of doubly linked list

// Node structure for the doubly linked list
function Node(data) {
    this.data = data;
    this.prev = null;
    this.next = null;
}

// Insert a node at the beginning
function insertBegin(head, data) {

    // Create a new node
    const new_node = new Node(data);

// Make next of it as head
    new_node.next = head;

// Set previous of head as new node
    if (head !== null) {
        head.prev = new_node;
}

    // Return new node as new head
    return new_node;
}

// Print the doubly linked list
function printList(head) {
    let curr = head;
    while (curr !== null) {
        console.log(curr.data);
        curr = curr.next;
}
}

// Create a hardcoded doubly linked list:
// 2 <-> 3 <-> 4
let head = new Node(2);
head.next = new Node(3);
head.next.prev = head;
head.next.next = new Node(4);
head.next.next.prev = head.next;

// Print the original list
console.log("Original Linked List:");
printList(head);

// Insert a new node at the front of the list
console.log
("After inserting Node 1 at the front:");
let data = 1;
head = insertBegin(head, data);

// Print the updated list
printList(head);

````








**Output**
```

Original Linked List: 2 3 4
After inserting Node 1 at the front: 1 2 3 4

```

[Insertion at the End of Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-the-end-of-doubly-linked-list/)
---------------------------------------------------------------------------------------------------------------------------

![Insertion-at-the-End-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809123955/Insertion-at-the-End-in-Doubly-Linked-List.webp)

Insertion at the End in the Doubly Linked List


To insert a new node at the end of the doubly linked list, we can use
the following steps:

* Allocate memory for a new node and assign the provided value to its
  data field.
* Initialize the next pointer of the new node to nullptr.
* If the list is empty:
  + Set the previous pointer of the new node to nullptr.
  + Update the head pointer to point to the new node.
                                                                                          * If the list is not empty:
                                                                                          + Traverse the list starting from the head to reach the last
                                                                                          node.
                                                                                          + Set the next pointer of the last node to point to the new
                                                                                          node.
                                                                                          + Set the previous pointer of the new node to point to the last
                                                                                          node.

                                                                                          Below are the implementation of the above approach:

                                                                                          C++
                                                                                          ````
                                                                                          // C++ Program to insert a node at the end of
//doubly linked list

#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node *next, *prev;

    Node(int new_data) {
        data = new_data;
next = prev = nullptr;
}
};

// Function to insert a new node at the end of
//doubly linked list
Node *insertEnd(Node *head, int new_data) {

    // Create a new node
    Node *new_node = new Node(new_data);

// If the linked list is empty, set the new
  	//node as the head of linked list
    if (head == NULL) {
        head = new_node;
}
    else {
          Node *curr = head;
        while (curr->next != NULL) {
            curr = curr->next;
}

        // Set the next of last node to new node
        curr->next = new_node;

// Set prev of new node to last node
        new_node->prev = curr;
}

    // Return the head of the doubly linked list
    return head;
}

void printList(Node *head) {
    Node *curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
    cout << endl;
}

int main() {

    // Create a harcoded doubly linked list:
    // 1 <-> 2 <-> 3
    Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;

// Print the original list
    cout << "Original Linked List: ";
    printList(head);

// Insert a new node with data 4 at the end
    cout << "Inserting Node with data 4 at the end: ";
int data = 4;
    head = insertEnd(head, data);

// Print the updated list
    printList(head);

return 0;
}

````

C
````
// C Program to insert a node at the end of
//doubly linked list

#include <stdio.h>

struct Node {
    int data;
    struct Node *next;
    struct Node *prev;
};

// Function to create a new node with the given data
struct Node *createNode(int new_data) {
    struct Node *new_node =
    (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
return new_node;
}

// Function to insert a new node at the end of the
//doubly linked list
struct Node* insertEnd(struct Node *head, int new_data) {
    struct Node *new_node = createNode(new_data);

// If the linked list is empty, set the
 	//new node as the head
    if (head == NULL) {
        head = new_node;
} else {
        struct Node *curr = head;
        while (curr->next != NULL) {
            curr = curr->next;
}

        // Set the next of last node to new node
        curr->next = new_node;
// Set prev of new node to last node
        new_node->prev = curr;
}

    return head;
}

void printList(struct Node *head) {
    struct Node *curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
}
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;

// Print the original list
    printf("Original Linked List: ");
    printList(head);

// Insert a new node with data 4 at the end
    printf("Inserting Node with data 4 at the end: ");
    head = insertEnd(head, 4);

// Print the updated list
    printList(head);

return 0;
}

````

Java
````
// Java Program to insert a node at the end of
// doubly linked list

class Node {
    int data;
    Node next, prev;

    Node(int newData) {
        data = newData;
next = prev = null;
}
}

class GFG {

    // Function to insert a new node at the end of the
    // doubly linked list
    public static Node insertEnd(Node head, int newData) {

        // Create a new node
        Node newNode = new Node(newData);

// If the linked list is empty, set the new node as
        // the head
        if (head == null) {
            head = newNode;
}
        else {
            Node curr = head;
            while (curr.next != null) {
                curr = curr.next;
}

            // Set the next of last node to the new node
            curr.next = newNode;

// Set the prev of new node to the last node
            newNode.prev = curr;
}

        return head;
}

    // Function to print the doubly linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

// Print the original list
        System.out.println("Original Linked List: ");
        printList(head);

// Insert a new node with data 4 at the end
        System.out.println(
            "Inserting Node with data 4 at the end: ");
int data = 4;
        head = insertEnd(head, data);

// Print the updated list
        printList(head);
}
}

````

Python
````
# Python Program to insert a node at the end of
#doubly linked list

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

# Function to insert a new node at the end of the
#doubly linked list
def insert_end(head, new_data):

    # Create a new node
    new_node = Node(new_data)

    # If the linked list is empty, set the new node
    #as the head
    if head is None:
        head = new_node
    else:
        curr = head
        while curr.next is not None:
            curr = curr.next

        # Set the next of the last node to the new node
        curr.next = new_node

        # Set the prev of the new node to the last node
        new_node.prev = curr

    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    # Print the original list
    print("Original Linked List: ", end="")
    print_list(head)

    # Insert a new node with data 4 at the end
    print("Inserting Node with data 4 at the end: ", end="")
    data = 4
    head = insert_end(head, data)

    # Print the updated list
    print_list(head)

````

C#
````
// C# Program to insert a node at the end of
//doubly linked list

using System;

class Node {
    public int Data;
public Node Next;
public Node Prev;

public Node(int data) {
        Data = data;
Next = null;
        Prev = null;
}
}

class GFG {

    // Function to insert a new node at the end
  	//of the doubly linked list
    public static Node InsertEnd(Node head, int newData) {

          // Create a new node
        Node newNode = new Node(newData);

// If the linked list is empty, set the
      	//new node as the head
        if (head == null) {
            head = newNode;
}
        else {
            Node curr = head;
            while (curr.Next != null) {
                curr = curr.Next;
}

            // Set the next of the last node to
          	//the new node
            curr.Next = newNode;

// Set the prev of the new node to
          	//the last node
            newNode.Prev = curr;
}

        return head;
}

    // Function to print the doubly linked list
    public static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

// Print the original list
        Console.Write("Original Linked List: ");
        PrintList(head);

// Insert a new node with data 4 at the end
        Console.Write("Inserting Node with data 4 at the end: ");
int data = 4;
        head = InsertEnd(head, data);

// Print the updated list
        PrintList(head);
}
}

````

JavaScript
````
// Javascript Program to insert a node at the end of
//doublylinked list

class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

function insertEnd(head, newData) {

    // Create a new node
    const newNode = new Node(newData);

// If the linked list is empty, set the
    //new node as the head
    if (head === null) {
        head = newNode;
}
    else {
        let curr = head;
        while (curr.next !== null) {
            curr = curr.next;
}

        // Set the next of the last node to the
        //new node
        curr.next = newNode;

// Set the prev of the new node to the
        //last node
        newNode.prev = curr;
}

    return head;
}

function printList(head)
{
    let curr = head;
    let result = "";
    while (curr !== null) {
        result += curr.data + " ";
        curr = curr.next;
}
    console.log(result.trim());
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

// Print the original list
console.log("Original Linked List: ");
printList(head);

// Insert a new node with data 4 at the end
console.log("Inserting Node with data 4 at the end: ");
const data = 4;
head = insertEnd(head, data);

// Print the updated list
printList(head);

````




**Output**
```

Original Linked List: 1 2 3
Inserting Node with data 4 at the end: 1 2 3 4

```

[Insertion at a Specific Position in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-doubly-linked-list/)
---------------------------------------------------------------------------------------------------------------------------------------------------

To insert a node at a specific Position in doubly linked list, we can
use the following steps:

![Insertion-at-a-Specific-Position-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124039/Insertion-at-a-Specific-Position-in-Doubly-Linked-List.webp)


Insertion at a Specific Position in Doubly Linked List



To insert a new node at a specific position,

* If position = 1, create a new node and make it the head of the linked
  list and return it.
* Otherwise, traverse the list to reach the node at position – 1,
  say ****curr****.
* If the position is valid, create a new node with given data,
  say ****new\\_node****.
* Update the next pointer of new node to the next
                                                                                                                                             of current node and prev pointer of new node to current
                                                                                                                                             node, ****new\\_node->next = curr->next****and ****new\\_node->prev = curr.****
                                                                                                                                             * Similarly, update next pointer of current node to
                                                                                                                                                              thenew node, ****curr->next = new\\_node****.
                                                                                                                                                              * If the new node is not the last node, update prev pointer of new
                                                                                                                                                                                                          node’s next to the new node, ****new\\_node->next->prev = new\\_node.****

                                                                                                                                                                                                          Below is the implementation of the above approach:

                                                                                                                                                                                                          C++
                                                                                                                                                                                                          ````
                                                                                                                                                                                                          // C++ Program to insert a node at a given position

                                                                                                                                                                                                      #include <bits/stdc++.h>
                                                                                                                                                                                                      using namespace std;

struct Node {
    int data;
    Node *next, *prev;

    Node(int new_data) {
        data = new_data;
next = prev = nullptr;
}
};

// Function to insert a new node at a given position
Node *insertAtPosition(Node *head, int pos, int new_data) {

    // Create a new node
    Node *new_node = new Node(new_data);

// Insertion at the beginning
    if (pos == 1) {
        new_node->next = head;

// If the linked list is not empty, set the prev
      	//of head to new node
        if (head != NULL)
            head->prev = new_node;

// Set the new node as the head of linked list
        head = new_node;
return head;
}

    Node *curr = head;
// Traverse the list to find the node before the
    // insertion point
    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {
        curr = curr->next;
}

    // If the position is out of bounds
    if (curr == NULL) {
        cout << "Position is out of bounds." << endl;
        delete new_node;
return head;
}

    // Set the prev of new node to curr
    new_node->prev = curr;

// Set the new of new node to next of curr
    new_node->next = curr->next;

// Update the next of current node to new node
       curr->next = new_node;

// If the new node is not the last node, update prev
                                             //of next node to new node
                                             if (new_node->next != NULL)
                                             new_node->next->prev = new_node;

// Return the head of the doubly linked list
    return head;
}

void printList(Node *head) {
    Node *curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
    cout << endl;
}

int main() {

    // Create a harcoded doubly linked list:
    // 1 <-> 2 <-> 4
    Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(4);
    head->next->next->prev = head->next;

// Print the original list
    cout << "Original Linked List: ";
    printList(head);

// Insert new node with data 3 at position 3
    cout << "Inserting Node with data 3 at position 3: ";
int data = 3;
int pos = 3;
    head = insertAtPosition(head, pos, data);

// Print the updated list
    printList(head);

return 0;
}

````

C
````
// C Program to insert a node at a given position

#include <stdio.h>

struct Node {
    int data;
    struct Node * next;
    struct Node * prev;
};

// Function to create a new node with the given data
struct Node * createNode(int new_data) {
    struct Node * new_node =
        (struct Node * ) malloc(sizeof(struct Node));
    new_node -> data = new_data;
    new_node -> next = NULL;
return new_node;
}

// Function to insert a new node at a given position
struct Node * insertAtPosition(struct Node * head, int pos, int new_data) {
    // Create a new node
    struct Node * new_node = createNode(new_data);

// Insertion at the beginning
    if (pos == 1) {
        new_node -> next = head;

// If the linked list is not empty, set the
      //prev of head to new node
        if (head != NULL) {
            head -> prev = new_node;
}

        // Set the new node as the head of linked list
        head = new_node;
return head;
}

    struct Node * curr = head;

// Traverse the list to find the node before the insertion point
    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {
        curr = curr -> next;
}

    // If the position is out of bounds
    if (curr == NULL) {
        printf("Position is out of bounds.\\n");
        free(new_node);
return head;
}

    // Set the prev of new node to curr
    new_node -> prev = curr;

// Set the next of new node to next of curr
    new_node -> next = curr -> next;

// Update the next of current node to new node
       curr -> next = new_node;

// If the new node is not the last node, update
                                             //the prev of next node to new node
                                             if (new_node -> next != NULL) {
                                             new_node -> next -> prev = new_node;
}

    // Return the head of the doubly linked list
    return head;
}

// Function to print the linked list
void printList(struct Node * head) {
    struct Node * curr = head;
    while (curr != NULL) {
        printf("%d ", curr -> data);
        curr = curr -> next;
}
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 4
    struct Node * head = createNode(1);
    head -> next = createNode(2);
    head -> next -> prev = head;
    head -> next -> next = createNode(4);
    head -> next -> next -> prev = head -> next;

// Print the original list
    printf("Original Linked List: ");
    printList(head);

// Insert new node with data 3 at position 3
    printf("Inserting Node with data 3 at position 3: ");
int data = 3;
int pos = 3;
    head = insertAtPosition(head, pos, data);

// Print the updated list
    printList(head);

return 0;
}

````

Java
````
// Java Program to insert a node at a given position

class Node {
    int data;
    Node next;
    Node prev;

    Node(int new_data) {
        data = new_data;
next = prev = null;
}
}

class GFG {

    // Function to insert a new node at a given position
    public static Node insertAtPosition(Node head, int pos, int new_data) {
        // Create a new node
        Node new_node = new Node(new_data);

// Insertion at the beginning
        if (pos == 1) {
            new_node.next = head;

// If the linked list is not empty, set
          	//the prev of head to new node
            if (head != null) {
                head.prev = new_node;
}

            // Set the new node as the head of linked list
            head = new_node;
return head;
}

        Node curr = head;

// Traverse the list to find the node before
      	//the insertion point
        for (int i = 1; i < pos - 1 && curr != null; ++i) {
            curr = curr.next;
}

        // If the position is out of bounds
        if (curr == null) {
            System.out.println("Position is out of bounds.");
return head;
}

        // Set the prev of new node to curr
        new_node.prev = curr;

// Set the next of new node to next of curr
        new_node.next = curr.next;

// Update the next of current node to new node
       curr.next = new_node;

// If the new node is not the last node, update
                                             //prev of next node to new node
                                             if (new_node.next != null) {
                                             new_node.next.prev = new_node;
}

        // Return the head of the doubly linked list
        return head;
}

    // Function to print the linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 4
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(4);
        head.next.next.prev = head.next;

// Print the original list
        System.out.print("Original Linked List: ");
        printList(head);

// Insert new node with data 3 at position 3
        System.out.print("Inserting Node with data 3 at position 3: ");
int data = 3;
int pos = 3;
        head = insertAtPosition(head, pos, data);

// Print the updated list
        printList(head);
}
}

````

Python
````
# Python Program to insert a node at a given position

class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None
        self.prev = None

def insert_at_position(head, pos, new_data):

    # Create a new node
    new_node = Node(new_data)

    # Insertion at the beginning
    if pos == 1:
        new_node.next = head

        # If the linked list is not empty, set the
        #prev of head to new node
        if head is not None:
            head.prev = new_node

        # Set the new node as the head of the linked list
        head = new_node
        return head

    curr = head

    # Traverse the list to find the node before the
    #insertion point
    for _ in range(1, pos - 1):
        if curr is None:
            print("Position is out of bounds.")
            return head
        curr = curr.next

    # If the position is out of bounds
    if curr is None:
        print("Position is out of bounds.")
        return head

    # Set the prev of new node to curr
    new_node.prev = curr

    # Set the next of new node to next of curr
    new_node.next = curr.next

    # Update the next of current node to new node
                       curr.next = new_node

                       # If the new node is not the last node, update
                                                                   #prev of next node to new node
                                                                   if new_node.next is not None:
                                                                   new_node.next.prev = new_node

                                                                   return head

                                                                   def print_list(head):
                                                                   curr = head
                                                                   while curr is not None:
                                                                   print(curr.data, end=" ")
                                                                   curr = curr.next
                                                                   print()

                                                                   if __name__ == "__main__":

                                                                   # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 4
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(4)
    head.next.next.prev = head.next

    # Print the original list
    print("Original Linked List: ", end="")
    print_list(head)

    # Insert new node with data 3 at position 3
    print("Inserting Node with data 3 at position 3: ", end="")
    data = 3
    pos = 3
    head = insert_at_position(head, pos, data)

    # Print the updated list
    print_list(head)

````

C#
````
// C# Program to insert a node at a given position

using System;

class Node {
    public int Data;
public Node Next;
public Node Prev;

public Node(int data) {
        Data = data;
Next = null;
        Prev = null;
}
}

class GFG {

    // Function to insert a new node at a given position
    static Node InsertAtPosition(Node head, int pos, int newData) {

        // Create a new node
        Node newNode = new Node(newData);

// Insertion at the beginning
        if (pos == 1) {
            newNode.Next = head;
            if (head != null)
                head.Prev = newNode;
            head = newNode;
return head;
}

        Node curr = head;

// Traverse the list to find the node
      	 //before the insertion point
        for (int i = 1; i < pos - 1 && curr != null; ++i) {
            curr = curr.Next;
}

        // If the position is out of bounds
        if (curr == null) {
            Console.WriteLine("Position is out of bounds.");
return head;
}

        // Set the prev of new node to curr
        newNode.Prev = curr;

// Set the next of new node to the next of curr
        newNode.Next = curr.Next;

// Update the next of current node to new node
       curr.Next = newNode;

// If the new node is not the last node, update
                                             //prev of next node to new node
                                             if (newNode.Next != null)
                                             newNode.Next.Prev = newNode;

return head;
}

    // Function to print the list
    static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 4
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(4);
        head.Next.Next.Prev = head.Next;

// Print the original list
        Console.WriteLine("Original Linked List: ");
        PrintList(head);

// Insert new node with data 3 at position 3
        Console.WriteLine("Inserting Node with data 3 at position 3: ");
        head = InsertAtPosition(head, 3, 3);

// Print the updated list
        PrintList(head);
}
}

````

JavaScript
````
// Javascript Program to insert a node at a given position

class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
        this.prev = null;
}
}

// Function to insert a new node at a given position
function insertAtPosition(head, pos, newData) {

    // Create a new node
    let newNode = new Node(newData);

// Insertion at the beginning
    if (pos === 1) {
        newNode.next = head;
        if (head !== null) {
            head.prev = newNode;
}
        head = newNode;
return head;
}

    let curr = head;

// Traverse the list to find the node
    //before the insertion point
    for (let i = 1; i < pos - 1 && curr !== null; ++i) {
        curr = curr.next;
}

    // If the position is out of bounds
    if (curr === null) {
        console.log("Position is out of bounds.");
return head;
}

    // Set the prev of new node to curr
    newNode.prev = curr;

// Set the next of new node to the next of curr
    newNode.next = curr.next;

// Update the next of current node to new node
       curr.next = newNode;

// If the new node is not the last node,
    // update prev of next node to new node
           if (newNode.next !== null) {
           newNode.next.prev = newNode;
}

    return head;
}

// Function to print the list
function printList(head) {
    let curr = head;
    while (curr !== null) {
        console.log(curr.data + " ");
        curr = curr.next;
}
    console.log();
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 4
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(4);
head.next.next.prev = head.next;

// Print the original list
console.log("Original Linked List:");
printList(head);

// Insert new node with data 3 at position 3
console.log("Inserting Node with data 3 at position 3:");
head = insertAtPosition(head, 3, 3);

// Print the updated list
printList(head);

````





**Output**
```

Original Linked List: 1 2 4
Inserting Node with data 3 at position 3: 1 2 3 4

```

[Deletion at the Beginning of Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-beginning-removal-of-first-node-in-a-doubly-linked-list/)
-----------------------------------------------------------------------------------------------------------------------------------------------------

![Deletion-at-the-Beginning-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124112/Deletion-at-the-Beginning-of-Doubly-Linked-List.webp)

Deletion at the Beginning of Doubly Linked List


To delete a node at the beginning in doubly linked list, we can use the
following steps:

* Check if the list is empty, there is nothing to delete. Return.
* Store the head pointer in a variable, say ****temp****.
* Update the head of linked list to the node next to the current head, ****head = head->next****.
                                                                        * If the new head is not NULL, update the previous pointer of new head
                                                                                                           to NULL, ****head->prev = NULL****.

                                                                                                           Below is the implementation of the above approach:

                                                                                                           C++
                                                                                                           ````
                                                                                                           // C++ Program to delete a node from the
// beginning of Doubly Linked List

#include <bits/stdc++.h>
using namespace std;

struct Node{
    int data;
    Node *prev;
    Node *next;
    Node(int d) {
      	data = d;
      	prev = next = nullptr;
}
};

// Deletes the first node (head) of the list
// and returns the second node as new head
Node *delHead(Node *head) {

    // If empty, return
    if (head == nullptr)
        return nullptr;

// Store in temp for deletion later
    Node *temp = head;

// Move head to the next node
    head = head->next;

// Set prev of the new head
    if (head != nullptr)
        head->prev = nullptr;

// Free memory and return new head
    delete temp;
return head;
}

void printList(Node *head) {
    for (Node *curr = head; curr != nullptr; curr = curr->next)
        cout << curr->data << " ";
    cout << endl;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the beginning: ");
    head = delHead(head);

    printList(head);

return 0;
}

````

C
````
// C Program to delete a node from the
// beginning of Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node *prev;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int data) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
return newNode;
}

// Function to delete the first node (head) of the list
// and return the second node as the new head
struct Node *delHead(struct Node *head) {
    // If empty, return NULL
    if (head == NULL)
        return NULL;

// Store in temp for deletion later
    struct Node *temp = head;

// Move head to the next node
    head = head->next;

// Set prev of the new head
    if (head != NULL)
        head->prev = NULL;

// Free memory and return new head
    free(temp);
return head;
}

void printList(struct Node *head) {
    struct Node *curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
}
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the beginning: ");
    head = delHead(head);

    printList(head);

return 0;
}

````

Java
````
// Java Program to delete a node from the
// beginning of Doubly Linked List

class Node {
    int data;
    Node prev;
    Node next;

    Node(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

class GFG {

    // Function to delete the first node (head) of the list
    // and return the second node as the new head
    public static Node delHead(Node head) {
        // If empty, return null
        if (head == null) {
            return null;
}

        // Store in temp for deletion later
        Node temp = head;

// Move head to the next node
        head = head.next;

// Set prev of the new head
        if (head != null) {
            head.prev = null;
}

        // Return new head
        return head;
}

    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

        System.out.print("Original Linked List: ");
        printList(head);

        System.out.print("After Deletion at the beginning: ");
        head = delHead(head);

        printList(head);
}
}

````

Python
````
# Python Program to delete a node from the
# beginning of Doubly Linked List

class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Function to delete the first node (head) of the list
# and return the second node as the new head
def del_head(head):

    # If empty, return None
    if head is None:
        return None

    # Store in temp for deletion later
    temp = head

    # Move head to the next node
    head = head.next

    # Set prev of the new head
    if head is not None:
        head.prev = None

    # Return new head
    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()


if __name__ == "__main__":

	# Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    print("Original Linked List: ", end="")
    print_list(head)

    print("After Deletion at the beginning: ", end="")
    head = del_head(head)

    print_list(head)

````

C#
````
// C# Program to delete a node from the
// beginning of Doubly Linked List

using System;

class Node {
    public int Data;
public Node Prev;
public Node Next;

public Node(int data) {
        Data = data;
        Prev = null;
Next = null;
}
}

class GFG {

    // Deletes the first node (head) of the list
    // and returns the second node as the new head
    public static Node DelHead(Node head) {

        // If empty, return null
        if (head == null)
            return null;

// Move head to the next node
        head = head.Next;

// Set prev of the new head
        if (head != null)
            head.Prev = null;

// Return new head
        return head;
}

    public static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

        Console.Write("Original Linked List: ");
        PrintList(head);

        Console.Write("After Deletion at the beginning: ");
        head = DelHead(head);

        PrintList(head);
}
}

````

JavaScript
````
// JavaScript Program to delete a node from the
// beginning of Doubly Linked List
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Deletes the first node (head) of the list and returns the second node as the new head
function delHead(head) {
    // If empty, return null
    if (head === null) {
        return null;
}

    // Store in temp for deletion later
    let temp = head;

// Move head to the next node
    head = head.next;

// Set prev of the new head
    if (head !== null) {
        head.prev = null;
}

    // Return new head
    return head;
}

// Function to print the list
function printList(head) {
    let curr = head;
    let output = \'\';
    while (curr !== null) {
        output += curr.data + \' \';
        curr = curr.next;
}
    console.log(output.trim());
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

console.log("Original Linked List: ");
printList(head);

console.log("After Deletion at the beginning: ");
head = delHead(head);

printList(head);

````



**Output**
```

Original Linked List: 1 2 3
After Deletion at the beginning: 2 3

```

[Deletion at the End of Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-end-removal-of-last-node-in-a-doubly-linked-list/)
----------------------------------------------------------------------------------------------------------------------------------------

![Deletion-at-the-End-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124140/Deletion-at-the-End-in-Doubly-Linked-List.webp)

Deletion at the End in Doubly Linked List


To delete a node at the end in doubly linked list, we can use the
following steps:

* Check if the doubly linked list is empty. If it is empty, then there
  is nothing to delete.
* If the list is not empty, then move to the last node of the doubly
  linked list, say ****curr****.
* Update the second-to-last node\'s next pointer to NULL, ****curr->prev->next = NULL****.
* Free the memory allocated for the node that was deleted.

Below is the implementation of the above approach:

C++
````
// C++ Program to delete a node from the end of
//Doubly Linked List

#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node *prev;
    Node *next;
    Node(int d) {
        data = d;
        prev = NULL;
        next = NULL;
    }
};

// Function to delete the last node of the doubly
// linked list
Node *delLast(Node *head) {

    // Corner cases
    if (head == NULL)
        return NULL;
    if (head->next == NULL) {
        delete head;
        return NULL;
    }

    // Traverse to the last node
    Node *curr = head;
    while (curr->next != NULL)
        curr = curr->next;

    // Update the previous node\'s next pointer
                                                                                         curr->prev->next = NULL;

// Delete the last node
    delete curr;

// Return the updated head
    return head;
}

void printList(Node *head) {
    Node *curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
}
    cout << endl;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the end: ");
    head = delLast(head);

    printList(head);

return 0;
}

````

C
````
// C Program to delete a node from the end of
//Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

// Function to delete the last node of the
//doubly linked list
struct Node* delLast(struct Node *head) {

    // Corner cases
    if (head == NULL)
        return NULL;
    if (head->next == NULL) {
        free(head);
return NULL;
}

    // Traverse to the last node
    struct Node *curr = head;
    while (curr->next != NULL)
        curr = curr->next;

// Update the previous node\'s next pointer
    curr->prev->next = NULL;

    // Delete the last node
    free(curr);

    // Return the updated head
    return head;
}

// Function to print the list
void printList(struct Node *head) {
    struct Node *curr = head;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }
    printf("\\n");
}

// Function to create a new node
struct Node* createNode(int data) {
    struct Node *newNode =
      (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;

    printf("Original Linked List: ");
    printList(head);

    printf("After Deletion at the end: ");
    head = delLast(head);

    printList(head);

    return 0;
}

````

Java
````
// Java Program to delete a node from the end of
//Doubly Linked List

class Node {
    int data;
    Node prev;
    Node next;

    Node(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}

class GFG {

    // Function to delete the last node of the
  	//doubly linked list
    public static Node delLast(Node head) {

        // Corner cases
        if (head == null) {
            return null;
        }
        if (head.next == null) {
            return null;
        }

        // Traverse to the last node
        Node curr = head;
        while (curr.next != null) {
            curr = curr.next;
        }

        // Update the previous node\'s next pointer
       if (curr.prev != null) {
       curr.prev.next = null;
}

        // Return the updated head
        return head;
}

    // Function to print the list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
}
        System.out.println();
}

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

        System.out.print("Original Linked List: ");
        printList(head);

        System.out.print("After Deletion at the end: ");
        head = delLast(head);

        printList(head);
}
}

````

Python
````
# Python Program to delete a node from the end of
#Doubly Linked List

class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

def del_last(head):

    # Corner cases
    if head is None:
        return None
    if head.next is None:
        return None

    # Traverse to the last node
    curr = head
    while curr.next is not None:
        curr = curr.next

    # Update the previous node\'s next pointer
    if curr.prev is not None:
        curr.prev.next = None

    # Return the updated head
    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    print("Original Linked List: ", end="")
    print_list(head)

    print("After Deletion at the end: ", end="")
    head = del_last(head)

    print_list(head)

````

C#
````
// C# Program to delete a node from the end of
//Doubly Linked List

using System;

class Node {
    public int Data;
    public Node Prev;
    public Node Next;

    public Node(int data) {
        Data = data;
        Prev = null;
        Next = null;
    }
}

class GFG {

    // Function to delete the last node of the
  	//doubly linked list
    static Node DelLast(Node head) {

      	// Corner cases
        if (head == null)
            return null;
        if (head.Next == null) {
            return null;
        }

        // Traverse to the last node
        Node curr = head;
        while (curr.Next != null)
            curr = curr.Next;

        // Update the previous node\'s next pointer
                                     if (curr.Prev != null)
                                     curr.Prev.Next = null;

// Delete the last node
        curr = null;

// Return the updated head
        return head;
}

    // Function to print the list
    static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
}
        Console.WriteLine();
}

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

        Console.Write("Original Linked List: ");
        PrintList(head);

        Console.Write("After Deletion at the end: ");
        head = DelLast(head);

        PrintList(head);
}
}

````

JavaScript
````
class Node {
    constructor(data) {
        this.data = data;
        this.prev = null;
        this.next = null;
}
}

// Function to delete the last node of the
//doubly linked list
function delLast(head) {
    // Corner cases
    if (head === null) return null;
    if (head.next === null) {
        // Only one node in the list
        return null;
}

    // Traverse to the last node
    let curr = head;
    while (curr.next !== null) {
        curr = curr.next;
}

    // Update the previous node\'s next pointer
    if (curr.prev !== null) {
        curr.prev.next = null;
    }

    // Node curr is now deleted (garbage collected in JS)
    return head;
}

// Function to print the list
function printList(head) {
    let curr = head;
    while (curr !== null) {
        console.log(curr.data + " ");
        curr = curr.next;
    }
}

// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

console.log("Original Linked List:");
printList(head);

console.log("After Deletion at the end:");
head = delLast(head);

printList(head);

````




**Output**
```

Original Linked List: 1 2 3
After Deletion at the end: 1 2

```

[Deletion at a Specific Position in Doubly Linked List](https://www.geeksforgeeks.org/delete-doubly-linked-list-node-given-position)
------------------------------------------------------------------------------------------------------------------------------------

![Deletion-at-a-Specific-Position-in-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124205/Deletion-at-a-Specific-Position-in-Doubly-Linked-List.webp)


Deletion at a Specific Position in Doubly Linked List



To delete a node at a specific position in doubly linked list, we can
use the following steps:

* Traverse to the node at the specified position, say ****curr****.
* If the position is valid, adjust the pointers to skip the node to be
  deleted.
  + If curr is not the head of the linked list, update the next
    pointer of the node before curr to point to the node after curr, ****curr->prev->next = curr-next****.
  + If curr is not the last node of the linked list, update the
    previous pointer of the node after curr to the node before curr, ****curr->next->prev = curr->prev****.
* Free the memory allocated for the deleted node.

Below is the implementation of the above approach:

C++
````
// C++ Program to delete node at a specific position
// in Doubly Linked List

#include <iostream>

using namespace std;

struct Node {
    int data;
    Node * prev;
    Node * next;
    Node(int d) {
        data = d;
        prev = next = NULL;
    }
};

// Function to delete a node at a specific position
// in the doubly linked list
Node * delPos(Node * head, int pos) {

    // If the list is empty
    if (!head)
        return head;

    Node * curr = head;

    // Traverse to the node at the given position
    for (int i = 1; curr && i < pos; ++i) {
        curr = curr -> next;
    }

    // If the position is out of range
    if (!curr)
        return head;

    // Update the previous node\'s next pointer
           if (curr -> prev)
           curr -> prev -> next = curr -> next;

// Update the next node\'s prev pointer
    if (curr -> next)
        curr -> next -> prev = curr -> prev;

    // If the node to be deleted is the head node
    if (head == curr)
        head = curr -> next;

    // Deallocate memory for the deleted node
    delete curr;
    return head;
}

// Function to print the doubly linked list
void printList(Node * head) {
    Node * curr = head;
    while (curr != nullptr) {
        cout << curr -> data << " ";
        curr = curr -> next;
    }
    cout << endl;
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node * head = new Node(1);
    head -> next = new Node(2);
    head -> next -> prev = head;
    head -> next -> next = new Node(3);
    head -> next -> next -> prev = head -> next;

    cout << "Original Linked List: ";
    printList(head);

    cout << "After Deletion at the position 2: ";
    head = delPos(head, 2);

    printList(head);

    return 0;
}

````

C
````
// C Program to delete node at a specific position
//in Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node * prev;
    struct Node * next;
};

struct Node * createNode(int data) {
    struct Node * newNode = (struct Node * )
    malloc(sizeof(struct Node));
    newNode -> data = data;
    newNode -> prev = NULL;
    newNode -> next = NULL;
    return newNode;
}

// Function to delete a node at a specific
//position in the doubly linked list
struct Node * delPos(struct Node * head, int pos) {

    // If the list is empty
    if (head == NULL)
        return head;

    struct Node * curr = head;

    // Traverse to the node at the given position
    for (int i = 1; curr && i < pos; ++i) {
        curr = curr -> next;
    }

    // If the position is out of range
    if (curr == NULL)
        return head;

    // Update the previous node\'s next pointer
       if (curr -> prev)
       curr -> prev -> next = curr -> next;

// Update the next node\'s prev pointer
    if (curr -> next)
        curr -> next -> prev = curr -> prev;

    // If the node to be deleted is the head node
    if (head == curr)
        head = curr -> next;

    // Deallocate memory for the deleted node
    free(curr);
    return head;
}

// Function to print the doubly linked list
void printList(struct Node * head) {
    struct Node * curr = head;
    while (curr != NULL) {
        printf("%d ", curr -> data);
        curr = curr -> next;
    }
    printf("\\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node * head = createNode(1);
    struct Node * temp1 = createNode(2);
    struct Node * temp2 = createNode(3);

    // Link the nodes together
    head -> next = temp1;
    temp1 -> prev = head;
    temp1 -> next = temp2;
    temp2 -> prev = temp1;

    printf("Original Linked List: ");
    printList(head);

    // Delete node at position 2
    head = delPos(head, 2);

    printf("After Deletion at position 2: ");
    printList(head);

    return 0;
}

````

Java
````
// Java Program to delete node at a specific position in Doubly Linked List

class Node {
    int data;
    Node prev;
    Node next;

    Node(int d) {
        data = d;
        prev = null;
        next = null;
    }
}

class GFG {

    // Function to delete a node at a
  	//specific position in the doubly linked list
    public static Node delPos(Node head, int pos) {

        // If the list is empty
        if (head == null) {
            return head;
        }

        Node curr = head;

        // Traverse to the node at the given position
        for (int i = 1; curr != null && i < pos; ++i) {
            curr = curr.next;
        }

        // If the position is out of range
        if (curr == null) {
            return head;
        }

        // Update the previous node\'s next pointer
       if (curr.prev != null) {
       curr.prev.next = curr.next;
}

        // Update the next node\'s prev pointer
        if (curr.next != null) {
            curr.next.prev = curr.prev;
        }

        // If the node to be deleted is the head node
        if (head == curr) {
            head = curr.next;
        }

        // Return the updated head
        return head;
    }

    // Function to print the doubly linked list
    public static void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;

        System.out.print("Original Linked List: ");
        printList(head);

        System.out.print("After Deletion at position 2: ");
        head = delPos(head, 2);

        printList(head);
    }
}

````

Python
````
# Python Program to delete node at a specific position
#in Doubly Linked List


class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None


# Function to delete a node at a specific position
#in the doubly linked list
def del_pos(head, pos):
    # If the list is empty
    if head is None:
        return head

    curr = head

    # Traverse to the node at the given position
    for i in range(1, pos):
        if curr is None:
            return head
        curr = curr.next

    # If the position is out of range
    if curr is None:
        return head

    # Update the previous node\'s next pointer
               if curr.prev is not None:
               curr.prev.next = curr.next

               # Update the next node\'s prev pointer
    if curr.next is not None:
        curr.next.prev = curr.prev

    # If the node to be deleted is the head node
    if head == curr:
        head = curr.next

    # Return the updated head
    return head


def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()


if __name__ == "__main__":

    # Create a hardcoded doubly linked list:
    # 1 <-> 2 <-> 3
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next

    print("Original Linked List: ", end="")
    print_list(head)

    print("After Deletion at the position 2: ", end="")
    head = del_pos(head, 2)

    print_list(head)

````

C#
````
// C# Program to delete node at a specific position
//in Doubly Linked List

using System;

class Node {
    public int Data;
    public Node Prev;
    public Node Next;

    public Node(int data) {
        Data = data;
        Prev = null;
        Next = null;
    }
}

class Program {
    // Function to delete a node at a specific position
    // in the doubly linked list
    static Node DelPos(Node head, int pos) {
        // If the list is empty
        if (head == null)
            return head;

        Node curr = head;

        // Traverse to the node at the given position
        for (int i = 1; curr != null && i < pos; ++i) {
            curr = curr.Next;
        }

        // If the position is out of range
        if (curr == null)
            return head;

        // Update the previous node\'s next pointer
                     if (curr.Prev != null)
                     curr.Prev.Next = curr.Next;

// Update the next node\'s prev pointer
        if (curr.Next != null)
            curr.Next.Prev = curr.Prev;

        // If the node to be deleted is the head node
        if (head == curr)
            head = curr.Next;

        // Deallocate memory for the deleted node
        // In C#, garbage collection will handle this
      	//automatically

        return head;
    }

    // Function to print the doubly linked list
    static void PrintList(Node head) {
        Node curr = head;
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.Next;
        }
        Console.WriteLine();
    }

    static void Main() {

        // Create a hardcoded doubly linked list:
        // 1 <-> 2 <-> 3
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Prev = head;
        head.Next.Next = new Node(3);
        head.Next.Next.Prev = head.Next;

        Console.Write("Original Linked List: ");
        PrintList(head);

        Console.Write("After Deletion at position 2: ");
        head = DelPos(head, 2);

        PrintList(head);
    }
}

````

JavaScript
````
class Node {
	constructor(data) {
		this.data = data;
		this.prev = null;
		this.next = null;
	}
}

// Function to delete a node at a specific position
// in the doubly linked list
function delPos(head, pos) {
	// If the list is empty
	if (head === null) return head;

	let curr = head;

	// Traverse to the node at the given position
	for (let i = 1; curr && i < pos; ++i) {
		curr = curr.next;
	}

	// If the position is out of range
	if (curr === null) return head;

	// Update the previous node\'s next pointer
       if (curr.prev) {
       curr.prev.next = curr.next;
}

	// Update the next node\'s prev pointer
	if (curr.next) {
		curr.next.prev = curr.prev;
	}

	// If the node to be deleted is the head node
	if (head === curr) {
		head = curr.next;
	}

	// Deallocate memory for the deleted node
	// In JavaScript, garbage collection handles
    //this automatically

	return head;
}

// Function to print the doubly linked list
function printList(head) {
	let curr = head;
	let result = [];
	while (curr !== null) {
		result.push(curr.data);
		curr = curr.next;
	}
	console.log(result.join(\' \'));
}


// Create a hardcoded doubly linked list:
// 1 <-> 2 <-> 3
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;

console.log("Original Linked List:");
printList(head);

console.log("After Deletion at the position 2:");
head = delPos(head, 2);

printList(head);

````


**Output**
```

Original Linked List: 1 2 3
After Deletion at the position 2: 1 3

```

Advantages of Doubly Linked List
--------------------------------

* ****Efficient traversal in both directions:**** Doubly linked lists allow for efficient traversal of the list in both
  directions, making it suitable for applications where frequent
  insertions and deletions are required.
* ****Easy insertion and deletion of nodes:**** The presence of pointers to both the previous and next nodes makes it
  easy to insert or delete nodes from the list, without having to
  traverse the entire list.
* ****Can be used to implement a stack or queue:**** Doubly linked lists can be used to implement both stacks and queues,
  which are common data structures used in programming.

Disadvantages of Doubly Linked List
-----------------------------------

* ****More complex than singly linked lists:****
  Doubly linked lists are more complex than singly linked lists, as they
  require additional pointers for each node.
* ****More memory overhead:**** Doubly linked lists require more memory overhead than singly linked
  lists, as each node stores two pointers instead of one.', 'A doubly linked list is a more complex data structure than a singly linked list, but it offers several advantages. The main advantage of a doubly linked list is that it allows for efficient traversal of the list in both directions. This is because each node in the list contains a pointer to the previous node and a pointer to the next node. This allows for quick and easy insertion and deletion of nodes from the list, as well as efficient traversal of the list in both directions.', 'Doubly Linked List Tutorial', 2, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('4cd8171b-fbfb-4ac2-bd58-4d59d056750d', e'What is a Circular Linked List?
-------------------------------


A

****circular linked list****
is a special type of linked list where all the nodes are connected to form a circle. Unlike a regular linked list, which ends with a node pointing to

****NULL****
, the last node in a circular linked list points back to the first node. This means that you can keep traversing the list without ever reaching a

****NULL****
value.


Types of Circular Linked Lists
------------------------------


We can create a circular linked list from both

[singly linked lists](https://www.geeksforgeeks.org/introduction-to-singly-linked-list/)
and

[doubly linked lists](https://www.geeksforgeeks.org/doubly-linked-list-tutorial-2/)
. So, circular linked list are basically of two types:


### 1. Circular Singly Linked List


In

****Circular Singly Linked List****
, each node has just one pointer called the “

****next****
” pointer. The next pointer of

****last node****
points back to the

****first node****
and this results in forming a circle. In this type of Linked list we can only move through the list in one direction.


![Representation-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806130914/Representation-of-circular-linked-list.webp)

Representation of Circular Singly Linked List

### 2. Circular Doubly Linked List:


In

****circular doubly linked****

****list,****
each node has two pointers

****prev****
and

****next,****
similar to doubly linked list. The

****prev****
pointer points to the previous node and the

****next****
points to the next node. Here, in addition to the

****last****
node storing the address of the first node, the

****first node****
will also store the address of the

****last node****
.


![Representation-of-circular-doubly-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145223/Representation-of-circular-doubly-linked-list.webp)

Representation of Circular Doubly Linked List

****Note:****
In this article, we will use the circular singly linked list to explain the working of circular linked lists.


Representation of a Circular Singly Linked List
-----------------------------------------------


Let’s take a look on the structure of a circular linked list.




![Node-structure-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145414/Node-structure-of-circular-linked-list.webp)

Representation of a Circular Singly Linked List

### Create/Declare a Node of Circular Linked List


Syntax to Declare a Circular Linked List in Different Languages:



C++

````
// Node structure
struct Node {
    int data;
    Node* next;

    Node(int value){
        data = value;
        next = nullptr;
    }
};

````

C

````
// Node structure
struct Node
{
    int data;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value){

    // Allocate memory
    struct Node *newNode =
      (struct Node *)malloc(sizeof(struct Node));

    // Set the data
    newNode->data = value;

    // Initialize next to NULL
    newNode->next = NULL;

    // Return the new node
    return newNode;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int data)
    {
        this.data = data;
        this.next = null;
    }
}

````

Python

````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

````

C#

````
public class Node {
    public int data;
    public Node next;

    public Node(int data){
        this.data = data;
        this.next = null;
    }
}

````

JavaScript

````
class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
    }
}

````


In the code above, each node has

****data****
and a

****pointer****
to the next node. When we create multiple nodes for a circular linked list, we only need to connect the last node back to the first one.


Example of Creating a Circular Linked List
------------------------------------------


Here’s an example of creating a circular linked list with three nodes (2, 3, 4):


![Circular-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240806111438/Circular-Linked-List.png)

Created a circular linked list with 3 nodes


C++

````
// Initilize and allocate memory for nodes
first = new Node(2);
second = new Node(3);
last = new Node(4);

// Connect nodes
first->next = second;
second->next = last;

// Connect last node to first node
last->next = first;

````

C

````
// Allocate memory for nodes
struct Node *first =
  (struct Node *)malloc(sizeof(struct Node));
struct Node *second =
  (struct Node *)malloc(sizeof(struct Node));
struct Node *last =
  (struct Node *)malloc(sizeof(struct Node));

// Initilize nodes
first->data = 2;
second->data = 3;
last->data = 4;

// Connect nodes
first->next = second;
second->next = last;
last->next = first;

````

Java

````
// Initilize and allocate memory for nodes
Node first = new Node(2);
Node second = new Node(3);
Node last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

````

Python

````
# Initilize and allocate memory for nodes
first = Node(2)
second = Node(3)
last = Node(4)

# Connect nodes
first.next = second
second.next = last
last.next = first

````

C#

````
// Initilize and allocate memory for nodes
Node first = new Node(2);
Node second = new Node(3);
Node last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

````

JavaScript

````
// Initilize and allocate memory for nodes
let first = new Node(2);
let second = new Node(3);
let last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

````



In the above code, we have created three nodes

****first, second,****
and

****last****
having values

****2, 3,****
and

****4****
respectively.


* After creating three nodes, we have connected these node in a series.
* Connect the first node “

  ****first”****
  to “

  ****second”****
  node by

  ****s****
  toring the address of “

  ****second”****
  node


  into

  ****first’s****
  next
* Connect the second node “

  ****second”****
  to “

  ****second”****
  node by

  ****s****
  toring the address of “

  ****third****
  ” node into

  ****second’s****
  next
* After connecting all the nodes, we reach the key characteristic of a circular linked list:

  linking the last node back to the first node


  . Therefore, we store the address of the “

  ****first****
  ” node in the “

  ****last****
  ” node.

### Why have we taken a pointer that points to the last node instead of the first node?


For the insertion of a node at the beginning, we need to traverse the whole list. Also, for insertion at the end, the whole list has to be traversed. If instead of the start pointer, we take a pointer to the last node, then in both cases there won’t be any need to traverse the whole list. So insertion at the beginning or at the end takes constant time, irrespective of the length of the list.


Operations on the Circular Linked list:
---------------------------------------


We can do some operations on the circular linked list similar to the singly and doubly linked list which are:


* ****Insertion****
  + Insertion at the empty list
  + Insertion at the beginning
  + Insertion at the end
  + Insertion at the given position
* ****Deletion****
  + Delete the first node
  + Delete the last node
  + Delete the node from any position
* ****Searching****

****Note:****
We will be using the circular singly linked list to represent the working of the circular linked list.


[Insertion in the circular linked list:](https://www.geeksforgeeks.org/circular-singly-linked-list-insertion/)
--------------------------------------------------------------------------------------------------------------


Insertion is a fundamental operation in linked lists that involves adding a new node to the list. The only extra step is connecting the last node to the first one. In the circular linked list mentioned below, we can insert nodes in four ways:


### 1. Insertion in an empty List in the circular linked list

> To insert a node in empty circular linked list, creates a
>
> ****new node****
> with the given data, sets its next pointer to point to itself, and updates the
>
> ****last****
> pointer to reference this
>
> ****new node****
> .

![Insertion-in-an-empty-list-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806193408/Insertion-in-an-empty-list-in-circular-linked-list.webp)

Insertion in an empty List


C++

````
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *next;
    Node(int value){
        data = value;
        next = nullptr;
    }
};

// Function to insert a node into an empty circular singly linked list
Node *insertInEmptyList(Node *last, int data){
    if (last != nullptr) return last;

    // Create a new node
    Node *newNode = new Node(data);

    // Point newNode to itself
    newNode->next = newNode;

    // Update last to point to the new node
    last = newNode;
    return last;
}

void printList(Node* last){
    if(last == NULL) return;

    // Start from the head node
    Node* head = last->next;
    while (true) {
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main(){
    Node *last = nullptr;

    // Insert a node into the empty list
    last = insertInEmptyList(last, 1);

    // Print the list
    cout << "List after insertion: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* createNode(int value);

// Function to insert a node into an empty
// circular singly linked list
struct Node* insertInEmptyList(struct Node* last, int data) {
    if (last != NULL) return last;

    // Create a new node
    struct Node* newNode = createNode(data);

    // Update last to point to the new node
    last = newNode;
    return last;
}

void printList(struct Node* last) {
    if (last == NULL) return;

    // Start from the head node
    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = newNode;
    return newNode;
}

int main() {
    struct Node* last = NULL;

    // Insert a node into the empty list
    last = insertInEmptyList(last, 1);

    // Print the list
    printf("List after insertion: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value) {
        data = value;
        next = null;
    }
}

public class Main {
    // Function to insert a node into an empty
    // circular singly linked list
    static Node insertInEmptyList(Node last, int data) {
        if (last != null) return last;

        // Create a new node
        Node newNode = new Node(data);

        // Point newNode to itself
        newNode.next = newNode;

        // Update last to point to the new node
        last = newNode;
        return last;
    }

    // Function to print the list
    static void printList(Node last) {
        if (last == null) return;

        // Start from the head node
        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Node last = null;

        // Insert a node into the empty list
        last = insertInEmptyList(last, 1);

        // Print the list
        System.out.print("List after insertion: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = self  # Point to itself

def insertInEmptyList(last, data):
    if last is not None:
        return last

    # Create a new node
    new_node = Node(data)

    # Update last to point to the new node
    last = new_node
    return last

def printList(last):
    if last is None:
        return

    # Start from the head node
    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

if __name__ == "__main__":
    last = None

    # Insert a node into the empty list
    last = insertInEmptyList(last, 1)

    # Print the list
    print("List after insertion: ", end="")
    printList(last)

````

JavaScript

````
class Node {
    constructor(value)
    {
        this.data = value;
        this.next = null;
    }
}

function insertInEmptyList(last, data)
{
    if (last !== null)
        return last;

    // Create a new node
    let newNode = new Node(data);

    // Point newNode to itself
    newNode.next = newNode;

    // Update last to point to the new node
    last = newNode;
    return last;
}

function printList(last)
{
    if (last === null)
        return;

    // Start from the head node
    let head = last.next;
    while (true) {
        console.log(head.data);
        head = head.next;
        if (head === last.next)
            break;
    }
}

// Main function

let last = null;

// Insert a node into the empty list
last = insertInEmptyList(last, 1);

// Print the list
console.log("List after insertion:");
printList(last);

````




**Output**
```
List after insertion: 1

```
### 2. Insertion at the beginning in circular linked list

> To insert a new node at the beginning of a circular linked list, we first create the
>
> ****new node****
> and allocate memory for it. If the list is empty (indicated by the last pointer being
>
> ****NULL****
> ), we make the
>
> ****new node****
> point to itself. If the list already contains nodes then we set the
>
> ****new node’s****
> next pointer to point to the
>
> ****current head****
> of the list (which is
>
> ****last->next****
> ), and then update the last node’s next pointer to point to the
>
> ****new node****
> . This maintains the circular structure of the list.

![Insertion-at-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150314/Insertion-at-the-beginning-of-circular-linked-list.webp)

Insertion at the beginning in circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;

    Node(int value)
    {
        data = value;
        next = nullptr;
    }
};

// Function to insert a node at the beginning of the
// circular linked list
Node* insertAtBeginning(Node* last, int value){
    // Allocate memory for the new node and set its data
    Node* newNode = new Node(value);

    // If the list is empty, make the new node point to
    // itself and set it as last
    if (last == nullptr) {
        newNode->next = newNode;
        return newNode;
    }

    // Insert the new node at the beginning
    newNode->next = last->next;
    last->next = newNode;

    return last;
}

void printList(Node* last){
  if(last == NULL) return;

    // Start from the head node
    Node* head = last->next;
    while (true) {
        cout << head->data << " ";
        head = head->next;
        if (head == last->next)
            break;
    }
    cout << endl;
}

int main(){

    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Insert 5 at the beginning
    last = insertAtBeginning(last, 5);

    cout << "List after inserting 5 at the beginning: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node
{
    int data;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value)
{
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the beginning
// of the circular linked list
struct Node *insertAtBeginning(struct Node *last, int value)
{
    struct Node *newNode = createNode(value);

    // If the list is empty, make the new node point to itself
    // and set it as last
    if (last == NULL)
    {
        newNode->next = newNode;
        return newNode;
    }

    // Insert the new node at the beginning
    newNode->next = last->next;
    last->next = newNode;

    return last;
}

void printList(struct Node *last)
{
    if (last == NULL) return;

    struct Node *head = last->next;
    while (1){
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next)
            break;
    }
    printf("\\n");
}

int main()
{
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);
    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Insert 5 at the beginning
    last = insertAtBeginning(last, 5);

    printf("List after inserting 5 at the beginning: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {

    // Function to insert a node at the beginning of the
    // circular linked list
    public static Node insertAtBeginning(Node last,
                                         int value){
        Node newNode = new Node(value);

        // If the list is empty, make the new node point to
        // itself and set it as last
        if (last == null) {
            newNode.next = newNode;
            return newNode;
        }

        // Insert the new node at the beginning
        newNode.next = last.next;
        last.next = newNode;

        return last;
    }

    // Function to print the circular linked list
    public static void printList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);
        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Insert 5 at the beginning
        last = insertAtBeginning(last, 5);

        System.out.print(
            "List after inserting 5 at the beginning: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Function to insert a node at the beginning of the circular linked list
def insert_at_beginning(last, value):
    new_node = Node(value)

    # If the list is empty, make the new node point to itself and set it as last
    if last is None:
        new_node.next = new_node
        return new_node

    # Insert the new node at the beginning
    new_node.next = last.next
    last.next = new_node

    return last

# Function to print the circular linked list
def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)
last = first.next.next
last.next = first

print("Original list: ", end="")
print_list(last)

# Insert 5 at the beginning
last = insert_at_beginning(last, 5)

print("List after inserting 5 at the beginning: ", end="")
print_list(last)

````

C#

````
using System;

public class Node
{
    public int data;
    public Node next;

    public Node(int value)
    {
        data = value;
        next = null;
    }
}

public class CircularLinkedList
{
    // Function to insert a node at the beginning of the circular linked list
    public static Node InsertAtBeginning(Node last, int value)
    {
        Node newNode = new Node(value);

        // If the list is empty, make the new node point to itself and set it as last
        if (last == null)
        {
            newNode.next = newNode;
            return newNode;
        }

        // Insert the new node at the beginning
        newNode.next = last.next;
        last.next = newNode;

        return last;
    }

    // Function to print the circular linked list
    public static void PrintList(Node last)
    {
        if (last == null)
            return;

        Node head = last.next;
        while (true)
        {
            Console.Write(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        Console.WriteLine();
    }

    public static void Main(string[] args)
    {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);
        Node last = first.next.next;
        last.next = first;

        Console.Write("Original list: ");
        PrintList(last);

        // Insert 5 at the beginning
        last = InsertAtBeginning(last, 5);

        Console.Write("List after inserting 5 at the beginning: ");
        PrintList(last);
    }
}

````

JavaScript

````
class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
    }
}

// Function to insert a node at the beginning of the
// circular linked list
function insertAtBeginning(last, value)
{
    const newNode = new Node(value);

    // If the list is empty, make the new node point to
    // itself and set it as last
    if (last === null) {
        newNode.next = newNode;
        return newNode;
    }

    // Insert the new node at the beginning
    newNode.next = last.next;
    last.next = newNode;

    return last;
}

// Function to print the circular linked list
function printList(last)
{
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
const first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);
let last
    = first.next.next; // Using let to allow reassignment
last.next = first;

console.log("Original list: ");
printList(last);

// Insert 5 at the beginning
last = insertAtBeginning(last, 5);

console.log("List after inserting 5 at the beginning: ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after inserting 5 at the beginning: 5 2 3 4

```
### 3. Insertion at the end in circular linked list

> To insert a new node at the end of a circular linked list, we first create the new node and allocate memory for it. If the list is empty (mean,
>
> ****last****
> or
>
> ****tail****
> pointer being
>
> ****NULL****
> ), we initialize the list with the
>
> ****new node****
> and making it point to itself to form a circular structure. If the list already contains nodes then we set the
>
> ****new node’s****
> next pointer to point to the
>
> ****current head****
> (which is
>
> ****tail->next****
> ), then update the
>
> ****current tail’s****
> next pointer to point to the
>
> ****new node****
> . Finally, we update the
>
> ****tail pointer****
> to the
>
> ****new node.****
> This will ensure that the
>
> ****new node****
> is now the
>
> ****last node****
> in the list while maintaining the circular linkage.

![Insertion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150353/Insertion-at-the-end-of-circular-linked-list.webp)

Insertion at the end in circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *next;
    Node(int value)
    {
        data = value;
        next = nullptr;
    }
};

// Function to insert a node at the end of a circular linked list
Node *insertEnd(Node *tail, int value)
{
    Node *newNode = new Node(value);
    if (tail == nullptr){
        // If the list is empty, initialize it with the new node
        tail = newNode;

        // Point to itself to form a circular structure
        newNode->next = newNode;
    }
    else{
        // Insert new node after the current tail
        // and update the tail pointer.
        // New node points to the head node
        newNode->next = tail->next;

        // Tail node points to the new node
        tail->next = newNode;

        // Update tail to be the new node
        tail = newNode;
    }
    return tail;
}

void printList(Node *last){
  if(last == NULL) return;

    // Start from the head node
    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next)
            break;
    }
    cout << endl;
}

int main(){
    // Create circular linked list: 2, 3, 4
    Node *first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node *last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Insert elements at the end of the circular linked list
    last = insertEnd(last, 5);
    last = insertEnd(last, 6);

    cout << "List after inserting 5 and 6: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node
{
    int data;
    struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value);

// Function to insert a node at the end of a circular linked list
struct Node *insertEnd(struct Node *tail, int value)
{
    struct Node *newNode = createNode(value);
    if (tail == NULL)
    {
        // If the list is empty, initialize it with the new node
        tail = newNode;
        newNode->next = newNode;
    }
    else
    {
        // Insert new node after the current tail and update the tail pointer
        newNode->next = tail->next;
        tail->next = newNode;
        tail = newNode;
    }
    return tail;
}

// Function to print the circular linked list
void printList(struct Node *last)
{
    if (last == NULL)
        return;

    struct Node *head = last->next;
    while (1)
    {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next)
            break;
    }
    printf("\\n");
}

struct Node *createNode(int value)
{
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main()
{
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Insert elements at the end of the circular linked list
    last = insertEnd(last, 5);
    last = insertEnd(last, 6);

    printf("List after inserting 5 and 6: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {

    // Function to insert a node at the end of a circular
    // linked list
    static Node insertEnd(Node tail, int value){
        Node newNode = new Node(value);
        if (tail == null) {
            // If the list is empty, initialize it with the
            // new node
            tail = newNode;
            newNode.next = newNode;
        }
        else {
            // Insert new node after the current tail and
            // update the tail pointer
            newNode.next = tail.next;
            tail.next = newNode;
            tail = newNode;
        }
        return tail;
    }

    // Function to print the circular linked list
    static void printList(Node last){
        if (last == null) return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Insert elements at the end of the circular linked
        // list
        last = insertEnd(last, 5);
        last = insertEnd(last, 6);

        System.out.print("List after inserting 5 and 6: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Function to insert a node at the end of a circular linked list


def insert_end(tail, value):
    new_node = Node(value)
    if tail is None:
        # If the list is empty, initialize
        # it with the new node
        tail = new_node
        new_node.next = new_node
    else:
        # Insert new node after the current tail
        # and update the tail pointer
        new_node.next = tail.next
        tail.next = new_node
        tail = new_node
    return tail

# Function to print the circular linked list


def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()


if __name__ == "__main__":
    # Create circular linked list: 2, 3, 4
    first = Node(2)
    first.next = Node(3)
    first.next.next = Node(4)

    last = first.next.next
    last.next = first

    print("Original list: ", end="")
    print_list(last)

    # Insert elements at the end of the circular linked list
    last = insert_end(last, 5)
    last = insert_end(last, 6)

    print("List after inserting 5 and 6: ", end="")
    print_list(last)

````

JavaScript

````
class Node {
    constructor(value){
        this.data = value;
        this.next = null;
    }
}

// Function to insert a node at the end of a circular linked
// list
function insertEnd(tail, value){
    let newNode = new Node(value);
    if (tail === null) {
        // If the list is empty, initialize it with the new
        // node
        tail = newNode;
        newNode.next = newNode;
    }
    else {
        // Insert new node after the current tail and update
        // the tail pointer
        newNode.next = tail.next;
        tail.next = newNode;
        tail = newNode;
    }
    return tail;
}

// Function to print the circular linked list
function printList(last)
{
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Insert elements at the end of the circular linked
// list
last = insertEnd(last, 5);
last = insertEnd(last, 6);

console.log("List after inserting 5 and 6: ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after inserting 5 and 6: 2 3 4 5 6

```
### 4. Insertion at specific position in circular linked list

> To insert a new node at a specific position in a circular linked list, we first check if the list is empty. If it is and the
>
> ****position****
> is not
>
> ****1****
> then we print an error message because the position doesn’t exist in the list. If the
>
> ****position****
> is
>
> ****1****
> then we create the
>
> ****new node****
> and make it point to itself. If the list is not empty, we create the
>
> ****new node****
> and traverse the list to find the correct insertion point. If the
>
> ****position****
> is
>
> ****1****
> , we insert the
>
> ****new node****
> at the beginning by adjusting the pointers accordingly. For other positions, we traverse through the list until we reach the desired position and inserting the
>
> ****new node****
> by updating the pointers. If the new node is inserted at the end, we also update the
>
> ****last****
> pointer to reference the new node, maintaining the circular structure of the list.

![Insertion-at-specific-position-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150431/Insertion-at-specific-position-of-circular-linked-list.webp)

Insertion at specific position in circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *next;
    Node(int value){
        data = value;
        next = nullptr;
    }
};

// Function to insert a node at a specific position in a circular linked list
Node *insertAtPosition(Node *last, int data, int pos){
    if (last == nullptr){
        // If the list is empty
        if (pos != 1){
            cout << "Invalid position!" << endl;
            return last;
        }
        // Create a new node and make it point to itself
        Node *newNode = new Node(data);
        last = newNode;
        last->next = last;
        return last;
    }

    // Create a new node with the given data
    Node *newNode = new Node(data);

    // curr will point to head initially
    Node *curr = last->next;

    if (pos == 1){
        // Insert at the beginning
        newNode->next = curr;
        last->next = newNode;
        return last;
    }

    // Traverse the list to find the insertion point
    for (int i = 1; i < pos - 1; ++i) {
        curr = curr->next;

        // If position is out of bounds
        if (curr == last->next){
            cout << "Invalid position!" << endl;
            return last;
        }
    }
    // Insert the new node at the desired position
    newNode->next = curr->next;
    curr->next = newNode;

    // Update last if the new node is inserted at the end
    if (curr == last) last = newNode;

    return last;
}

void printList(Node *last){
    if (last == NULL) return;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main(){
    // Create circular linked list: 2, 3, 4
    Node *first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node *last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Insert elements at specific positions
    int data = 5, pos = 2;
    last = insertAtPosition(last, data, pos);
    cout << "List after insertions: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the Node structure
struct Node {
    int data;
    struct Node *next;
};

struct Node* createNode(int value);

// Function to insert a node at a specific position in a circular linked list
struct Node* insertAtPosition(struct Node *last, int data, int pos) {
    if (last == NULL) {
        // If the list is empty
        if (pos != 1) {
            printf("Invalid position!\\n");
            return last;
        }
        // Create a new node and make it point to itself
        struct Node *newNode = createNode(data);
        last = newNode;
        last->next = last;
        return last;
    }

    // Create a new node with the given data
    struct Node *newNode = createNode(data);

    // curr will point to head initially
    struct Node *curr = last->next;

    if (pos == 1) {
        // Insert at the beginning
        newNode->next = curr;
        last->next = newNode;
        return last;
    }

    // Traverse the list to find the insertion point
    for (int i = 1; i < pos - 1; ++i) {
        curr = curr->next;

        // If position is out of bounds
        if (curr == last->next) {
            printf("Invalid position!\\n");
            return last;
        }
    }

    // Insert the new node at the desired position
    newNode->next = curr->next;
    curr->next = newNode;

    // Update last if the new node is inserted at the end
    if (curr == last) last = newNode;

    return last;
}

// Function to print the circular linked list
void printList(struct Node *last) {
    if (last == NULL) return;

    struct Node *head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Insert elements at specific positions
    int data = 5, pos = 2;
    last = insertAtPosition(last, data, pos);
    printf("List after insertions: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {

    // Function to insert a node at a specific position in a
    // circular linked list
    static Node insertAtPosition(Node last, int data,
                                 int pos){
        if (last == null) {
            // If the list is empty
            if (pos != 1) {
                System.out.println("Invalid position!");
                return last;
            }
            // Create a new node and make it point to itself
            Node newNode = new Node(data);
            last = newNode;
            last.next = last;
            return last;
        }

        // Create a new node with the given data
        Node newNode = new Node(data);

        // curr will point to head initially
        Node curr = last.next;

        if (pos == 1) {
            // Insert at the beginning
            newNode.next = curr;
            last.next = newNode;
            return last;
        }

        // Traverse the list to find the insertion point
        for (int i = 1; i < pos - 1; ++i) {
            curr = curr.next;

            // If position is out of bounds
            if (curr == last.next) {
                System.out.println("Invalid position!");
                return last;
            }
        }

        // Insert the new node at the desired position
        newNode.next = curr.next;
        curr.next = newNode;

        // Update last if the new node is inserted at the
        // end
        if (curr == last)
            last = newNode;

        return last;
    }

    static void printList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        System.out.println();
    }

    public static void main(String[] args)
    {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Insert elements at specific positions
        int data = 5, pos = 2;
        last = insertAtPosition(last, data, pos);
        System.out.print("List after insertions: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

# Function to insert a node at a specific position in a circular linked list
def insertAtPosition(last, data, pos):
    if last is None:
        # If the list is empty
        if pos != 1:
            print("Invalid position!")
            return last
        # Create a new node and make it point to itself
        new_node = Node(data)
        last = new_node
        last.next = last
        return last

    # Create a new node with the given data
    new_node = Node(data)

    # curr will point to head initially
    curr = last.next

    if pos == 1:
        # Insert at the beginning
        new_node.next = curr
        last.next = new_node
        return last

    # Traverse the list to find the insertion point
    for i in range(1, pos - 1):
        curr = curr.next

        # If position is out of bounds
        if curr == last.next:
            print("Invalid position!")
            return last

    # Insert the new node at the desired position
    new_node.next = curr.next
    curr.next = new_node

    # Update last if the new node is inserted at the end
    if curr == last:
        last = new_node

    return last

# Function to print the circular linked list
def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

if __name__ == "__main__":
    # Create circular linked list: 2, 3, 4
    first = Node(2)
    first.next = Node(3)
    first.next.next = Node(4)

    last = first.next.next
    last.next = first

    print("Original list: ", end="")
    print_list(last)

    # Insert elements at specific positions
    data = 5
    pos = 2
    last = insertAtPosition(last, data, pos)
    print("List after insertions: ", end="")
    print_list(last)

````

JavaScript

````
class Node {
    constructor(value){
        this.data = value;
        this.next = null;
    }
}

// Function to insert a node at a specific position in a
// circular linked list
function insertAtPosition(last, data, pos)
{
    if (last === null) {
        // If the list is empty
        if (pos !== 1) {
            console.log("Invalid position!");
            return last;
        }
        // Create a new node and make it point to itself
        let newNode = new Node(data);
        last = newNode;
        last.next = last;
        return last;
    }

    // Create a new node with the given data
    let newNode = new Node(data);

    // curr will point to head initially
    let curr = last.next;

    if (pos === 1) {
        // Insert at the beginning
        newNode.next = curr;
        last.next = newNode;
        return last;
    }

    // Traverse the list to find the insertion point
    for (let i = 1; i < pos - 1; ++i) {
        curr = curr.next;

        // If position is out of bounds
        if (curr === last.next) {
            console.log("Invalid position!");
            return last;
        }
    }

    // Insert the new node at the desired position
    newNode.next = curr.next;
    curr.next = newNode;

    // Update last if the new node is inserted at the end
    if (curr === last)
        last = newNode;

    return last;
}

// Function to print the circular linked list
function printList(last){
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Insert elements at specific positions
let data = 5;
let pos = 2;
last = insertAtPosition(last, data, pos);
console.log("List after insertions: ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after insertions: 2 5 3 4

```

[Deletion from a Circular Linked List](https://www.geeksforgeeks.org/deletion-circular-linked-list/?ref=ml_lbp)
---------------------------------------------------------------------------------------------------------------


Deletion involves removing a node from the linked list. The main difference is that we need to ensure the list remains circular after the deletion. We can delete a node in a circular linked list in three ways:


### 1. Delete the first node in circular linked list

> To delete the first node of a circular linked list, we first check if the list is empty. If it is then we print a message and return
>
> ****NULL****
> . If the list contains only one node (the
>
> ****head****
> is the same as the
>
> ****last****
> ) then we delete that node and set the
>
> ****last****
> pointer to
>
> ****NULL****
> . If there are multiple nodes then we update the
>
> ****last->next****
> pointer to skip the
>
> ****head****
> node and effectively removing it from the list. We then delete the
>
> ****head****
> node to free the allocated memory. Finally, we return the updated
>
> ****last****
> pointer, which still points to the
>
> ****last****
> node in the list.

![Deletion-from-the-beginning-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150500/Deletion-from-the-beginning-of-circular-linked-list.webp)

Delete the first node in circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to delete the first node of the circular linked list
Node* deleteFirstNode(Node* last) {
    if (last == nullptr) {
        // If the list is empty
        cout << "List is empty" << endl;
        return nullptr;
    }

    Node* head = last->next;

    if (head == last) {
        // If there is only one node in the list
        delete head;
        last = nullptr;
    } else {
        // More than one node in the list
        last->next = head->next;
        delete head;
    }

    return last;
}

void printList(Node* last) {
    if(last == NULL) return ;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Delete the first node
    last = deleteFirstNode(last);

    cout << "List after deleting first node: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

struct Node* deleteFirstNode(struct Node* last) {
    if (last == NULL) {
        // If the list is empty
        printf("List is empty\\n");
        return NULL;
    }

    struct Node* head = last->next;

    if (head == last) {
        // If there is only one node in the list
        free(head);
        last = NULL;
    } else {
        // More than one node in the list
        last->next = head->next;
        free(head);
    }

    return last;
}

void printList(struct Node* last) {
    if (last == NULL) return;

    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    struct Node* first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node* last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    last = deleteFirstNode(last);

    printf("List after deleting first node: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value) {
        data = value;
        next = null;
    }
}

public class GFG {
    public static Node deleteFirstNode(Node last) {
        if (last == null) {
            // If the list is empty
            System.out.println("List is empty");
            return null;
        }

        Node head = last.next;

        if (head == last) {
            // If there is only one node in the list
            last = null;
        } else {
            // More than one node in the list
            last.next = head.next;
        }

        return last;
    }

    public static void printList(Node last) {
        if (last == null) return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Delete the first node
        last = deleteFirstNode(last);

        System.out.print("List after deleting first node: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def deleteFirstNode(last):
    if last is None:
        # If the list is empty
        print("List is empty")
        return None

    head = last.next

    if head == last:
        # If there is only one node in the list
        last = None
    else:
        # More than one node in the list
        last.next = head.next

    return last

def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)

last = first.next.next
last.next = first

print("Original list: ", end="")
print_list(last)

# Delete the first node
last = deleteFirstNode(last)

print("List after deleting first node: ", end="")
print_list(last)

````

JavaScript

````
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function deleteFirstNode(last) {
    if (last === null) {
        // If the list is empty
        console.log("List is empty");
        return null;
    }

    let head = last.next;

    if (head === last) {
        // If there is only one node in the list
        last = null;
    } else {
        // More than one node in the list
        last.next = head.next;
    }

    return last;
}

function printList(last) {
    if (last === null) return;

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next) break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete the first node
last = deleteFirstNode(last);

console.log("List after deleting first node: ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after deleting first node: 3 4

```
### 2. Delete a specific node in circular linked list

> To delete a specific node from a circular linked list, we first check if the list is empty. If it is then we print a message and return
>
> ****nullptr****
> . If the list contains only one node and it matches the
>
> ****key****
> then we delete that node and set
>
> ****last****
> to
>
> ****nullptr****
> . If the node to be deleted is the first node then we update the
>
> ****next****
> pointer of the
>
> ****last****
> node to skip the
>
> ****head****
> node and delete the
>
> ****head****
> . For other nodes, we traverse the list using two pointers:
>
> ****curr****
> (to find the node) and
>
> ****prev****
> (to keep track of the previous node). If we find the node with the matching key then we update the next pointer of
>
> ****prev****
> to skip the
>
> ****curr****
> node and delete it. If the node is found and it is the last node, we update the
>
> ****last****
> pointer accordingly. If the node is not found then do nothing and
>
> ****tail****
> or
>
> ****last****
> as it is. Finally, we return the updated
>
> ****last****
> pointer.

![Delete-a-specific-node-in-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150531/Delete-a-specific-node-in-circular-linked-list.webp)

Delete a specific node in circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to delete a specific node in the circular linked list
Node* deleteSpecificNode(Node* last, int key) {
    if (last == nullptr) {
        // If the list is empty
        cout << "List is empty, nothing to delete." << endl;
        return nullptr;
    }

    Node* curr = last->next;
    Node* prev = last;

    // If the node to be deleted is the only node in the list
    if (curr == last && curr->data == key) {
        delete curr;
        last = nullptr;
        return last;
    }

    // If the node to be deleted is the first node
    if (curr->data == key) {
        last->next = curr->next;
        delete curr;
        return last;
    }

    // Traverse the list to find the node to be deleted
    while (curr != last && curr->data != key) {
        prev = curr;
        curr = curr->next;
    }

    // If the node to be deleted is found
    if (curr->data == key) {
        prev->next = curr->next;
        if (curr == last) {
            last = prev;
        }
        delete curr;
    } else {
        // If the node to be deleted is not found
        cout << "Node with data " << key
          << " not found." << endl;
    }

    return last;
}

// Function to print the circular linked list
void printList(Node* last) {
     if (last == NULL){
        cout << "List is Empty";
        return;
    }

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Delete a specific node
    int key = 3;
    last = deleteSpecificNode(last, key);

    cout << "List after deleting node " << key << ": ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node in the circular linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to delete a specific node in the circular linked list
struct Node* deleteSpecificNode(struct Node* last, int key) {
    if (last == NULL) {
        // If the list is empty
        printf("List is empty, nothing to delete.\\n");
        return NULL;
    }

    struct Node* curr = last->next;
    struct Node* prev = last;

    // If the node to be deleted is the only node in the list
    if (curr == last && curr->data == key) {
        free(curr);
        last = NULL;
        return last;
    }

    // If the node to be deleted is the first node
    if (curr->data == key) {
        last->next = curr->next;
        free(curr);
        return last;
    }

    // Traverse the list to find the node to be deleted
    while (curr != last && curr->data != key) {
        prev = curr;
        curr = curr->next;
    }

    // If the node to be deleted is found
    if (curr->data == key) {
        prev->next = curr->next;
        if (curr == last) {
            last = prev;
        }
        free(curr);
    } else {
        // If the node to be deleted is not found
        printf("Node with data %d not found.\\n", key);
    }

    return last;
}

void printList(struct Node* last) {
    if (last == NULL) {
        printf("List is Empty");
        return;
    }

    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    // Create circular linked list: 2, 3, 4
    struct Node* first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node* last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Delete a specific node
    int key = 3;
    last = deleteSpecificNode(last, key);

    printf("List after deleting node %d: ", key);
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;
    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {
    public static Node deleteSpecificNode(Node last,
                                          int key){
        if (last == null) {
            // If the list is empty
            System.out.println(
                "List is empty, nothing to delete.");
            return null;
        }
        Node curr = last.next;
        Node prev = last;

        // If the node to be deleted is the only node in the
        // list
        if (curr == last && curr.data == key) {
            last = null;
            return last;
        }

        // If the node to be deleted is the first node
        if (curr.data == key) {
            last.next = curr.next;
            return last;
        }

        // Traverse the list to find the node to be deleted
        while (curr != last && curr.data != key) {
            prev = curr;
            curr = curr.next;
        }

        // If the node to be deleted is found
        if (curr.data == key) {
            prev.next = curr.next;
            if (curr == last) {
                last = prev;
            }
        }
        else {
            // If the node to be deleted is not found
            System.out.println("Node with data " + key
                               + " not found.");
        }
        return last;
    }

    public static void printList(Node last){
        if (last == null) {
            System.out.println("List is Empty");
            return;
        }

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Delete a specific node
        int key = 3;
        last = deleteSpecificNode(last, key);

        System.out.print("List after deleting node " + key
                         + ": ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def deleteSpecificNode(last, key):
    if last is None:
        # If the list is empty
        print("List is empty, nothing to delete.")
        return None

    curr = last.next
    prev = last

    # If the node to be deleted is the only node in the list
    if curr == last and curr.data == key:
        last = None
        return last

    # If the node to be deleted is the first node
    if curr.data == key:
        last.next = curr.next
        return last

    # Traverse the list to find the node to be deleted
    while curr != last and curr.data != key:
        prev = curr
        curr = curr.next

    # If the node to be deleted is found
    if curr.data == key:
        prev.next = curr.next
        if curr == last:
            last = prev
    else:
        # If the node to be deleted is not found
        print(f"Node with data {key} not found.")

    return last

def printList(last):
    if last is None:
        print("List is Empty")
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)

last = first.next.next
last.next = first

print("Original list: ", end="")
printList(last)

# Delete a specific node
key = 3
last = deleteSpecificNode(last, key)

print(f"List after deleting node {key}: ", end="")
printList(last)

````

JavaScript

````
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function deleteSpecificNode(last, key) {
    if (last === null) {
        // If the list is empty
        console.log("List is empty, nothing to delete.");
        return null;
    }

    let curr = last.next;
    let prev = last;

    // If the node to be deleted is the only node in the list
    if (curr === last && curr.data === key) {
        last = null;
        return last;
    }

    // If the node to be deleted is the first node
    if (curr.data === key) {
        last.next = curr.next;
        return last;
    }

    // Traverse the list to find the node to be deleted
    while (curr !== last && curr.data !== key) {
        prev = curr;
        curr = curr.next;
    }

    // If the node to be deleted is found
    if (curr.data === key) {
        prev.next = curr.next;
        if (curr === last) {
            last = prev;
        }
    } else {
        // If the node to be deleted is not found
        console.log("Node with data " + key + " not found.");
    }

    return last;
}

function printList(last) {
    if (last === null) {
        console.log("List is Empty");
        return;
    }

    let head = last.next;
    while (true) {
        console.log(head.data + " ");
        head = head.next;
        if (head === last.next) break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete a specific node
let key = 3;
last = deleteSpecificNode(last, key);

console.log("List after deleting node " + key + ": ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after deleting node 3: 2 4

```
### 3. Deletion at the end of Circular linked list

> To delete the last node in a circular linked list, we first check if the list is empty. If it is, we print a message and return
>
> ****nullptr****
> . If the list contains only one node (where the
>
> ****head****
> is the same as the
>
> ****last****
> ), we delete that node and set
>
> ****last****
> to
>
> ****nullptr****
> . For lists with multiple nodes, we need to traverse the list to find the
>
> ****second last node****
> . We do this by starting from the
>
> ****head****
> and moving through the list until we reach the node whose next pointer points to
>
> ****last****
> . Once we find the
>
> ****second last****
> node then we update its next pointer to point back to the
>
> ****head,****
> this effectively removing the last node from the list. We then delete the last node to free up memory and return the updated
>
> ****last****
> pointer, which now points to the last node.

![Deletion-at-the-end-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806150601/Deletion-at-the-end-of-circular-linked-list.webp)

Deletion at the end of Circular linked list


C++

````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to delete the last node in the circular linked list
Node* deleteLastNode(Node* last) {
    if (last == nullptr) {
        // If the list is empty
        cout << "List is empty, nothing to delete." << endl;
        return nullptr;
    }
    Node* head = last->next;

    // If there is only one node in the list
    if (head == last) {
        delete last;
        last = nullptr;
        return last;
    }
    // Traverse the list to find the second last node
    Node* curr = head;
    while (curr->next != last) {
        curr = curr->next;
    }
    // Update the second last node\'s next pointer
    // to point to head
    curr->next = head;
    delete last;
    last = curr;

    return last;
}

void printList(Node* last) {
   if(last == NULL) return;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Delete the last node
    last = deleteLastNode(last);

    cout << "List after deleting last node: ";
    printList(last);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Define the structure for a node in the circular linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to delete the last node in the circular linked list
struct Node* deleteLastNode(struct Node* last) {
    if (last == NULL) {
        // If the list is empty
        printf("List is empty, nothing to delete.\\n");
        return NULL;
    }
    struct Node* head = last->next;

    // If there is only one node in the list
    if (head == last) {
        free(last);
        last = NULL;
        return last;
    }
    // Traverse the list to find the second last node
    struct Node* curr = head;
    while (curr->next != last) {
        curr = curr->next;
    }
    // Update the second last node\'s next pointer to point to head
    curr->next = head;
    free(last);
    last = curr;

    return last;
}

void printList(struct Node* last) {
    if (last == NULL) return;

    struct Node* head = last->next;
    while (1) {
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next) break;
    }
    printf("\\n");
}

struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

int main() {
    // Create circular linked list: 2, 3, 4
    struct Node* first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node* last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Delete the last node
    last = deleteLastNode(last);

    printf("List after deleting last node: ");
    printList(last);

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;

    Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {
    public static Node deleteLastNode(Node last){
        if (last == null) {
            // If the list is empty
            System.out.println(
                "List is empty, nothing to delete.");
            return null;
        }
        Node head = last.next;

        // If there is only one node in the list
        if (head == last) {
            last = null;
            return last;
        }
        // Traverse the list to find the second last node
        Node curr = head;
        while (curr.next != last) {
            curr = curr.next;
        }
        // Update the second last node\'s next pointer to
        // point to head
        curr.next = head;
        last = curr;

        return last;
    }

    public static void printList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        System.out.println();
    }

    public static void main(String[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Delete the last node
        last = deleteLastNode(last);

        System.out.print("List after deleting last node: ");
        printList(last);
    }
}

````

Python

````
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def deleteLastNode(last):
    if last is None:
        # If the list is empty
        print("List is empty, nothing to delete.")
        return None

    head = last.next

    # If there is only one node in the list
    if head == last:
        last = None
        return last

    # Traverse the list to find the second last node
    curr = head
    while curr.next != last:
        curr = curr.next

    # Update the second last node\'s next pointer to point to head
    curr.next = head
    last = curr

    return last

def printList(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

# Create circular linked list: 2, 3, 4
first = Node(2)
first.next = Node(3)
first.next.next = Node(4)

last = first.next.next
last.next = first

print("Original list: ", end="")
printList(last)

# Delete the last node
last = deleteLastNode(last)

print("List after deleting last node: ", end="")
printList(last)

````

C#

````
using System;

public class Node {
    public int data;
    public Node next;

    public Node(int value)
    {
        data = value;
        next = null;
    }
}

public class GFG {
    // Function to delete the last node in the circular
    // linked list
    public static Node deleteLastNode(Node last)
    {
        if (last == null) {
            // If the list is empty
            Console.WriteLine(
                "List is empty, nothing to delete.");
            return null;
        }
        Node head = last.next;

        // If there is only one node in the list
        if (head == last) {
            last = null;
            return last;
        }
        // Traverse the list to find the second last node
        Node curr = head;
        while (curr.next != last) {
            curr = curr.next;
        }
        // Update the second last node\'s next pointer
        // to point to head
        curr.next = head;
        last = curr;

        return last;
    }

    // Function to print the circular linked list
    public static void printList(Node last)
    {
        if (last == null) {
            Console.WriteLine("List is Empty");
            return;
        }

        Node head = last.next;
        while (true) {
            Console.Write(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        Console.WriteLine();
    }

    public static void Main(string[] args)
    {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        Console.Write("Original list: ");
        printList(last);

        // Delete the last node
        last = deleteLastNode(last);

        Console.Write("List after deleting last node: ");
        printList(last);
    }
}

````

JavaScript

````
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function deleteLastNode(last) {
    if (last === null) {
        // If the list is empty
        console.log("List is empty, nothing to delete.");
        return null;
    }
    let head = last.next;

    // If there is only one node in the list
    if (head === last) {
        last = null;
        return last;
    }
    // Traverse the list to find the second last node
    let curr = head;
    while (curr.next !== last) {
        curr = curr.next;
    }
    // Update the second last node\'s next pointer to point to head
    curr.next = head;
    last = curr;

    return last;
}

function printList(last) {
    if (last === null) return;

    let head = last.next;
    while (true) {
        process.stdout.write(head.data + " ");
        head = head.next;
        if (head === last.next) break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list: ");
printList(last);

// Delete the last node
last = deleteLastNode(last);

console.log("List after deleting last node: ");
printList(last);

````




**Output**
```
Original list: 2 3 4
List after deleting last node: 2 3

```

[Searching in Circular Linked list](https://www.geeksforgeeks.org/searching-in-circular-linked-list/?ref=ml_lbp)
----------------------------------------------------------------------------------------------------------------


Searching in a circular linked list is similar to searching in a regular linked list. We start at a given node and traverse the list until you either find the target value or return to the starting node. Since the list is circular, make sure to keep track of where you started to avoid an infinite loop.


> To search for a specific value in a circular linked list, we first check if the list is empty. If it is then we return
>
> ****false****
> . If the list contains nodes then we start from the
>
> ****head****
> node (which is the
>
> ****last->next****
> ) and traverse the list. We use a pointer
>
> ****curr****
> to iterate through the nodes until we reach back to the
>
> ****head****
> . During traversal, if we find a node whose
>
> ****data****
> matches the given
>
> ****key****
> then we return
>
> ****true****
> to indicating that the value was found. After the loop, we also check the last node to ensure we don’t miss it. If the
>
> ****key****
> is not found after traversing the entire list then we return
>
> ****false****
> .

C++

````
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// Function to search for a specific value in the
// circular linked list
bool search(Node* last, int key) {
    if (last == nullptr) {
        // If the list is empty
        return false;
    }

    Node* head = last->next;
    Node* curr = head;

    // Traverse the list to find the key
    while (curr != last) {
        if (curr->data == key) {
          // Key found
            return true;
        }
        curr = curr->next;
    }

    // Check the last node
    if (last->data == key) {
      // Key found
        return true;
    }
    // Key not found
    return false;
}

void printList(Node* last) {
   if(last == NULL) return;

    Node *head = last->next;
    while (true){
        cout << head->data << " ";
        head = head->next;
        if (head == last->next) break;
    }
    cout << endl;
}

int main() {
    // Create circular linked list: 2, 3, 4
    Node* first = new Node(2);
    first->next = new Node(3);
    first->next->next = new Node(4);

    Node* last = first->next->next;
    last->next = first;

    cout << "Original list: ";
    printList(last);

    // Search for a specific value
    int key = 3;
    bool found = search(last, key);
    if (found) {
        cout << "Value " << key << " found in the list." << endl;
    } else {
        cout << "Value " << key << " not found in the list." << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// Definition of the Node structure
struct Node{
    int data;
    struct Node *next;
};

// Function to search for a specific value in the circular linked list
int search(struct Node *last, int key){
    if (last == NULL){
        // If the list is empty
        return 0;
    }

    struct Node *head = last->next;
    struct Node *curr = head;

    // Traverse the list to find the key
    while (curr != last){
        if (curr->data == key){
            // Key found
            return 1;
        }
        curr = curr->next;
    }

    // Check the last node
    if (last->data == key){
        // Key found
        return 1;
    }
    // Key not found
    return 0;
}

// Function to print the circular linked list
void printList(struct Node *last){
    if (last == NULL) return;

    struct Node *head = last->next;
    while (1){
        printf("%d ", head->data);
        head = head->next;
        if (head == last->next)
            break;
    }
    printf("\\n");
}
// Function to create a new node
struct Node *createNode(int value){
    struct Node *temp = (struct Node *)malloc(sizeof(struct Node));
    temp->data = value;
    temp->next = NULL;
    return temp;
}

int main(){
    // Create circular linked list: 2, 3, 4
    struct Node *first = createNode(2);
    first->next = createNode(3);
    first->next->next = createNode(4);

    struct Node *last = first->next->next;
    last->next = first;

    printf("Original list: ");
    printList(last);

    // Search for a specific value
    int key = 3;
    int found = search(last, key);
    if (found){
        printf("Value %d found in the list.\\n", key);
    }
    else{
        printf("Value %d not found in the list.\\n", key);
    }

    return 0;
}

````

Java

````
class Node {
    int data;
    Node next;
    Node(int value) {
        data = value;
        next = null;
    }
}

public class CircularLinkedList {
    // Function to search for a specific value
    // in the circular linked list
    static boolean search(Node last, int key) {
        if (last == null) {
            // If the list is empty
            return false;
        }

        Node head = last.next;
        Node curr = head;

        // Traverse the list to find the key
        while (curr != last) {
            if (curr.data == key) {
                // Key found
                return true;
            }
            curr = curr.next;
        }

        // Check the last node
        if (last.data == key) {
            // Key found
            return true;
        }
        // Key not found
        return false;
    }

    static void printList(Node last) {
        if (last == null) return;

        Node head = last.next;
        while (true) {
            System.out.print(head.data + " ");
            head = head.next;
            if (head == last.next) break;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        System.out.print("Original list: ");
        printList(last);

        // Search for a specific value
        int key = 3;
        boolean found = search(last, key);
        if (found) {
            System.out.println("Value " + key
                               + " found in the list.");
        } else {
            System.out.println("Value " + key +
                               " not found in the list.");
        }
    }
}

````

Python

````
class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

def search(last, key):
    if last is None:
        # If the list is empty
        return False

    head = last.next
    curr = head

    # Traverse the list to find the key
    while curr != last:
        if curr.data == key:
            # Key found
            return True
        curr = curr.next

    # Check the last node
    if last.data == key:
        # Key found
        return True
    # Key not found
    return False

def print_list(last):
    if last is None:
        return

    head = last.next
    while True:
        print(head.data, end=" ")
        head = head.next
        if head == last.next:
            break
    print()

if __name__ == "__main__":
    # Create circular linked list: 2, 3, 4
    first = Node(2)
    first.next = Node(3)
    first.next.next = Node(4)

    last = first.next.next
    last.next = first

    print("Original list:", end=" ")
    print_list(last)

    # Search for a specific value
    key = 3
    found = search(last, key)
    if found:
        print(f"Value {key} found in the list.")
    else:
        print(f"Value {key} not found in the list.")

````

C#

````
using System;

public class Node {
    public int data;
    public Node next;
    public Node(int value){
        data = value;
        next = null;
    }
}

public class GFG {
    // Function to search for a specific value in the
    // circular linked list
    public static bool Search(Node last, int key){
        if (last == null) {
            // If the list is empty
            return false;
        }

        Node head = last.next;
        Node curr = head;

        // Traverse the list to find the key
        while (curr != last) {
            if (curr.data == key) {
                // Key found
                return true;
            }
            curr = curr.next;
        }

        // Check the last node
        if (last.data == key) {
            // Key found
            return true;
        }
        // Key not found
        return false;
    }

    public static void PrintList(Node last){
        if (last == null)
            return;

        Node head = last.next;
        while (true) {
            Console.Write(head.data + " ");
            head = head.next;
            if (head == last.next)
                break;
        }
        Console.WriteLine();
    }

    public static void Main(string[] args){
        // Create circular linked list: 2, 3, 4
        Node first = new Node(2);
        first.next = new Node(3);
        first.next.next = new Node(4);

        Node last = first.next.next;
        last.next = first;

        Console.Write("Original list: ");
        PrintList(last);

        // Search for a specific value
        int key = 3;
        bool found = Search(last, key);
        if (found) {
            Console.WriteLine("Value " + key
                              + " found in the list.");
        }
        else {
            Console.WriteLine("Value " + key
                              + " not found in the list.");
        }
    }
}

````

JavaScript

````
class Node {
    constructor(value){
        this.data = value;
        this.next = null;
    }
}

function search(last, key){
    if (last === null) {
        // If the list is empty
        return false;
    }

    let head = last.next;
    let curr = head;

    // Traverse the list to find the key
    while (curr !== last) {
        if (curr.data === key) {
            // Key found
            return true;
        }
        curr = curr.next;
    }

    // Check the last node
    if (last.data === key) {
        // Key found
        return true;
    }
    // Key not found
    return false;
}

function printList(last){
    if (last === null)
        return;

    let head = last.next;
    while (true) {
        process.stdout.write(head.data + " ");
        head = head.next;
        if (head === last.next)
            break;
    }
    console.log();
}

// Create circular linked list: 2, 3, 4
let first = new Node(2);
first.next = new Node(3);
first.next.next = new Node(4);

let last = first.next.next;
last.next = first;

console.log("Original list:");
printList(last);

// Search for a specific value
let key = 3;
let found = search(last, key);
if (found) {
    console.log(`Value ${key} found in the list.`);
}
else {
    console.log(`Value ${key} not found in the list.`);
}

````




**Output**
```
Original list: 2 3 4
Value 3 found in the list.

```

Advantages of Circular Linked Lists
-----------------------------------

* In circular linked list, the last node points to the first node. There are no null references, making traversal easier and reducing the chances of encountering null pointer exceptions.
* We can traverse the list from any node and return to it without needing to restart from the head, which is useful in applications requiring a circular iteration.
* Circular linked lists can easily implement circular queues, where the last element connects back to the first, allowing for efficient resource management.
* In a circular linked list, each node has a reference to the next node in the sequence. Although it doesn’t have a direct reference to the previous node like a doubly linked list, we can still find the previous node by traversing the list.

Disadvantages of Circular Linked Lists
--------------------------------------

* Circular linked lists are more complex to implement than singly linked lists.
* Traversing a circular linked list without a clear stopping condition can lead to infinite loops if not handled carefully.
* Debugging can be more challenging due to the circular nature, as traditional methods of traversing linked lists may not apply.

Applications of Circular Linked Lists
-------------------------------------

* It is used for time-sharing among different users, typically through a

  ****Round-Robin scheduling mechanism.****
* In multiplayer games, a circular linked list can be used to switch between players. After the last player’s turn, the list cycles back to the first player.
* Circular linked lists are often used in buffering applications, such as streaming data, where data is continuously produced and consumed.
* In media players, circular linked lists can manage playlists, this allowing users to loop through songs continuously.
* Browsers use circular linked lists to manage the cache. This allows you to navigate back through your browsing history efficiently by pressing the BACK button.
', 'A circular linked list is a data structure where the last node connects back to the first, forming a loop. This structure allows for continuous traversal without any interruptions. Circular linked lists are especially helpful for tasks like scheduling and managing playlists, this allowing for smooth navigation. In this tutorial, we’ll cover the basics of circular linked lists, how to work with them, their advantages and disadvantages, and their applications.', 'Introduction to Circular Linked List', 3, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('184c2a73-cbb4-45dd-9892-6ee6acc78a7b', e'Advantages of Linked Lists (or Most Common Use Cases):
------------------------------------------------------

* Linked Lists are mostly used because of their effective insertion and deletion.  We only need to change few pointers (or references) to insert (or delete) an item in the middle
* [Insertion and deletion](https://www.geeksforgeeks.org/insertion-deletion-stl-set-c/)
  at any point in a linked list take O(1) time. Whereas in an

  [array](https://www.geeksforgeeks.org/array-data-structure/)
  data structure, insertion / deletion in the middle takes O(n) time.
* This data structure is simple and can be also used to implement

  [a stack](https://www.geeksforgeeks.org/stack-data-structure/)
  ,

  [queues,](https://www.geeksforgeeks.org/queue-data-structure/)
  and other

  [abstract data structures](https://www.geeksforgeeks.org/abstract-data-types/)
  .
* Implementation of Queue and Deque data structures : Simple array implementation is not efficient at all. We must use circular array to efficiently implement which is complex. But with linked list, it is easy and straightforward. That is why most of the language libraries use Linked List internally to implement these data structures..
* Linked List might turn out to be more space efficient compare to arrays in cases where we cannot guess the number of elements in advance. In case of arrays, the whole memory for items is allocated together. Even with dynamic sized arrays like vector in C++ or list in Python or ArrayList in Java. the internal working involves de-allocation of whole memory and allocation of a bigger chunk when insertions happen beyond the current capacity.

Applications of Linked Lists:
-----------------------------

* Linked Lists can be used to implement stacks, queue, deque,

  [sparse matrices](https://www.geeksforgeeks.org/sparse-matrix-representation/)
  and adjacency list representation of graphs.
* [Dynamic memory allocation](https://www.geeksforgeeks.org/what-is-dynamic-memory-allocation/)
  in operating systems and compilers (linked list of free blocks).
* Manipulation of polynomials
* Arithmetic operations on long integers.
* In operating systems, they can be used in Memory management, process scheduling (for example circular linked list for round robin scheduling) and file system.
* Algorithms that need to frequently insert or delete items from large collections of data.
* LRU cache, which uses a doubly linked list to keep track of the most recently used items in a cache.

Applications of Linked Lists in real world:
-------------------------------------------

* The list of songs in the music player are linked to the previous and next songs.
* In a web browser, previous and next web page URLs can be linked through the previous and next buttons (Doubly Linked List)
* In image viewer, the previous and next images can be linked with the help of the previous and next buttons (Doubly Linked List)
* Circular Linked Lists can be used to implement things in round manner where we go to every element one by one.
* Linked List are preferred over arrays for implementations of Queue and Deque data structures because of fast deletions (or insertions) from the front of the linked lists.

Disadvantages of Linked Lists:
------------------------------


Linked lists are a popular data structure in computer science, but like any other data structure, they have certain disadvantages as well. Some of the key disadvantages of linked lists are:


* ****Slow Access Time:****
  Accessing elements in a linked list can be slow, as you need to traverse the linked list to find the element you are looking for, which is an O(n) operation. This makes linked lists a poor choice for situations where you need to access elements quickly.
* ****Pointers or References:****
  Linked lists use pointers or references to access the next node, which can make them more complex to understand and use compared to arrays. This complexity can make linked lists more difficult to debug and maintain.
* ****Higher overhead:****
  Linked lists have a higher overhead compared to arrays, as each node in a linked list requires extra memory to store the reference to the next node.
* ****Cache Inefficiency:****
  Linked lists are cache-inefficient because the memory is not contiguous. This means that when you traverse a linked list, you are not likely to get the data you need in the cache, leading to cache misses and slow performance.


In conclusion, linked lists are a powerful and flexible data structure, but they have certain disadvantages that need to be taken into consideration when deciding whether to use them or not. For example, if you need fast access time, arrays might be a better choice, but if you need to insert or delete elements frequently, linked lists might be the better choice.
', 'A Linked List is a linear data structure that is used to store a collection of data with the help of nodes. Please remember the following points before moving forward.', 'Applications, Advantages and Disadvantages of Linked List', 4, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('e6b3784f-3ef1-4b59-896b-06430bafe574', e'Given a Singly Linked List, the task is to find the Length of the Linked List.


****Examples:****


> ****Input:****
> LinkedList = 1->3->1->2->1
>
>
>
> ****Output:****
> 5
>
>
> ****Input:****
> LinkedList = 2->4->1->9->5->3->6
>
>
>
> ****Output:****
> 7

Iterative Approach to Find the Length of a Linked List:
-------------------------------------------------------

> The idea is similar to
>
> [traversal of Linked List](https://www.geeksforgeeks.org/traversal-of-singly-linked-list/)
> with an additional variable
>
>
> to count the number of nodes in the Linked List.


Following is the approach to find the length of the Linked List:


* Initialize count as 0.
* Initialize a node pointer, curr = head.
* Do following while curr is not NULL
  + curr = curr -> next
  + Increment count by 1.
* Return count.


Below is the implementation of the above approach:


C++

````
// Iterative C++ program to find length
// or count of nodes in a linked list

#include <bits/stdc++.h>
using namespace std;

// Link list node
class Node {
public:
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// Counts number of nodes in linked list
int countNodes(Node* head) {

    // Initialize count with 0
    int count = 0;

    // Initialize curr with head of Linked List
    Node* curr = head;

    // Traverse till we reach nullptr
    while (curr != nullptr) {

          // Increment count by 1
        count++;

          // Move pointer to next node
        curr = curr->next;
    }

      // Return the count of nodes
    return count;
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 1 -> 3 -> 1 -> 2 -> 1
    Node* head = new Node(1);
    head->next = new Node(3);
    head->next->next = new Node(1);
    head->next->next->next = new Node(2);
    head->next->next->next->next = new Node(1);

    // Function call to count the number of nodes
    cout << "Count of nodes is " << countNodes(head);
    return 0;
}

````

C

````
// Iterative C program to find length or count of nodes in a
// linked list

#include <stdio.h>
#include <stdlib.h>

// Link list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node =
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Counts number of nodes in linked list
int countNodes(struct Node* head) {
    // Initialize count with 0
    int count = 0;

    // Initialize curr with head of Linked List
    struct Node* curr = head;

    // Traverse till we reach NULL
    while (curr != NULL) {

        // Increment count by 1
        count++;

          // Move pointer to next node
        curr = curr->next;
    }

    // Return the count of nodes
    return count;
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 1 -> 3 -> 1 -> 2 -> 1
    struct Node* head = createNode(1);
    head->next = createNode(3);
    head->next->next = createNode(1);
    head->next->next->next = createNode(2);
    head->next->next->next->next = createNode(1);

    // Function call
    printf("Count of nodes is %d", countNodes(head));
    return 0;
}

````

Java

````
// Iterative Java program to count the number of
// nodes in a linked list

// Node class to define a linked list node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int newData) {
        data = newData;
        next = null;
    }
}

// Class to define methods related to the linked list
public class GFG {

    // Counts number of nodes in linked list
    public static int countNodes(Node head) {

        // Initialize count with 0
        int count = 0;

        // Initialize curr with head of Linked List
        Node curr = head;

        // Traverse till we reach null
        while (curr != null) {

            // Increment count by 1
            count++;

            // Move pointer to next node
            curr = curr.next;
        }
        // Return the count of nodes
        return count;
    }

    // Driver code
    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 3 -> 1 -> 2 -> 1
        Node head = new Node(1);
        head.next = new Node(3);
        head.next.next = new Node(1);
        head.next.next.next = new Node(2);
        head.next.next.next.next = new Node(1);

        // Function call to count the number of nodes
        System.out.println("Count of nodes is "
                           + countNodes(head));
    }
}

````

Python

````
# Iterative Python program to count the number of nodes
# in a linked list


class Node:
    def __init__(self, new_data):

        # Constructor to initialize a new node with data
        self.data = new_data
        self.next = None


def count_nodes(head):

    # Counts number of nodes in linked list
    # Initialize count with 0
    count = 0

    # Initialize curr with head of Linked List
    curr = head

    # Traverse till we reach None
    while curr is not None:
        # Increment count by 1
        count += 1

        # Move pointer to next node
        curr = curr.next

    # Return the count of nodes
    return count


# Driver code
if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 3 -> 1 -> 2 -> 1
    head = Node(1)
    head.next = Node(3)
    head.next.next = Node(1)
    head.next.next.next = Node(2)
    head.next.next.next.next = Node(1)

    # Function call to count the number of nodes
    print("Count of nodes is", count_nodes(head))

````

C#

````
// Iterative C# program to find length or count of nodes
// in a linked list

using System;

// Link list node
class Node {
    public int Data;
    public Node Next;

    // Constructor to initialize a new node with data
    public Node(int newData) {
        Data = newData;
        Next = null;
    }
}

class GFG {

    // Counts number of nodes in linked list
    static int CountNodes(Node head) {

          // Initialize count with 0
        int count = 0;

        // Initialize curr with head of Linked List
        Node curr = head;

        // Traverse till we reach null
        while (curr != null) {
            // Increment count by 1
            count++;

            // Move pointer to next node
            curr = curr.Next;
        }

        // Return the count of nodes
        return count;
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 3 -> 1 -> 2 -> 1
        Node head = new Node(1);
        head.Next = new Node(3);
        head.Next.Next = new Node(1);
        head.Next.Next.Next = new Node(2);
        head.Next.Next.Next.Next = new Node(1);

        // Function call to count the number of nodes
        Console.WriteLine("Count of nodes is "
                          + CountNodes(head));
    }
}

````

JavaScript

````
// Iterative JavaScript program to find length
// or count of nodes in a linked list

// Linked List Node
class Node {

    // Constructor to initialize a new node
    // with data
    constructor(newData) {
        this.data = newData;
        this.next = null;
    }
}

// Counts number of nodes in linked list
function countNodes(head) {
    // Initialize count with 0
    let count = 0;

    // Initialize curr with head of Linked List
    let curr = head;

    // Traverse till we reach null
    while (curr !== null) {

        // Increment count by 1
        count++;

        // Move pointer to next node
        curr = curr.next;
    }

    // Return the count of nodes
    return count;
}

// Driver code

// Create a hard-coded linked list:
// 1 -> 3 -> 1 -> 2 -> 1
let head = new Node(1);
head.next = new Node(3);
head.next.next = new Node(1);
head.next.next.next = new Node(2);
head.next.next.next.next = new Node(1);

// Function call to count the number of nodes
console.log("Count of nodes is " + countNodes(head));

````




**Output**
```
Count of nodes is 5
```

****Time complexity:****
O(N), Where

****N****
is the size of the linked list



****Auxiliary Space:****
O(1), As constant extra space is used.


Recursive Approach to Find the Length of a Linked List:
-------------------------------------------------------

> The idea is to use
>
> [recursion](https://www.geeksforgeeks.org/introduction-to-recursion-data-structure-and-algorithm-tutorials/)
> by maintaining a function, say
>
> ****countNodes(node)****
> which takes a node as an argument and calls itself with the next node until we reach the end of the Linked List. Each of the recursive call returns
>
> ****1 + count of remaining nodes****
> .


Below is the implementation of the above approach:


C++

````
// Recursive C++ program to find length
// or count of nodes in a linked list

#include <bits/stdc++.h>
using namespace std;

// Link list node
class Node {
public:
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// Recursively count number of nodes in linked list
int countNodes(Node* head) {

    // Base Case
    if (head == NULL) {
        return 0;
    }

    // Count this node plus the rest of the list
    return 1 + countNodes(head->next);
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 1 -> 3 -> 1 -> 2 -> 1
    Node* head = new Node(1);
    head->next = new Node(3);
    head->next->next = new Node(1);
    head->next->next->next = new Node(2);
    head->next->next->next->next = new Node(1);

    // Function call to count the number of nodes
    cout << "Count of nodes is " << countNodes(head);
    return 0;
}

````

C

````
// Recursive C program to find length
// or count of nodes in a linked list

#include <stdio.h>
#include <stdlib.h>

// Link list node
struct Node {
    int data;
    struct Node* next;
};

// Constructor to initialize a new node with data
struct Node* createNode(int new_data) {
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Recursively count number of nodes in linked list
int countNodes(struct Node* head) {

    // Base Case
    if (head == NULL) {
        return 0;
    }

    // Count this node plus the rest of the list
    return 1 + countNodes(head->next);
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 1 -> 3 -> 1 -> 2 -> 1
    struct Node* head = createNode(1);
    head->next = createNode(3);
    head->next->next = createNode(1);
    head->next->next->next = createNode(2);
    head->next->next->next->next = createNode(1);

    // Function call to count the number of nodes
    printf("Count of nodes is %d\\n", countNodes(head));
    return 0;
}

````

Java

````
// Recursive Java program to find length
// or count of nodes in a linked list

// Link list node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

// Recursively count number of nodes in linked list
public class GFG {
    public static int countNodes(Node head) {

        // Base Case
        if (head == null) {
            return 0;
        }

        // Count this node plus the rest of the list
        return 1 + countNodes(head.next);
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 3 -> 1 -> 2 -> 1
        Node head = new Node(1);
        head.next = new Node(3);
        head.next.next = new Node(1);
        head.next.next.next = new Node(2);
        head.next.next.next.next = new Node(1);

        // Function call to count the number of nodes
        System.out.println("Count of nodes is "
                           + countNodes(head));
    }
}

````

Python

````
# Recursive Python program to find length
# or count of nodes in a linked list

# Linked List Node
class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Recursively count number of nodes in linked list
def count_nodes(head):
    # Base Case
    if head is None:
        return 0

    # Count this node plus the rest of the list
    return 1 + count_nodes(head.next)


# Driver code
if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 3 -> 1 -> 2 -> 1
    head = Node(1)
    head.next = Node(3)
    head.next.next = Node(1)
    head.next.next.next = Node(2)
    head.next.next.next.next = Node(1)

    # Function call to count the number of nodes
    print("Count of nodes is", count_nodes(head))

````

C#

````
// Recursive C# program to find length
// or count of nodes in a linked list

using System;

// Link list node
public class Node {
    public int Data;
    public Node Next;

    // Constructor to initialize a new node with data
    public Node(int new_data) {
        Data = new_data;
        Next = null;
    }
}

// Recursively count number of nodes in linked list
public class GFG {
    public static int CountNodes(Node head) {

        // Base Case
        if (head == null) {
            return 0;
        }

        // Count this node plus the rest of the list
        return 1 + CountNodes(head.Next);
    }

    // Driver code
    public static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 3 -> 1 -> 2 -> 1
        Node head = new Node(1);
        head.Next = new Node(3);
        head.Next.Next = new Node(1);
        head.Next.Next.Next = new Node(2);
        head.Next.Next.Next.Next = new Node(1);

        // Function call to count the number of nodes
        Console.WriteLine("Count of nodes is " + CountNodes(head));
    }
}

````

JavaScript

````
// Recursive Javascript program to find length
// or count of nodes in a linked list

// Link list node
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// Recursively count number of nodes in linked list
function countNodes(head) {

    // Base Case
    if (head === null) {
        return 0;
    }

    // Count this node plus the rest of the list
    return 1 + countNodes(head.next);
}

// Driver code
// Create a hard-coded linked list:
// 1 -> 3 -> 1 -> 2 -> 1
let head = new Node(1);
head.next = new Node(3);
head.next.next = new Node(1);
head.next.next.next = new Node(2);
head.next.next.next.next = new Node(1);

// Function call to count the number of nodes
console.log("Count of nodes is " + countNodes(head));

````




**Output**
```
Count of nodes is 5
```

****Time Complexity:****
O(N), where

****N****
is the length of Linked List.



****Auxiliary Space:****
O(N), Extra space is used in the recursion call stack.', '', 'Find Length of a Linked List (Iterative and Recursive)', 5, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('522fe91a-61af-4a65-9b20-bb62618061e5', e'Given a Singly Linked List, the task is to print all the elements in the list.


****Examples:****

> ****Input:****
> 1->2->3->4->5->null
>
>
>
> ****Output:****
> 1 2 3 4 5
>
>
>
> ****Explanation:****
> Every element of each node from head node to last node is printed.
>
>
> ****Input:****
> 10->20->30->40->50->null
>
>
>
> ****Output:****
> 10 20 30 40 50
>
>
>
> ****Explanation:****
> Every element of each node from head node to last node is printed.

Table of Content

* [Iterative Approach - O(n) Time and O(1) Space](#iterative-approach-on-time-and-o1-space)
* [Recursive Approach - O(n) Time and O(n) Memory Space](#recursive-approach-on-time-and-on-memory-space)
### Iterative Approach - O(n) Time and O(1) Space


The process of printing a

****singly linked list****
involves printing the value of each node and then going on to the next node and print that node\'s value also and so on, till we reach the last node in the singly linked list, whose next node points towards the null.


****Step-by-Step Algorithm****

> * We will initialize a temporary pointer to the head node of the singly linked list.
> * After that, we will check if that pointer is null or not null, if it is null, then return.
> * While the pointer is not null, we will access and print the data of the current node, then we move the pointer to next node.


Program to Print the Singly Linked List using Iteration.


C++

````
//Driver Code Starts{
#include <iostream>

using namespace std;

//Driver Code Ends }

// A linked list node
class Node {
public:
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        this->data = new_data;
        this->next = nullptr;
    }
};

// Function to print the singly linked list
void printList(Node* head) {

    // A loop that runs till head is nullptr
    while (head != nullptr) {

        // Printing data of current node
        cout << head->data << " ";

        // Moving to the next node
        head = head->next;
    }
}

//Driver Code Starts{

int main() {

    // Create a linked list: 10 -> 20 -> 30 -> 40
    Node* head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);
    head->next->next->next = new Node(40);

    printList(head);

    return 0;
}

//Driver Code Ends }

````

C

````
//Driver Code Starts{
#include <stdio.h>
#include <stdlib.h>

//Driver Code Ends }

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node->data = new_data;
    node->next = NULL;
    return node;
}

// Function to print the singly linked list
void printList(struct Node* head) {

    // A loop that runs till head is NULL
    while (head != NULL) {

        // Printing data of current node
        printf("%d ", head->data);

        // Moving to the next node
        head = head->next;
    }
}

//Driver Code Starts{

int main() {

    // Create a linked list: 10 -> 20 -> 30 -> 40
    struct Node* head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    printList(head);

    return 0;
}

//Driver Code Ends }

````

Java

````
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int newData) {
        this.data = newData;
        this.next = null;
    }
}

class GfG {

    // Function to print the singly linked list
    static void printList(Node head) {

        // A loop that runs till head is null
        while (head != null) {

            // Printing data of current node
            System.out.print(head.data + " ");

            // Moving to the next node
            head = head.next;
        }
    }

//Driver Code Starts{
    public static void main(String[] args) {

        // Create a linked list: 10 -> 20 -> 30 -> 40
        Node head = new Node(10);
        head.next = new Node(20);
        head.next.next = new Node(30);
        head.next.next.next = new Node(40);

        printList(head);
    }
}

//Driver Code Ends }

````

Python

````
# A linked list node
class Node:
    def __init__(self, newData):
        # Constructor to initialize a new node with data
        self.data = newData
        self.next = None

# Function to print the singly linked list
def printList(head):

    # A loop that runs till head is None
    while head is not None:

        # Printing data of current node
        print(head.data, end=" ")

        # Moving to the next node
        head = head.next

if __name__ == "__main__":

#Driver Code Starts{
    # Create a linked list: 10 -> 20 -> 30 -> 40
    head = Node(10)
    head.next = Node(20)
    head.next.next = Node(30)
    head.next.next.next = Node(40)

    printList(head)

#Driver Code Ends }

````

C#

````
//Driver Code Starts{
using System;

//Driver Code Ends }

class Node {
    public int data;
    public Node next;

    // Constructor to initialize a new node with data
    public Node(int new_data) {
        this.data = new_data;
        this.next = null;
    }
}

class GfG {

    // Function to print the singly linked list
    static void printList(Node head) {

        // A loop that runs till head is null
        while (head != null) {

            // Printing data of current node
            Console.Write(head.data + " ");

            // Moving to the next node
            head = head.next;
        }
    }

//Driver Code Starts{

    static void Main(string[] args) {

        // Create a linked list: 10 -> 20 -> 30 -> 40
        Node head = new Node(10);
        head.next = new Node(20);
        head.next.next = new Node(30);
        head.next.next.next = new Node(40);

        printList(head);
    }
}

//Driver Code Ends }

````

JavaScript

````
class Node {
    constructor(newData) {
        // Constructor to initialize a new node with data
        this.data = newData;
        this.next = null;
    }
}

// Function to print the singly linked list
function printList(head) {

	let result = \'\';

    // A loop that runs till head is null
    while (head !== null) {

        // Printing data of current node
        result += head.data + \' \';

        // Moving to the next node
        head = head.next;
    }

    console.log(result.trim());
}

//Driver Code Starts{
// Driver Code

// Create a linked list: 10 -> 20 -> 30 -> 40
const head = new Node(10);
head.next = new Node(20);
head.next.next = new Node(30);
head.next.next.next = new Node(40);

printList(head);


//Driver Code Ends }

````




**Output**
```
10 20 30 40

```

****Time Complexity:****
O(n), where

****n****
is the number of nodes in the linked list.



****Auxiliary Space:****
O(1)


### Recursive Approach - O(n) Time and O(n) Memory Space


We can also traverse the singly linked list using recursion. We start at the head node of the singly linked list, check if it is null or not and print its value. We then call the traversal function again with the next node passed as pointer.


****Step-by-Step Algorithm****

> * Firstly, we define a recursive method to traverse the singly linked list, which takes a node as a parameter.
> * In this function, the base case is that if the node is null then we will return from the recursive method.
> * We then pass the head node as the parameter to this function.
> * After that, we access and print the data of the current node.
> * At last, we will make a recursive call to this function with the next node as the parameter.


Program to Print the Singly Linked List using Recursion.


C++

````
#include <iostream>
using namespace std;

// A linked list node
class Node {
public:
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        this->data = new_data;
        this->next = nullptr;
    }
};

// Function to print the singly linked list
void printList(Node* head) {

    // Base condition is when the head is nullptr
    if (head == nullptr) {
        return;
    }

    // Printing the current node data
    cout << head->data << " ";

    // Moving to the next node
    printList(head->next);
}

int main() {

    // Create a linked list: 10 -> 20 -> 30 -> 40
    Node* head = new Node(10);
    head->next = new Node(20);
    head->next->next = new Node(30);
    head->next->next->next = new Node(40);

    printList(head);

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node with given data
struct Node* createNode(int new_data) {
    struct Node* new_node
        = (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Function to print the singly linked list
void printList(struct Node* head) {

    // Base condition is when the head is nullptr
    if (head == NULL) {
        return;
    }

    // Printing the current node data
    printf("%d ", head->data);

    // Moving to the next node
    printList(head->next);
}

int main() {

    // Create a linked list: 10 -> 20 -> 30 -> 40
    struct Node* head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    printList(head);

    return 0;
}

````

Java

````
// A linked list node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

class GfG {

    // Function to print the singly linked list
    static void printList(Node head) {

        // Base condition is when the head is nullptr
        if (head == null) {
            return;
        }

        // Printing the current node data
        System.out.print(head.data + " ");

        // Moving to the next node
        printList(head.next);
    }

    public static void main(String[] args) {

        // Create a linked list: 10 -> 20 -> 30 -> 40
        Node head = new Node(10);
        head.next = new Node(20);
        head.next.next = new Node(30);
        head.next.next.next = new Node(40);

        printList(head);
    }
}

````

Python

````
# A linked list node
class Node:
    def __init__(self, data):

        # Constructor to initialize a new node with data
        self.data = data
        self.next = None

# Function to print the singly linked list
def printList(head):

    # Base condition is when the head is nullptr
    if head is None:
        return

    # Printing the current node data
    print(head.data, end=" ")

    # Moving to the next node
    printList(head.next)

if __name__ == "__main__":

    # Create a linked list: 10 -> 20 -> 30 -> 40
    head = Node(10)
    head.next = Node(20)
    head.next.next = Node(30)
    head.next.next.next = Node(40)

    printList(head)

````

C#

````
using System;

// A linked list node
class Node {
    public int Data { get;set; }
    public Node Next { get;set; }

    // Constructor to initialize a new node with data
    public Node(int newData) {
        Data = newData;
        Next = null;
    }
}

class GfG {

    // Function to print the singly linked list
    static void printList(Node head) {

        // Base condition is when the head is nullptr
        if (head == null) {
            return;
        }

        // Printing the current node data
        Console.Write(head.Data + " ");

        // Moving to the next node
        printList(head.Next);
    }

    static void Main() {

        // Create a linked list: 10 -> 20 -> 30 -> 40
        Node head = new Node(10);
        head.Next = new Node(20);
        head.Next.Next = new Node(30);
        head.Next.Next.Next = new Node(40);

        printList(head);
    }
}

````




**Output**
```
10 20 30 40

```

****Time Complexity:****
O(n), where

****n****
is number of nodes in the linked list.



****Space complexity:****
O(n) because of recursive stack space.', '', 'Print Linked List', 6, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('52d5e2e5-8598-413c-be15-d5c2a0db1948', e'Given a linked list and a

****key****
, the task is to check if

****key****
is present in the linked list or not.


****Examples:****

> ****Input:****
> 14 -> 21 -> 11 -> 30 -> 10, key = 14
>
>
>
> ****Output:****
> Yes
>
>
>
> ****Explanation:****
> 14 is present in the linked list.
>
>
> ****Input:****
> 6 -> 21 -> 17 -> 30 -> 10 -> 8, key = 13
>
>
>
> ****Output:****
> No
>
>
>
> ****Explanation:****
> No node in the linked list has value = 13.

Table of Content

* [Search an element in a Linked List (Iterative Approach) – O(N) Time and O(1) Space](#search-an-element-in-a-linked-list-iterative-approach)
* [Search an element in a Linked List (Recursive Approach) – O(N) Time and O(N) Space](#search-an-element-in-a-linked-list-recursive-approach)

Search an element in a Linked List (Iterative Approach) – O(N) Time and O(1) Space:
-----------------------------------------------------------------------------------

> The idea is to traverse all the nodes of the linked list, starting from the
>
> ****head****
> . While traversing, if we find a node whose value is equal to
>
> ****key****
> then print “Yes”, otherwise print “No”.


Follow the below steps to solve the problem:



* Initialize a node pointer,

  ****curr = head****
  .
* Do following while current is not NULL
  + If the current value (i.e.,

    ****curr->key****
    ) is equal to the key being searched return true.
  + Otherwise, move to the next node (

    ****curr = curr->next****
    ).
* If the key is not found, return false


Below is the implementation of the above approach.



C++

````
// Iterative C++ program to search
// an element in linked list

#include <iostream>
using namespace std;

// A linked list node
class Node {
public:
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data)
    {
        data = new_data;
        next = nullptr;
    }
};

// Checks whether key is present in linked list
bool searchKey(Node* head, int key) {

    // Initialize curr with the head of linked list
    Node* curr = head;

    // Iterate over all the nodes
    while (curr != NULL) {

        // If the current node\'s value is equal to key,
        // return true
        if (curr->data == key)
            return true;

        // Move to the next node
        curr = curr->next;
    }

    // If there is no node with value as key, return false
    return false;
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 14 -> 21 -> 13 -> 30 -> 10
    Node* head = new Node(14);
    head->next = new Node(21);
    head->next->next = new Node(13);
    head->next->next->next = new Node(30);
    head->next->next->next->next = new Node(10);

      // Key to search in the linked list
      int key = 14;

    if (searchKey(head, key))
        cout << "Yes";
    else
        cout << "No";

    return 0;
}

````

C

````
// Iterative C program to search
// an element in linked list

#include <stdio.h>
#include <stdbool.h>

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node =
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Checks whether key is present in linked list
bool searchKey(struct Node* head, int key) {

    // Initialize curr with the head of linked list
    struct Node* curr = head;

    // Iterate over all the nodes
    while (curr != NULL) {

        // If the current node\'s value is equal to key,
        // return true
        if (curr->data == key)
            return true;

        // Move to the next node
        curr = curr->next;
    }

    // If there is no node with value as key, return false
    return false;
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 14 -> 21 -> 13 -> 30 -> 10
    struct Node* head = createNode(14);
    head->next = createNode(21);
    head->next->next = createNode(13);
    head->next->next->next = createNode(30);
    head->next->next->next->next = createNode(10);

      // Key to search in the linked list
      int key = 14;

    if (searchKey(head, key))
        printf("Yes");
    else
        printf("No");

    return 0;
}

````

Java

````
// Iterative Java program to search
// an element in linked list

// A Linked List Node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

public class GFG {

    // Checks whether key is present in linked list
    static boolean searchKey(Node head, int key) {

        // Initialize curr with the head of linked list
        Node curr = head;

        // Iterate over all the nodes
        while (curr != null) {

            // If the current node\'s value is equal to key,
            // return true
            if (curr.data == key)
                return true;

            // Move to the next node
            curr = curr.next;
        }

        // If there is no node with value as key, return
        // false
        return false;
    }

      // Driver code
    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 14 -> 21 -> 13 -> 30 -> 10
        Node head = new Node(14);
        head.next = new Node(21);
        head.next.next = new Node(13);
        head.next.next.next = new Node(30);
        head.next.next.next.next = new Node(10);

        // Key to search in the linked list
        int key = 14;

        if (searchKey(head, key))
            System.out.println("Yes");
        else
            System.out.println("No");
    }
}

````

Python

````
# Iterative Python program to search
# an element in linked list

# A Linked List Node
class Node:

      # Constructor to intialize a node with data
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Checks whether key is present in linked list
def search_key(head, key):

    # Initialize curr with the head of linked list
    curr = head

    # Iterate over all the nodes
    while curr is not None:

        # If the current node\'s value is equal to key,
        # return true
        if curr.data == key:
            return True

        # Move to the next node
        curr = curr.next

    # If there is no node with value as key, return false
    return False

# Driver code
if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 14 -> 21 -> 13 -> 30 -> 10
    head = Node(14)
    head.next = Node(21)
    head.next.next = Node(13)
    head.next.next.next = Node(30)
    head.next.next.next.next = Node(10)

    # Key to search in the linked list
    key = 14

    if search_key(head, key):
        print("Yes")
    else:
        print("No")

````

C#

````
// Iterative C# program to search
// an element in linked list

using System;

// A Linked List Node
class Node {
    public int Data;
    public Node Next;

    // Constructor to initialize a new node with data
    public Node(int new_data) {
        Data = new_data;
        Next = null;
    }
}

// Driver code
class GFG {

    // Checks whether key is present in linked list
    static bool SearchKey(Node head, int key) {

        // Initialize curr with the head of linked list
        Node curr = head;

        // Iterate over all the nodes
        while (curr != null) {

            // If the current node\'s value is equal to key,
            // return true
            if (curr.Data == key)
                return true;

            // Move to the next node
            curr = curr.Next;
        }

        // If there is no node with value as key, return
        // false
        return false;
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 14 -> 21 -> 13 -> 30 -> 10
        Node head = new Node(14);
        head.Next = new Node(21);
        head.Next.Next = new Node(13);
        head.Next.Next.Next = new Node(30);
        head.Next.Next.Next.Next = new Node(10);

        // Key to search in the linked list
        int key = 14;

        if (SearchKey(head, key))
            Console.WriteLine("Yes");
        else
            Console.WriteLine("No");
    }
}

````

JavaScript

````
// Iterative JavaScript program to search
// an element in linked list

// A Linked List Node
class Node {

    // Constructor to initialize a new node with data
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Checks whether key is present in linked list
function searchKey(head, key) {

    // Initialize curr with the head of linked list
    let curr = head;

    // Iterate over all the nodes
    while (curr !== null) {

        // If the current node\'s value is equal to key,
        // return true
        if (curr.data === key)
            return true;

        // Move to the next node
        curr = curr.next;
    }

    // If there is no node with value as key, return false
    return false;
}

// Driver code

// Create a hard-coded linked list:
// 14 -> 21 -> 13 -> 30 -> 10
let head = new Node(14);
head.next = new Node(21);
head.next.next = new Node(13);
head.next.next.next = new Node(30);
head.next.next.next.next = new Node(10);

// Key to search in the linked list
let key = 14;

if (searchKey(head, key))
console.log("Yes");
else
console.log("No");

````




**Output**
```
Yes
```

****Time Complexity:****
O(N), Where

****N****
is the number of nodes in the Linked List.



****Auxiliary Space:****
O(1)


Search an element in a Linked List (Recursive Approach) – O(N) Time and O(N) Space:
-----------------------------------------------------------------------------------

> The idea is to recursively traverse all the nodes starting from the
>
> ****head****
> of linked list. For any node, if the value is equal to
>
> ****key****
> , then return true. Otherwise, recursively search the next node. If at any point the head reaches
>
> ****NULL****
> , it means that we have reached the end of linked list so return
>
> ****false****
> .


Follow the below steps to solve the problem:


* If the head is NULL, return false.
* If the head’s key is the same as

  ****X****
  , return true;
* Else recursively search in the next node.


Below is the recursive implementation of the above algorithm.


C++

````
// Recursive C++ program to search
// an element in linked list

#include <iostream>
using namespace std;

// A Linked List Node
struct Node {
    int data;
    Node* next;

      // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// Checks whether the key is present in linked list
bool searchKey(struct Node* head, int key) {

    // Base case
    if (head == NULL)
        return false;

    // If key is present in current node, return true
    if (head->data == key)
        return true;

    // Recur for remaining list
    return searchKey(head->next, key);
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 14 -> 21 -> 13 -> 30 -> 10
    struct Node* head = new Node(14);
    head->next = new Node(21);
    head->next->next = new Node(13);
    head->next->next->next = new Node(30);
    head->next->next->next->next = new Node(10);

      // Key to search in the linked list
      int key = 14;

    if (searchKey(head, key))
        printf("Yes");
    else
        printf("No");

    return 0;
}

````

C

````
// Recursive C program to search
// an element in linked list

#include <stdio.h>
#include <stdbool.h>

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node =
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Checks whether the key is present in linked list
bool searchKey(struct Node* head, int key) {

    // Base case
    if (head == NULL)
        return 0;

    // If key is present in current node, return true
    if (head->data == key)
        return 1;

    // Recur for remaining list
    return searchKey(head->next, key);
}

// Driver code
int main() {

    // Create a hard-coded linked list:
    // 14 -> 21 -> 13 -> 30 -> 10
    struct Node* head = createNode(14);
    head->next = createNode(21);
    head->next->next = createNode(13);
    head->next->next->next = createNode(30);
    head->next->next->next->next = createNode(10);

      // Key to search in the linked list
      int key = 14;

    if (searchKey(head, key))
        printf("Yes");
    else
        printf("No");

    return 0;
}

````

Java

````
// Recursive Java program to search
// an element in linked list

// A Linked List Node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

// Driver code
public class GFG {

    // Checks whether the key is present in linked list
    static boolean searchKey(Node head, int key) {

        // Base case
        if (head == null)
            return false;

        // If key is present in current node, return true
        if (head.data == key)
            return true;

        // Recur for remaining list
        return searchKey(head.next, key);
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 14 -> 21 -> 13 -> 30 -> 10
        Node head = new Node(14);
        head.next = new Node(21);
        head.next.next = new Node(13);
        head.next.next.next = new Node(30);
        head.next.next.next.next = new Node(10);

        // Key to search in the linked list
        int key = 14;

        if (searchKey(head, key))
            System.out.println("Yes");
        else
            System.out.println("No");
    }
}

````

Python

````
# Recursive Python program to search
# an element in linked list

# A Linked List Node
class Node:

      # Constructor to initialize a new node with data
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Checks whether the key is present in linked list
def searchKey(head, key):

    # Base case
    if head is None:
        return False

    # If key is present in current node, return true
    if head.data == key:
        return True

    # Recur for remaining list
    return searchKey(head.next, key)

# Driver code
if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 14 -> 21 -> 13 -> 30 -> 10
    head = Node(14)
    head.next = Node(21)
    head.next.next = Node(13)
    head.next.next.next = Node(30)
    head.next.next.next.next = Node(10)

    # Key to search in the linked list
    key = 14

    if searchKey(head, key):
        print("Yes")
    else:
        print("No")

````

C#

````
// Recursive C# program to search
// an element in linked list

using System;

// A Linked List Node
class Node {
    public int data;
    public Node next;

    // Constructor to initialize a new node with data
    public Node(int new_data) {
        data = new_data;
        next = null;
    }
}

// Checks whether the key is present in linked list
class GFG {

      // Checks whether the key is present in linked list
    static bool SearchKey(Node head, int key) {

        // Base case
        if (head == null)
            return false;

        // If key is present in current node, return true
        if (head.data == key)
            return true;

        // Recur for remaining list
        return SearchKey(head.next, key);
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 14 -> 21 -> 13 -> 30 -> 10
        Node head = new Node(14);
        head.next = new Node(21);
        head.next.next = new Node(13);
        head.next.next.next = new Node(30);
        head.next.next.next.next = new Node(10);

        // Key to search in the linked list
        int key = 14;

        if (SearchKey(head, key))
            Console.WriteLine("Yes");
        else
            Console.WriteLine("No");
    }
}

````

JavaScript

````
// Recursive Javascript program to search
// an element in linked list


// A Linked List Node
class Node {

    // Constructor to initialize a new node with data
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Checks whether the key is present in linked list
function searchKey(head, key) {

    // Base case
    if (head === null)
        return false;

    // If key is present in current node, return true
    if (head.data === key)
        return true;

    // Recur for remaining list
    return searchKey(head.next, key);
}

// Create a hard-coded linked list:
// 14 -> 21 -> 13 -> 30 -> 10
let head = new Node(14);
head.next = new Node(21);
head.next.next = new Node(13);
head.next.next.next = new Node(30);
head.next.next.next.next = new Node(10);

// Key to search in the linked list
let key = 14;

if (searchKey(head, key))
console.log("Yes");
else
console.log("No");

````




**Output**
```
Yes
```

****Time Complexity:****
O(N), where

****N****
is the number of nodes in the linked list.



****Auxiliary Space:****
O(N), Stack space used by recursive calls', '', 'Search an element in a Linked List (Iterative and Recursive)', 7, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('cf626aff-7b6c-4197-a2cb-c8365f512ec8', e'Given a singly linked list and a position (1-based indexing), the task is to delete a linked list node at the given position.


****Note:****
Position will be valid (i.e, 1 <= position <= linked list length)


****Example:****


> ****Input:****
> position = 2, Linked List = 8->2->3->1->7
>
>
>
> ****Output:****
> Linked List =  8->3->1->7
>
>
> ****Input:****
> position = 1, Linked List = 8->2->3->1->7
>
>
>
> ****Output:****
> Linked List = 2->3->1->7

****Approach:****


Deletion at a specified position in a linked list involves removing a node from a specific index/position, which can be the first, middle, or last node.


> To perform the deletion, If the position is 1, we update the
>
> ****head****
> to point to the
>
> ****next node****
> and delete the current head. For other positions, we traverse the list to reach the node just before the specified
>
> ****position****
> . If the target node exists, we adjust the next of this previous node to point to next of
>
> ****next nodes****
> , which will result in skipping the target node.

![Deletion-specific-At-End--](https://media.geeksforgeeks.org/wp-content/uploads/20240729185435/Deletion-specific-At-End--.webp)

Delete a Linked List node at a given position


Step-by-step approach:


* If list is empty (

  ****head****
  ==

  ****NULL)****
  , returns the

  ****head****
  .
* If the

  ****position****
  to delete is

  ****1****
  (the head node):
  + Update

    ****head = temp->next****
* Traverse the list until reaching the desired position:
  + Initialize

    ****prev****
    to keep track of the previous node.
  + Move

    ****temp****
    through the list until the position is reached.
* Check for Valid Position:
  + If

    ****temp****
    becomes

    ****NULL****
    , it means the position exceeds the number of nodes in the list. Print a message and return the

    ****head****
    .
* If the node to delete is found:
  + Set

    ****prev->next****
    to

    ****temp->next****
    , effectively skipping over the node to be deleted.

****Code Implementation:****

C++14

````
// C++ program to delete a linked list node at a given
// position
#include <iostream>
using namespace std;

// Node structure for the linked list
struct Node {
    int data;
    Node* next;
    Node(int data)
        : data(data)
        , next(nullptr)
    {
    }
};

// Function to delete a node at a given position
Node* deleteNode(Node* head, int position)
{
    // previous of node to be deleted
    Node* prev;
    Node* temp = head;

    // Base case if linked list is empty
    if (temp == NULL)
        return head;

    // Case 1: Head is to be deleted
    if (position == 1) {
        // make next node as head and free old head
        head = temp->next;
        free(temp);
        return head;
    }

    // Case 2: Node to be deleted is in middle
    // Traverse till given position
    for (int i = 1; i != position; i++) {
        prev = temp;
        temp = temp->next;
    }

    // If given position is found, delete node
    if (temp != NULL) {
        prev->next = temp->next;
        free(temp);
    }
    // If given position is not present
    else {
        cout << "Data not present\\n";
    }

    return head;
}

void printList(Node* head)
{
    while (head != nullptr) {
        cout << head->data << " -> ";
        head = head->next;
    }
    cout << "nullptr" << endl;
}

// Driver code
int main()
{
    // Creating a static linked list
    // 1 -> 2 -> 3 -> 4 -> 5 -> nullptr
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Original list: ";
    printList(head);

    // Deleting node at position 2
    int position = 2;
    head = deleteNode(head, position);

    cout << "List after deletion : ";
    printList(head);

    // Cleanup remaining nodes
    while (head != nullptr) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }

    return 0;
}

````

C

````
// C program to delete a linked list node at a given
// position

#include <stdio.h>
#include <stdlib.h>

// Node structure for the linked list
struct Node {
    int data;
    struct Node* next;
};

struct Node* newNode(int data)
{
    struct Node* node
        = (struct Node*)malloc(sizeof(struct Node));
    node->data = data;
    node->next = NULL;
    return node;
}

// Function to delete a node at a given position
struct Node* deleteNode(struct Node* head, int position)
{
    struct Node* temp = head;
    struct Node* prev = NULL;

    // Base case if linked list is empty
    if (temp == NULL)
        return head;

    // Case 1: Head is to be deleted
    if (position == 1) {
        head = temp->next;
        free(temp);
        return head;
    }

    // Case 2: Node to be deleted is in middle
    // Traverse till given position
    for (int i = 1; temp != NULL && i < position; i++) {
        prev = temp;
        temp = temp->next;
    }

    // If given position is found, delete node
    if (temp != NULL) {
        prev->next = temp->next;
        free(temp);
    }
    else {
        printf("Data not present\\n");
    }

    return head;
}

void printList(struct Node* head)
{
    while (head != NULL) {
        printf("%d -> ", head->data);
        head = head->next;
    }
    printf("NULL\\n");
}

// Driver code
int main()
{
    struct Node* head = newNode(1);
    head->next = newNode(2);
    head->next->next = newNode(3);
    head->next->next->next = newNode(4);
    head->next->next->next->next = newNode(5);

    printf("Original list: ");
    printList(head);

    int position = 2;
    head = deleteNode(head, position);

    printf("List after deletion: ");
    printList(head);

    // Cleanup remaining nodes
    while (head != NULL) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
    }

    return 0;
}

````

Java

````
// Java program to delete a linked list node at a given
// position

// Node class to define a linked list node
class Node {
    int data;
    Node next;

    Node(int data)
    {
        this.data = data;
        this.next = null;
    }
}

public class LinkedList {
    // Function to delete a node at a given position
    public static Node deleteNode(Node head, int position)
    {
        Node temp = head;
        Node prev = null;

        // Base case if linked list is empty
        if (temp == null)
            return head;

        // Case 1: Head is to be deleted
        if (position == 1) {
            head = temp.next;
            return head;
        }

        // Case 2: Node to be deleted is in middle
        // Traverse till given position
        for (int i = 1; temp != null && i < position; i++) {
            prev = temp;
            temp = temp.next;
        }

        // If given position is found, delete node
        if (temp != null) {
            prev.next = temp.next;
        }
        else {
            System.out.println("Data not present");
        }

        return head;
    }

    // Function to print the linked list
    public static void printList(Node head)
    {
        while (head != null) {
            System.out.print(head.data + " -> ");
            head = head.next;
        }
        System.out.println("null");
    }

    // Driver code
    public static void main(String[] args)
    {
        // Creating a static linked list
        // 1 -> 2 -> 3 -> 4 -> 5 -> null
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

        // Print original list
        System.out.print("Original list: ");
        printList(head);

        // Deleting node at position 2
        int position = 2;
        head = deleteNode(head, position);

        // Print list after deletion
        System.out.print("List after deletion: ");
        printList(head);
    }
}

````

Python

````
# Python program to delete a linked list node at
# a given position


class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Function to delete a node at a given position


def deleteNode(head, position):
    temp = head
    prev = None

    # Base case if linked list is empty
    if temp is None:
        return head

    # Case 1: Head is to be deleted
    if position == 1:
        head = temp.next
        return head

    # Case 2: Node to be deleted is in middle
    # Traverse till given position
    for i in range(1, position):
        prev = temp
        temp = temp.next
        if temp is None:
            print("Data not present")
            return head

    # If given position is found, delete node
    if temp is not None:
        prev.next = temp.next

    return head

# Function to print the linked list


def printList(head):
    while head:
        print(f"{head.data} -> ", end="")
        head = head.next
    print("None")


# Driver code
if __name__ == "__main__":
    # Creating a static linked list
    # 1 -> 2 -> 3 -> 4 -> 5 -> None
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)

    # Print original list
    print("Original list: ", end="")
    printList(head)

    # Deleting node at position 2
    position = 2
    head = deleteNode(head, position)

    # Print list after deletion
    print("List after deletion: ", end="")
    printList(head)

````

JavaScript

````
// Javascript program to delete a linked list node at a
// given position
class Node {
    constructor(data)
    {
        this.data = data;
        this.next = null;
    }
}

// Function to delete a node at a given position
function deleteNode(head, position)
{
    let temp = head;
    let prev = null;

    // Base case if linked list is empty
    if (temp === null)
        return head;

    // Case 1: Head is to be deleted
    if (position === 1) {
        head = temp.next;
        return head;
    }

    // Case 2: Node to be deleted is in middle
    // Traverse till given position
    for (let i = 1; temp !== null && i < position; i++) {
        prev = temp;
        temp = temp.next;
    }

    // If given position is found, delete node
    if (temp !== null) {
        prev.next = temp.next;
    }
    else {
        console.log("Data not present");
    }

    return head;
}

// Function to print the linked list
function printList(head)
{
    while (head !== null) {
        process.stdout.write(head.data + " -> ");
        head = head.next;
    }
    console.log("null");
}

// Driver code
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);

// Print original list
console.log("Original list: ");
printList(head);

// Deleting node at position 2
let position = 2;
head = deleteNode(head, position);

// Print list after deletion
console.log("List after deletion: ");
printList(head);

````




**Output**
```
Original list: 1 -> 2 -> 3 -> 4 -> 5 -> nullptr
List after deletion : 1 -> 3 -> 4 -> 5 -> nullptr

```

****Time Complexity****
: O(n), where n is the number of nodes in the list



****Auxiliary Space:****
O(1)
', '', 'Delete a Linked List node at a given position', 8, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('21a97134-4f54-443f-870a-71183556f602', e'Given a

****linked list****
, the task is to

****delete****
the linked list completely.


****Examples:****

> ****Input:****
> head: 1 -> 2 -> 3 -> 4 -> 5 -> NULL
>
>
>
> ****Output:****
> NULL
>
>
>
> ****Explanation:****
> Linked List is Deleted.
>
>
>
>
>
> ****Input:****
> head: 1 -> 12 -> 1 -> 4 -> 1 -> NULL
>
>
>
> ****Output:****
> NULL
>
>
>
> ****Explanation:****
> Linked List is Deleted.

Table of Content

* [[Expected Approach – 1] Using Recursion – O(n) Time and O(n) Space](#expected-approach-1-using-recursion-on-time-and-on-space)
* [[Expected Approach – 2] Using Iteration – O(n) Time and O(1) Space](#expected-approach-2-using-iteration-on-time-and-o1-space)
### [Expected Approach – 1] Using Recursion – O(n) Time and O(n) Space:

> The idea is to use
>
> [****recursion****](https://www.geeksforgeeks.org/introduction-to-recursion-2/)
> to delete the entire linked list. Traverse from the
>
> ****head****
> to the
>
> ****end****
> of the list recursively. While backtracking, delete the
>
> ****currrent****
> node. This ensures that each node is processed after its subsequent nodes.


Below is the implementation of the above approach:


C++

````
// C++ program to delete a linked list
// using recursion
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int x) {
        data = x;
        next = nullptr;
    }
};

// Given the head of a list, delete the list
// using recursion
void deleteList(Node* curr) {

    // Base case: If the list is empty, return
    if (curr == nullptr) {
        return;
    }

    // Recursively delete the next node
    deleteList(curr->next);

    // Delete the current node
    delete curr;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    deleteList(head);
    cout << "NULL";

    return 0;
}

````

C

````
// C program to delete a linked list
// using recursion
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

// Given the head of a list, delete the list
// using recursion
void deleteList(struct Node* curr) {

    // Base case: If the list is empty, return
    if (curr == NULL) {
        return;
    }

    // Recursively delete the next node
    deleteList(curr->next);

    // Delete the current node
    free(curr);
}

struct Node* createNode(int new_data) {
    struct Node* new_node =
        (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    struct Node* head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);

    deleteList(head);
    printf("NULL");

    return 0;
}

````

Java

````
// Java program to delete a linked list
class Node {
    int data;
    Node next;

    Node(int x) {
        data = x;
        next = null;
    }
}


public class GfG {

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

           // Set head to null to remove the reference to the linked list.
        // This allows Java\'s garbage collector to automatically clean up
        // the memory used by the nodes, as there are no more references
        // to the nodes in the linked list.
          head = null;
          System.out.print("NULL");
    }

}

````

Python

````
# Python program to delete a linked list

class Node:
    def __init__(self, x):
        self.data = x
        self.next = None


if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 2 -> 3 -> 4 -> 5
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)

    # Set head to None to remove the reference to the linked list.
    # This allows Python\'s garbage collector to automatically reclaim
    # the memory used by the nodes, as there are no more references
    # to the nodes in the linked list.
    head = None
    print("NULL")

````

C#

````
// C# program to delete a linked list

using System;

class Node {
    public int Data;
    public Node next;

    public Node(int x) {
        Data = x;
        next = null;
    }
}

class GfG {

    static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

           // Set head to null to remove the reference to the linked list.
        // This allows C#\'s garbage collector to automatically reclaim
        // the memory used by the nodes, as there are no more references
        // to the nodes in the linked list.
        head = null;
        Console.WriteLine("NULL");
    }
}

````

JavaScript

````
// JavaScript program to delete a linked list

class Node {
    constructor(x) {
        this.data = x;
        this.next = null;
    }
}

// Create a hard-coded linked list:
// 1 -> 2 -> 3 -> 4 -> 5
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);

// Set head to null to remove the reference to the linked list.
// This allows JavaScript\'s garbage collector to automatically reclaim
// the memory used by the nodes, as there are no more references
// to the nodes in the linked list.
head = null;
console.log("NULL");

````




**Output**
```
NULL
```

****Time Complexity:****
O(n), where

****n****
is the number of nodes in the given linked list.



****Auxiliary Space:****
O(n)


### [Expected Approach – 2] Using Iteration – O(n) Time and O(1) Space:

> The idea is to
>
> ****iteratively****
> delete the list by starting from the
>
> ****head****
> and moving towards the
>
> ****end****
> . At each step, the function stores a
>
> ****reference****
> to the
>
> ****next****
> node, deletes the
>
> ****current****
> node, and
>
> ****moves****
> to the next node. This continues until all nodes are deleted.


Below is the implementation of the above approach:


C++

````
// C++ program to delete a linked list
// using iteration
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int x) {
        data = x;
        next = nullptr;
    }
};

// Given the head of a list, delete the list
// using iteration
void deleteList(Node* curr) {

    // Iterate through the list until it becomes empty
    while (curr != nullptr) {

        // Store the next node before deleting current
        Node* temp = curr->next;

        // Delete the current node
        delete curr;

        // Move to the next node
        curr = temp;
    }
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    deleteList(head);
    head = nullptr;

    cout << "NULL";

    return 0;
}

````

C

````
// C program to delete a linked list
// using iteration
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

// Given the head of a list, delete the list
// using iteration
void deleteList(struct Node* curr) {

    // Iterate through the list until it becomes empty
    while (curr != NULL) {

        // Store the next node before deleting current
        struct Node* temp = curr->next;

        // Delete the current node
        free(curr);

        // Move to the next node
        curr = temp;
    }
}

struct Node* createNode(int new_data) {
    struct Node* new_node =
        (struct Node*)malloc(sizeof(struct Node));

    new_node->data = new_data;
    new_node->next = NULL;

    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    struct Node* head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);

    deleteList(head);
    head = NULL;

    printf("NULL");

    return 0;
}

````

Java

````
// Java program to delete a linked list
class Node {
    int data;
    Node next;

    Node(int x) {
        data = x;
        next = null;
    }
}

public class GfG {

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

           // Set head to null to remove the reference to the linked list.
        // This allows Java\'s garbage collector to automatically clean up
        // the memory used by the nodes, as there are no more references
        // to the nodes in the linked list.
          head = null;
          System.out.print("NULL");
    }

}

````

Python

````
# Python program to delete a linked list

class Node:
    def __init__(self, x):
        self.data = x
        self.next = None


if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 2 -> 3 -> 4 -> 5
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)

    # Set head to None to remove the reference to the linked list.
    # This allows Python\'s garbage collector to automatically reclaim
    # the memory used by the nodes, as there are no more references
    # to the nodes in the linked list.
    head = None
    print("NULL")

````

C#

````
// C# program to delete a linked list

using System;

class Node {
    public int Data;
    public Node next;

    public Node(int x) {
        Data = x;
        next = null;
    }
}


class GfG {

    static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

           // Set head to null to remove the reference to the linked list.
        // This allows C#\'s garbage collector to automatically reclaim
        // the memory used by the nodes, as there are no more references
        // to the nodes in the linked list.
        head = null;
        Console.WriteLine("NULL");
    }
}

````

JavaScript

````
// JavaScript program to delete a linked list

class Node {
    constructor(x) {
        this.data = x;
        this.next = null;
    }
}

// Create a hard-coded linked list:
// 1 -> 2 -> 3 -> 4 -> 5
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);

// Set head to null to remove the reference to the linked list.
// This allows JavaScript\'s garbage collector to automatically reclaim
// the memory used by the nodes, as there are no more references
// to the nodes in the linked list.
head = null;
console.log("NULL");

````




**Output**
```
NULL
```

****Time Complexity:****
O(n), where

****n****
is the number of nodes in the given linked list.



****Auxiliary Space:****
O(1)', '', 'Write a function to delete a Linked List', 9, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('a904febf-06a7-4308-ad85-436b2ed04ba7', e'Given a

****LinkedList****
and an

****index****
(1-based). The task is to find the

****data value****
stored in the node at that

****kth****
position. If no such node exists whose index is

****k****
then

****return -1.****

****Example:****


> ****Input****
> : 1->10->30->14, index = 2
>
>
>
> ****Output****
> : 10
>
>
>
> ****Explanation****
> : The node value at index 2 is 10
>
>
> ![Maximum-of-all-subarrays-of-size-K](https://media.geeksforgeeks.org/wp-content/uploads/20240822110836/Maximum-of-all-subarrays-of-size-K.webp)
>
>
>
> ****Input****
> : 1->32->12->10->30->14->100, index = 8
>
>
>
> ****Output****
> : -1
>
>
>
> ****Explanation****
> : No such node exists at index = 8.

Table of Content

* [[Naive Approach] Recursive Method – O(n) Time and O(n) Space](#approach-1-using-recursion-on-time-and-on-space)
* [[Expected Approach-2] Iterative Method – O(n) Time and O(1) Space](#approach-2-using-iterative-method-on-time-and-o1-space)
### ****[Naive Approach] Recursive Method – O(n) Time and O(n) Space****

> The idea is to use the
>
> [****recursive****](https://www.geeksforgeeks.org/introduction-to-recursion-2/)
> ****method****
> to find the value of
>
> ****index****
> node
>
> ****(1- based)****
> . Call the function
>
> ****GetNth(head,index)****
> recusively, where
>
> ****head****
> will represent the
>
> ****current head****
> node . Decrement the index
>
> ****value by 1****
> on every recursion call. When the
>
> ****n reaches 1****
> ,we will return the
>
> ****data****
> of current node.


Below is the implementation of above approach:


C++

````
//C++ program to find the data at nth node
//recursively

#include <bits/stdc++.h>
using namespace std;
struct Node {
    int data;
    Node* next;
    Node(int x) {
      data = x;
      next = NULL;
    }
};

// Takes head pointer of the linked list and index
// as arguments and returns data at index.
int GetNth(Node* head, int index) {

    // If the list is empty or index is out of bounds
    if (head == NULL)
        return -1;

    // If index equals 1, return node\'s data
    if (index == 1)
        return head->data;

    // Recursively move to the next node
    return GetNth(head->next, index - 1);
}


int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Element at index 3 is " << GetNth(head, 3) << endl;

    return 0;
}

````

C

````
// C program to find the data at nth node
// recursively

#include <stdio.h>
struct Node {
    int data;
    struct Node *next;
};

// Takes head pointer of the linked list and index
// as arguments and returns data at index.
int GetNth(struct Node *head, int index) {

    // If the list is empty or index is out of bounds
    if (head == NULL)
        return -1;

    // If index equals 1, return node\'s data
    if (index == 1)
        return head->data;

    // Recursively move to the next node
    return GetNth(head->next, index - 1);
}

struct Node *createNode(int new_data) {
    struct Node *new_node =
      (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);
    printf("Element at index 3 is %d\\n", GetNth(head, 3));

    return 0;
}

````

Java

````
// Java program to find n\'th node in linked list
// using recursion

import java.io.*;
class Node {
    int data;
    Node next;

    Node(int x){
        data = x;
        next = null;
    }
}

class GfG {

    // Takes head pointer of the linked list and index
    // as arguments and return data at index*/
    static int GetNth(Node head, int index) {

        if (head == null)
            return -1;

        // if index equal to 1 return node.data
        if (index == 1)
            return head.data;

        // recursively decrease n and increase
        // head to next pointer
        return GetNth(head.next, index - 1);
    }

    public static void main(String args[]) {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

        System.out.printf("Element at index 3 is %d",
                          GetNth(head, 3));
    }
}

````

Python

````
# Python program to find the Nth node in
# linked list using recursion

class Node:
    def __init__(self, x):
        self.data = x
        self.next = None

# Recursive method to find the Nth node
def get_nth_node(head, index):

    # Helper function to handle recursion
    #and count tracking
        if head is None:
            print(-1)

        if index == 1:
            print(head.data)
        else:
            get_nth_node(head.next, index-1)

if __name__ == "__main__":

    # Create a linked list: 1 -> 2 -> 3 -> 4 -> 5
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)
    print("Element at index 3 is", end=" ")
    get_nth_node(head, 3)

````

C#

````
// C# program to find the Nth node in
// linked list using recursion

using System;

class Node {
    public int Data;
    public Node Next;

    public Node(int x) {
        Data = x;
        Next = null;
    }
}

class GfG {

    // Takes head pointer of the linked list and index
    // as arguments and returns data at index
    static int GetNth(Node head, int index) {

        // Base Condition
        if (head == null)
            return -1;

        // If n equals 0, return the node\'s data
        if (index == 1)
            return head.Data;

        // Recursively move to the next node
        return GetNth(head.Next, index - 1);
    }

    public static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Next = new Node(3);
        head.Next.Next.Next = new Node(4);
        head.Next.Next.Next.Next = new Node(5);

        Console.WriteLine("Element at index 3 is {0}", GetNth(head, 3));
    }
}

````

JavaScript

````
// JavaScript program to find the n\'th node in
// a linked list using recursion

class Node {
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

function GetNth(head, index) {

    // Base case: if the list is empty or index is out of
    // bounds
    if (head === null) {
        return -1;
    }

    // Base case: if count equals n, return node\'s data
    if (index === 1) {
        return head.data;
    }

    // Recursive case: move to the next node and decrease
    // index
    return GetNth(head.next, index - 1);
}

// Create a hard-coded linked list:
// 1 -> 2 -> 3 -> 4 -> 5
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);
console.log("Element at index 3 is", GetNth(head, 3));

````




**Output**
```
Element at index 3 is 3

```

****Time Complexity :****
O(n)

****,****
where n is the nth node of linked list.



****Auxiliary Space:****
O(n), for recursive call stack


### ****[Expected Approach-2] Iterative Method – O(n) Time and O(1) Space****

> The idea is similar to recursive
>
> ****approach to find****
> the value at
>
> ****index****
> node
>
> ****(1- based)****
> .We will use a variable say,
>
> ****count = 1****
> to track the node
>
> ****s.****
> Traverse the list until
>
> ****curr != NULL****
> . Increment the
>
>
> count
>
>
> if count is
>
> ****not equal****
> to
>
> ****index****
> node
>
> ****(1- based) ,****
> else if count equals to the
>
> ****index****
> node, return data at
>
> ****current****
> node.


Below is the implementation of above approach :


C++

````
// C++ program to find n\'th
// node in linked list (iteratively)

#include <iostream>
using namespace std;

class Node {
  public:
    int data;
    Node *next;
    Node(int x) {
        data = x;
        next = nullptr;
    }
};

// Function to find the nth node in the list
int GetNth(Node *head, int index) {
    Node *curr = head;
    int count = 1;

    while (curr != nullptr) {
        if (count == index)
            return curr->data;
        count++;
        curr = curr->next;
    }

    return -1;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    Node *head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Element at index 3 is " << GetNth(head, 3) << endl;

    return 0;
}

````

C

````
// C program to find n\'th
// node in linked list (iteratively)

#include <stdio.h>
struct Node {
    int data;
    struct Node *next;
};

// Function to find the nth node in the list
int GetNth(struct Node *head, int index)
{
    struct Node *curr = head;
    int count = 1;
    while (curr != NULL) {
        if (count == index)
            return curr->data;
        count++;
        curr = curr->next;
    }

    return -1;
}

struct Node *createNode(int new_data) {
    struct Node *new_node =
      (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);
    printf("Element at index 3 is %d\\n", GetNth(head, 3));
}

````

Java

````
// Java program to find the Nth node in
// a linked list iteratively

class Node {
    int data;
    Node next;
    Node(int x) {
        data = x;
        next = null;
    }
}

class GfG {

    // Function to find the nth node in the list iteratively
    static int getNthNodeIterative(Node head, int index) {
        Node current = head;
        int count = 1;

        // Traverse the list until the end or until the nth
        // node is reached
        while (current != null) {
            if (count == index) {
                return current.data;
            }
            count++;
            current = current.next;
        }

        // Return -1 if the index is out of bounds
        return -1;
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

        int index = 3;
        int result = getNthNodeIterative(head, index);
        if (result != -1) {
            System.out.println("Element at index " + index
                               + " is " + result);
        }
        else {
            System.out.println("Index " + index
                               + " is out of bounds");
        }
    }
}

````

Python

````
# Python program to find the Nth node in
# a linked list iteratively

class Node:
    def __init__(self, x):
        self.data = x
        self.next = None

# Function to find the nth node in the list iteratively
def get_nth_node_iterative(head, n):
    current = head
    count = 1

    # Traverse the list until the end or until the nth node is reached
    while current is not None:
        if count == n:
            return current.data
        count += 1
        current = current.next

    # Return -1 if the index is out of bounds
    return -1

if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 2 -> 3 -> 4 -> 5
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)
    index = 3
    result = get_nth_node_iterative(head, index)
    if result != -1:
        print(f"Element at index {index} is {result}")
    else:
        print(f"Index {index} is out of bounds")

````

C#

````
// Iterative C# program to find the nth node in
// a linked list

using System;

class Node {
    public int Data;
    public Node Next;
    public Node(int x) {
        Data = x;
        Next = null;
    }
}

class GfG {

    // Given the head of a list and index, find the nth node
    // and return its data
    static int GetNthNode(Node head, int n) {
        Node current = head;
        int count = 1;

        // Traverse the list until the nth node is found or
        // end of the list is reached
        while (current != null) {
            if (count == n) {
                return current.Data;
            }
            count++;
            current = current.Next;
        }

        // Return -1 if the index is out of bounds
        return -1;
    }

   public static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5
        Node head = new Node(1);
        head.Next = new Node(2);
        head.Next.Next = new Node(3);
        head.Next.Next.Next = new Node(4);
        head.Next.Next.Next.Next = new Node(5);
        int index = 3;
        int result = GetNthNode(head, index);
        if (result != -1) {
            Console.WriteLine($"Element at index {index} is {result}");
        }
        else {
            Console.WriteLine($"Index {index} is out of bounds");
        }
    }
}

````

JavaScript

````
// Iterative JavaScript program to find the Nth node in a
// linked list

class Node {
    constructor(x) {
        this.data = x;
        this.next = null;
    }
}

// Given the head of a list and an index, return the data at
// the index
function getNth(head, index) {
    let current = head;
    let count = 1;

    // Traverse the linked list
    while (current !== null) {
        if (count === index) {
            // Return data at the current
            // node if index matches
            return current.data;
        }
        count++;
        current = current.next;
    }

    // Return -1 if index is out of bounds
    return -1;
}

// Create a hard-coded linked list:
// 1 -> 2 -> 3 -> 4 -> 5
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);
let index = 3;
let result = getNth(head, index);
if (result !== -1) {
    console.log(`Element at index ${index} is ${result}`);
}
else {
    console.log(`Index ${index} is out of bounds`);
}

````




**Output**
```
Element at index 3 is 3

```

****Time Complexity :****
O(n)

****,****
where n is the nth node of linked list.



****Auxiliary Space:****
O(1)', '', 'Write a function to get Nth node in a Linked List', 10, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('c4109005-926f-4553-bb7a-e8751a632d01', e'Given a Linked List of

****M****
nodes and a number

****N****
, find the value at the Nth node from the end of the Linked List. If there is no Nth node from the end, print -1.


****Examples:****

> ****Input:****
> 1 -> 2 -> 3 -> 4, N = 3
>
>
>
> ****Output:****
> 2
>
>
>
> ****Explanation:****
> Node 2 is the third node from the end of the linked list.
>
>
> ****Input:****
> 35 -> 15 -> 4 -> 20, N = 4
>
>
>
> ****Output:****
> 35
>
>
>
> ****Explanation:****
> Node 35 is the fourth node from the end of the linked list.

Table of Content

* [[Naive Approach] By Finding the length of list – Two Pass – O(M) Time and O(1) Space](#naive-approach-finding-the-length-of-list-and-return-the-node-two-pass-om-time-and-o1-space)
* [[Expected Approach] Using Two Pointers – One Pass – O(M) Time and O(1) Space](#expected-approach-using-two-pointers-one-pass-om-time-and-o1-space)
### ****[Naive Approach]**** Finding the length of list – Two Pass – O(M) Time and O(1) Space

> The idea is to count the number of nodes in linked list in the first pass, say
>
> ****len****
> . In the second pass, return the
>
> ****(len – n + 1)th****
> nodes from beginning of the Linked List.

C++14

````
// C++ program to find Nth node from end of linked list

#include <bits/stdc++.h>
using namespace std;

// Link list node
struct Node {
    int data;
    Node* next;

      // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// Function to find the Nth node from the last of a linked list
int findNthFromLast(Node* head, int N) {
    int len = 0, i;

      // Pointer to store the copy of head
    Node* temp = head;

    // Count the number of nodes in Linked List
    while (temp != NULL) {
        temp = temp->next;
        len++;
    }

    // Check if value of N is not
    // more than length of the linked list
    if (len < N)
        return -1;

    temp = head;

    // Get the (len - N + 1)th node from the beginning
    for (i = 1; i < len - N + 1; i++)
        temp = temp->next;

    return temp->data;
}

int main() {

    // Create a hard-coded linked list:
    // 35 -> 15 -> 4 -> 20
    Node* head = new Node(35);
    head->next = new Node(15);
    head->next->next = new Node(4);
    head->next->next->next = new Node(20);

    // Function Call to find the 4th node from end
    cout << findNthFromLast(head, 4);
    return 0;
}

````

C

````
// C program to find Nth node from end of linked list

#include <stdio.h>

// Link list node
struct Node {
    int data;
    struct Node* next;
};

// Function to find the Nth node from the last of a linked list
int findNthFromLast(struct Node* head, int N) {
    int len = 0, i;

    // Pointer to store the copy of head
    struct Node* temp = head;

    // Count the number of nodes in Linked List
    while (temp != NULL) {
        temp = temp->next;
        len++;
    }

    // Check if value of N is not more than length of the linked list
    if (len < N)
        return -1;

    temp = head;

    // Get the (len - N + 1)th node from the beginning
    for (i = 1; i < len - N + 1; i++)
        temp = temp->next;

    return temp->data;
}

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node =
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 35 -> 15 -> 4 -> 20
    struct Node* head = createNode(35);
    head->next = createNode(15);
    head->next->next = createNode(4);
    head->next->next->next = createNode(20);

    // Function Call to find the 4th node from end
    printf("%d\\n", findNthFromLast(head, 4));

    return 0;
}

````

Java

````
// Java program to find Nth node from
// end of linked list

// Link list node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

public class GFG {
      // Function to find the Nth node from the last of a linked list
    static int findNthFromLast(Node head, int N) {
        int len = 0, i;

        // Pointer to store the copy of head
        Node temp = head;

        // Count the number of nodes in Linked List
        while (temp != null) {
            temp = temp.next;
            len++;
        }

        // Check if value of N is not more than length of the linked list
        if (len < N)
            return -1;

        temp = head;

        // Get the (len - N + 1)th node from the beginning
        for (i = 1; i < len - N + 1; i++)
            temp = temp.next;

        return temp.data;
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 35 -> 15 -> 4 -> 20
        Node head = new Node(35);
        head.next = new Node(15);
        head.next.next = new Node(4);
        head.next.next.next = new Node(20);

        // Function Call to find the 4th node from end
        System.out.println(findNthFromLast(head, 4));
    }
}

````

Python

````
# Python3 program to find Nth node from end of linked list

# Link list node
class Node:

   # Constructor to initialize a new node with data
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Function to find the Nth node from the last of a linked list
def findNthFromLast(head, N):
    length = 0
    temp = head

    # Count the number of nodes in Linked List
    while temp is not None:
        temp = temp.next
        length += 1

    # Check if value of N is not more than length of the linked list
    if length < N:
        return -1

    temp = head

    # Get the (length - N + 1)th node from the beginning
    for _ in range(1, length - N + 1):
        temp = temp.next

    return temp.data

if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 35 -> 15 -> 4 -> 20
    head = Node(35)
    head.next = Node(15)
    head.next.next = Node(4)
    head.next.next.next = Node(20)

    # Function Call to find the 4th node from end
    print(findNthFromLast(head, 4))

````

C#

````
// C# program to find N\'th node from end of linked list
using System;

// Link list node
class Node {
    public int data;
    public Node next;

    // Constructor to initialize a new node with data
    public Node(int new_data) {
        data = new_data;
        next = null;
    }
}

// Function to find the Nth node from the last of a linked list
class GFG {
    static int FindNthFromLast(Node head, int N) {
        int len = 0;
        Node temp = head;

        // Count the number of nodes in Linked List
        while (temp != null) {
            temp = temp.next;
            len++;
        }

        // Check if value of N is not more than length of the linked list
        if (len < N)
            return -1;

        temp = head;

        // Get the (len - N + 1)th node from the beginning
        for (int i = 1; i < len - N + 1; i++)
            temp = temp.next;

        return temp.data;
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 35 -> 15 -> 4 -> 20
        Node head = new Node(35);
        head.next = new Node(15);
        head.next.next = new Node(4);
        head.next.next.next = new Node(20);

        // Function Call to find the 4th node from end
        Console.WriteLine(FindNthFromLast(head, 4));
    }
}

````

JavaScript

````
// Javascript program to find N\'th node from end of linked list

// Link list node
class Node {

    // Constructor to initialize a new node with data
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Function to find the Nth node from the last of a linked list
function findNthFromLast(head, N) {
    let len = 0;
    let temp = head;

    // Count the number of nodes in Linked List
    while (temp !== null) {
        temp = temp.next;
        len++;
    }

    // Check if value of N is not more than length of the linked list
    if (len < N) {
        return -1;
    }

    temp = head;

    // Get the (len - N + 1)th node from the beginning
    for (let i = 1; i < len - N + 1; i++) {
        temp = temp.next;
    }

    return temp.data;
}

// Create a hard-coded linked list:
// 35 -> 15 -> 4 -> 20
let head = new Node(35);
head.next = new Node(15);
head.next.next = new Node(4);
head.next.next.next = new Node(20);

// Function Call to find the 4th node from end
console.log(findNthFromLast(head, 4));

````




**Output**
```
35
```

****Time complexity:****
O(M) where

****M****
is the size of the linked list



****Auxiliary Space:****
O(1)


### [Expected Approach] Using Two Pointers – One Pass – O(M) Time and O(1) Space

> The idea is to maintain two pointers, say
>
> ****main\\_ptr****
> and
>
> ****ref\\_ptr****
> point to the head of Linked List and move
>
> ****ref\\_ptr****
> to the Nth node from the head to ensure that the distance between main\\_ptr and ref\\_ptr is
>
> ****(N – 1)****
> . Now, move both the pointers simultaneously until ref\\_ptr reaches the last node. Since the distance between main\\_ptr and ref\\_ptr is (N – 1), so when ref\\_ptr will reach the
>
> ****last node****
> , main\\_ptr will reach
>
> ****Nth****
> node from the end of Linked List. Return the value of node pointed by main\\_ptr.


Below image is a dry run of the above approach:








Follow the given steps to solve the problem:


* Maintain two pointers

  ****main\\_ptr****
  and

  ****ref\\_ptr****
* Move ref\\_ptr to the Nth node from the start
* Now move both main\\_ptr and ref\\_ptr, until the ref\\_ptr reaches the last node
* Now return the data of the main\\_ptr, as it is at the Nth node from the end

C++

````
// C++ program to find Nth node from end of linked list

#include <bits/stdc++.h>
using namespace std;

// Link list node
struct Node {
    int data;
    Node* next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// function to find Nth node from the end of linked list
int nthFromEnd(Node *head, int N) {

    // create two pointers main_ptr and ref_ptr
    // initially pointing to head.
    Node* main_ptr = head;
    Node* ref_ptr = head;

    // move ref_ptr to the n-th node from beginning.
    for (int i = 1; i < N; i++) {
        ref_ptr = ref_ptr->next;

          // If the ref_ptr reaches NULL, then it means
          // N > length of linked list
        if (ref_ptr == NULL) {
            return -1;
        }
    }

    // move ref_ptr and main_ptr by one node until
    // ref_ptr reaches last node of the list.
    while (ref_ptr->next != NULL) {
        ref_ptr = ref_ptr->next;
        main_ptr = main_ptr->next;
    }

    return main_ptr->data;
}

int main() {

    // Create a hard-coded linked list:
    // 35 -> 15 -> 4 -> 20
    Node* head = new Node(35);
    head->next = new Node(15);
    head->next->next = new Node(4);
    head->next->next->next = new Node(20);

    // Function Call to find the 4th node from end
    cout << nthFromEnd(head, 4);
    return 0;
}

````

C

````
// C program to find Nth node from end of linked list

#include <stdio.h>

// Link list node
struct Node {
    int data;
    struct Node* next;
};

// Function to find the Nth node from the last of a linked
// list
int findNthFromLast(struct Node* head, int N) {

    // Create two pointers main_ptr and ref_ptr initially
    // pointing to head
    struct Node* main_ptr = head;
    struct Node* ref_ptr = head;

    // Move ref_ptr to the N-th node from the beginning
    for (int i = 1; i < N; i++) {
        ref_ptr = ref_ptr->next;

        // If the ref_ptr reaches NULL, then it means
        // N > length of linked list
        if (ref_ptr == NULL) {
            return -1;
        }
    }

    // Move ref_ptr and main_ptr by one node until ref_ptr
    // reaches the last node of the list
    while (ref_ptr->next != NULL) {
        ref_ptr = ref_ptr->next;
        main_ptr = main_ptr->next;
    }

    return main_ptr->data;
}

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node
        = (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded linked list:
    // 35 -> 15 -> 4 -> 20
    struct Node* head = createNode(35);
    head->next = createNode(15);
    head->next->next = createNode(4);
    head->next->next->next = createNode(20);

    // Function Call to find the 4th node from end
    printf("%d\\n", findNthFromLast(head, 4));

    return 0;
}

````

Java

````
// Java program to find Nth node from end of linked list

// Link list node
class Node {
    int data;
    Node next;

    // Constructor to initialize a new node with data
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

public class GFG {

    // Function to find Nth node from the end of linked list
    static int nthFromEnd(Node head, int N) {

        // Create two pointers main_ptr and ref_ptr
        // initially pointing to head.
        Node main_ptr = head;
        Node ref_ptr = head;

        // Move ref_ptr to the N-th node from beginning.
        for (int i = 1; i < N; i++) {
            ref_ptr = ref_ptr.next;

            // If the ref_ptr reaches NULL, then it means
            // N > length of linked list
            if (ref_ptr == null) {
                return -1;
            }
        }

        // Move ref_ptr and main_ptr by one node until
        // ref_ptr reaches last node of the list.
        while (ref_ptr.next != null) {
            ref_ptr = ref_ptr.next;
            main_ptr = main_ptr.next;
        }

        return main_ptr.data;
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 35 -> 15 -> 4 -> 20
        Node head = new Node(35);
        head.next = new Node(15);
        head.next.next = new Node(4);
        head.next.next.next = new Node(20);

        // Function Call to find the 4th node from end
        System.out.println(nthFromEnd(head, 4));
    }
}

````

Python

````
# Python3 program to find Nth node from end of linked list

# Link list node
class Node:

      # Constructor to initialize a new node with data
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Function to find Nth node from the end of linked list
def nth_from_end(head, N):

    # Create two pointers main_ptr and ref_ptr
    # initially pointing to head.
    main_ptr = head
    ref_ptr = head

    # Move ref_ptr to the N-th node from beginning.
    for _ in range(1, N):
        ref_ptr = ref_ptr.next

        # If the ref_ptr reaches None, then it means
        # N > length of linked list
        if ref_ptr is None:
            return -1

    # Move ref_ptr and main_ptr by one node until
    # ref_ptr reaches last node of the list.
    while ref_ptr.next is not None:
        ref_ptr = ref_ptr.next
        main_ptr = main_ptr.next

    return main_ptr.data

if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 35 -> 15 -> 4 -> 20
    head = Node(35)
    head.next = Node(15)
    head.next.next = Node(4)
    head.next.next.next = Node(20)

    # Function Call to find the 4th node from end
    print(nth_from_end(head, 4))

````

C#

````
// C# program to find Nth node from end of linked list
using System;

class GFG {

    // Node class for the linked list
    class Node {
        public int Data;
        public Node Next;

          // Constructor to initialize a new node with data
        public Node(int newData) {
            Data = newData;
            Next = null;
        }
    }

    // Function to find the Nth node from the end of the
    // linked list
    static int NthFromEnd(Node head, int N) {
        Node mainPtr = head;
        Node refPtr = head;

        // Move refPtr to the N-th node from the beginning
        for (int i = 1; i < N; i++) {
            refPtr = refPtr ?.Next;

            // If the refPtr reaches null, then N > length
            // of linked list
            if (refPtr == null) {
                return -1;
            }
        }

        // Move refPtr and mainPtr by one node until refPtr
        // reaches the last node
        while (refPtr?.Next != null) {
            refPtr = refPtr.Next;
            mainPtr = mainPtr.Next;
        }

        return mainPtr.Data;
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 35 -> 15 -> 4 -> 20
        Node head = new Node(35);
        head.Next = new Node(15);
        head.Next.Next = new Node(4);
        head.Next.Next.Next = new Node(20);

        // Function call to find the 4th node from the end
        Console.WriteLine(NthFromEnd(head, 4));
    }
}

````

JavaScript

````
// javascript program to find n\'th
// node from end of linked list

// Linked List Node
class Node {

    // Constructor to initialize a new node with data
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// Function to find Nth node from the end of linked list
function nthFromEnd(head, N) {
    let mainPtr = head;
    let refPtr = head;

    // Move refPtr to the N-th node from the beginning
    for (let i = 1; i < N; i++) {
        refPtr = refPtr.next;

        if (refPtr === null) {

            // If N is greater than the length of the linked list
            return -1;
        }
    }

    // Move refPtr and mainPtr by one node until refPtr reaches the last node
    while (refPtr.next !== null) {
        refPtr = refPtr.next;
        mainPtr = mainPtr.next;
    }

    return mainPtr.data;
}

// Create a hard-coded linked list:
// 35 -> 15 -> 4 -> 20
const head = new Node(35);
head.next = new Node(15);
head.next.next = new Node(4);
head.next.next.next = new Node(20);

// Function call to find the 4th node from end
console.log(nthFromEnd(head, 4));

````




**Output**
```
Node no. 4 from end is: 35

```

****Time Complexity:****
O(M) where

****M****
is the length of the linked list



****Auxiliary Space:****
O(1)', '', 'Program for Nth node from the end of a Linked List', 11, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('0f29c6e9-3edb-43c1-b60d-41e4c65c90e0', e'Given a

[doubly linked list](https://www.geeksforgeeks.org/doubly-linked-list/)
, The task is to find the

****number of nodes in****
the given doubly linked list.


Example:


> ****Input****
> : 1<->2<->3<->4
>
>
>
> ****output****
> : 4
>
>
> ****Input****
> : 1<->2
>
>
>
> ****output****
> : 2

### By Traversing the Doubly linked list – O(n) Time and O(1) Space

> The idea is to traverse the doubly linked list starting from the
>
> ****head****
> node. Increment the
>
> ****size****
> variable until we reaches end.


Algorithm :


* Initialize a variable

  ****size****
  to 0
* Initialize a

  ****curr****
  node to

  ****head****
* Do the following while the

  ****curr node****
  is not NULL
  + ****curr = curr -> next****
  + ****size++;****
* Return

  ****size****
  .


Below is the implementation of above approach:


C++

````
// C++ program to
// find size of doubly linked list.
#include <bits/stdc++.h>
using namespace std;

class Node {
  public:
    int data;
    Node *next;
    Node *prev;
    Node(int val) {
        data = val;
        next = nullptr;
        prev = nullptr;
    }
};

// This function returns size of linked list
int findSize(Node *curr) {
    int size = 0;
    while (curr != NULL) {
        size++;
        curr = curr->next;
    }
    return size;
}

int main() {

    // Create a hard-coded doubly linked list:
    // 1 <-> 2 <-> 3 <-> 4
    Node *head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;
    head->next->next->next = new Node(4);
    head->next->next->next->prev = head->next->next;

    cout << findSize(head);
    return 0;
}

````

C

````
// C program to find size of doubly linked list.
#include <stdio.h>

struct Node {
  int data;
  struct Node* prev;
  struct Node* next;
};


int findSize(struct Node* curr) {
  int size = 0;
  while (curr != NULL) {
    size++;
    curr = curr->next;
  }
  return size;
}

struct Node *createNode(int new_data) {
    struct Node *new_node =
      (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}

int main() {

    // Create a hard-coded doubly linked list:
    // 1 <-> 2 <-> 3 <-> 4
    struct Node *head = createNode(1);
    head->next = createNode(2);
    head->next->prev = head;
    head->next->next = createNode(3);
    head->next->next->prev = head->next;
    head->next->next->next = createNode(4);
    head->next->next->next->prev = head->next->next;
      printf("%d", findSize(head));

  return 0;
}

````

Java

````
// A complete working Java program to
// find the size of a doubly linked list.
class Node {
    int data;
    Node next;
    Node prev;

    Node(int val) {
        data = val;
        next = null;
        prev = null;
    }
}

public class GfG {

    // This function returns the size of
      // the linked list
    static int findSize(Node curr) {
        int size = 0;
        while (curr != null) {
            size++;
            curr = curr.next;
        }
        return size;
    }

    public static void main(String[] args) {

        // Create a hard-coded doubly linked list:
        // 1 <-> 2 <-> 3 <-> 4
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;
        head.next.next.next = new Node(4);
        head.next.next.next.prev = head.next.next;

        System.out.println(findSize(head));
    }
}

````

Python

````
# A complete working Python program to
# find the size of a doubly linked list.

class Node:
    def __init__(self, val):
        self.data = val
        self.next = None
        self.prev = None

# This function returns the size of
# the linked list
def find_size(curr):
    size = 0
    while curr:
        size += 1
        curr = curr.next
    return size

if __name__ == "__main__":

    # Create a hard-coded doubly linked list:
    # 1 <-> 2 <-> 3 <-> 4
    head = Node(1)
    head.next = Node(2)
    head.next.prev = head
    head.next.next = Node(3)
    head.next.next.prev = head.next
    head.next.next.next = Node(4)
    head.next.next.next.prev = head.next.next

    print(find_size(head))

````

C#

````
// A complete working C# program to
// find the size of a doubly linked list.
using System;

class Node {
    public int data;
    public Node next;
    public Node prev;

    public Node(int val) {
        data = val;
        next = null;
        prev = null;
    }
}

class GfG {

    // This function returns the size of
      // the linked list
    static int FindSize(Node curr) {
        int size = 0;
        while (curr != null) {
            size++;
            curr = curr.next;
        }
        return size;
    }

    static void Main() {

        // Create a hard-coded doubly linked list:
        // 1 <-> 2 <-> 3 <-> 4
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.prev = head;
        head.next.next = new Node(3);
        head.next.next.prev = head.next;
        head.next.next.next = new Node(4);
        head.next.next.next.prev = head.next.next;

        Console.WriteLine(FindSize(head));
    }
}

````

JavaScript

````
// A complete working JavaScript program to
// find the size of a doubly linked list.

class Node {
    constructor(val) {
        this.data = val;
        this.next = null;
        this.prev = null;
    }
}

// This function returns the size
// of the linked list
function findSize(curr) {
    let size = 0;
    while (curr !== null) {
        size++;
        curr = curr.next;
    }
    return size;
}

// Create a hard-coded doubly linked list:
// 1 <-> 2 <-> 3 <-> 4
let head = new Node(1);
head.next = new Node(2);
head.next.prev = head;
head.next.next = new Node(3);
head.next.next.prev = head.next;
head.next.next.next = new Node(4);
head.next.next.next.prev = head.next.next;

console.log(findSize(head));

````




**Output**
```
4
```

****Time Complexity: O(n),****
where n is the number of nodes in the linked list.



****Auxiliary Space:****

****O(1)****', '', 'Program to find size of Doubly Linked List', 12, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('0c68fc2c-a6d9-4306-a996-07fbf5dccb2e', e'Given a

****singly linked list,****
the task is to remove every k

th
node of the linked list. Assume that k is always less than or equal to the length of the Linked List.


****Examples :****


> ****Input:****
> LinkedList: 1 -> 2 -> 3 -> 4 -> 5 -> 6, k = 2
>
>
>
> ****Output:****
> 1 -> 3 -> 5
>
>
>
> ****Explanation:****
> After removing every 2nd node of the linked list, the resultant linked list will be: 1 -> 3 -> 5 .
>
>
> ****Input:****
> LinkedList: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10, k = 3
>
>
>
> ****Output:****
> 1 -> 2 -> 4 -> 5 -> 7 -> 8 -> 10
>
>
>
> ****Explanation:****
> After removing every 3rd node of the linked list, the resultant linked list will be: 1 -> 2 -> 4 -> 5 -> 7 -> 8 -> 10.

### [Expected Approach – 1] Iterative Approach – O(n) Time and O(1) Space

> The idea is to traverse the linked list while maintaining a
>
> ****counter****
> to track node positions. Every time the counter reaches
>
> ****k,****
> update the next pointer of the
>
> ****previous****
> node to
>
> ****skip****
> the current k
>
> th
> node, effectively removing it from the list. Continue this process until reaching the
>
> ****end****
> of the list. This method ensures that the
>
> ****k****
> ****th****
>
> nodes are removed as required while
>
> ****preserving****
> the rest of the list structure.


Below is the implementation of the above approach:


C++

````
// C++ program to delete every k-th Node of
// a singly linked list.
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int x) {
        data = x;
        next = nullptr;
    }
};

// Function to remove every kth node in the linked list
Node* deleteK(Node* head, int k) {

    // If list is empty or k is 0, return the head
    if (head == nullptr || k <= 0)
        return head;

    Node* curr = head;
    Node* prev = nullptr;

    // Initialize counter to track node positions
    int count = 0;

    // Traverse the linked list
    while (curr != nullptr) {
        count++;

        // If count is a multiple of k, remove current node
        if (count % k == 0) {

            // skip the current node
            if (prev != nullptr) {
                prev->next = curr->next;
            }
            else {

                head = curr->next;
            }
        }
        else {

            // Update previous node pointer only if
            // we do not remove the node
            prev = curr;
        }
        curr = curr->next;
    }

    return head;
}

void printList(Node* head) {

    Node* curr = head;
    while (curr != nullptr) {
        cout << curr->data << " ";
        curr = curr->next;
    }
}

int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5 -> 6
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);
    head->next->next->next->next->next = new Node(6);
    int k = 2;
    head = deleteK(head, k);
    printList(head);

    return 0;
}

````

C

````
// C program to delete every k-th Node of
// a singly linked list.
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

// Function to remove every kth node in the linked list
struct Node* deleteK(struct Node* head, int k) {

    // If list is empty or k is 0, return the head
    if (head == NULL || k <= 0)
        return head;

    struct Node* curr = head;
    struct Node* prev = NULL;

    int count = 0;

    while (curr != NULL) {
        count++;

        // If count is a multiple of k, remove
        // current node
        if (count % k == 0) {

            // skip the current node
            if (prev != NULL) {
                prev->next = curr->next;
            }
            else {

                head = curr->next;
            }
            free(curr);
            curr = prev != NULL ? prev->next : head;
        }
        else {

            // Update previous node pointer only if
            // we do not remove the node
            prev = curr;
            curr = curr->next;
        }
    }
    return head;
}

void printList(struct Node* node) {
   struct Node* curr = node;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }
    printf("\\n");
}

struct Node* createNode(int new_data) {
    struct Node* new_node =
        (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}


int main() {

    // Create a hard-coded linked list:
    // 1 -> 2 -> 3 -> 4 -> 5 -> 6
    struct Node* head = createNode(1);
    head->next = createNode(2);
    head->next->next = createNode(3);
    head->next->next->next = createNode(4);
    head->next->next->next->next = createNode(5);
    head->next->next->next->next->next = createNode(6);

    int k = 2;
    head = deleteK(head, k);

    printList(head);

    return 0;
}

````

Java

````
// Java program to delete every k-th Node of
// a singly linked list.
class Node {
    int data;
    Node next;

    Node(int newData) {
        data = newData;
        next = null;
    }
}

public class GfG {

    // Function to remove every kth node in the
    // linked list
    static Node deleteK(Node head, int k) {

        // If list is empty or k is 0, return the head
        if (head == null || k <= 0)
            return head;

        Node curr = head;

        Node prev = null;

        int count = 0;

        // Traverse the linked list
        while (curr != null) {

            // Increment the counter for each node
            count++;

            // If count is a multiple of k, remove
            // current node
            if (count % k == 0) {

                // skip the current node
                if (prev != null) {
                    prev.next = curr.next;
                }
               else {

                    // If removing the head node
                    head = curr.next;
                }
            }
           else {

                // Update previous node pointer only if
                // we do not remove the node
                prev = curr;
            }
            curr = curr.next;
        }

        return head;
    }

    static void printList(Node head) {

        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5 -> 6
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);
        head.next.next.next.next.next = new Node(6);
        int k = 2;

        head = deleteK(head, k);

        printList(head);
    }
}

````

Python

````
# Python program to delete every k-th Node of
# a singly linked list.
class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Function to remove every kth node in the linked list
def delete_k(head, k):

    # If list is empty or k is 0, return the head
    if head is None or k <= 0:
        return head

    curr = head
    prev = None

    count = 0

    while curr is not None:
        count += 1

        # If count is a multiple of k, remove current node
        if count % k == 0:

            # Bypass the current node
            if prev is not None:
                prev.next = curr.next
            else:

                # If removing the head node
                head = curr.next
        else:

            # Update previous node pointer only if
            # we do not remove the node
            prev = curr

        curr = curr.next

    return head

def print_list(head):
    curr = head
    while curr is not None:
        print(curr.data, end=" ")
        curr = curr.next
    print()

if __name__ == "__main__":

    # Create a hard-coded linked list:
    # 1 -> 2 -> 3 -> 4 -> 5 -> 6
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    head.next.next.next = Node(4)
    head.next.next.next.next = Node(5)
    head.next.next.next.next.next = Node(6)
    k = 2
    head = delete_k(head, k)
    print_list(head)

````

C#

````
// C# program to delete every k-th Node of
// a singly linked list.
using System;

class Node {
    public int Data;
    public Node next;

    public Node(int newData) {
        Data = newData;
        next = null;
    }
}

class GfG {

    // Function to remove every kth node in the linked list
    static Node DeleteK(Node head, int k) {

        // If list is empty or k is 0, return the head
        if (head == null || k <= 0)
            return head;

        Node curr = head;
        Node prev = null;

        int count = 0;

        while (curr != null) {
            count++;

            // If count is a multiple of k, remove
            // current node
            if (count % k == 0) {

                // Bypass the current node
                if (prev != null) {
                    prev.next = curr.next;
                }
                else {

                    // If removing the head node
                    head = curr.next;
                }
            }
            else {

                // Update previous node pointer only if
                // we do not remove the node
                prev = curr;
            }
            curr = curr.next;
        }
        return head;
    }

    static void PrintList(Node curr) {
        while (curr != null) {
            Console.Write(curr.Data + " ");
            curr = curr.next;
        }
        Console.WriteLine();
    }

    static void Main() {

        // Create a hard-coded linked list:
        // 1 -> 2 -> 3 -> 4 -> 5 -> 6
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);
        head.next.next.next.next.next = new Node(6);

        int k = 2;
        head = DeleteK(head, k);

        PrintList(head);
    }
}

````

JavaScript

````
// Javascript program to delete every k-th Node of
// a singly linked list.
class Node {
    constructor(newData) {
        this.data = newData;
        this.next = null;
    }
}

// Function to remove every kth node in the linked list
function deleteK(head, k) {

    // If list is empty or k is 0, return the head
    if (head === null || k <= 0) {
        return head;
    }

    let curr = head;
    let prev = null;
    let count = 0;

    // Traverse the linked list
    while (curr !== null) {
        count++;

        // If count is a multiple of k, remove
        // current node
        if (count % k === 0) {

            // skip the current node
            if (prev !== null) {
                prev.next = curr.next;
            }
            else {

                // If removing the head node
                head = curr.next;
            }
        }
        else {

            // Update previous node pointer only if
            // we do not remove the node
            prev = curr;
        }
        curr = curr.next;
    }
    return head;
}

function printList(curr) {
    let output = "";
    while (curr !== null) {
        output += curr.data + " ";
        curr = curr.next;
    }
    console.log(output.trim());
}

// Create a hard-coded linked list:
// 1 -> 2 -> 3 -> 4 -> 5 -> 6
let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);
head.next.next.next.next.next = new Node(6);

let k = 2;
head = deleteK(head, k);

printList(head);

````




**Output**
```
1 3 5
```

****Time Complexity :****
O(n),


where

****n****
is the number of nodes.



****Auxiliary Space :****
O(1)', '', 'Remove every k-th node of the linked list', 13, null, 'bd157822-862c-4b14-80e0-791fb1f7f1f6', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('5579b7b8-f82f-4a7d-9fe5-7ec75bf66434', e'Basic Terminologies of Queue
----------------------------

* ****Front:**** Position of the entry in a queue ready to be served, that is, the
  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.
* ****Rear:****
  Position of the last entry in the queue, that is, the one most
  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.
* ****Size:**** Size refers to the ****current**** number of elements in the queue.
* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.

****Representation of Queue****
-------------------------------

![Representation-of-Queue-Data-Structure](https://media.geeksforgeeks.org/wp-content/uploads/20241212130245410876/Representation-of-Queue-Data-Structure-768.webp)

Operations on Queue
-------------------

### ****1. Enqueue:****

Enqueue operation ****adds (or stores) an element to the end of the queue****. 

****Steps:****

1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.
2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.
3. Insert the element at the rear.


![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)


![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)


![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)


![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)


![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)


![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)



Previous





Pause

Next





3 / 6



### ****2. Dequeue:****

Dequeue operation removes the element at the front of the queue. The
following steps are taken to perform the dequeue operation:


1. Check if the ****queue is empty****. If so, return an ****underflow**** error.
2. Remove the element at the ****front****.
3. ****Increment**** the ****front**** pointer to the next element.


![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)



Previous





Play

Next





1 / 6



### ****3. Peek or Front Operation:****

This operation returns the element at the front end without removing
it.

### 4. Size Operation:

This operation returns the numbers of elements present in the
queue.

### ****5. isEmpty Operation:****

This operation returns a boolean value that indicates whether the queue
is empty or not.

### ****6. isFull Operation:****

This operation returns a boolean value that indicates whether the queue
is full or not.

Implementation of Queue Data Structure
--------------------------------------

Queue can be implemented using following data structures:

* [Implementation of Queue using Arrays](https://www.geeksforgeeks.org/introduction-and-array-implementation-of-queue)
* [Implementation of Queue using Linked List](https://www.geeksforgeeks.org/queue-linked-list-implementation)

Complexity Analysis of Operations on Queue
------------------------------------------

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****enqueue**** | O(1) | O(1) |
| ****dequeue**** | O(1) | O(1) |
| front | O(1) | O(1) |
| size | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| isFull | O(1) | O(1) |

****Types of Queues****
-----------------------

Queue data structure can be classified into 4 types:

1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the
   element from the front of the queue.
2. [****Double-Ended Queue (Deque)****](https://www.geeksforgeeks.org/deque-set-1-introduction-applications)****:****
   In a double-ended queue the insertion and deletion operations, both
   can be performed from both ends. They are of two types:
   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be
     taken from only one end but deletion can be done from any of the
     ends.
   * ****Output Restricted Queue:****
     This is also a simple queue. In this type of queue, the input can
     be taken from both ends but deletion can be done from only one
     end.
3. [****Circular Queue:****](https://www.geeksforgeeks.org/introduction-to-circular-queue) This is a special type of queue where the last position is connected
   back to the first position. Here also the operations are performed in
   FIFO order.
4. [****Priority Queue****](https://www.geeksforgeeks.org/priority-queue-set-1-introduction)****:****
   A priority queue is a special queue where the elements are accessed
   based on the priority assigned to them. They are of two types:
   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in
     increasing order of their priority values. Element with smallest
     priority value is popped first.
   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in
     decreasing order of their priority values. Element with largest
     priority is popped first.

![Types-of-Queue](https://media.geeksforgeeks.org/wp-content/uploads/20241212125924381216/Types-of-Queue-660.webp)

****Applications of Queue Data Structure****
--------------------------------------------

Application of queue is common. In a computer system, there may be
queues of tasks waiting for the printer, for access to disk storage, or
even in a time-sharing system, for use of the CPU. Within a single
program, there may be multiple requests to be kept in a queue, or one
task may create other tasks, which must be done in turn by keeping them
in a queue.

* A Queue is always used as a buffer when we have a speed mismatch
  between a producer and consumer. For example keyboard and CPU.
* Queue can be used where we have a single resource and multiple
  consumers like a single CPU and multiple processes.
* In a network, a queue is used in devices such as a router/switch and
  mail queue.
* Queue can be used in various algorithm techniques like Breadth First
  Search, Topological Sort, etc.', e'Queue is a linear data structure that follows FIFO (First In First Out) Principle, so the first element inserted is the first to be popped out.
', 'Introduction to Queue Data Structure', 1, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('562940a2-1089-4c6d-a938-5fe36049bc5f', e'**Basic Operations on Queue:**
------------------------------

Some of the basic operations for Queue in Data Structure are:

* **enqueue() –** Insertion of elements to the queue.
* **dequeue() –** Removal of elements from the queue.
* **peek() or front()-** Acquires the data element available
  at the front node of the queue without deleting it.
* **rear() –** This operation returns the element at the rear
  end without removing it.
* **isFull() –** Validates if the queue is full.
* **isEmpty() –** Checks if the queue is empty.
* **size():** This operation returns the size of the queue
  i.e. the total number of elements it contains.

![](https://media.geeksforgeeks.org/wp-content/uploads/20221209094646/Queue-768.png)

Queue Data Structure

### **Operation 1: enqueue()**

Inserts an element at the end of the queue i.e. at the rear end.

The following steps should be taken to enqueue (insert) data into a queue:

* Check if the queue is full.
* If the queue is full, return overflow error and exit.
* If the queue is not full, increment the rear pointer to point to the
  next empty space.
* Add the data element to the queue location, where the rear is pointing.
* return success.

![Enqueue representation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122158/fifo1-660x371.png)

Enqueue representation

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `printf``(``"\\nQueue is full\\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}` |
| --- |





Java
----

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `System.out.println(``"\\nQueue is full\\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `void` `enqueue(``struct` `Queue* queue,` `int` `item)`  `{`  `if` `(isFull(queue))`  `return``;`  `queue->rear = (queue->rear + 1) % queue->capacity;`  `queue->array[queue->rear] = item;`  `queue->size = queue->size + 1;`  `printf``(``"%d enqueued to queue\\n"``, item);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to add an item to the queue.`  `# It changes rear and size`  `def` `EnQueue(``self``, item):`  `if` `self``.isFull():`  `print``(``"Full"``)`  `return`  `self``.rear` `=` `(``self``.rear` `+` `1``)` `%` `(``self``.capacity)`  `self``.Q[``self``.rear]` `=` `item`  `self``.size` `=` `self``.size` `+` `1`  `print``(``"% s enqueued to queue"` `%` `str``(item))`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `void` `enqueue(``int` `item)`  `{`  `if` `(rear == max - 1) {`  `Console.WriteLine(``"Queue Overflow"``);`  `return``;`  `}`  `else` `{`  `ele[++rear] = item;`  `}`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `enqueue(element){`  `// adding element to the queue`  `this``.items.push(element);`  `}`    `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 2: dequeue()**

This operation removes and returns an element that is at the front end of
the queue.

The following steps are taken to perform the dequeue operation:

* Check if the queue is empty.
* If the queue is empty, return the underflow error and exit.
* If the queue is not empty, access the data where the front is pointing.
* Increment the front pointer to point to the next available data element.
* The Return success.

![Dequeue operation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122625/fifo2-660x371.png)

Dequeue operation

Below is the Implementation of above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `printf``(``"\\nQueue is empty\\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i = 0; i < rear - 1; i++) {`  `queue[i] = queue[i + 1];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}` |
| --- |





Java
----

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `System.out.println(``"\\nQueue is empty\\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i =` `0``; i < rear -` `1``; i++) {`  `queue[i] = queue[i +` `1``];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `int` `dequeue(``struct` `Queue* queue)`  `{`  `if` `(isEmpty(queue)) {`  `printf``(``"\\nQueue is empty\\n"``);`  `return``;`  `}`  `int` `item = queue->array[queue->front];`  `queue->front = (queue->front + 1) % queue->capacity;`  `queue->size = queue->size - 1;`  `return` `item;`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to remove an item from queue.`  `# It changes front and size`      `def` `DeQueue(``self``):`  `if` `self``.isEmpty():`  `print``(``"Queue is empty"``)`  `return`    `print``(``"% s dequeued from queue"` `%` `str``(``self``.Q[``self``.front]))`  `self``.front` `=` `(``self``.front` `+` `1``)` `%` `(``self``.capacity)`  `self``.size` `=` `self``.size` `-` `1`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `public` `int` `dequeue()`  `{`  `if` `(front == rear + 1) {`  `Console.WriteLine(``"Queue is Empty"``);`  `return` `-1;`  `}`  `else` `{`  `int` `p = ele[front++];`  `return` `p;`  `}`  `}`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `dequeue(){`  `// removing element from the queue`  `// returns underflow when called`  `// on empty queue`  `if``(``this``.isEmpty()){`  `document.write(``"<br>Queue is empty<br>"``);`  `return` `-1;`  `}`  `return` `this``.items.shift();`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 3: front()**

This operation returns the element at the front end without removing it.

The following steps are taken to perform the front operation:

* If the queue is empty return the most minimum value.
* otherwise, return the front value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `// Function to get front of queue`  `int` `front(Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}` |
| --- |





Java
----

  



  

  




| `// Function to get front of queue`  `int` `front(Queue queue)`  `{`  `if` `(isempty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.front];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to get front of queue`  `def` `que_front(``self``):`  `if` `self``.isempty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.front]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[front];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `// Function to get front of queue`  `front(){`  `// returns the Front element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[0];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 4 : rear()

This operation returns the element at the rear end without removing it.

The following steps are taken to perform the rear operation:

* If the queue is empty return the most minimum value.
* otherwise, return the rear value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue* queue)`  `{`  `if` `(isEmpty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}` |
| --- |





Java
----

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue queue)`  `{`  `if` `(isEmpty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.rear];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to get rear of queue`  `def` `que_rear(``self``):`  `if` `self``.isEmpty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.rear]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[rear];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `rear(){`  `// returns the Rear element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[``this``.items.length-1];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 5: isEmpty():**

This operation returns a boolean value that indicates whether the queue is
empty or not.

The following steps are taken to perform the Empty operation:

* check if front value is equal to -1 or not, if yes then return true
  means queue is empty.
* Otherwise return false, means queue is not empty

Below is the implementation of the above approach:

* C++
* Java
* C#
* C
* Python3
* Javascript

C++
---

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}` |
| --- |





Java
----

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `boolean` `isEmpty()`  `{`  `if` `(front == -``1``)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C#
--

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by lokeshmvs21.` |
| --- |





C
-

  



  

  




| `// Queue is empty when size is 0`  `bool` `isEmpty(``struct` `Queue* queue)`  `{`  `return` `(queue->size == 0);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Queue is empty when size is 0`  `def` `isEmpty(``self``):`  `return` `self``.size` `=``=` `0`  `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `</script>`  `isEmpty(){`  `// return true if the queue is empty.`  `return` `this``.items.length == 0;`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 6 : isFull()**

This operation returns a boolean value that indicates whether the queue is
full or not.

The following steps are taken to perform the isFull() operation:

* Check if front value is equal to zero and rear is equal to the capacity
  of queue if yes then return true.
* otherwise return false

Below is the Implementation of the above approach:

* C++
* Java
* C
* C#
* Python3
* Javascript

C++
---

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `bool` `isFull()`  `{`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}` |
| --- |





Java
----

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `boolean` `isFull()`  `{`  `if` `(front ==` `0` `&& rear == MAX_SIZE -` `1``) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Queue is full when size becomes`  `// equal to the capacity`  `bool` `isFull(``struct` `Queue* queue)`  `{`  `return` `(queue->size == queue->capacity);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `bool` `isFull(``int` `item) {` `return` `(rear == max - 1); }`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Queue is full when size becomes`  `# equal to the capacity`      `def` `isFull(``self``):`  `return` `self``.size` `=``=` `self``.capacity`    `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `function` `isFull() {`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityamaharshi21.` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 7: size()

This operation returns the size of the queue i.e. the total number of
elements it contains.

```
queuename.size()
Parameters :
No parameters are passed
Returns :
Number of elements in the container
```

* C++
* Java
* Python
* C#
* Javascript

C++
---

  



  

  




| `// CPP program to illustrate`  `// Implementation of size() function`  `#include <iostream>`  `#include <queue>`  `using` `namespace` `std;`    `int` `main()`  `{`  `int` `sum = 0;`  `queue<``int``> myqueue;`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `cout << myqueue.size();`    `return` `0;`  `}` |
| --- |





Java
----

  



  

  




| `// Java program to illustrate implementation of size()`  `// function`    `import` `java.util.*;`    `public` `class` `Main {`  `public` `static` `void` `main(String[] args)`  `{`  `int` `sum =` `0``;`  `Queue<Integer> myqueue =` `new` `LinkedList<>();`  `myqueue.add(``1``);`  `myqueue.add(``8``);`  `myqueue.add(``3``);`  `myqueue.add(``6``);`  `myqueue.add(``2``);`    `// Queue becomes 1, 8, 3, 6, 2`    `System.out.println(myqueue.size());`  `}`  `}`    `// This code is contributed by lokesh.` |
| --- |





Python
------

  



  

  




| `from` `collections` `import` `deque`    `def` `main():`  `sum` `=` `0`  `myqueue` `=` `deque()`  `myqueue.append(``1``)`  `myqueue.append(``8``)`  `myqueue.append(``3``)`  `myqueue.append(``6``)`  `myqueue.append(``2``)`    `# Queue becomes 1, 8, 3, 6, 2`    `print``(``len``(myqueue))`    `main()`    `# This code is contributed by aadityamaharshi21.` |
| --- |





C#
--

  



  

  




| `using` `System;`  `using` `System.Collections.Generic;`    `namespace` `ConsoleApp1 {`  `class` `MainClass {`  `public` `static` `void` `Main(``string``[] args)`  `{`  `int` `sum = 0;`  `Queue<``int``> myqueue =` `new` `Queue<``int``>();`  `myqueue.Enqueue(1);`  `myqueue.Enqueue(8);`  `myqueue.Enqueue(3);`  `myqueue.Enqueue(6);`  `myqueue.Enqueue(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `Console.WriteLine(myqueue.Count);`  `}`  `}`  `}`    `// This code is contributed by adityamaharshi21.` |
| --- |





Javascript
----------

  



  

  




| `// Javascript code`  `let sum = 0;`  `let myqueue=[];`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `console.log(myqueue.length);` |
| --- |







**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

', '', 'Basic Operations for Queue in Data Structure', 3, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('bdde6e1b-edc4-4731-a95b-bd1a61a42a7d', e'![How-to-Learn-DSA](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20220507102444/How-to-Start-Leaning-DSA.jpg)




# DSA Full Form
The Full form of DSA is ****Data Structures and Algorithms****. As the name itself suggests, it is a combination of two separate yet interrelated topics – **Data Structure**
and **Algorithms**. In this journey to acquire a good grasp of DSA and become efficient in it, every programmer faces a big challenge ****“How to start learning DSA?”****. In this article, we will be focusing on everything about DSA and how to begin your journey of DSA from scratch.


## What is Data Structure? 



A  data structure is a particular way of storing and organizing data in our devices to use the data efficiently and effectively. The main idea behind using data structures is to minimize the time and space complexities. An efficient data structure takes minimum memory space and requires minimum time to execute the data.


## What is Algorithm?


Algorithm means a process or set of well-defined instructions that are typically used to solve a particular group of problems or perform a specific type of calculation. To explain in simpler terms, it is a set of operations performed in a step-by-step manner to execute a task.


![](https://media.geeksforgeeks.org/wp-content/uploads/20220502160120/WhatisAlgorithm1024x631-660x407.jpg)


To learn more about algorithms refer to our article about “[****Introduction to Algorithm****](https://www.geeksforgeeks.org/introduction-to-algorithms/)“.


# Why Should you learn Data Structure and Algorithm?

Before moving to the question of “How to start learning”, first, let us look at why should we learn data structures and algorithms.

Every basic, as well as advanced, software and internet service, even searching a topic on the internet, all use one or other data structure or algorithm to implement. So in order to understand how any automated software or service works, it is a must to learn about data structures and algorithms first.

For example, like in our daily life, in order to pour a glass of water from a bottle, we need to implement a series of steps, such as
  - 1. Place the glass in a vertical position with the mouth upwards
  - 2. Open the bottle cap
  - 3. Pick the bottle up
  - 4. Bend the bottle such that the mouth of the bottle is aligned with the mouth of the glass
  - 5. The water will start pouring.
  - 6. Once the glass is filled with water, straight up the bottle again.
  - 7. Keep the bottle down
  - 8. Close the lid of the bottle.


Although these steps seem very basic, they need to be implemented in the same manner every time to get the desired output. As per the definition above, we already know that any set of rules to do a specific task is known as an algorithm. Hence the above-mentioned steps can be distinguished as an algorithm, and the glass can be distinguished as a data structure to store water. Therefore, data structure and algorithms can be seen everywhere in our day-to-day life, and it is very necessary to understand them to perform our daily tasks in life.


To learn in detail about the need for DSA refer to the article on “[****Why data structures and algorithms are necessary****](https://www.geeksforgeeks.org/why-data-structures-and-algorithms-are-important-to-learn/)“.




## 5 Steps to start learning DSA


Let us now move to the most important question “****How to start learning DSA?****“


This procedure may vary from person to person. But here we are trying to provide a general solution to the problem. A beginner can follow the step-by-step process as given below to get started with DSA:


#### **1. Getting to know the topics:**


The most important step is to find out the topics and the best of the resources for those. Before starting to learn about DSA first get an idea of what are the things you need to learn and the available resources for them.


When divided into parts, namely data structure and algorithm; one may follow the below topics in-order while starting to learn DSA:


* ****Data Structure:****
  + [Array](https://www.geeksforgeeks.org/array-data-structure/)
  + [String](https://www.geeksforgeeks.org/category/data-structures/c-strings/)
  + [Matrix](https://www.geeksforgeeks.org/array-data-structure/matrix-data-structure/)
  + [Linked List](https://www.geeksforgeeks.org/data-structures/linked-list/)
  + [Stack](https://www.geeksforgeeks.org/stack-data-structure/)
  + [Queue](https://www.geeksforgeeks.org/queue-data-structure/)
  + [Tree](https://www.geeksforgeeks.org/introduction-to-tree-data-structure/)
  + [Graph](https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/)
    , etc
* ****Algorithms:****
  + [Searching](https://www.geeksforgeeks.org/searching-algorithms/)
  + [Sorting](http://www.geeksforgeeks.org/sorting-algorithms/)
  + [Hashing](http://www.geeksforgeeks.org/hashing-data-structure/)
  + [Prefix sum](https://www.geeksforgeeks.org/prefix-sum-array-implementation-applications-competitive-programming/)
  + [Suffix Sum](https://www.geeksforgeeks.org/suffix-sum-array/)
  + [Greedy](http://www.geeksforgeeks.org/greedy-algorithms/)
  + [Recursion](http://www.geeksforgeeks.org/recursion/)
  + [Backtracking](http://www.geeksforgeeks.org/backtracking-algorithms/)
  + [Tree and Graph traversals](https://www.geeksforgeeks.org/algorithms-gq/graph-traversals-gq/)
  + [Dynamic Programming](https://www.geeksforgeeks.org/dynamic-programming/)
  + Advanced algorithms on tree and graph

#### **2. Finding the best resources for learning DSA**


Once you have known what you have to learn, it is now time to find out from where you have to learn. You can [****learn DSA****](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/) from various text, video or hybrid types of resources such as:
* Textbooks on DSA like Introduction to Algorithms by T.H.Cormen, etc.
* Self Paced Courses on DSA like [Data Structures and Algorithms – Self Paced](https://gfgcdn.com/tu/Ql6/)
* Live Online Classes on DSA like [DSA Live for Working Professionals](https://www.geeksforgeeks.org/courses/geeks-classes-live?utm_source=gfg-article&utm_medium=Q1-2023&utm_campaign=geeks-classes-live)

#### **3. Learn the Fundamentals of DSA properly:**


After gathering all the topics and resources, it’s time to start learning the DSA. To learn about any algorithm and data structure, the most crucial step is to learn the fundamentals first. Without learning the basics properly we cannot implement them properly and also cannot move to advanced applications.


Based on the chosen resources, make sure to spend a keen amount of time learning about the fundamentals of each data structure and the basics of algorithms. Make sure to practice at every step to help solidify your learnings. You can also use our [Practice portal](https://practice.geeksforgeeks.org/) for this purpose.


#### **4. Master data structures and algorithms one by one:**


Once you have become well versed with the fundamentals of DSA, it is now time to learn about the DSA in depth, i.e., know about the various detailed applications of Data Structures, learn about various complex algorithms, and how to implement them in problems.


Here as well you need to keep practicing at every step, to make sure to solidify your DSA learnings. You can also try to attend various coding competitions and challenges to practice and test your learning so far. Here’s a list of [Top 15 websites for coding competitions and challenges (https://www.geeksforgeeks.org/top-15-websites-for-coding-challenges-and-competitions/) that you can try out.


#### **5. Consistency is the key:**


Every monument is built brick by brick by working on a daily basis consistently, and so is the case for DSA. You must try to learn at least 1 new topic every day and solve at least 1 new problem related to it every day. Making this a practice for each day every day will help you master DSA in the best possible manner.


Make sure to give coding challenges at regular intervals as well. You might face challenges in solving even 1 problem in the beginning, but at the end, it will be all worth it. You can try [GeeksforGeeks POTD](https://practice.geeksforgeeks.org/problem-of-the-day) to solve one problem based on DSA every day and here you can also use the discussion forums to help you make sure you get the logic properly. To know more about the discussion portals read the article – [Stuck in Programming: Get The Solution From These 10 Best Websites](https://www.geeksforgeeks.org/stuck-in-programming-get-the-solution-from-these-10-best-websites/)
.


# Key Points to keep in mind to master DSA

#### **1. Spaced Repetition:**

A most common question anyone faces is: “*****I solved a number of questions but still cannot solve them after 7 – 10 days. How can I remember them?*****“.


The first and foremost answer to this is ****Not**** to try to remember the codes. The solution lies in practice and spaced repetition.


> ****Spaced repetition****  is a method to fully learn something by recalling and reviewing the concepts in particular time intervals until you learn the concepts completely.


As seen the best time intervals will be to solve the problem again in a couple of days, then in 7-10 days and then in a month. It will help you to develop the habit of revising any topic at a proper time interval.It is always noticed that if you are revising concepts on spaced repetition so that’s make your concepts more and more well built and clear.


#### **2. Practice more and more:**


By now you are equipped with basic data structures and algorithms. Now the most important thing is your speed and efficiency i.e. how quickly you can find out the optimal solution and minimize the error in your approach.

As with any other work, the only way for this is also to “practice, practice and practice”. You can practice them in several online platforms for practicing problems. Also, you can participate in real-time challenges held time-to-time.

Some of the coding challenges that can help you achieve this are:


* One problem each day of varying difficulty: [Problem Of The Day (POTD).](https://practice.geeksforgeeks.org/problem-of-the-day)
* Choose a problem on your own for any particular topic: [Practice Problems based on specific Data Structures or Algorithms](https://www.geeksforgeeks.org/explore?page=1&sortBy=submissions)

#### **3. Solve a variety of problems:**


Now it is time to increase the size of your arsenal. As you have mastered a handful of data structures and algorithms, let’s venture out to solve problems of varying difficulty and topics.


It will help you in two ways.


* As the problems are not bound by categories, it will increase the pool of your data structures and algorithms through exposure to unknown algorithms. This time you will not require to code all the problems as you have already solved and programmed so many other problems.
* This will also boost your thinking capacity and you will come to know about the applications of different algorithms.


You can also refer to below links to practice problems in its respective difficulties:


* [School level](https://www.geeksforgeeks.org/explore?page=1&difficulty[]=-2&sortBy=submissions)
* [Basic level](https://www.geeksforgeeks.org/explore?page=1&difficulty[]=-1&sortBy=submissions)
* [Easy level](https://www.geeksforgeeks.org/explore?page=1&difficulty[]=0&sortBy=submissions)
* [Medium level](https://www.geeksforgeeks.org/explore?page=1&difficulty[]=1&sortBy=submissions)
* [Hard level](https://www.geeksforgeeks.org/explore?page=1&difficulty[]=2&sortBy=submissions)


You can also try from our curated lists of problems from below articles:


* [SDE SHEET – A Complete Guide for SDE Preparation](https://www.geeksforgeeks.org/sde-sheet-a-complete-guide-for-sde-preparation/)
* [DSA Sheet by Love Babbar](https://www.geeksforgeeks.org/dsa-sheet-by-love-babbar/)

#### **4. Participate in Coding Challenges:**


A good amount of time is dedicated by now and you have also learned a lot. But have you reached your goal of mastering DSA – the reason behind your learning data structures and algorithms?


The only way to get the answer is by checking yourself out against other enthusiasts and original masters of DSA. There is hardly any other solution to this that is better than participating in some competitive coding challenges to gauge your ability. It will increase your coding speed and widen your view of how a problem can have so many varieties of approaches and also it helps you to be familiar with the interview environment because in interview you have time bound so by giving contests repeatedly to your on the path of boost your problem solving skills.


Also upsolving the contest is very much essential help building your concepts more robust. So must remember  always solve the problems that you don’t able to solve in the contest.


#### **5. Try solving Interview questions:**


Though you have done almost everything, there is always room for improvement. Let us assume you are a consistent performer in real-time coding challenges and showing great results in that. Still, it is possible that you are not always finding out the most optimal solution to a problem, because competitive coding does not always require the most efficient approach.


There solving interview questions can prove handy. It is a natural practice in interviews to seek the most optimal approach. Now, by exposing yourself to interview questions you will become efficient day by day and also get prepared for interviews.


You can also try to solve the most asked interview questions based on the list curated by us at:


* [Must Do Coding Questions for Companies](https://www.geeksforgeeks.org/must-do-coding-questions-for-companies-like-amazon-microsoft-adobe/)
* [Top 50 Array Coding Problems for Interviews](https://www.geeksforgeeks.org/top-50-array-coding-problems-for-interviews/)
* [Top 50 String Coding Problems for Interviews](https://www.geeksforgeeks.org/top-50-string-coding-problems-for-interviews/)
* [Top 50 Tree Coding Problems for Interviews](https://www.geeksforgeeks.org/top-50-tree-coding-problems-for-interviews/)
* [Top 50 Dynamic Programming Coding Problems for Interviews](https://www.geeksforgeeks.org/top-50-dynamic-programming-coding-problems-for-interviews/)

## How long does it take to learn Data Structure and Algorithms?


Let us first clarify a thing that learning is a never-ending process. You can learn new things even after programming for years. But a viable question is “How long will it take to learn the basics of DSA”. Though the answer to the question varies from person to person and their time and dedication, an average approximation can be provided for this question. It is fair to say that one can master the basics within ****10-12 weeks**** if one dedicates ****3-4 hours a day****. Again this varies from person to person. One may master it in 1 month and for some, it may take 5-6 months or more than that. This approximation is based on the time offered for courses like the ones run by Swayam (a Government of India initiative), GeeksForGeeks and others.


## How to be good at Data Structure and Algorithms?


Since you have learned how to start learning DSA, the next goal is obviously to be good at DSA. Let us first clarify one thing. There is no easy way to be good at programming. But there is an efficient way to do so.  That depends on factors like:


* Prior knowledge
* Why you want to learn
* Available resources
* A perfect guide.
* Consistency


For more details, refer to the article “

[****How can one become good at Data Structures and Algorithms****](https://www.geeksforgeeks.org/how-can-one-become-good-at-data-structures-and-algorithms-easily/)
“.


# What are the best resources?


As mentioned earlier, now we will discuss about the best possible resources. At ****GeeksForGeeks**** have a vast collection of tutorials and problems related to DSA covering all types of topics from basic to the most advanced ones. Anyone willing to learn about a topic can anytime find the topics in the [****Archive section of GeeksForGeeks****](https://www.geeksforgeeks.org/fundamentals-of-algorithms). There are also several past, running and upcoming courses available in the [****GeeksForGeeks Courses****](https://gfgcdn.com/tu/Ql7/).


# What are the best platforms?


Now we have learned about resources. But there is one more crucial step – practicing the problem. We need some platform to practice and implement our knowledge. ****GeeksForGeeks**** has the perfect solution for that. We have built the [****GeeksForGeeks Practice Portal****](https://practice.geeksforgeeks.org/) exclusively for that reason. There are numerous problems available in the practice section. Moreover, you have the facility to filter the problems based on the type of data structure or algorithm, or even difficulty.


# Conclusion


From the above discussion, we can conclude that though the process of learning data structures and algorithms is a bit lengthy and tough,it requires consistent hard work and practice if you follow the right path, be methodical with your approach of collecting resources and revisions and practice problems you will surely be able to learn DSA if an efficient way.


You must remember one thing during your learning phase – Learning is a continuous process. So prime objective would be to remain consistent and dedicate at least a minimum amount of time of your day towards learning DSA. If you are inconsistent then it is highly likely that you will forget the previously learned topics and have to start afresh which will ruin your efforts made till now.


Also it is always seen that no one’s journey is perfect so must remember that practices makes a man perfect and there are many up’s and down’s so don’t afraid from all that keep learning and keep growing.', 'Let us first know what the term DSA actually means.', 'How to Start Learning DSA?', 1, '7328995b-6079-4bd9-8be0-7c9152d5a73b', 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', true);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('05314b1e-7150-418d-8cb5-f7cd32765857', e'# What is Data Structure?

A ****data structure**** is a storage that is used to store and organize data. It is a way of arranging data on a computer so that it can be accessed and updated efficiently.

A data structure is not only used for organizing the data. It is also used for processing, retrieving, and storing data. There are different basic and advanced types of data structures that are used in almost every program or software system that has been developed. So we must have good knowledge about data structures. 

# Classification of Data Structure

![](https://media.geeksforgeeks.org/wp-content/uploads/20220520182504/ClassificationofDataStructure-660x347.jpg)

Classification of Data Structure

1.  ****Linear Data Structure:**** Data structure in which data elements are arranged sequentially or linearly, where each element is attached to its previous and next adjacent elements, is called a linear data structure.   
    ****Example:**** Array, Stack, Queue, Linked List, etc.
2.  ****Static Data Structure:**** Static data structure has a fixed memory size. It is easier to access the elements in a static data structure.   
    ****Example****: array.
3.  ****Dynamic Data Structure:**** In dynamic data structure, the size is not fixed. It can be randomly updated during the runtime which may be considered efficient concerning the memory (space) complexity of the code.   
    ****Example****: Queue, Stack, etc.
4.  ****Non-Linear Data Structure:**** Data structures where data elements are not placed sequentially or linearly are called non-linear data structures. In a non-linear data structure, we can’t traverse all the elements in a single run only.   
    ****Examples:**** Trees and Graphs.

Please refer [****Complete Data Structures & Algorithms Tutorial****](https://www.geeksforgeeks.org/dsa-tutorial-learn-data-structures-and-algorithms/) for topic-wise guide, practice problems and interview questions.', 'Data structures are the fundamental building blocks of computer programming. They define how data is organized, stored, and manipulated within a program. Understanding data structures is very important for developing efficient and effective algorithms.', 'Data Structures Overview', 2, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('cb775c45-7400-4554-a210-bddb2ade9f03', null, null, null, 2, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('44efdcdf-0629-48f9-a271-496cf8c1294f', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 3, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('40150d1a-6472-4cf3-a814-7c130783073d', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 4, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('06a8e89e-01d3-4218-a5c7-b50229b9d379', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 5, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('e0464e2f-bb5b-4c3b-bd4f-ef5d1de1a1bd', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 6, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('cd803866-117e-4313-99e4-b46b7e250340', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 7, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('2faf87e7-73ca-41ba-b628-8460a26f8c14', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 8, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('3f6c11f2-85d6-4d03-808c-c4e1e5ca2b6e', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 9, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('2a878929-d192-4a08-a92c-f93b22786c0f', e'**Types of Queues:**

There are **five different types of queues** that are used in
different scenarios. They are:

1. Input Restricted Queue (this is a Simple Queue)
2. Output Restricted Queue (this is also a Simple Queue)
3. Circular Queue
4. Double Ended Queue (Deque)
5. Priority Queue
   * Ascending Priority Queue
   * Descending Priority Queue

![Types of Queues](https://media.geeksforgeeks.org/wp-content/uploads/20220623134709/typesofqueues.jpg)

Types of Queues

**1.** [**Circular Queue**](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/)**:** Circular Queue is a linear data structure in which the
operations are performed based on FIFO (First In First Out) principle and
the last position is connected back to the first position to make a
circle. It is also called **‘Ring Buffer’**. This queue is
primarily used in the following cases:

1. **Memory Management:** The unused memory locations in the
   case of ordinary queues can be utilized in circular queues.
2. **Traffic system:** In a computer-controlled traffic
   system, circular queues are used to switch on the traffic lights one by
   one repeatedly as per the time set.
3. **CPU Scheduling:** Operating systems often maintain a
   queue of processes that are ready to execute or that are waiting for a
   particular event to occur.

The time complexity for the circular Queue is O(1).

**2. Input restricted Queue:** In this type of Queue, the
input can be taken from one side only(rear) and deletion of elements can
be done from both sides(front and rear). This kind of Queue does not
follow FIFO(first in first out).  This queue is used in cases where
the consumption of the data needs to be in FIFO order but if there is a
need to remove the recently inserted data for some reason and one such
case can be irrelevant data, performance issue, etc.



![Input Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131417/inputrestrictedqueue.jpg)

Input Restricted Queue

**Advantages of Input restricted Queue:**

* Prevents overflow and overloading of the queue by limiting the number of
  items added
* Helps maintain stability and predictable performance of the system

**Disadvantages of Input restricted Queue:**

* May lead to resource wastage if the restriction is set too low and items
  are frequently discarded
* May lead to waiting or blocking if the restriction is set too high and
  the queue is full, preventing new items from being added.

**3. Output restricted Queue:** In this type of Queue, the
input can be taken from both sides(rear and front) and the deletion of the
element can be done from only one side(front).  This queue is used in
the case where the inputs have some priority order to be executed and the
input can be placed even in the first place so that it is executed
first.

![Output Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131455/outputrestrictedqueue.jpg)

Output Restricted Queue

**4.** [**Double ended Queue**](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/)**:** Double Ended Queue is also a Queue data structure in
which the insertion and deletion operations are performed at both the ends
(front and rear). That means, we can insert at both front and rear
positions and can delete from both front and rear positions.  Since
Deque supports both stack and queue operations, it can be used as both.
The Deque data structure supports clockwise and anticlockwise rotations in
O(1) time which can be useful in certain applications. Also, the problems
where elements need to be removed and or added both ends can be
efficiently solved using Deque.

![Double Ended Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131811/doubleended.jpg)

Double Ended Queue

**5.** [**Priority Queue**](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)**:** A priority queue is a special type of queue in which
each element is associated with a priority and is served according to its
priority. There are two types of Priority Queues. They are:

1. **Ascending Priority Queue:** Element can be inserted
   arbitrarily but only smallest element can be removed. For example,
   suppose there is an array having elements 4, 2, 8 in the same order. So,
   while inserting the elements, the insertion will be in the same sequence
   but while deleting, the order will be 2, 4, 8.
2. **Descending priority Queue:** Element can be inserted
   arbitrarily but only the largest element can be removed first from the
   given Queue. For example, suppose there is an array having elements 4,
   2, 8 in the same order. So, while inserting the elements, the insertion
   will be in the same sequence but while deleting, the order will be 8, 4,
   2.

The time complexity of the Priority Queue is O(logn).

[**Applications of a Queue:**](https://www.geeksforgeeks.org/applications-of-queue-data-structure/)

The
[queue](https://www.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/)
is used when things don’t have to be processed immediately, but have to be
processed in First In First Out order like
[Breadth First Search](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/). This property of Queue makes it also useful in the following kind of
scenarios.

1. When a resource is shared among multiple consumers. Examples include
   [CPU scheduling](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/),
   [Disk Scheduling](https://www.geeksforgeeks.org/disk-scheduling-algorithms/).
2. When data is transferred asynchronously (data not necessarily received
   at the same rate as sent) between two processes. Examples include IO
   Buffers,
   [pipes](https://www.geeksforgeeks.org/piping-in-unix-or-linux/), file IO, etc.
3. Linear Queue: A linear queue is a type of queue where data elements are
   added to the end of the queue and removed from the front of the queue.
   Linear queues are used in applications where data elements need to be
   processed in the order in which they are received. Examples include
   printer queues and message queues.
4. Circular Queue: A circular queue is similar to a linear queue, but the
   end of the queue is connected to the front of the queue. This allows for
   efficient use of space in memory and can improve performance. Circular
   queues are used in applications where the data elements need to be
   processed in a circular fashion. Examples include CPU scheduling and
   memory management.
5. Priority Queue: A priority queue is a type of queue where each element
   is assigned a priority level. Elements with higher priority levels are
   processed before elements with lower priority levels. Priority queues
   are used in applications where certain tasks or data elements need to be
   processed with higher priority. Examples include operating system task
   scheduling and network packet scheduling.
6. Double-ended Queue: A double-ended queue, also known as a deque, is a
   type of queue where elements can be added or removed from either end of
   the queue. This allows for more flexibility in data processing and can
   be used in applications where elements need to be processed in multiple
   directions. Examples include job scheduling and searching algorithms.
7. Concurrent Queue: A concurrent queue is a type of queue that is designed
   to handle multiple threads accessing the queue simultaneously.
   Concurrent queues are used in multi-threaded applications where data
   needs to be shared between threads in a thread-safe manner. Examples
   include database transactions and web server requests.

**Issues of Queue :**

Some common issues that can arise when using queues:

1. Queue overflow: Queue overflow occurs when the queue reaches its maximum
   capacity and is unable to accept any more elements. This can cause data
   loss and can lead to application crashes.
2. Queue underflow: Queue underflow occurs when an attempt is made to
   remove an element from an empty queue. This can cause errors and
   application crashes.
3. Priority inversion: Priority inversion occurs in priority queues when a
   low-priority task holds a resource that a high-priority task needs. This
   can cause delays in processing and can impact system performance.
4. Deadlocks: Deadlocks occur when multiple threads or processes are
   waiting for each other to release resources, resulting in a situation
   where none of the threads can proceed. This can happen when using
   concurrent queues and can lead to system crashes.
5. Performance issues: Queue performance can be impacted by various
   factors, such as the size of the queue, the frequency of access, and the
   type of operations performed on the queue. Poor queue performance can
   lead to slower system performance and reduced user experience.
6. Synchronization issues: Synchronization issues can arise when multiple
   threads are accessing the same queue simultaneously. This can result in
   data corruption, race conditions, and other errors.
7. Memory management issues: Queues can use up significant amounts of
   memory, especially when processing large data sets. Memory leaks and
   other memory management issues can occur, leading to system crashes and
   other errors.

**Reference :**

Some references for further reading on queues:

1. “Data Structures and Algorithms in Java” by Robert Lafore – This book
   provides an in-depth explanation of different types of queues and their
   implementations in Java.
2. “Introduction to Algorithms” by Thomas H. Cormen et al. – This textbook
   covers the basic concepts of data structures and algorithms, including
   queues and their various applications.
3. “Concurrency in C# Cookbook” by Stephen Cleary – This book provides
   practical examples of how to use concurrent queues in C# programming.
4. “Queue (abstract data type)” on Wikipedia – This article provides an
   overview of queues and their properties, as well as examples of their
   applications.
5. “The Art of Computer Programming, Volume 1: Fundamental Algorithms” by
   Donald E. Knuth – This book includes a detailed analysis of different
   queue algorithms and their performance.
6. “Queues and the Producer-Consumer Problem” by Douglas C. Schmidt – This
   paper discusses how queues can be used to solve the producer-consumer
   problem in concurrent programming.', e'Queue is a linear structure that follows a particular order in which the
operations are performed. The order is First In First Out (FIFO). A good
example of a queue is any queue of consumers for a resource where the
consumer that came first is served first. In this article, the different
types of queues are discussed.', 'Different Types of Queues and its Applications', 2, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('6c6539f0-a9f9-4639-b197-d3fc89870e6a', e'****Enqueue**** and when an element is deleted from the queue, then the operation is
known as ****Dequeue.****It is important to know that we cannot insert an element if the size of
the queue is full and cannot delete an element when the queue itself is
empty. If we try to insert an element even after the queue is full, then
such a condition is known as overflow whereas, if we try to delete an
element even after the queue is empty then such a condition is known as
underflow.

****Primary Queue Operations:****

* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue
  at the end i.e. at the rear end. (Where T is Generic i.e we can define
  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****
* ****int dequeue():****
  When this operation is performed, an element is removed from the front
  end and is returned. This operation take ****constant time i.e O(1).****

****Auxiliary Queue Operations:****

* ****int front():**** This operation will return the element at the front without removing
  it and it take O(1) time.
* ****int rear():**** This operation will return the element at the rear without removing
  it, Its Time Complexity is O(1).
* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This
  Operation also done in O(1).
* ****int size():**** This operation will return the size of the queue i.e. the total
  number of elements present in the queue and it’s time complexity is
  O(1).

****Types of Queues:****

* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version
  of a queue. Here, insertion of an element i.e. the Enqueue operation
  takes place at the rear end and removal of an element i.e. the Dequeue
  operation takes place at the front end.
* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In
  a circular queue, the element of the queue act as a circular ring. The
  working of a circular queue is similar to the linear queue except for
  the fact that the last element is connected to the first element. Its
  advantage is that the memory is utilized in a better way. This is
  because if there is an empty space i.e. if no element is present at a
  certain position in the queue, then an element can be easily added at
  that position.
* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it
  arranges the elements in a queue based on some priority. The priority
  can be something where the element with the highest value has the
  priority so it creates a queue with decreasing order of values. The
  priority can also be such that the element with the lowest value gets
  the highest priority so in turn it creates a queue with increasing
  order of values.
* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests
  double ended, it means that an element can be inserted or removed from
  both the ends of the queue unlike the other queues in which it can be
  done only from one end. Because of this property it may not obey the
  First In First Out property.

****Implementation of Queue:****

* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited
  number of elements.
* ****Linked list allocation:****
  A queue can be implemented using a linked list. It can organize an
  unlimited number of elements.

****Applications of Queue:****

* ****Multi programming:**** Multi programming means when multiple programs are running in the
  main memory. It is essential to organize these multiple programs and
  these multiple programs are organized as queues.
* ****Network:**** In a network, a queue is used in devices such as a router or a
  switch. another application of a queue is a mail queue which is a
  directory that stores data and controls files for mail messages.
* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that
  are scheduled to be executed one after another. These jobs are
  assigned to the processor one by one which is organized using a
  queue.
* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.

****Real-time application of Queue:****

* Working as a buffer between a slow and a fast device. For example
  keyboard and CPU, and two devices on network.
* ATM Booth Line
* Ticket Counter Line
* CPU task scheduling
* Waiting time of each customer at call centers.

****Advantages of Queue:****

* A large amount of data can be managed efficiently with ease.
* Operations such as insertion and deletion can be performed with ease
  as it follows the first in first out rule.
* Queues are useful when a particular service is used by multiple
  consumers.
* Queues are fast in speed for data inter-process communication.
* Queues can be used in the implementation of other data
  structures.

****Disadvantages of Queue:****

* The operations such as insertion and deletion of elements from the
  middle are time consuming.
* In a classical queue, a new element can only be inserted when the
  existing elements are deleted from the queue.
* Searching an element takes O(N) time.
* Maximum size of a queue must be defined prior in case of array
  implementation.', e'A Queue
is a linear data structure. This data structure follows a particular
order in which the operations are performed. The order is First In First Out (FIFO). It means that the element that is inserted first in the queue will
come out first and the element that is inserted last will come out last.', 'Applications, Advantages and Disadvantages of Queue', 4, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('3126233c-3e02-455e-8152-6d095b943168', e'Basic Terminologies of Queue
----------------------------

* ****Front:**** Position of the entry in a queue ready to be served, that is, the
  first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.
* ****Rear:****
  Position of the last entry in the queue, that is, the one most
  recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.
* ****Size:**** Size refers to the ****current**** number of elements in the queue.
* ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.

****Representation of Queue****
-------------------------------

![Representation-of-Queue-Data-Structure](https://media.geeksforgeeks.org/wp-content/uploads/20241212130245410876/Representation-of-Queue-Data-Structure-768.webp)

Operations on Queue
-------------------

### ****1. Enqueue:****

Enqueue operation ****adds (or stores) an element to the end of the queue****. 

****Steps:****

1. Check if the ****queue is full****. If so, return an ****overflow**** error and exit.
2. If the queue is ****not full****, increment the ****rear**** pointer to the next available position.
3. Insert the element at the rear.


![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)![Enqueue-Operation-in-Queue-01.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010297668/Enqueue-Operation-in-Queue-01.webp)


![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)![Enqueue-Operation-in-Queue-02.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010180461/Enqueue-Operation-in-Queue-02.webp)


![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)![Enqueue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125010068824/Enqueue-Operation-in-Queue-03.webp)


![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)![Enqueue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009956179/Enqueue-Operation-in-Queue-04.webp)


![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)![Enqueue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009838736/Enqueue-Operation-in-Queue-05.webp)


![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)![Enqueue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125009700162/Enqueue-Operation-in-Queue-06.webp)



Previous





Pause

Next





3 / 6



### ****2. Dequeue:****

Dequeue operation removes the element at the front of the queue. The
following steps are taken to perform the dequeue operation:


1. Check if the ****queue is empty****. If so, return an ****underflow**** error.
2. Remove the element at the ****front****.
3. ****Increment**** the ****front**** pointer to the next element.


![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-02-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-03.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-04.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-05.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)


![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)![Dequeue-Operation-in-Queue-06.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241212125307686242/Dequeue-Operation-in-Queue-01-.webp)



Previous





Play

Next





1 / 6



### ****3. Peek or Front Operation:****

This operation returns the element at the front end without removing
it.

### 4. Size Operation:

This operation returns the numbers of elements present in the
queue.

### ****5. isEmpty Operation:****

This operation returns a boolean value that indicates whether the queue
is empty or not.

### ****6. isFull Operation:****

This operation returns a boolean value that indicates whether the queue
is full or not.

Implementation of Queue Data Structure
--------------------------------------

Queue can be implemented using following data structures:

* [Implementation of Queue using Arrays](https://www.geeksforgeeks.org/introduction-and-array-implementation-of-queue)
* [Implementation of Queue using Linked List](https://www.geeksforgeeks.org/queue-linked-list-implementation)

Complexity Analysis of Operations on Queue
------------------------------------------

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****enqueue**** | O(1) | O(1) |
| ****dequeue**** | O(1) | O(1) |
| front | O(1) | O(1) |
| size | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| isFull | O(1) | O(1) |

****Types of Queues****
-----------------------

Queue data structure can be classified into 4 types:

1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the
   element from the front of the queue.
2. [****Double-Ended Queue (Deque)****](https://www.geeksforgeeks.org/deque-set-1-introduction-applications)****:****
   In a double-ended queue the insertion and deletion operations, both
   can be performed from both ends. They are of two types:
   * ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be
     taken from only one end but deletion can be done from any of the
     ends.
   * ****Output Restricted Queue:****
     This is also a simple queue. In this type of queue, the input can
     be taken from both ends but deletion can be done from only one
     end.
3. [****Circular Queue:****](https://www.geeksforgeeks.org/introduction-to-circular-queue) This is a special type of queue where the last position is connected
   back to the first position. Here also the operations are performed in
   FIFO order.
4. [****Priority Queue****](https://www.geeksforgeeks.org/priority-queue-set-1-introduction)****:****
   A priority queue is a special queue where the elements are accessed
   based on the priority assigned to them. They are of two types:
   * ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in
     increasing order of their priority values. Element with smallest
     priority value is popped first.
   * ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in
     decreasing order of their priority values. Element with largest
     priority is popped first.

![Types-of-Queue](https://media.geeksforgeeks.org/wp-content/uploads/20241212125924381216/Types-of-Queue-660.webp)

****Applications of Queue Data Structure****
--------------------------------------------

Application of queue is common. In a computer system, there may be
queues of tasks waiting for the printer, for access to disk storage, or
even in a time-sharing system, for use of the CPU. Within a single
program, there may be multiple requests to be kept in a queue, or one
task may create other tasks, which must be done in turn by keeping them
in a queue.

* A Queue is always used as a buffer when we have a speed mismatch
  between a producer and consumer. For example keyboard and CPU.
* Queue can be used where we have a single resource and multiple
  consumers like a single CPU and multiple processes.
* In a network, a queue is used in devices such as a router/switch and
  mail queue.
* Queue can be used in various algorithm techniques like Breadth First
  Search, Topological Sort, etc.', e'Queue is a linear data structure that follows FIFO (First In First Out) Principle, so the first element inserted is the first to be popped out.
', 'Introduction to Queue Data Structure', 5, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('8d4f2d0d-a9f3-49f5-a13e-9aa4fad99826', e'**Types of Queues:**

There are **five different types of queues** that are used in
different scenarios. They are:

1. Input Restricted Queue (this is a Simple Queue)
2. Output Restricted Queue (this is also a Simple Queue)
3. Circular Queue
4. Double Ended Queue (Deque)
5. Priority Queue
   * Ascending Priority Queue
   * Descending Priority Queue

![Types of Queues](https://media.geeksforgeeks.org/wp-content/uploads/20220623134709/typesofqueues.jpg)

Types of Queues

**1.** [**Circular Queue**](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/)**:** Circular Queue is a linear data structure in which the
operations are performed based on FIFO (First In First Out) principle and
the last position is connected back to the first position to make a
circle. It is also called **‘Ring Buffer’**. This queue is
primarily used in the following cases:

1. **Memory Management:** The unused memory locations in the
   case of ordinary queues can be utilized in circular queues.
2. **Traffic system:** In a computer-controlled traffic
   system, circular queues are used to switch on the traffic lights one by
   one repeatedly as per the time set.
3. **CPU Scheduling:** Operating systems often maintain a
   queue of processes that are ready to execute or that are waiting for a
   particular event to occur.

The time complexity for the circular Queue is O(1).

**2. Input restricted Queue:** In this type of Queue, the
input can be taken from one side only(rear) and deletion of elements can
be done from both sides(front and rear). This kind of Queue does not
follow FIFO(first in first out).  This queue is used in cases where
the consumption of the data needs to be in FIFO order but if there is a
need to remove the recently inserted data for some reason and one such
case can be irrelevant data, performance issue, etc.



![Input Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131417/inputrestrictedqueue.jpg)

Input Restricted Queue

**Advantages of Input restricted Queue:**

* Prevents overflow and overloading of the queue by limiting the number of
  items added
* Helps maintain stability and predictable performance of the system

**Disadvantages of Input restricted Queue:**

* May lead to resource wastage if the restriction is set too low and items
  are frequently discarded
* May lead to waiting or blocking if the restriction is set too high and
  the queue is full, preventing new items from being added.

**3. Output restricted Queue:** In this type of Queue, the
input can be taken from both sides(rear and front) and the deletion of the
element can be done from only one side(front).  This queue is used in
the case where the inputs have some priority order to be executed and the
input can be placed even in the first place so that it is executed
first.

![Output Restricted Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131455/outputrestrictedqueue.jpg)

Output Restricted Queue

**4.** [**Double ended Queue**](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/)**:** Double Ended Queue is also a Queue data structure in
which the insertion and deletion operations are performed at both the ends
(front and rear). That means, we can insert at both front and rear
positions and can delete from both front and rear positions.  Since
Deque supports both stack and queue operations, it can be used as both.
The Deque data structure supports clockwise and anticlockwise rotations in
O(1) time which can be useful in certain applications. Also, the problems
where elements need to be removed and or added both ends can be
efficiently solved using Deque.

![Double Ended Queue](https://media.geeksforgeeks.org/wp-content/uploads/20220623131811/doubleended.jpg)

Double Ended Queue

**5.** [**Priority Queue**](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/)**:** A priority queue is a special type of queue in which
each element is associated with a priority and is served according to its
priority. There are two types of Priority Queues. They are:

1. **Ascending Priority Queue:** Element can be inserted
   arbitrarily but only smallest element can be removed. For example,
   suppose there is an array having elements 4, 2, 8 in the same order. So,
   while inserting the elements, the insertion will be in the same sequence
   but while deleting, the order will be 2, 4, 8.
2. **Descending priority Queue:** Element can be inserted
   arbitrarily but only the largest element can be removed first from the
   given Queue. For example, suppose there is an array having elements 4,
   2, 8 in the same order. So, while inserting the elements, the insertion
   will be in the same sequence but while deleting, the order will be 8, 4,
   2.

The time complexity of the Priority Queue is O(logn).

[**Applications of a Queue:**](https://www.geeksforgeeks.org/applications-of-queue-data-structure/)

The
[queue](https://www.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/)
is used when things don’t have to be processed immediately, but have to be
processed in First In First Out order like
[Breadth First Search](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/). This property of Queue makes it also useful in the following kind of
scenarios.

1. When a resource is shared among multiple consumers. Examples include
   [CPU scheduling](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/),
   [Disk Scheduling](https://www.geeksforgeeks.org/disk-scheduling-algorithms/).
2. When data is transferred asynchronously (data not necessarily received
   at the same rate as sent) between two processes. Examples include IO
   Buffers,
   [pipes](https://www.geeksforgeeks.org/piping-in-unix-or-linux/), file IO, etc.
3. Linear Queue: A linear queue is a type of queue where data elements are
   added to the end of the queue and removed from the front of the queue.
   Linear queues are used in applications where data elements need to be
   processed in the order in which they are received. Examples include
   printer queues and message queues.
4. Circular Queue: A circular queue is similar to a linear queue, but the
   end of the queue is connected to the front of the queue. This allows for
   efficient use of space in memory and can improve performance. Circular
   queues are used in applications where the data elements need to be
   processed in a circular fashion. Examples include CPU scheduling and
   memory management.
5. Priority Queue: A priority queue is a type of queue where each element
   is assigned a priority level. Elements with higher priority levels are
   processed before elements with lower priority levels. Priority queues
   are used in applications where certain tasks or data elements need to be
   processed with higher priority. Examples include operating system task
   scheduling and network packet scheduling.
6. Double-ended Queue: A double-ended queue, also known as a deque, is a
   type of queue where elements can be added or removed from either end of
   the queue. This allows for more flexibility in data processing and can
   be used in applications where elements need to be processed in multiple
   directions. Examples include job scheduling and searching algorithms.
7. Concurrent Queue: A concurrent queue is a type of queue that is designed
   to handle multiple threads accessing the queue simultaneously.
   Concurrent queues are used in multi-threaded applications where data
   needs to be shared between threads in a thread-safe manner. Examples
   include database transactions and web server requests.

**Issues of Queue :**

Some common issues that can arise when using queues:

1. Queue overflow: Queue overflow occurs when the queue reaches its maximum
   capacity and is unable to accept any more elements. This can cause data
   loss and can lead to application crashes.
2. Queue underflow: Queue underflow occurs when an attempt is made to
   remove an element from an empty queue. This can cause errors and
   application crashes.
3. Priority inversion: Priority inversion occurs in priority queues when a
   low-priority task holds a resource that a high-priority task needs. This
   can cause delays in processing and can impact system performance.
4. Deadlocks: Deadlocks occur when multiple threads or processes are
   waiting for each other to release resources, resulting in a situation
   where none of the threads can proceed. This can happen when using
   concurrent queues and can lead to system crashes.
5. Performance issues: Queue performance can be impacted by various
   factors, such as the size of the queue, the frequency of access, and the
   type of operations performed on the queue. Poor queue performance can
   lead to slower system performance and reduced user experience.
6. Synchronization issues: Synchronization issues can arise when multiple
   threads are accessing the same queue simultaneously. This can result in
   data corruption, race conditions, and other errors.
7. Memory management issues: Queues can use up significant amounts of
   memory, especially when processing large data sets. Memory leaks and
   other memory management issues can occur, leading to system crashes and
   other errors.

**Reference :**

Some references for further reading on queues:

1. “Data Structures and Algorithms in Java” by Robert Lafore – This book
   provides an in-depth explanation of different types of queues and their
   implementations in Java.
2. “Introduction to Algorithms” by Thomas H. Cormen et al. – This textbook
   covers the basic concepts of data structures and algorithms, including
   queues and their various applications.
3. “Concurrency in C# Cookbook” by Stephen Cleary – This book provides
   practical examples of how to use concurrent queues in C# programming.
4. “Queue (abstract data type)” on Wikipedia – This article provides an
   overview of queues and their properties, as well as examples of their
   applications.
5. “The Art of Computer Programming, Volume 1: Fundamental Algorithms” by
   Donald E. Knuth – This book includes a detailed analysis of different
   queue algorithms and their performance.
6. “Queues and the Producer-Consumer Problem” by Douglas C. Schmidt – This
   paper discusses how queues can be used to solve the producer-consumer
   problem in concurrent programming.', e'Queue is a linear structure that follows a particular order in which the
operations are performed. The order is First In First Out (FIFO). A good
example of a queue is any queue of consumers for a resource where the
consumer that came first is served first. In this article, the different
types of queues are discussed.', 'Different Types of Queues and its Applications', 6, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('dd501d4c-f5c6-424f-9678-af343551671c', e'**Basic Operations on Queue:**
------------------------------

Some of the basic operations for Queue in Data Structure are:

* **enqueue() –** Insertion of elements to the queue.
* **dequeue() –** Removal of elements from the queue.
* **peek() or front()-** Acquires the data element available
  at the front node of the queue without deleting it.
* **rear() –** This operation returns the element at the rear
  end without removing it.
* **isFull() –** Validates if the queue is full.
* **isEmpty() –** Checks if the queue is empty.
* **size():** This operation returns the size of the queue
  i.e. the total number of elements it contains.

![](https://media.geeksforgeeks.org/wp-content/uploads/20221209094646/Queue-768.png)

Queue Data Structure

### **Operation 1: enqueue()**

Inserts an element at the end of the queue i.e. at the rear end.

The following steps should be taken to enqueue (insert) data into a queue:

* Check if the queue is full.
* If the queue is full, return overflow error and exit.
* If the queue is not full, increment the rear pointer to point to the
  next empty space.
* Add the data element to the queue location, where the rear is pointing.
* return success.

![Enqueue representation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122158/fifo1-660x371.png)

Enqueue representation

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `printf``(``"\\nQueue is full\\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}` |
| --- |





Java
----

  



  

  




| `void` `queueEnqueue(``int` `data)`  `{`  `// Check queue is full or not`  `if` `(capacity == rear) {`  `System.out.println(``"\\nQueue is full\\n"``);`  `return``;`  `}`    `// Insert element at the rear`  `else` `{`  `queue[rear] = data;`  `rear++;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `void` `enqueue(``struct` `Queue* queue,` `int` `item)`  `{`  `if` `(isFull(queue))`  `return``;`  `queue->rear = (queue->rear + 1) % queue->capacity;`  `queue->array[queue->rear] = item;`  `queue->size = queue->size + 1;`  `printf``(``"%d enqueued to queue\\n"``, item);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to add an item to the queue.`  `# It changes rear and size`  `def` `EnQueue(``self``, item):`  `if` `self``.isFull():`  `print``(``"Full"``)`  `return`  `self``.rear` `=` `(``self``.rear` `+` `1``)` `%` `(``self``.capacity)`  `self``.Q[``self``.rear]` `=` `item`  `self``.size` `=` `self``.size` `+` `1`  `print``(``"% s enqueued to queue"` `%` `str``(item))`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `void` `enqueue(``int` `item)`  `{`  `if` `(rear == max - 1) {`  `Console.WriteLine(``"Queue Overflow"``);`  `return``;`  `}`  `else` `{`  `ele[++rear] = item;`  `}`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `enqueue(element){`  `// adding element to the queue`  `this``.items.push(element);`  `}`    `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 2: dequeue()**

This operation removes and returns an element that is at the front end of
the queue.

The following steps are taken to perform the dequeue operation:

* Check if the queue is empty.
* If the queue is empty, return the underflow error and exit.
* If the queue is not empty, access the data where the front is pointing.
* Increment the front pointer to point to the next available data element.
* The Return success.

![Dequeue operation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122625/fifo2-660x371.png)

Dequeue operation

Below is the Implementation of above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `printf``(``"\\nQueue is empty\\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i = 0; i < rear - 1; i++) {`  `queue[i] = queue[i + 1];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}` |
| --- |





Java
----

  



  

  




| `void` `queueDequeue()`  `{`  `// If queue is empty`  `if` `(front == rear) {`  `System.out.println(``"\\nQueue is empty\\n"``);`  `return``;`  `}`    `// Shift all the elements from index 2`  `// till rear to the left by one`  `else` `{`  `for` `(``int` `i =` `0``; i < rear -` `1``; i++) {`  `queue[i] = queue[i +` `1``];`  `}`    `// decrement rear`  `rear--;`  `}`  `return``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `int` `dequeue(``struct` `Queue* queue)`  `{`  `if` `(isEmpty(queue)) {`  `printf``(``"\\nQueue is empty\\n"``);`  `return``;`  `}`  `int` `item = queue->array[queue->front];`  `queue->front = (queue->front + 1) % queue->capacity;`  `queue->size = queue->size - 1;`  `return` `item;`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to remove an item from queue.`  `# It changes front and size`      `def` `DeQueue(``self``):`  `if` `self``.isEmpty():`  `print``(``"Queue is empty"``)`  `return`    `print``(``"% s dequeued from queue"` `%` `str``(``self``.Q[``self``.front]))`  `self``.front` `=` `(``self``.front` `+` `1``)` `%` `(``self``.capacity)`  `self``.size` `=` `self``.size` `-` `1`  `# This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to remove an item from queue.`  `// It changes front and size`  `public` `int` `dequeue()`  `{`  `if` `(front == rear + 1) {`  `Console.WriteLine(``"Queue is Empty"``);`  `return` `-1;`  `}`  `else` `{`  `int` `p = ele[front++];`  `return` `p;`  `}`  `}`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `dequeue(){`  `// removing element from the queue`  `// returns underflow when called`  `// on empty queue`  `if``(``this``.isEmpty()){`  `document.write(``"<br>Queue is empty<br>"``);`  `return` `-1;`  `}`  `return` `this``.items.shift();`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 3: front()**

This operation returns the element at the front end without removing it.

The following steps are taken to perform the front operation:

* If the queue is empty return the most minimum value.
* otherwise, return the front value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `// Function to get front of queue`  `int` `front(Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}` |
| --- |





Java
----

  



  

  




| `// Function to get front of queue`  `int` `front(Queue queue)`  `{`  `if` `(isempty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.front];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->front];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to get front of queue`  `def` `que_front(``self``):`  `if` `self``.isempty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.front]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[front];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `// Function to get front of queue`  `front(){`  `// returns the Front element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[0];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 4 : rear()

This operation returns the element at the rear end without removing it.

The following steps are taken to perform the rear operation:

* If the queue is empty return the most minimum value.
* otherwise, return the rear value.

Below is the Implementation of the above approach:

* C++
* Java
* C
* Python3
* C#
* Javascript

C++
---

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue* queue)`  `{`  `if` `(isEmpty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}` |
| --- |





Java
----

  



  

  




| `// Function to get rear of queue`  `int` `rear(Queue queue)`  `{`  `if` `(isEmpty(queue))`  `return` `Integer.MIN_VALUE;`  `return` `queue.arr[queue.rear];`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Function to get front of queue`  `int` `front(``struct` `Queue* queue)`  `{`  `if` `(isempty(queue))`  `return` `INT_MIN;`  `return` `queue->arr[queue->rear];`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Function to get rear of queue`  `def` `que_rear(``self``):`  `if` `self``.isEmpty():`  `return` `"Queue is empty"`  `return` `self``.Q[``self``.rear]`    `# This code is contributed By Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to get front of queue`  `public` `int` `front()`  `{`  `if` `(isempty())`  `return` `INT_MIN;`  `return` `arr[rear];`  `}`    `// This code is contributed By Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `<script>`  `rear(){`  `// returns the Rear element of`  `// the queue without removing it.`  `if``(``this``.isEmpty())`  `return` `"No elements in Queue<br>"``;`  `return` `this``.items[``this``.items.length-1];`  `}`  `// This code is contributed By Susobhan Akhuli`  `<script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 5: isEmpty():**

This operation returns a boolean value that indicates whether the queue is
empty or not.

The following steps are taken to perform the Empty operation:

* check if front value is equal to -1 or not, if yes then return true
  means queue is empty.
* Otherwise return false, means queue is not empty

Below is the implementation of the above approach:

* C++
* Java
* C#
* C
* Python3
* Javascript

C++
---

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}` |
| --- |





Java
----

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `boolean` `isEmpty()`  `{`  `if` `(front == -``1``)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C#
--

  



  

  




| `// This function will check whether`  `// the queue is empty or not:`  `bool` `isEmpty()`  `{`  `if` `(front == -1)`  `return` `true``;`  `else`  `return` `false``;`  `}`    `// This code is contributed by lokeshmvs21.` |
| --- |





C
-

  



  

  




| `// Queue is empty when size is 0`  `bool` `isEmpty(``struct` `Queue* queue)`  `{`  `return` `(queue->size == 0);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Queue is empty when size is 0`  `def` `isEmpty(``self``):`  `return` `self``.size` `=``=` `0`  `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `</script>`  `isEmpty(){`  `// return true if the queue is empty.`  `return` `this``.items.length == 0;`  `}`  `// This code is contributed by Susobhan Akhuli`  `</script>` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### **Operation 6 : isFull()**

This operation returns a boolean value that indicates whether the queue is
full or not.

The following steps are taken to perform the isFull() operation:

* Check if front value is equal to zero and rear is equal to the capacity
  of queue if yes then return true.
* otherwise return false

Below is the Implementation of the above approach:

* C++
* Java
* C
* C#
* Python3
* Javascript

C++
---

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `bool` `isFull()`  `{`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}` |
| --- |





Java
----

  



  

  




| `// This function will check`  `// whether the queue is full or not.`  `boolean` `isFull()`  `{`  `if` `(front ==` `0` `&& rear == MAX_SIZE -` `1``) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityapburujwale` |
| --- |





C
-

  



  

  




| `// Queue is full when size becomes`  `// equal to the capacity`  `bool` `isFull(``struct` `Queue* queue)`  `{`  `return` `(queue->size == queue->capacity);`  `}`    `// This code is contributed by Susobhan Akhuli` |
| --- |





C#
--

  



  

  




| `// Function to add an item to the queue.`  `// It changes rear and size`  `public` `bool` `isFull(``int` `item) {` `return` `(rear == max - 1); }`  `// This code is contributed by Susobhan Akhuli` |
| --- |





Python3
-------

  



  

  




| `# Queue is full when size becomes`  `# equal to the capacity`      `def` `isFull(``self``):`  `return` `self``.size` `=``=` `self``.capacity`    `# This code is contributed by Susobhan Akhuli` |
| --- |





Javascript
----------

  



  

  




| `function` `isFull() {`  `if` `(front == 0 && rear == MAX_SIZE - 1) {`  `return` `true``;`  `}`  `return` `false``;`  `}`    `// This code is contributed by aadityamaharshi21.` |
| --- |








**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

### Operation 7: size()

This operation returns the size of the queue i.e. the total number of
elements it contains.

```
queuename.size()
Parameters :
No parameters are passed
Returns :
Number of elements in the container
```

* C++
* Java
* Python
* C#
* Javascript

C++
---

  



  

  




| `// CPP program to illustrate`  `// Implementation of size() function`  `#include <iostream>`  `#include <queue>`  `using` `namespace` `std;`    `int` `main()`  `{`  `int` `sum = 0;`  `queue<``int``> myqueue;`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `cout << myqueue.size();`    `return` `0;`  `}` |
| --- |





Java
----

  



  

  




| `// Java program to illustrate implementation of size()`  `// function`    `import` `java.util.*;`    `public` `class` `Main {`  `public` `static` `void` `main(String[] args)`  `{`  `int` `sum =` `0``;`  `Queue<Integer> myqueue =` `new` `LinkedList<>();`  `myqueue.add(``1``);`  `myqueue.add(``8``);`  `myqueue.add(``3``);`  `myqueue.add(``6``);`  `myqueue.add(``2``);`    `// Queue becomes 1, 8, 3, 6, 2`    `System.out.println(myqueue.size());`  `}`  `}`    `// This code is contributed by lokesh.` |
| --- |





Python
------

  



  

  




| `from` `collections` `import` `deque`    `def` `main():`  `sum` `=` `0`  `myqueue` `=` `deque()`  `myqueue.append(``1``)`  `myqueue.append(``8``)`  `myqueue.append(``3``)`  `myqueue.append(``6``)`  `myqueue.append(``2``)`    `# Queue becomes 1, 8, 3, 6, 2`    `print``(``len``(myqueue))`    `main()`    `# This code is contributed by aadityamaharshi21.` |
| --- |





C#
--

  



  

  




| `using` `System;`  `using` `System.Collections.Generic;`    `namespace` `ConsoleApp1 {`  `class` `MainClass {`  `public` `static` `void` `Main(``string``[] args)`  `{`  `int` `sum = 0;`  `Queue<``int``> myqueue =` `new` `Queue<``int``>();`  `myqueue.Enqueue(1);`  `myqueue.Enqueue(8);`  `myqueue.Enqueue(3);`  `myqueue.Enqueue(6);`  `myqueue.Enqueue(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `Console.WriteLine(myqueue.Count);`  `}`  `}`  `}`    `// This code is contributed by adityamaharshi21.` |
| --- |





Javascript
----------

  



  

  




| `// Javascript code`  `let sum = 0;`  `let myqueue=[];`  `myqueue.push(1);`  `myqueue.push(8);`  `myqueue.push(3);`  `myqueue.push(6);`  `myqueue.push(2);`    `// Queue becomes 1, 8, 3, 6, 2`    `console.log(myqueue.length);` |
| --- |







**Complexity Analysis:**  
**Time Complexity:** O(1)  
**Space Complexity:** O(N)

', '', 'Basic Operations for Queue in Data Structure', 7, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('21135289-e645-4045-a26c-697c91f3873f', e'****Enqueue**** and when an element is deleted from the queue, then the operation is
known as ****Dequeue.****It is important to know that we cannot insert an element if the size of
the queue is full and cannot delete an element when the queue itself is
empty. If we try to insert an element even after the queue is full, then
such a condition is known as overflow whereas, if we try to delete an
element even after the queue is empty then such a condition is known as
underflow.

****Primary Queue Operations:****

* ****void enqueue(int Element):**** When this operation is performed, an element is inserted in the queue
  at the end i.e. at the rear end. (Where T is Generic i.e we can define
  Queue of any type of data structure.) This operation take ****constant time i.e O(1).****
* ****int dequeue():****
  When this operation is performed, an element is removed from the front
  end and is returned. This operation take ****constant time i.e O(1).****

****Auxiliary Queue Operations:****

* ****int front():**** This operation will return the element at the front without removing
  it and it take O(1) time.
* ****int rear():**** This operation will return the element at the rear without removing
  it, Its Time Complexity is O(1).
* ****int isEmpty():**** This operation indicates whether the queue is empty or not. This
  Operation also done in O(1).
* ****int size():**** This operation will return the size of the queue i.e. the total
  number of elements present in the queue and it’s time complexity is
  O(1).

****Types of Queues:****

* ****Simple Queue:**** Simple queue also known as a linear queue is the most basic version
  of a queue. Here, insertion of an element i.e. the Enqueue operation
  takes place at the rear end and removal of an element i.e. the Dequeue
  operation takes place at the front end.
* ****Circular Queue:****This is mainly an efficient array implementation of Simple Queue. In
  a circular queue, the element of the queue act as a circular ring. The
  working of a circular queue is similar to the linear queue except for
  the fact that the last element is connected to the first element. Its
  advantage is that the memory is utilized in a better way. This is
  because if there is an empty space i.e. if no element is present at a
  certain position in the queue, then an element can be easily added at
  that position.
* ****Priority Queue:**** This queue is a special type of queue. Its specialty is that it
  arranges the elements in a queue based on some priority. The priority
  can be something where the element with the highest value has the
  priority so it creates a queue with decreasing order of values. The
  priority can also be such that the element with the lowest value gets
  the highest priority so in turn it creates a queue with increasing
  order of values.
* ****Dequeue:**** Dequeue is also known as Double Ended Queue. As the name suggests
  double ended, it means that an element can be inserted or removed from
  both the ends of the queue unlike the other queues in which it can be
  done only from one end. Because of this property it may not obey the
  First In First Out property.

****Implementation of Queue:****

* ****Sequential allocation:**** A queue can be implemented using an array. It can organize a limited
  number of elements.
* ****Linked list allocation:****
  A queue can be implemented using a linked list. It can organize an
  unlimited number of elements.

****Applications of Queue:****

* ****Multi programming:**** Multi programming means when multiple programs are running in the
  main memory. It is essential to organize these multiple programs and
  these multiple programs are organized as queues.
* ****Network:**** In a network, a queue is used in devices such as a router or a
  switch. another application of a queue is a mail queue which is a
  directory that stores data and controls files for mail messages.
* ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that
  are scheduled to be executed one after another. These jobs are
  assigned to the processor one by one which is organized using a
  queue.
* ****Shared resources:**** Queues are used as waiting lists for a single shared resource.

****Real-time application of Queue:****

* Working as a buffer between a slow and a fast device. For example
  keyboard and CPU, and two devices on network.
* ATM Booth Line
* Ticket Counter Line
* CPU task scheduling
* Waiting time of each customer at call centers.

****Advantages of Queue:****

* A large amount of data can be managed efficiently with ease.
* Operations such as insertion and deletion can be performed with ease
  as it follows the first in first out rule.
* Queues are useful when a particular service is used by multiple
  consumers.
* Queues are fast in speed for data inter-process communication.
* Queues can be used in the implementation of other data
  structures.

****Disadvantages of Queue:****

* The operations such as insertion and deletion of elements from the
  middle are time consuming.
* In a classical queue, a new element can only be inserted when the
  existing elements are deleted from the queue.
* Searching an element takes O(N) time.
* Maximum size of a queue must be defined prior in case of array
  implementation.', e'A Queue
is a linear data structure. This data structure follows a particular
order in which the operations are performed. The order is First In First Out (FIFO). It means that the element that is inserted first in the queue will
come out first and the element that is inserted last will come out last.', 'Applications, Advantages and Disadvantages of Queue', 8, null, 'c9b04774-3a81-43ab-ace6-5242360d9e07', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('0f01db32-ffc7-4834-9e6c-2ac158bdbac3', e'![Insertion-at-the-End-in-Doubly-Linked-List-copy](https://media.geeksforgeeks.org/wp-content/uploads/20240809123741/Insertion-at-the-End-in-Doubly-Linked-List-copy.webp)

# Representation of Doubly Linked List in Data Structure

In a data structure, a doubly linked list is represented using nodes that have three fields:

1.  Data
2.  A pointer to the next node (**next**)
3.  A pointer to the previous node (**prev**)

![Node-Structure-of-Doubly-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240809124907/Node-Structure-of-Doubly-Linked-List.webp)


# Node Definition

Here is how a node in a Doubly Linked List is typically represented:


```cpp
struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;
  
    // Constructor
    Node(int d) {
       data = d;
       prev = next = nullptr;      
    }
};
```
```c
struct Node {

    // To store the Value or data.
    int data;

    // Pointer to point the Previous Element
    Node* prev;

    // Pointer to point the Next Element
    Node* next;
};

// Function to create a new node
struct Node *createNode(int new_data) {
    struct Node *new_node = (struct Node *)
    malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}
```
```java
class Node {

    // To store the Value or data.
    int data;

    // Reference to the Previous Node
    Node prev;
  
    // Reference to the next Node
    Node next;
  
    // Constructor
    Node(int d) {
       data = d;
       prev = next = null;      
    }
};
```
```python
class Node:
  
    def __init__(self, data):
        # To store the value or data.
        self.data = data

        # Reference to the previous node
        self.prev = None

        # Reference to the next node
        self.next = None
```
```csharp
class Node
{
  	// To store the value or data
    public int Data; 
  
  	// Pointer to the next node
    public Node Next; 
  
  	// Pointer to the previous node
    public Node Prev; 

    // Constructor
    public Node(int d)
    {
        Data = d;
        Prev = Next = null;      
    }
}
```
```javascript
class Node {
    constructor(data)
    {
        // To store the value or data.
        this.data = data;

        // Reference to the previous node
        this.prev = null;

        // Reference to the next node
        this.next = null;
    }
}
```


Each node in a **Doubly Linked List** contains the **data** it holds, a pointer to the **next** node in the list, and a pointer to the **previous** node in the list. By linking these nodes together through the **next** and **prev** pointers, we can traverse the list in both directions (forward and backward), which is a key feature of a Doubly Linked List.


## 1. Traversal in Doubly Linked List

Traversal in a **Doubly Linked List** involves visiting each node, processing its data, and moving to the next or previous node using the forward (`next`) and backward (`prev`) pointers.

**Step-by-Step Approach for Traversal:**

1.  **Start from the head** of the list.
2.  **Traverse forward**:
    -   Visit the current node and process its data (e.g., print it).
    -   Move to the next node using `current = current->next`.
    -   Repeat the process until the end of the list (`current == NULL`).
3.  **Optionally, traverse backward**:
    -   Start from the tail (last node).
    -   Visit the current node and process its data.
    -   Move to the previous node using `current = current->prev`.
    -   Repeat the process until the beginning of the list (`current == NULL`).

Traversal is useful for displaying or processing all nodes in a doubly linked list.

> To read more about Traversal Operation Refer, [Traversal in Doubly Linked List](https://www.geeksforgeeks.org/traversal-in-doubly-linked-list/)

## 2. Finding Length of Doubly Linked List

A Doubly Linked List (DLL) is a type of linked list where each node has two pointers:

1.  One pointing to the next node in the sequence.
2.  One pointing to the previous node in the sequence.

To find the length of a doubly linked list, we need to traverse the list while counting the nodes.

**Step-by-Step Approach for finding length:**

1.  **Initialize a counter**: Start with a counter variable (`count = 0`).
2.  **Set a pointer to the head node**: Use a pointer (`current`) and initialize it to the head of the linked list.
3.  **Traverse the list**:
    -   While the pointer (`current`) is not `NULL`, increment the `count` by `1`.
    -   Move to the next node (`current = current.next`).
4.  **Stop at the end of the list**: When the pointer reaches `NULL`, stop the loop.
5.  **Return the count**: The final value of `count` gives the length of the doubly linked list.

> To read more about Finding Length of DLL Refer, [Program to find size of Doubly Linked List](https://www.geeksforgeeks.org/program-find-size-doubly-linked-list/)

## 3. Insertion in a Doubly Linked List

[Insertion](https://www.geeksforgeeks.org/introduction-and-insertion-in-a-doubly-linked-list/#insertion-at-a-specific-position-in-doubly-linked-list) in a **Doubly Linked List (DLL)** involves adding a new node at a specific position while maintaining the connections between nodes. Since each node contains a pointer to both the previous and next node, insertion requires adjusting these pointers carefully.

**There are three primary types of insertion in a DLL:**

**1. Insertion at the Beginning**

1.  Create a new node with the given data.
2.  Set the `next` pointer of the new node to the current head.
3.  If the list is not empty, update the `prev` pointer of the current head to point to the new node.
4.  Update the head of the list to the new node.

> Read more about Insertion at the Beginning Refer, [Insert a Node at Front/Beginning of Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-frontbeginning-of-doubly-linked-list/)

**2. Insertion at the End**

1.  Create a new node with the given data.
2.  If the list is empty, set the new node as the head.
3.  Traverse the list until the last node is found.
4.  Set the `next` pointer of the last node to the new node.
5.  Set the `prev` pointer of the new node to the last node.

> Read more about Insertion at the End Refer, [Insert a Node at the end of Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-the-end-of-doubly-linked-list/)

##3. Insertion at a Specific Position

1.  Create a new node with the given data.
2.  If inserting at the beginning, follow the steps for insertion at the start.
3.  Traverse the list to find the node after which insertion is needed.
4.  Set the `next` pointer of the new node to the next node of the current position.
5.  Set the `prev` pointer of the new node to the current node.
6.  Update the `prev` pointer of the next node to point to the new node (if it exists).
7.  Update the `next` pointer of the previous node to point to the new node.

> Read more about Insertion at a specific position Refer, [Insert a Node at a specific position in Doubly Linked List](https://www.geeksforgeeks.org/insert-a-node-at-a-specific-position-in-doubly-linked-list/)

## 4. Deletion in a Doubly Linked List

[Deletion](https://www.geeksforgeeks.org/deletion-in-linked-list/) in a **Doubly Linked List (DLL)** involves removing a node while maintaining the integrity of the list. Since each node contains pointers to both its previous and next nodes, deletion requires careful pointer adjustments to ensure no broken links occur.

**Types of Deletion in a Doubly Linked List**

**1. Deletion at the Beginning**

1.  Check if the list is empty; if it is, return as there is nothing to delete.
2.  Store the current head node in a temporary variable.
3.  Move the head pointer to the next node.
4.  If the new head exists, update its `prev` pointer to `NULL`.
5.  Delete the old head node to free memory.

> Read more about Deletion at the Beginning Refer, [Deletion at beginning (Removal of first node) in a Doubly Linked List](https://www.geeksforgeeks.org/remove-first-node-of-the-linked-list/)

**2. Deletion at the End**

1.  Check if the list is empty; if it is, return.
2.  Traverse the list to find the last node.
3.  Store the last node in a temporary variable.
4.  Update the `next` pointer of the second-last node to `NULL`, making it the new tail.
5.  Delete the last node to free memory.

> Read more about Deletion at the End Refer, [Deletion at end (Removal of last node) in a Doubly Linked List](https://www.geeksforgeeks.org/deletion-at-end-removal-of-last-node-in-a-doubly-linked-list/)

**3. Deletion at a Specific Position**

1.  Check if the list is empty; if it is, return.
2.  Traverse the list to find the node to be deleted.
3.  Store the node to be deleted in a temporary variable.
4.  Update the `next` pointer of the previous node to point to the next node.
5.  Update the `prev` pointer of the next node to point to the previous node (if it exists).
6.  Delete the target node to free memory.

> Read more about Deletion at a specific position Refer, [Delete a Doubly Linked List node at a given position](https://www.geeksforgeeks.org/delete-doubly-linked-list-node-given-position/)

# Advantages of Doubly Linked List

-   **Efficient traversal in both directions:** Doubly linked lists allow for efficient traversal of the list in both directions, making it suitable for applications where frequent insertions and deletions are required.
-   **Easy insertion and deletion of nodes:** The presence of pointers to both the previous and next nodes makes it easy to insert or delete nodes from the list, without having to traverse the entire list.
-   **Can be used to implement a stack or queue:** Doubly linked lists can be used to implement both stacks and queues, which are common data structures used in programming.

# Disadvantages of Doubly Linked List

-   **More complex than singly linked lists:** Doubly linked lists are more complex than singly linked lists, as they require additional pointers for each node.
-   **More memory overhead:** Doubly linked lists require more memory overhead than singly linked lists, as each node stores two pointers instead of one.

# Applications of Doubly Linked List

-   Implementation of undo and redo functionality in text editors.
-   Cache implementation where quick insertion and deletion of elements are required.
-   Browser history management to navigate back and forth between visited pages.
-   Music player applications to manage playlists and navigate through songs efficiently.
-   Implementing data structures like [Deque](https://www.geeksforgeeks.org/deque-set-1-introduction-applications) (double-ended queue) for efficient insertion and deletion at both ends.', 'A doubly linked list is a more complex data structure than a singly linked list, but it offers several advantages.', 'Doubly Linked List', 7, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('ae34492a-cfab-417f-952f-ddb4957195e8', e'Given a number

****n****
, we need to print its table.


****Examples :****


> ****Input****
> : 5
>
>
>
> ****Output****
> :
>
>
>
> 5 \\* 1 = 5
>
>
>
> 5 \\* 2 = 10
>
>
>
> 5 \\* 3 = 15
>
>
>
> 5 \\* 4 = 20
>
>
>
> 5 \\* 5 = 25
>
>
>
> 5 \\* 6 = 30
>
>
>
> 5 \\* 7 = 35
>
>
>
> 5 \\* 8 = 40
>
>
>
> 5 \\* 9 = 45
>
>
>
> 5 \\* 10 = 50

Table of Content

* [Iterative Approach – O(1) Time and O(1) Space](#using-a-loop-o1-time-and-o1-space)
* [Recursive Approach – O(1) Time and O(1) Space](#using-recursion-o1-space-and-o1-time)
### Iterative Approach – O(1) Time and O(1) Space

C++

````
// CPP program to print table of a number
#include <iostream>
using namespace std;

void printTable(int n) {
  for (int i = 1; i <= 10; ++i)
        cout << n << " * " << i << " = "
             << n * i << endl;
}

int main() {
    int n = 5;  // Change here to change output
    printTable(n);
    return 0;
}

````

Java

````
// Java program to print table of a number
import java.io.*;

class GfG {

    public static void printTable(int n)  {

        for (int i = 1; i <= 10; ++i)
            System.out.println(n + " * " + i +
                               " = " + n * i);
    }

    public static void main(String arg[]){
        int n = 5;
        printTable(n);
    }
}

````

Python

````
# Python Program to print table of a number

def printTable(n):

    for i in range (1, 11):

        # multiples from 1 to 10
        print "%d * %d = %d" % (n, i, n * i)


if __name__ == "__main__":
  n = 5
  printTable(n)

````

C#

````
// C# program to print table of a number
using System;

class GfG {
    public static void printTable(int n) {

        for (int i = 1; i <= 10; ++i)
            Console.Write(n + " * " + i +
                              " = " + n *
                               i + "\\n");
    }

    public static void Main()   {
      int n = 5;
      printTable(n);

    }
}

````

JavaScript

````
// Javascript program to print
// table of a number

function printTable(n) {
for (let i = 1; i <= 10; ++i)
    console.log( n + " * " +i +
            " = " + n *
                i);
}

// Driver Code
let n = 5;
printTable(n);

````

****Output :****


```
5 * 1 = 5
5 * 2 = 10
5 * 3 = 15
5 * 4 = 20
5 * 5 = 25
5 * 6 = 30
5 * 7 = 35
5 * 8 = 40
5 * 9 = 45
5 * 10 = 50
```
### ****Recursive Approach – O(1) Time and O(1) Space****

C++

````
#include <iostream>
using namespace std;

// printTable() prints table of number and takes
//1 required value that is number of whose teble to be printed
//and an optional input i whose default value is 1

void printTable(int n, int i = 1) {
    if (i == 11)// base case
        return;
    cout << n << " * " << i << " = " << n * i << endl;
    i++;//increment i
    printTable(n,i);
}

int main() {
    int n = 5;
    printTable(n);
}

````

Java

````
import java.util.*;

class GfG {

    // printTable() prints table of number and takes
    // 1 required value that is number of whose teble to be
    // printed and an optional input i whose default value is 1
    static void printTable(int n, Integer... val)  {
          int i = 1;
        if (val.length != 0)
            i = val[0];
        if (i == 11) // base case
            return;
        System.out.println(n + " * " + i + " = " + n * i);
        i++; // increment i
        printTable(n, i);
    }

    public static void main(String[] args) {
        int n = 5;
        printTable(n);
    }
}


````

Python

````
# printTable() prints table of number and takes
# 1 required value that is number of whose teble to be printed
# and an optional input i whose default value is 1
def printTable(n, i=1):

    if (i == 11):  # base case
        return
    print(n, "*", i, "=", n * i)
    i += 1  # increment i
    printTable(n, i)

if __name__ == "__main__":
  n = 5
  printTable(n)

````

C#

````
using System;
using System.Collections.Generic;

class GfG {

  // print_table() prints table of number and takes
  // 1 required value that is number of whose teble to be
  // printed and an optional input i whose default value is 1
  static void printTable(int n, int i = 1) {
    if (i == 11) // base case
      return;
    Console.WriteLine(n + " * " + i + " = " + n * i);
    i++; // increment i
    printTable(n, i);
  }

  public static void Main(string[] args) {
    int n = 5;
    printTable(n);
  }
}

````

JavaScript

````
// printTable() prints table of number and takes
//1 required value that is number of whose teble to be printed
//and an optional input i whose default value is 1

function printTable(n, i = 1) {
    if (i == 11)// base case
        return;
    console.log(n + " * " + i + " = " + n * i);
    i++;//increment i
    printTable(n,i);
}

// Driver Code
let n = 5;
printTable(n);

````




**Output**
```
5 * 1 = 5
5 * 2 = 10
5 * 3 = 15
5 * 4 = 20
5 * 5 = 25
5 * 6 = 30
5 * 7 = 35
5 * 8 = 40
5 * 9 = 45
5 * 10 = 50
```

****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1), since the recursion stack will only go up to 10.

', '', 'Program to print multiplication table of a number', 19, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('22607c58-8b6f-45e8-ab9c-6da9a201ea46', e'# Bubble Sort Introduction
****Bubble Sort**** is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst-case time complexity are quite high.

-   We sort the array using multiple passes. After the first pass, the maximum element goes to end (its correct position). Same way, after second pass, the second largest element goes to second last position and so on.
-   In every pass, we process only those elements that have already not moved to correct position. After k passes, the largest k elements must have been moved to the last k positions.
-   In a pass, we consider remaining elements and compare all adjacent and swap if larger element is before a smaller element. If we keep doing this, we get the largest (among the remaining elements) at its correct position.

# How does Bubble Sort Work?

![bubble-sort-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240925153535/bubble-sort-1.webp)![bubble-sort-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240925153536/bubble-sort-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240925153536/bubble-sort-3.webp)

Below is the implementation of the bubble sort. It can be optimized by stopping the algorithm if the inner loop didn\'t cause any swap. 

```cpp
#include <bits/stdc++.h>
using namespace std;

// An optimized version of Bubble Sort 
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    bool swapped;
  
    for (int i = 0; i < n - 1; i++) {
        swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
      
        // If no two elements were swapped, then break
        if (!swapped)
            break;
    }
}

// Function to print a vector
void printVector(const vector<int>& arr) {
    for (int num : arr)
        cout << " " << num;
}

int main() {
    vector<int> arr = { 64, 34, 25, 12, 22, 11, 90 };
    bubbleSort(arr);
    cout << "Sorted array: \\n";
    printVector(arr);
    return 0;
}
```
```c
// Optimized implementation of Bubble sort
#include <stdbool.h>
#include <stdio.h>

void swap(int* xp, int* yp){
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

// An optimized version of Bubble Sort
void bubbleSort(int arr[], int n){
    int i, j;
    bool swapped;
    for (i = 0; i < n - 1; i++) {
        swapped = false;
        for (j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(&arr[j], &arr[j + 1]);
                swapped = true;
            }
        }

        // If no two elements were swapped by inner loop,
        // then break
        if (swapped == false)
            break;
    }
}

// Function to print an array
void printArray(int arr[], int size){
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", arr[i]);
}

int main(){
    int arr[] = { 64, 34, 25, 12, 22, 11, 90 };
    int n = sizeof(arr) / sizeof(arr[0]);
    bubbleSort(arr, n);
    printf("Sorted array: \\n");
    printArray(arr, n);
    return 0;
}
```
```java
// Optimized java implementation of Bubble sort
import java.io.*;

class GFG {
    
    // An optimized version of Bubble Sort
    static void bubbleSort(int arr[], int n){
        int i, j, temp;
        boolean swapped;
        for (i = 0; i < n - 1; i++) {
            swapped = false;
            for (j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    
                    // Swap arr[j] and arr[j+1]
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }

            // If no two elements were
            // swapped by inner loop, then break
            if (swapped == false)
                break;
        }
    }

    // Function to print an array
    static void printArray(int arr[], int size){
        int i;
        for (i = 0; i < size; i++)
            System.out.print(arr[i] + " ");
        System.out.println();
    }

    // Driver program
    public static void main(String args[]){
        int arr[] = { 64, 34, 25, 12, 22, 11, 90 };
        int n = arr.length;
        bubbleSort(arr, n);
        System.out.println("Sorted array: ");
        printArray(arr, n);
    }
}
```
```python
# Optimized Python program for implementation of Bubble Sort
def bubbleSort(arr):
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n):
        swapped = False

        # Last i elements are already in place
        for j in range(0, n-i-1):

            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater
            # than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if (swapped == False):
            break

# Driver code to test above
if __name__ == "__main__":
    arr = [64, 34, 25, 12, 22, 11, 90]

    bubbleSort(arr)

    print("Sorted array:")
    for i in range(len(arr)):
        print("%d" % arr[i], end=" ")
```
```csharp
// Optimized C# implementation of Bubble sort
using System;

class GFG {
  
    // An optimized version of Bubble Sort
    static void bubbleSort(int[] arr, int n){
        int i, j, temp;
        bool swapped;
        for (i = 0; i < n - 1; i++) {
            swapped = false;
            for (j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    
                    // Swap arr[j] and arr[j+1]
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }

            // If no two elements were
            // swapped by inner loop, then break
            if (swapped == false)
                break;
        }
    }

    // Function to print an array
    static void printArray(int[] arr, int size){
        int i;
        for (i = 0; i < size; i++)
            Console.Write(arr[i] + " ");
        Console.WriteLine();
    }

    // Driver method
    public static void Main(){
        int[] arr = { 64, 34, 25, 12, 22, 11, 90 };
        int n = arr.Length;
        bubbleSort(arr, n);
        Console.WriteLine("Sorted array:");
        printArray(arr, n);
    }
}
```
```javascript
// Optimized javaScript implementation
// of Bubble sort
function bubbleSort(arr, n){
    var i, j, temp;
    var swapped;
    for (i = 0; i < n - 1; i++){
        swapped = false;
        for (j = 0; j < n - i - 1; j++){
            if (arr[j] > arr[j + 1]) 
            {
                // Swap arr[j] and arr[j+1]
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }

        // IF no two elements were 
        // swapped by inner loop, then break
        if (swapped == false)
        break;
    }
}

// Function to print an array 
function printArray(arr, size){
  var i;
  for (i = 0; i < size; i++)
      console.log(arr[i] + " ");
}

// Driver program
var arr = [ 64, 34, 25, 12, 22, 11, 90 ];
var n = arr.length;
bubbleSort(arr, n);
console.log("Sorted array: ");
printArray(arr, n);
```

```output
Sorted array: 
 11 12 22 25 34 64 90
```

# Complexity Analysis of Bubble Sort

****Time Complexity:**** O(n$^2$)  
****Auxiliary Space:**** O(1)  
Please refer [Complexity Analysis of Bubble Sort](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-bubble-sort/) for details.

# Advantages of Bubble Sort
-   Bubble sort is easy to understand and implement.
-   It does not require any additional memory space.
-   It is a stable sorting algorithm, meaning that elements with the same key value maintain their relative order in the sorted output.

# Disadvantages of Bubble Sort

-   Bubble sort has a time complexity of O(n<sup><span>2</span></sup>) which makes it very slow for large data sets.
-   Bubble sort has almost no or limited real world applications. It is mostly used in academics to teach different ways of sorting.

', 'Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order.', 'Bubble Sort', 12, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('f78e2af6-1794-45be-b006-823c73f08c3c', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 10, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('29efa51f-d459-47a6-a735-6424352e6031', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 11, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('7e8c461b-6e74-4564-9530-6ee8a40eb6fd', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 12, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('409c6668-9870-48f1-8a1c-5a9191b1931b', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 13, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('8c839104-abfa-435c-9b41-3e62d1d8d101', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 14, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('085a07b3-3796-4665-b80b-d06e53e77358', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 15, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('c545ccf7-bd6f-4cc4-8968-37ebeb793d30', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 16, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('26690fd3-6c33-4660-ab78-a775fce63ff4', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 17, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('b1a2bec7-f49b-4d01-a799-d27664456f71', e'A number is called as a

****Jumping Number****
if all adjacent digits in it differ by

****1****
. The difference between

****‘9****
’ and

****‘0’****
is not considered as 1.



All single digit numbers are considered as Jumping Numbers. For example 7, 8987 and 4343456 are

****Jumping numbers****
but 796 and 89098 are not.



Given a positive number

****x****
, print all

****Jumping Numbers****
smaller than or equal to

****x****
. The numbers can be printed in any order.


****Example:****

```
Input: x = 20
Output:  0 1 2 3 4 5 6 7 8 9 10 12

Input: x = 105
Output:  0 1 2 3 4 5 6 7 8 9 10 12
         21 23 32 34 43 45 54 56 65
         67 76 78 87 89 98 101

Note: Order of output doesn\'t matter,
                                                                                                                                    i.e. numbers can be printed in any order
```


One

****Simple Solution****
is to traverse all

[numbers](https://www.geeksforgeeks.org/numbers/)
from

****0****
to

****x****
. For every traversed number, check if it is a Jumping number. If

****yes****
, then print it. Otherwise ignore it.


C++14

````
#include <bits/stdc++.h>

using namespace std;

void print_sieve(int& x)
{
    int i,temp,digit;
    bool check;

    for(i=0;i<=x;i++)
    {
        if(i<10)
        {
            cout<<i<<" ";
            continue;
        }
        check=1;
        temp=i;
        digit=temp%10;
        temp/=10;
        while(temp)
        {
            if(abs(digit-temp%10)!=1)
            {
                check=0;
                break;
            }
            digit=temp%10;
            temp/=10;
        }
        if(check)
        cout<<i<<" ";
    }
}

int main()
{
    int x=105;
    print_sieve(x);

    return 0;
}

````

Java

````
// Java program to implement
// the above approach
import java.util.*;
import java.lang.*;
import java.io.*;

class GFG
{
  public static void print_sieve(int x)
  {
    int i, temp, digit;
    int check;

    for(i = 0; i <= x; i++)
    {
      if(i < 10)
      {
        System.out.print(i + " ");
        continue;
      }
      check = 1;
      temp = i;
      digit = temp % 10;
      temp /= 10;
      while(temp != 0)
      {
        if(Math.abs(digit - temp % 10) != 1)
        {
          check = 0;
          break;
        }
        digit = temp % 10;
        temp /= 10;
      }
      if(check != 0)
        System.out.print(i + " ");
    }
  }

  // Driver Code
  public static void main(String[] args)
  {
    int x = 105;
    print_sieve(x);
  }
}

// This code is contributed by Pushpesh Raj.

````

Python

````
# Python3 program to implement the approach

# Function to print the jumping numbers
# in the range [0, x]
def print_sieve(x):

    # iterating over all the numbers
    # in the range [0, x]
    for i in range(x + 1):
        if(i < 10):

            # all numbers in [0, 9] are
            # jumping numbers
            print(i, end=" ")
            continue

        # the variable check tracks if
        # the number is valid
        check = 1
        temp = i
        digit = temp % 10
        temp //= 10
        while(temp > 0):

            if(abs(digit - temp % 10) != 1):

                check = 0
                break

            digit = temp % 10
            temp //= 10

        # printing i if check is 1
        if(check):
            print(i, end=" ")

# Driver Code
x = 105
print_sieve(x)

# This code is contributed by phasing17

````

C#

````
// C# program to implement
// the above approach
using System;

class GFG
{

  static void print_sieve(int x)
  {
    int i, temp, digit;
    int check;

    for(i = 0; i <= x; i++)
    {
      if(i < 10)
      {
        Console.Write(i + " ");
        continue;
      }
      check = 1;
      temp = i;
      digit = temp % 10;
      temp /= 10;
      while(temp != 0)
      {
        if(Math.Abs(digit - temp % 10) != 1)
        {
          check = 0;
          break;
        }
        digit = temp % 10;
        temp /= 10;
      }
      if(check != 0)
        Console.Write(i + " ");
    }
  }

  // Driver Code
  public static void Main()
  {
    int x = 105;
    print_sieve(x);
  }
}

// This code is contributed by code_hunt.

````

JavaScript

````
<script>

function print_sieve(x)
{
    let i,temp,digit;
    let check;

    for(i = 0; i <= x; i++)
    {
        if(i < 10)
        {
            document.write(i," ");
            continue;
        }
        check = 1;
        temp = i;
        digit = temp % 10;
        temp = Math.floor(temp / 10);
        while(temp)
        {
            if(Math.abs(digit - temp % 10) != 1)
            {
                check = 0;
                break;
            }
            digit = temp % 10;
            temp = Math.floor(temp / 10);
        }
        if(check)
            document.write(i," ");
    }
}

let x = 105;
print_sieve(x);

// This code is contributed by shinjanpatra

</script>

````




**Output**
```
0 1 2 3 4 5 6 7 8 9 10 12 21 23 32 34 43 45 54 56 65 67 76 78 87 89 98 101
```

*****Time Complexity:*****
O(x)



*****Auxiliary Space:*****
O(1)


An

****Efficient Solution****
can solve this problem in

****O(k)****
time where

****k****
is number of Jumping Numbers smaller than or equal to

****x****
. The idea is use

[BFS](https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/)
or

[DFS](https://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/)
.



Assume that we have a graph where the starting node is

****0****
and we need to traverse it from the start node to all the reachable nodes.


With the restrictions given in the graph about the jumping numbers, what do you think should be the restrictions defining the next transitions in the graph.


```
Lets take a example for input x = 90

Start node = 0
From 0, we can move to 1 2 3 4 5 6 7 8 9
[these are not in our range so we don\'t add it]

Now from 1, we can move to 12 and 10
From 2, 23 and 21
From 3, 34 and 32
.
.
.
.
.
.
and so on.
```


Below is BFS based implementation of above idea.


C++

````
// Finds and prints all jumping numbers smaller than or
// equal to x.
#include <bits/stdc++.h>
using namespace std;

// Prints all jumping numbers smaller than or equal to x starting
// with \'num\'. It mainly does BFS starting from \'num\'.
void bfs(int x, int num)
{
    // Create a queue and enqueue \'i\' to it
    queue<int> q;
    q.push(num);

    // Do BFS starting from i
    while (!q.empty()) {
        num = q.front();
        q.pop();

        if (num <= x) {
            cout << num << " ";
            int last_dig = num % 10;

            // If last digit is 0, append next digit only
            if (last_dig == 0)
                q.push((num * 10) + (last_dig + 1));

            // If last digit is 9, append previous digit only
            else if (last_dig == 9)
                q.push((num * 10) + (last_dig - 1));

            // If last digit is neither 0 nor 9, append both
            // previous and next digits
            else {
                q.push((num * 10) + (last_dig - 1));
                q.push((num * 10) + (last_dig + 1));
            }
        }
    }
}

// Prints all jumping numbers smaller than or equal to
// a positive number x
void printJumping(int x)
{
    cout << 0 << " ";
    for (int i = 1; i <= 9 && i <= x; i++)
        bfs(x, i);
}

// Driver program
int main()
{
    int x = 40;
    printJumping(x);
    return 0;
}

````

Java

````
// Finds and prints all jumping numbers smaller than or
// equal to x.
import java.util.*;
import java.lang.*;
import java.io.*;

class GFG {

    // Prints all jumping numbers smaller than or equal to x starting
    // with \'num\'. It mainly does BFS starting from \'num\'.
    public void bfs(int x, int num)
    {
        // Create a queue and enqueue \'i\' to it
        Queue<Integer> q = new LinkedList<Integer>();
        q.add(num);

        // Do BFS starting from i
        while (!q.isEmpty()) {
            num = q.peek();
            q.poll();
            if (num <= x) {
                System.out.print(num + " ");
                int last_digit = num % 10;

                // If last digit is 0, append next digit only
                if (last_digit == 0) {
                    q.add((num * 10) + (last_digit + 1));
                }

                // If last digit is 9, append previous digit only
                else if (last_digit == 9) {
                    q.add((num * 10) + (last_digit - 1));
                }

                // If last digit is neither 0 nor 9, append both
                // previous and next digits
                else {
                    q.add((num * 10) + (last_digit - 1));
                    q.add((num * 10) + (last_digit + 1));
                }
            }
        }
    }

    // Prints all jumping numbers smaller than or equal to
    // a positive number x
    public void printJumping(int x)
    {
        System.out.print("0 ");

        for (int i = 1; i <= 9 && i <= x; i++) {
            this.bfs(x, i);
        }
    }

    // Driver program
    public static void main(String[] args) throws IOException
    {
        int x = 40;
        GFG obj = new GFG();
        obj.printJumping(x);
    }
}

````

Python

````
# Class queue for use later
class Queue:
    def __init__(self):
        self.lst = []

    def is_empty(self):
        return self.lst == []

    def enqueue(self, elem):
        self.lst.append(elem)

    def dequeue(self):
        return self.lst.pop(0)

# Prints all jumping numbers smaller than or equal to
# x starting with \'num\'. It mainly does BFS starting
# from \'num\'.
def bfs(x, num):

    # Create a queue and enqueue i to it
    q = Queue()
    q.enqueue(num)

    # Do BFS starting from 1
    while (not q.is_empty()):
        num = q.dequeue()

        if num<= x:
            print(str(num), end =\' \')
            last_dig = num % 10

            # If last digit is 0, append next digit only
            if last_dig == 0:
                q.enqueue((num * 10) + (last_dig + 1))

            # If last digit is 9, append previous digit
            # only
            elif last_dig == 9:
                q.enqueue((num * 10) + (last_dig - 1))

            # If last digit is neither 0 nor 9, append
            # both previous digit and next digit
            else:
                q.enqueue((num * 10) + (last_dig - 1))
                q.enqueue((num * 10) + (last_dig + 1))

# Prints all jumping numbers smaller than or equal to
# a positive number x
def printJumping(x):
    print (str(0), end =\' \')
    for i in range(1, 10):
        bfs(x, i)

# Driver Program ( Change value of x as desired )
x = 40
printJumping(x)

# This code is contributed by Saket Modi

````

C#

````
// C# program to finds and prints all jumping
// numbers smaller than or equal to x.
using System;
using System.Collections.Generic;

class GFG
{

    // Prints all jumping numbers smaller than or
    // equal to x starting with \'num\'. It mainly
    // does BFS starting from \'num\'.
    public void bfs(int x, int num)
    {
        // Create a queue and enqueue \'i\' to it
        Queue<int> q = new Queue<int>();
        q.Enqueue(num);

        // Do BFS starting from i
        while (q.Count!=0)
        {
            num = q.Peek();
            q.Dequeue();
            if (num <= x)
            {
                Console.Write(num + " ");
                int last_digit = num % 10;

                // If last digit is 0, append next digit only
                if (last_digit == 0)
                {
                    q.Enqueue((num * 10) + (last_digit + 1));
                }

                // If last digit is 9, append previous digit only
                else if (last_digit == 9)
                {
                    q.Enqueue((num * 10) + (last_digit - 1));
                }

                // If last digit is neither 0 nor 9, append both
                // previous and next digits
                else
                {
                    q.Enqueue((num * 10) + (last_digit - 1));
                    q.Enqueue((num * 10) + (last_digit + 1));
                }
            }
        }
    }

    // Prints all jumping numbers smaller than or equal to
    // a positive number x
    public void printJumping(int x)
    {
        Console.Write("0 ");

        for (int i = 1; i <= 9 && i <= x; i++)
        {
            this.bfs(x, i);
        }
    }

    // Driver code
    public static void Main(String[] args)
    {
        int x = 40;
        GFG obj = new GFG();
        obj.printJumping(x);
    }
}

// This code has been contributed by 29AjayKumar

````

JavaScript

````
<script>

// Finds and prints all jumping numbers
// smaller than or equal to x.

// Prints all jumping numbers smaller than
// or equal to x starting with \'num\'. It
// mainly does BFS starting from \'num\'.
function bfs(x, num)
{

    // Create a queue and enqueue \'i\' to it
    let q = [];
    q.push(num);

    // Do BFS starting from i
    while (q.length != 0)
    {
        num = q.shift();

        if (num <= x)
        {
            document.write(num + " ");
            let last_digit = num % 10;

            // If last digit is 0, append next digit only
            if (last_digit == 0)
            {
                q.push((num * 10) + (last_digit + 1));
            }

            // If last digit is 9, append previous
            // digit only
            else if (last_digit == 9)
            {
                q.push((num * 10) + (last_digit - 1));
            }

            // If last digit is neither 0 nor 9,
            // append both previous and next digits
            else
            {
                q.push((num * 10) + (last_digit - 1));
                q.push((num * 10) + (last_digit + 1));
            }
        }
    }
}

// Prints all jumping numbers smaller
// than or equal to a positive number x
function printJumping(x)
{
    document.write("0 ");

    for(let i = 1; i <= 9 && i <= x; i++)
    {
        bfs(x, i);
    }
}

// Driver code
let x = 40;
printJumping(x);

// This code is contributed by rag2127

</script>

````




**Output**
```
0 1 10 12 2 21 23 3 32 34 4 5 6 7 8 9
```

*****Time Complexity:*****
O(k) time where

****k****
is number of Jumping Numbers smaller than or equal to

****x****


*****Auxiliary Space:*****
O(1)


Thanks to Gaurav Ahirwar for above solution.


****Exercise:****


1. Change the above solution to use DFS instead of BFS.
2. Extend your solution to print all numbers in sorted order instead of any order.
3. Further extend the solution to print all numbers in a given range.

****DFS based solution:****


In the

[DFS](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)
based approach we start building our numbers from single digits , i.e. from 1 – 9. Then we check for next possible digit and if possible we call the dfs for those numbers, increasing the number of digits with each call.


****Algorithm:****

```
1. We will start from every possible single digit, i.e. from 1 to 9
2. In the dfs we first write the base case, then
3. We print the current number
4. We get the last digit of current number and
  check the possibilities for the next digit.
  The next digit can either be last digit + 1 or last digit - 1
5. If the last digit is either 0 or 9 we have only one option for
  next number, else both the options are possible.
```


See

****C++ implementation****
of above approach:


C++

````
// C++ implementation of the above approach
#include <bits/stdc++.h>
using namespace std;
#define ll long long

void dfs(ll cnum, const ll& num)
{
    if (cnum > num) // base case
        return;

    cout << cnum << " "; // print the current number

    int l_dig = cnum % 10; // get the last digit of current number

    // for the next digit we have two options
    ll first = cnum * 10 + l_dig + 1;
    ll second = cnum * 10 + l_dig - 1;

    if (l_dig == 0) // here as second option will give us a
                    // -ve number we will skip it
        dfs(first, num);
    else if (l_dig == 9) // here as first option will give
                         // us a -ve number we will skip it
        dfs(second, num);
    else // else we call on both the options
    {
        dfs(first, num);
        dfs(second, num);
    }
}

void PrintJumping(long long X)
{
    cout << 0 << " ";
    for (ll i = 1; i <= 9; i++) {
        dfs(i, X); // generate all the numbers starting
                   // from i
    }
}

int main()
{

    long long X = 40;
    PrintJumping(X);
    return 0;
}
// This code is contributed by Abhijeet Kumar(abhijeet19403)

````

Java

````
// Java implementation of the above approach
import java.util.*;

class gfg2 {
    static void dfs(long cnum, long num)
    {
        if (cnum > num) // base case
            return;

        System.out.print(cnum
                         + " "); // print the current number

        int l_dig = (int)(cnum % 10); // get the last digit
                                      // of current number

        // for the next digit we have two options
        long first = cnum * 10 + l_dig + 1;
        long second = cnum * 10 + l_dig - 1;

        if (l_dig == 0) // here as second option will give
                        // us a -ve number we will skip it
            dfs(first, num);
        else if (l_dig
                 == 9) // here as first option will give
                       // us a -ve number we will skip it
            dfs(second, num);
        else // else we call on both the options
        {
            dfs(first, num);
            dfs(second, num);
        }
    }

    static void PrintJumping(long X)
    {
        System.out.print(0 + " ");
        for (long i = 1L; i <= 9; i++) {
            dfs(i, X); // generate all the numbers starting
                       // from i
        }
    }
    public static void main(String[] args)
    {
        long X = 40;
        PrintJumping(X);
    }
}
// This code is contributed by karandeep1234

````

Python

````
# Python3 implementation of the above approach
def dfs(cnum, num):
    # base case
    if cnum > num:
        return

    # print the current number
    print(cnum, end=" ")

    # get the last digit of the current number
    l_dig = cnum % 10

    # for the next digit we have two options
    first = cnum * 10 + l_dig + 1
    second = cnum * 10 + l_dig - 1

    # here as second option will give us a -ve number
    # we will skip it
    if l_dig == 0:
        dfs(first, num)
    # here as first option will give us a -ve number
    # we will skip it
    elif l_dig == 9:
        dfs(second, num)
    # else we will call on both the options
    else:
        dfs(first, num)
        dfs(second, num)

# Print Jumping numbers
def PrintJumping(X):
    print(0, end=" ")
    for i in range(1, 10):
        dfs(i, X)

# Driver code
if __name__ == \'__main__\':
    X = 40
    PrintJumping(X)

    # This code is contributed by factworx412

````

C#

````
// C# implementation of the above approach
using System;

class GFG {
  static void dfs(long cnum, long num)
  {
    if (cnum > num) // base case
      return;

    Console.Write(cnum
                  + " "); // print the current number

    int l_dig = (int)(cnum % 10); // get the last digit
    // of current number

    // for the next digit we have two options
    long first = cnum * 10 + l_dig + 1;
    long second = cnum * 10 + l_dig - 1;

    if (l_dig == 0) // here as second option will give
      // us a -ve number we will skip it
      dfs(first, num);
    else if (l_dig
             == 9) // here as first option will give
      // us a -ve number we will skip it
      dfs(second, num);
    else // else we call on both the options
    {
      dfs(first, num);
      dfs(second, num);
    }
  }

  static void PrintJumping(long X)
  {
    Console.Write(0 + " ");
    for (long i = 1L; i <= 9; i++) {
      dfs(i, X); // generate all the numbers starting
      // from i
    }
  }
  static void Main(string[] args)
  {
    long X = 40;
    PrintJumping(X);
  }
}

// This code is contributed by karandeep1234

````

JavaScript

````
    // Javascript implementation of the above approach
    function dfs(cnum, num)
    {
        if (cnum > num) // base case
            return;

        console.log(cnum+" "); // print the current number

        let l_dig = cnum % 10; // get the last digit of current number

        // for the next digit we have two options
        let first = cnum * 10 + l_dig + 1;
        let second = cnum * 10 + l_dig - 1;

        if (l_dig == 0) // here as second option will give us a
                        // -ve number we will skip it
            dfs(first, num);
        else if (l_dig == 9) // here as first option will give
                            // us a -ve number we will skip it
            dfs(second, num);
        else // else we call on both the options
        {
            dfs(first, num);
            dfs(second, num);
        }
    }

    function PrintJumping(X)
    {
        console.log(0+" ");
        for(let i = 1; i <= 9; i++) {
            dfs(i, X); // generate all the numbers starting
                    // from i
        }
    }

        let X = 40;
        PrintJumping(X);

    // This code is contributed by Aman Kumar.

````




**Output**
```
0 1 12 10 2 23 21 3 34 32 4 5 6 7 8 9
```

****Time Complexity:****
O(k)


Here k is the total number of jumping numbers.


****Auxiliary Space:****
O(len(N))


Here len(N) is the maximum length from all the jumping numbers, the extra space is used due to recursive function call stack.

', '', 'Print all Jumping Numbers smaller than or equal to a given value', 4, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('023ee905-49cc-4ff9-b0f6-57f68b7a1d9a', e'

[****LCM****](https://www.geeksforgeeks.org/lcm-least-common-multiple/)
of two numbers is the smallest number which can be divided by both numbers.


> ****Input****
> : a = 12, b = 18
>
>
>
> ****Output****
> : 36
>
>
>
> 36 is the smallest number divisible by both 12 and 18
>
>
> ****Input****
> : a = 5, b = 11
>
>
>
> ****Output****
> : 55
>
>
>
> 55 is the smallest number divisible by both 5 and 11


A

****simple solution****
is to

[find all prime factors](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)
of both numbers, then find union of all factors present in both

[numbers](https://www.geeksforgeeks.org/numbers/)
. Finally, return the product of elements in union.


An

****efficient solution****
is based on the below formula for LCM of two numbers ‘a’ and ‘b’.


![relation---------between---------hcf---------and---------lcm_________](https://media.geeksforgeeks.org/wp-content/uploads/20241122160112040184/relation---------between---------hcf---------and---------lcm_________.webp)
> a x b = LCM(a, b) \\* GCD (a, b)
>
>
>
>
>
> LCM(a, b) = (a x b) / GCD(a, b)


We have discussed

[function to find GCD of two numbers](https://www.geeksforgeeks.org/c-program-find-gcd-hcf-two-numbers/)
. Using GCD, we can find LCM.


Below is the implementation of the above idea:



C++

````
// C++ program to find LCM of two numbers
#include <iostream>
using namespace std;

// Recursive function to return gcd of a and b
long long gcd(long long int a, long long int b)
{
  if (b == 0)
    return a;
  return gcd(b, a % b);
}

// Function to return LCM of two numbers
long long lcm(int a, int b)
{
    return (a / gcd(a, b)) * b;
}

// Driver program to test above function
int main()
{
    int a = 15, b = 20;
    cout <<"LCM of " << a << " and "
         << b << " is " << lcm(a, b);
    return 0;
}

````

C

````
// C program to find LCM of two numbers
#include <stdio.h>

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

// Function to return LCM of two numbers
int lcm(int a, int b)
{
    return (a / gcd(a, b)) * b;
}

// Driver program to test above function
int main()
{
    int a = 15, b = 20;
    printf("LCM of %d and %d is %d ", a, b, lcm(a, b));
    return 0;
}

````

Java

````
// Java program to find LCM of two numbers.
import java.io.*;
public class Test
{
    // Recursive method to return gcd of a and b
    static int gcd(int a, int b)
    {
        if (a == 0)
            return b;
        return gcd(b % a, a);
    }

    // method to return LCM of two numbers
    static int lcm(int a, int b)
    {
        return (a / gcd(a, b)) * b;
    }

    // Driver method
    public static void main(String[] args)
    {
        int a = 15, b = 20;
        System.out.println("LCM of " + a +
                           " and " + b +
                      " is " + lcm(a, b));
    }
}

````

Python

````
# Python program to find LCM of two numbers

# Recursive function to return gcd of a and b
def gcd(a,b):
    if a == 0:
        return b
    return gcd(b % a, a)

# Function to return LCM of two numbers
def lcm(a,b):
    return (a // gcd(a,b))* b

# Driver program to test above function
a = 15
b = 20
print(\'LCM of\', a, \'and\', b, \'is\', lcm(a, b))

# This code is contributed by Danish Raza

````

C#

````
// C# program to find LCM
// of two numbers.
using System;
class GFG {

    // Recursive method to
    // return gcd of a and b
    static int gcd(int a, int b)
    {
        if (a == 0)
            return b;
        return gcd(b % a, a);
    }

    // method to return
    // LCM of two numbers
    static int lcm(int a, int b)
    {
        return (a / gcd(a, b)) * b;
    }

    // Driver method
    public static void Main()
    {
        int a = 15, b = 20;
        Console.WriteLine("LCM of " + a +
         " and " + b + " is " + lcm(a, b));
    }
}

// This code is contributed by anuj_67.

````

JavaScript

````
<script>

// Javascript program to find LCM of two numbers

// Recursive function to return gcd of a and b
function gcd(a, b)
{
if (b == 0)
    return a;
return gcd(b, a % b);
}

// Function to return LCM of two numbers
function lcm(a, b)
{
    return (a / gcd(a, b)) * b;
}

// Driver program to test above function

    let a = 15, b = 20;
    document.write("LCM of " + a + " and "
    + b + " is " + lcm(a, b));


// This code is contributed by Mayank Tyagi

</script>

````

PHP

````
<?php
// PHP program to find LCM of two numbers

// Recursive function to
// return gcd of a and b
function gcd( $a, $b)
{
   if ($a == 0)
        return $b;
    return gcd($b % $a, $a);
}

// Function to return LCM
// of two numbers
function lcm( $a, $b)
{
    return ($a / gcd($a, $b)) * $b;
}

    // Driver Code
    $a = 15;
    $b = 20;
    echo "LCM of ",$a, " and "
         ,$b, " is ", lcm($a, $b);

// This code is contributed by anuj_67.
?>

````




**Output**
```
LCM of 15 and 20 is 60
```

****Time Complexity:****
O(log(min(a,b))



****Auxiliary Space:****
O(log(min(a,b))


****Another Efficient Approach: Using conditional for loop****

C++

````
// C++ program to find LCM of 2 numbers
#include <bits/stdc++.h>
using namespace std;

// Function to return LCM of two numbers
int LCM(int a, int b)
{
    int greater = max(a, b);
    int smallest = min(a, b);
    for (int i = greater; ; i += greater) {
        if (i % smallest  == 0)
            return i;
    }
}

// Driver program to test above function
int main()
{
    int a = 10, b = 5;
    cout << "LCM of " << a << " and "
         << b << " is " << LCM(a, b);
    return 0;
}

````

Java

````
// Java program to find LCM of 2 numbers

import java.util.Scanner;

public class LCM {
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        int a = 10;
        int b = 5;
        int lcm = findLCM(a, b);
        System.out.println("LCM of " + a + " and " + b
                           + " is " + lcm);
        sc.close();
    }
    // Function to return LCM of two numbers
    public static int findLCM(int a, int b)
    {
        int greater = Math.max(a, b);
        int smallest = Math.min(a, b);
        for (int i = greater;; i += greater) {
            if (i % smallest == 0)
                return i;
        }
    }
}

````

Python

````
# Python program to find LCM of two numbers

# Function to return LCM of two numbers
def LCM(a, b):
    greater = max(a, b)
    smallest = min(a, b)
    for i in range(greater, a*b+1, greater):
        if i % smallest == 0:
            return i

# Driver program to test above function
if __name__ == \'__main__\':
    a = 10
    b = 5
    print("LCM of", a, "and", b, "is", LCM(a, b))

````

C#

````
// C# program to find LCM of 2 numbers
using System;

class LCMProgram
{

  // Function to return LCM of two numbers
  static int LCM(int a, int b)
  {
    int greater = Math.Max(a, b);
    int smallest = Math.Min(a, b);
    for (int i = greater;; i += greater) {
      if (i % smallest == 0)
        return i;
    }
  }

  // Driver program to test above function
  static void Main()
  {
    int a = 10, b = 5;
    Console.WriteLine("LCM of " + a + " and " + b
                      + " is " + LCM(a, b));
  }
}

````

JavaScript

````
// Javascript program to find LCM of two numbers

// Function to return LCM of two numbers
function LCM(a, b){
    let greater = Math.max(a, b);
    let smallest = Math.min(a, b);
    for(let i = greater; i <= a*b; i+=greater){
        if(i % smallest == 0){
            return i;
        }
    }
}

// Driver program to test above function
let a = 10;
let b = 5;
console.log("LCM of", a, "and", b, "is", LCM(a, b));

````




**Output**
```
LCM of 10 and 5 is 10
```

****Time Complexity:****
O(min(a,b))



****Auxiliary Space:****
O(1)
', 'LCM of two numbers is the smallest number which can be divided by both numbers.', 'Program to find LCM of two numbers', 5, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('995fe7e2-ea73-4f91-8cbc-00bcdc769c4d', e'Given two numbers

****a****
and

****b****
, the task is to find the

[GCD](https://www.geeksforgeeks.org/greatest-common-divisor-gcd/)
of the two numbers.


****Note:****
The GCD (Greatest Common Divisor) or HCF (Highest Common Factor) of two numbers is the largest number that divides both of them.



![gcd](https://media.geeksforgeeks.org/wp-content/uploads/20240920171939/gcd.webp)




****Examples:****

> ****Input:****
> a = 20, b = 28
>
>
>
> ****Output:****
> 4
>
>
>
> ****Explanation:****
> The factors of 20 are 1, 2, 4, 5, 10 and 20. The factors of 28 are 1, 2, 4, 7, 14 and 28. Among these factors, 1, 2 and 4 are the common factors of both 20 and 28. The greatest among the common factors is 4.
>
>
> ****Input:****
> a = 60, b = 36
>
>
>
> ****Output:****
> 12

Naive Approach for GCD of two numbers:
--------------------------------------

> The basic idea is to find the minimum of the two numbers and find its highest factor which is also a factor of the other
>
> [number](https://www.geeksforgeeks.org/numbers/)
> .


Below is the code implementation of the above idea:



C++

````
// C++ program to find GCD of two numbers

#include <bits/stdc++.h>
using namespace std;

// Function to return gcd of a and b
int gcd(int a, int b)
{
    // Find Minimum of a and b
    int result = min(a, b);
    while (result > 0) {
        if (a % result == 0 && b % result == 0) {
            break;
        }
        result--;
    }

    // Return gcd of a and b
    return result;
}

// Driver code
int main()
{
    int a = 98, b = 56;
    cout << "GCD of " << a << " and " << b << " is "
         << gcd(a, b);
    return 0;
}

````

C

````
// C program to find GCD of two numbers

#include <math.h>
#include <stdio.h>

// Function to return gcd of a and b
int gcd(int a, int b)
{
    // Find Minimum of a and b
    int result = ((a < b) ? a : b);
    while (result > 0) {
        if (a % result == 0 && b % result == 0) {
            break;
        }
        result--;
    }

    // Return gcd of a and b
    return result;
}

// Driver code
int main()
{
    int a = 98, b = 56;
    printf("GCD of %d and %d is %d ", a, b, gcd(a, b));
    return 0;
}

````

Java

````
// Java program to find GCD of two numbers
import java.io.*;

public class GFG {

    // Function to return gcd of a and b
    static int gcd(int a, int b)
    {
        // Find Minimum of a and b
        int result = Math.min(a, b);
        while (result > 0) {
            if (a % result == 0 && b % result == 0) {
                break;
            }
            result--;
        }

        // Return gcd of a and b
        return result;
    }

    // Driver code
    public static void main(String[] args)
    {
        int a = 98, b = 56;
        System.out.print("GCD of " + a + " and " + b
                         + " is " + gcd(a, b));
    }
}

````

Python

````
# Python program to find GCD of two numbers


# Function to find gcd of two numbers
def gcd(a, b):

    # Find minimum of a and b
    result = min(a, b)

    while result:
        if a % result == 0 and b % result == 0:
            break
        result -= 1

    # Return the gcd of a and b
    return result


# Driver Code
if __name__ == \'__main__\':
    a = 98
    b = 56
    print(f"GCD of {a} and {b} is {gcd(a, b)}")

````

C#

````
// C# program to find GCD of two numbers

using System;
public class GFG {

    // Function to return gcd of a and b
    static int gcd(int a, int b)
    {
        // Find Minimum of a and b
        int result = Math.Min(a, b);
        while (result > 0) {
            if (a % result == 0 && b % result == 0) {
                break;
            }
            result--;
        }

        // Return gcd of a and b
        return result;
    }

    // Driver code
    public static void Main(string[] args)
    {
        int a = 98, b = 56;
        Console.WriteLine("GCD of " + a + " and " + b
                          + " is " + gcd(a, b));
    }
}

````

JavaScript

````
// Javascript program to find GCD of two numbers
// Function to return gcd of a and b
function gcd(a,b)
{
    // Find Minimum of a and b
    let result = Math.min(a, b);
    while (result > 0) {
        if (a % result == 0 && b % result == 0) {
            break;
        }
        result--;
    }

    // Return gcd of a and b
    return result;
}

// Driver program to test above function
let a = 98;
let b = 56;
console.log("GCD of ",a," and ",b," is ",gcd(a, b));

````




**Output**
```
GCD of 98 and 56 is 14
```

****Time Complexity:****
O(min(a,b))



****Auxiliary Space:****
O(1)


[Euclidean algorithm](https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended)
for GCD of two numbers:
--------------------------------------------------------------------------------------------------------------------


The idea of this algorithm is, the GCD of two numbers doesn’t change if the smaller number is subtracted from the bigger number. This is the

****Euclidean algorithm by subtraction****
. It is a process of repeat subtraction, carrying the result forward each time until the result is equal to any one number being subtracted.


****Pseudo-code:****

> gcd(a, b):
>
>
>
> if a = b:
>
>
>
> return a
>
>
>
> if a > b:
>
>
>
> return gcd(a – b, b)
>
>
>
> else:
>
>
>
> return gcd(a, b – a)


Below is the implementation of the above approach.



C++

````
// C++ program to find GCD of two numbers
// code is updated by himanshug9119 - linkedin URL -
// https://www.linkedin.com/in/himanshug9119/
#include <bits/stdc++.h>
using namespace std;

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    // Everything divides 0
    if (a == 0)
        return b;
    if (b == 0)
        return a;

    // Base case
    if (a == b)
        return a;

    // a is greater
    if (a > b)
        return gcd(a - b, b);
    return gcd(a, b - a);
}

// Driver code
int main()
{
    int a = 98, b = 56;
    cout << "GCD of " << a << " and " << b << " is "
         << gcd(a, b);
    return 0;
}

````

C

````
// C program to find GCD of two numbers

#include <stdio.h>

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    // Everything divides 0
    if (a == 0)
        return b;
    if (b == 0)
        return a;

    // Base case
    if (a == b)
        return a;

    // a is greater
    if (a > b)
        return gcd(a - b, b);
    return gcd(a, b - a);
}

// Driver code
int main()
{
    int a = 98, b = 56;
    printf("GCD of %d and %d is %d ", a, b, gcd(a, b));
    return 0;
}

````

Java

````
// Java program to find GCD of two numbers

import java.io.*;

class Test {

    // Recursive function to return gcd of a and b
    static int gcd(int a, int b)
    {
        // Everything divides 0
        if (a == 0)
            return b;
        if (b == 0)
            return a;

        // Base case
        if (a == b)
            return a;

        // a is greater
        if (a > b)
            return gcd(a - b, b);
        return gcd(a, b - a);
    }

    // Driver code
    public static void main(String[] args)
    {
        int a = 98, b = 56;
        System.out.println("GCD of " + a + " and " + b
                           + " is " + gcd(a, b));
    }
}

````

Python

````
# Python program to find GCD of two numbers


# Recursive function to return gcd of a and b
def gcd(a, b):

    # Everything divides 0
    if (a == 0):
        return b
    if (b == 0):
        return a

    # Base case
    if (a == b):
        return a

    # a is greater
    if (a > b):
        return gcd(a-b, b)
    return gcd(a, b-a)


# Driver code
if __name__ == \'__main__\':
    a = 98
    b = 56
    if(gcd(a, b)):
        print(\'GCD of\', a, \'and\', b, \'is\', gcd(a, b))
    else:
        print(\'not found\')

# This code is contributed by Danish Raza

````

C#

````
// C# program to find GCD of two numbers

using System;

class GFG {

    // Recursive function to return gcd of a and b
    static int gcd(int a, int b)
    {
        // Everything divides 0
        if (a == 0)
            return b;
        if (b == 0)
            return a;

        // Base case
        if (a == b)
            return a;

        // a is greater
        if (a > b)
            return gcd(a - b, b);

        return gcd(a, b - a);
    }

    // Driver code
    public static void Main()
    {
        int a = 98, b = 56;
        Console.WriteLine("GCD of " + a + " and " + b
                          + " is " + gcd(a, b));
    }
}

// This code is contributed by anuj_67.

````

JavaScript

````
// Javascript program to find GCD of two numbers

// Recursive function to return gcd of a and b
function gcd(a, b)
{
    // Everything divides 0
    if (a == 0)
    return b;
    if (b == 0)
    return a;

    // Base case
    if (a == b)
        return a;

    // a is greater
    if (a > b)
        return gcd(a-b, b);
    return gcd(a, b-a);
}

// Driver program to test above function

    let a = 98, b = 56;
    console.log("GCD of "+ a + " and " + b + " is " + gcd(a, b));

// This code is contributed by Mayank Tyagi

````

PHP

````
<?php
// PHP program to find GCD
// of two numbers

// Recursive function to return gcd of a and b
function gcd($a, $b)
{
    // Everything divides 0
    if ($a == 0)
       return $b;
    if ($b == 0)
       return $a;

    // Base case
    if($a == $b)
        return $a ;

    // a is greater
    if($a > $b)
        return gcd( $a-$b , $b ) ;

    return gcd( $a , $b-$a ) ;
}

// Driver code
$a = 98 ;
$b = 56 ;

echo "GCD of $a and $b is ", gcd($a , $b) ;

// This code is contributed by Anivesh Tiwari
?>

````




**Output**
```
GCD of 98 and 56 is 14
```

****Time Complexity:****
O(min(a,b))



****Auxiliary Space:****
O(min(a,b)) because it uses internal stack data structure in recursion.


****Optimization by checking divisibility:****
----------------------------------------------


The above method can be optimized based on the following idea:


> If we notice the previous approach, we can see at some point, one number becomes a factor of the other so instead of repeatedly subtracting till both become equal, we can check if it is a factor of the other.

****Illustration:****


See the below illustration for a better understanding:


> Consider a = 98 and b = 56
>
>
> ****a = 98, b = 56:****
>
> * a > b so put a = a-b and b remains same. So  a = 98-56 = 42  & b= 56.
>
> ****a = 42, b = 56:****
>
> * Since b > a, we check if b%a=0. Since answer is no, we proceed further.
> * Now b>a. So b = b-a and a remains same. So b = 56-42 = 14 & a= 42.
>
> ****a = 42, b = 14:****
>
> * Since a>b, we check if a%b=0. Now the answer is yes.
> * So we print smaller among a and b as H.C.F . i.e. 42 is  3 times of 14.
>
>
> So
>
> ****HCF****
> is 14.


Below is the implementation of the above approach:


C++

````
// C++ program to find GCD of two numbers

#include <bits/stdc++.h>
using namespace std;

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    // Everything divides 0
    if (a == 0)
        return b;
    if (b == 0)
        return a;

    // Base case
    if (a == b)
        return a;

    // a is greater
    if (a > b) {
        if (a % b == 0)
            return b;
        return gcd(a - b, b);
    }
    if (b % a == 0)
        return a;
    return gcd(a, b - a);
}

// Driver code
int main()
{
    int a = 98, b = 56;
    cout << "GCD of " << a << " and " << b << " is "
         << gcd(a, b);
    return 0;
}

````

Java

````
public class GCD {
    // Recursive function to return gcd of a and b
    static int gcd(int a, int b) {
        // Everything divides 0
        if (a == 0)
            return b;
        if (b == 0)
            return a;

        // Base case
        if (a == b)
            return a;

        // a is greater
        if (a > b) {
            if (a % b == 0)
                return b;
            return gcd(a - b, b);
        }
        if (b % a == 0)
            return a;
        return gcd(a, b - a);
    }

    // Driver code
    public static void main(String[] args) {
        int a = 98, b = 56;
        System.out.println("GCD of " + a + " and " + b + " is " + gcd(a, b));
    }
}
// This code is contributed by rambabuguphka

````

Python

````
def gcd(a, b):
    # Everything divides 0
    if a == 0:
        return b
    if b == 0:
        return a

    # Base case
    if a == b:
        return a

    # a is greater
    if a > b:
        if a % b == 0:
            return b
        return gcd(a - b, b)
    if b % a == 0:
        return a
    return gcd(a, b - a)

# Driver code
a = 98
b = 56
print(f"GCD of {a} and {b} is {gcd(a, b)}")

````

C#

````
using System;

public class GFG
{
    // Recursive function to return gcd of a and b
    static int GCD(int a, int b)
    {
        // Everything divides 0
        if (a == 0)
            return b;
        if (b == 0)
            return a;

        // Base case
        if (a == b)
            return a;

        // a is greater
        if (a > b)
        {
            if (a % b == 0)
                return b;
            return GCD(a - b, b);
        }
        if (b % a == 0)
            return a;
        return GCD(a, b - a);
    }

    // Main method
    public static void Main(string[] args)
    {
        int a = 98, b = 56;
        Console.WriteLine("GCD of " + a + " and " + b + " is " + GCD(a, b));
    }
}

// This code is add by Avinash Wani

````

JavaScript

````
// Recursive function to return gcd of a and b
function gcd(a, b) {
    // Everything divides 0
    if (a === 0) {
        return b;
    }
    if (b === 0) {
        return a;
    }

    // Base case
    if (a === b) {
        return a;
    }

    // a is greater
    if (a > b) {
        if (a % b === 0) {
            return b;
        }
        return gcd(a - b, b);
    }
    if (b % a === 0) {
        return a;
    }
    return gcd(a, b - a);
}

// Driver code
let a = 98;
let b = 56;
console.log(`GCD of ${a} and ${b} is ${gcd(a, b)}`);

````




**Output**
```
GCD of 98 and 56 is 14
```

****Time Complexity:****
O(min(a, b))



****Auxiliary Space:****
O(1)


****Optimization using division:****
------------------------------------

> Instead of the Euclidean algorithm by subtraction, a better approach can be used. We don’t perform subtraction here. we continuously divide the bigger number by the smaller number. More can be learned about this
>
> ****efficient solution****
> by using the modulo operator in
>
> [Euclidean algorithm](https://www.geeksforgeeks.org/euclidean-algorithms-basic-and-extended)
> .


Below is the implementation of the above approach.


C++

````
// C++ program to find GCD of two numbers
#include <iostream>
using namespace std;
// Recursive function to return gcd of a and b in single line
int gcd(int a, int b)
{
    return b == 0 ? a : gcd(b, a % b);
}

// Driver program to test above function
int main()
{
    int a = 98, b = 56;
    cout<<"GCD of "<<a<<" and "<<b<<" is "<<gcd(a, b);
    return 0;
}

````

C

````
// C program to find GCD of two numbers
#include <stdio.h>

// Recursive function to return gcd of a and b
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

// Driver program to test above function
int main()
{
    int a = 98, b = 56;
    printf("GCD of %d and %d is %d ", a, b, gcd(a, b));
    return 0;
}

````

Java

````
// Java program to find GCD of two numbers
import java.io.*;

class Test
{
    // Recursive function to return gcd of a and b
    static int gcd(int a, int b)
    {
      if (b == 0)
        return a;
      return gcd(b, a % b);
    }

    // Driver method
    public static void main(String[] args)
    {
        int a = 98, b = 56;
        System.out.println("GCD of " + a +" and " + b + " is " + gcd(a, b));
    }
}

````

Python

````
# Recursive function to return gcd of a and b
def gcd(a,b):

    # Everything divides 0
    if (b == 0):
         return a
    return gcd(b, a%b)

# Driver program to test above function
a = 98
b = 56
if(gcd(a, b)):
    print(\'GCD of\', a, \'and\', b, \'is\', gcd(a, b))
else:
    print(\'not found\')

# This code is contributed by Danish Raza

````

C#

````
// C# program to find GCD of two
// numbers
using System;

class GFG {

    // Recursive function to return
    // gcd of a and b
    static int gcd(int a, int b)
    {
       if (b == 0)
          return a;
       return gcd(b, a % b);
    }

    // Driver method
    public static void Main()
    {
        int a = 98, b = 56;
        Console.WriteLine("GCD of "
          + a +" and " + b + " is "
                      + gcd(a, b));
    }
}

// This code is contributed by anuj_67.

````

JavaScript

````
<script>

// Javascript program to find GCD of two number

// Recursive function to return gcd of a and b

function gcd(a, b){

  // Everything divides 0
  if(b == 0){
    return a;
  }

  return gcd(b, a % b);
}

// Driver code
let a = 98;
let b = 56;

document.write(`GCD of ${a} and ${b} is ${gcd(a, b)}`);

// This code is contributed by _saurabh_jaiswal

</script>

````

PHP

````
<?php
// PHP program to find GCD
// of two numbers

// Recursive function to
// return gcd of a and b
function gcd($a, $b)
{
    // Everything divides 0
    if($b==0)
        return $a ;

    return gcd( $b , $a % $b ) ;
}

// Driver code
$a = 98 ;
$b = 56 ;

echo "GCD of $a and $b is ", gcd($a , $b) ;

// This code is contributed by Anivesh Tiwari
?>

````




**Output**
```
GCD of 98 and 56 is 14
```

****Complexity Analysis:****

****Time Complexity:****
O(log(min(a,b)))


* The derivation for this is obtained from the analysis of the worst-case scenario.
* What we do is we ask what are the 2 least numbers that take 1 step, those would be (1,1). If we want to increase the number of steps to 2 while keeping the numbers as low as possible as we can take the numbers to be (1,2). Similarly, for 3 steps, the numbers would be (2,3), 4 would be (3,5), 5 would be (5,8).
* So we can notice a pattern here, for the nth step the numbers would be (fib(n), fib(n+1)). So the worst-case time complexity would be O(n) where

  ****a ? fib(n)****
  and

  ****b ? fib(n+1)****
  .
* Now Fibonacci series is an exponentially growing series where the ratio of n

  th
  /(n-1)

  th
  term approaches (sqrt(5)+1)/2 which is also called the golden ratio. So we can see that the time complexity of the algorithm increases linearly as the terms grow exponentially hence the time complexity would be

  ****log(min(a,b))****
  .

****Auxiliary Space:****
O(log(min(a,b))


****Iterative implementation for GCD of two numbers using Euclidean Algorithm:****
----------------------------------------------------------------------------------


Below is the iterative way to find the GCD of two numbers using Euclidean algorithm.


C++

````
// C++ program to find GCD of two numbers
#include <bits/stdc++.h>
using namespace std;

// Iterative function to return gcd of a and b
int gcd(int a, int b)
{
    while (a > 0 && b > 0) {
        if (a > b) {
            a = a % b;
        }
        else {
            b = b % a;
        }
    }
    if (a == 0) {
        return b;
    }
    return a;
}

// Driver code
int main()
{
    int a = 98, b = 56;
    cout << "GCD of " << a << " and " << b << " is "
         << gcd(a, b);
    return 0;
}

````

C

````
// C program to find GCD of two numbers
#include <stdio.h>

// Iterative function to return gcd of a and b
int gcd(int a, int b)
{
    while (a > 0 && b > 0) {
        if (a > b) {
            a = a % b;
        }
        else {
            b = b % a;
        }
    }
    if (a == 0) {
        return b;
    }
    return a;
}

// Driver code
int main()
{
    int a = 98, b = 56;
    printf("GCD of %d and %d is %d ", a, b, gcd(a, b));
    return 0;
}

````

Java

````
// Java program to find GCD of two numbers
import java.io.*;

class Test {

    // Iterative function to return gcd of a and b
    static int gcd(int a, int b)
    {
        while (a > 0 && b > 0) {
            if (a > b) {
                a = a % b;
            }
            else {
                b = b % a;
            }
        }
        if (a == 0) {
            return b;
        }
        return a;
    }

    // Driver code
    public static void main(String[] args)
    {
        int a = 98, b = 56;
        System.out.println("GCD of " + a + " and " + b
                           + " is " + gcd(a, b));
    }
}

````

Python

````
# Itervative function to return gcd of a and b


def gcd(a, b):

    # Everything divides 0
    while(a > 0 and b > 0):
        if (a > b):
            a = a % b
        else:
            b = b % a

    if (a == 0):
        return b
    return a


# Driver code
if __name__ == \'__main__\':
    a = 98
    b = 56
    if(gcd(a, b)):
        print(\'GCD of\', a, \'and\', b, \'is\', gcd(a, b))
    else:
        print(\'not found\')

````

C#

````
// C# program to find GCD of two numbers
using System;

class GFG {

    // Iterative function to return gcd of a and b
    static int gcd(int a, int b)
    {
        while (a > 0 && b > 0) {
            if (a > b) {
                a = a % b;
            }
            else {
                b = b % a;
            }
        }
        if (a == 0) {
            return b;
        }
        return a;
    }

    // Driver code
    public static void Main()
    {
        int a = 98, b = 56;
        Console.WriteLine("GCD of " + a + " and " + b
                          + " is " + gcd(a, b));
    }
}

// This code is contributed by anuj_67.

````

JavaScript

````
// Javascript program to find GCD of two number

// Recursive function to return gcd of a and b

function gcd(a, b){

  // Everything divides 0
      while (a > 0 && b > 0) {
        if (a > b) {
            a = a % b;
        }
        else {
            b = b % a;
        }
    }
    if (a == 0) {
        return b;
    }
    return a;
}

// Driver code
let a = 98;
let b = 56;

console.log(`GCD of ${a} and ${b} is ${gcd(a, b)}`);

// This code is contributed by _saurabh_jaiswal

````




**Output**
```
GCD of 98 and 56 is 14
```

****Time Complexity:****
O(log(min(a,b)))



****Auxiliary Space:****
O(1)


### GCD of two numbers using inbuilt function:


Languages like C++ have inbuilt functions to calculate GCD of two numbers.


Below is the implementation using inbuilt functions.


C++

````
// c++ program to find gcd using inbuilt functions
#include <algorithm>
#include <iostream>
using namespace std;

int main()
{
    int a = 98, b = 56;
    cout << "The gcd of a and b is " << __gcd(a, b) << endl;
    return 0;
}

````

Java

````
// JAVA program to find gcd using inbuilt functions
import java.math.BigInteger;
import java.util.*;

public class GFG {
    public static void main(String[] args)
    {
        int a = 98, b = 56;
        int gcd = gcd(a, b);
        System.out.println("The gcd of a and b is " + gcd);
    }

    public static int gcd(int a, int b)
    {
        BigInteger bigA = BigInteger.valueOf(Math.abs(a));
        BigInteger bigB = BigInteger.valueOf(Math.abs(b));
        BigInteger gcd = bigA.gcd(bigB);
        return gcd.intValue();
    }
}
// This code is contributed by Taranpreet Singh.

````

Python

````
# Python program to find gcd using inbuilt function using math library
import math

#Driver code
if __name__ == \'__main__\':
  a = 98
  b = 56
  gcd_result = math.gcd(a, b) # inbuilt function gcd() using math library

  print("The gcd of a and b is", gcd_result)

# This code is contributed by guptapratik

````

C#

````
using System;

class Program
{
    static void Main()
    {
        int a = 98, b = 56;
        Console.WriteLine($"The gcd of a and b is {GCD(a, b)}");
    }

    static int GCD(int a, int b)
    {
        return Math.Abs(b == 0 ? a : GCD(b, a % b));
    }
}

````

JavaScript

````
function gcd(a, b) {
    if (b === 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}

// Example usage
const a = 98;
const b = 56;
console.log("The gcd of a and b is " + gcd(a, b));


// Contributed By Siddhesh22

````




**Output**
```
The gcd of a and b is 14

```

****Time Complexity:****
O(log(min(a, b)))



****Auxiliary Space:****
O(1)

', '', 'Program to Find GCD or HCF of Two Numbers', 6, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('d1958775-d3e0-4bf8-b656-d1136cdb0e05', e'Given the number

****n****
(n >=0), find its

[factorial](https://www.geeksforgeeks.org/factorial/)
. Factorial of n is defined as 1 x 2 x … x n. For n = 0, factorial is 1. We are going to discuss iterative and recursive programs in this post.


****Examples:****

> ****Input****
> : n = 5
>
>
>
> ****Output****
> : 120
>
>
>
> ****Explanation****
> : 5! = 5 \\* 4 \\* 3 \\* 2 \\* 1 = 120
>
>
> ****Input****
> : n = 4
>
>
>
> ****Output****
> : 24
>
>
>
> ****Explanation****
> : 4! = 4 \\* 3 \\* 2 \\* 1 = 24
>
>
> ****Input****
> : n = 0
>
>
>
> ****Output****
> : 1
>
>
> ****Input****
> : n = 1
>
>
>
> ****Output****
> : 1

### ****Iterative Solution****


The idea is simple, we initialize result as 1. Then run a loop from 1 to n and multiply every number with n.



> ****Illustration for n = 4****
>
>
> Initialize res = 1
>
>
>
> Run a loop for i = 2 to 4
>
>
>
> i = 2 : res = res \\* 2 = 2
>
>
>
> i = 3 : res = res \\* 3 = 6
>
>
>
> i = 4 : res = res \\* 4 = 24

C++

````
// C++ program for factorial of a number
#include <iostream>
using namespace std;

// function to find factorial of given number
int factorial(int n)
{
    int res = 1;
    for (int i = 2; i <= n; i++)
        res *= i;
    return res;
}

// Driver code
int main()
{
    int num = 5;
    cout << "Factorial of " << num << " is " << factorial(num) << endl;
    return 0;
}

````

C

````
#include <stdio.h>

// function to find factorial of given number
int factorial(int n)
{
    int res = 1, i;
    for (i = 2; i <= n; i++)
        res *= i;
    return res;
}

int main()
{
    int num = 5;
    printf("Factorial of %d is %d", num, factorial(num));
    return 0;
}

````

Java

````
// Java program to find factorial of given number
class GfG {

    // Method to find factorial of the given number
    static int factorial(int n)
    {
        int res = 1;
        for (int i = 2; i <= n; i++)
            res *= i;
        return res;
    }

    // Driver method
    public static void main(String[] args)
    {
        int num = 5;
        System.out.println("Factorial of " + num + " is "
                           + factorial(5));
    }
}

````

Python

````
# Python 3 program to find
# factorial of given number
def factorial(n):

    res = 1

    for i in range(2, n + 1):
        res *= i
    return res


# Driver Code
num = 5
print("Factorial of", num, "is", factorial(num))

````

C#

````
// C# program to find
// factorial of given number
using System;

class Test {
    // Method to find factorial
    // of given number
    static int factorial(int n)
    {
        int res = 1;

        for (int i = 2; i <= n; i++)
            res *= i;
        return res;
    }

    // Driver method
    public static void Main()
    {
        int num = 5;
        Console.WriteLine("Factorial of " + num + " is "
                          + factorial(5));
    }
}

````

JavaScript

````
// JavaScript program to find factorial of given number

// Method to find factorial of the given number
function factorial(n)
{
    let res = 1;
    for (let i = 2; i <= n; i++)
        res *= i;
    return res;
}

// Driver method
let num = 5;
console.log("Factorial of " + num + " is " + factorial(5));

````

PHP

````
<?php
// function to find factorial of given number
function factorial($n)
{
    $res = 1;
    for ($i = 2; $i <= $n; $i++) {
        $res *= $i;
    }
    return $res;
}

// Driver code
$num = 5;
echo "Factorial of $num is " . factorial($num) . "\\n";
?>

````




**Output**
```
Factorial of 5 is 120

```

****Time Complexity:****
O(n), since we are running a loop from 1 to n.



****Auxiliary Space:****
O(1)


### ****Recursive Solution****


Let us first see how we can break factorial(n) into smaller problem and then define recurrance.


> * ****n!****
>   = n \\* (n – 1) \\* (n – 2) …. 2 \\* 1
> * ****(n – 1)!****
>   = (n – 1) \\* (n – 2) … 2 \\* 1
>
>
> From the above two equations, we can say that n
>
> ****! = n \\* (n – 1)!****
>
>
>
>
> Since the problem can be broken down into The idea is to define a recursive function, say
>
> ****factorial(n)****
> to calculate the
>
> [factorial](https://www.geeksforgeeks.org/factorial/)
> of number
>
> ****n****
> . According to the value of n, we can have two cases:
>
>
> ****if****
> n
>
> ****= 0 or n = 1 :****
>
>
>
> factorial(n) = 1
>
>
>
> ****Else****
> :
>
>
>
> factorial(n) = n \\* factorial(n – 1).

****Illustration:****

![factorial](https://media.geeksforgeeks.org/wp-content/uploads/20240924132748/factorial.webp)




Below is the implementation of the above approach:


C++

````
// C++ program to find factorial of given number
#include <iostream>
using namespace std;

// Function to find factorial
// of given number
int factorial(int n)
{
    if (n == 0 || n == 1)
        return 1;
    return n * factorial(n - 1);
}

// Driver code
int main()
{
    int num = 5;
    cout << "Factorial of " << num << " is " << factorial(num) << endl;
    return 0;
}

````

C

````
// C program to find factorial of given number
#include <stdio.h>

// function to find factorial of given number
int factorial(int n)
{
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}

int main()
{
    int num = 5;
    printf("Factorial of %d is %d", num, factorial(num));
    return 0;
}

````

Java

````
// Java program to find factorial of given number
class Test {

    // Method to find factorial of the given number
    static int factorial(int n)
    {
        int res = 1, i;
        for (i = 2; i <= n; i++)
            res *= i;
        return res;
    }

    // Driver method
    public static void main(String[] args)
    {
        int num = 5;
        System.out.println("Factorial of " + num + " is "
                           + factorial(5));
    }
}

````

Python

````
# Python 3 program to find
# factorial of given number
def factorial(n):

    if n == 0:
        return 1

    return n * factorial(n - 1)


# Driver Code
num = 5
print(f"Factorial of {num} is {factorial(num)}")

````

C#

````
// C# program to find factorial
// of given number
using System;

class Test {
    // method to find factorial
    // of given number
    static int factorial(int n)
    {
        if (n == 0)
            return 1;

        return n * factorial(n - 1);
    }

    // Driver method
    public static void Main()
    {
        int num = 5;
        Console.WriteLine("Factorial of " + num + " is "
                          + factorial(5));
    }
}

````

JavaScript

````
// Javascript to find factorial
// of given number

// function to find factorial
// of given number
function factorial(n)
{
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}

// Driver Code
let num = 5;
console.log("Factorial of " + num + " is "
            + factorial(num));

````

PHP

````
<?php
// PHP program to find factorial
// of given number

// function to find factorial
// of given number
function factorial($n)
{
    if ($n == 0)
        return 1;
    return $n * factorial($n - 1);
}

    // Driver Code
    $num = 5;
    echo "Factorial of ", $num, " is ", factorial($num);

?>

````




**Output**
```
Factorial of 5 is 120

```

****Time Complexity:****
O(n), since the function is being called n times



****Auxiliary Space:****
O(n), In the worst case, the recursion stack space would be full with all the function calls waiting to get completed and that would make it an O(n) recursion stack space.


****Which approach is better – iterative or recursive?****


Iterative approach is better as the recursive approach requires extra space for recursion call stack and overhead of recursion calls. However writing a recursive code is always a fun exercise.


****How do we handle large numbers?****


One simple improvement that we can do is use long long in C/C++ and long in Java/C#, but that does not help much as factorials are really large numbers and causes overflow for small values. Please refer
', '', 'Factorial of a Number', 8, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('770b0b45-edf6-4bc7-9880-e2727206798f', e'
Given two positive numbers x and y, check if y is a power of x or not.


**Examples :**

> **Input:**
> x = 10, y = 1
>
>
> **Output:**
> True
>
>
> x^0 = 1
>
> **Input:**
> x = 10, y = 1000
>
>
> **Output:**
> True
>
>
> x^3 = 1
>
> **Input:**
> x = 10, y = 1001
>
>
> **Output:**
> False

Recommended Practice

[Check if a number is power of another number](https://www.geeksforgeeks.org/problems/check-if-a-number-is-power-of-another-number5442/1/)


[Try It!](https://www.geeksforgeeks.org/problems/check-if-a-number-is-power-of-another-number5442/1/)


A simple solution is to repeatedly compute the powers of x. If a power becomes equal to y, then y is a power, else not.

C++
---

















```
// C++ program to check if a number is power of
// another number
#include <bits/stdc++.h>
using namespace std;

/* Returns 1 if y is a power of x */
bool isPower( int x, long int y)
{
// The only power of 1 is 1 itself
if (x == 1)
return (y == 1);

// Repeatedly compute power of x
long int pow = 1;
while ( pow < y)
pow *= x;

// Check if power of x becomes y
return ( pow == y);
}

/* Driver program to test above function */
int main()
{
cout << isPower(10, 1) << endl;
cout << isPower(1, 20) << endl;
cout << isPower(2, 128) << endl;
cout << isPower(2, 30) << endl;
return 0;
}
```





Java
----

















```
// Java program to check if a number is power of
// another number
public class Test {
// driver method to test power method
public static void main(String[] args)
{
// check the result for true/false and print.
System.out.println(isPower( 10 , 1 ) ? 1 : 0 );
System.out.println(isPower( 1 , 20 ) ? 1 : 0 );
System.out.println(isPower( 2 , 128 ) ? 1 : 0 );
System.out.println(isPower( 2 , 30 ) ? 1 : 0 );
}
/* Returns true if y is a power of x */
public static boolean isPower( int x, int y)
{
// The only power of 1 is 1 itself
if (x == 1 )
return (y == 1 );

// Repeatedly compute power of x
int pow = 1 ;
while (pow < y)
pow = pow * x;

// Check if power of x becomes y
return (pow == y);
}
}

// This code is contributed by Jyotsna.
```





Python3
-------

















```
# python program to check
# if a number is power of
# another number

# Returns true if y is a
# power of x
def isPower (x, y):

# The only power of 1
# is 1 itself
if (x = = 1 ):
return (y = = 1 )

# Repeatedly compute
# power of x
pow = 1
while ( pow < y):
pow = pow * x

# Check if power of x
# becomes y
return ( pow = = y)


# Driver Code
# check the result for
# true/false and print.
if (isPower( 10 , 1 )):
print ( 1 )
else :
print ( 0 )

if (isPower( 1 , 20 )):
print ( 1 )
else :
print ( 0 )
if (isPower( 2 , 128 )):
print ( 1 )
else :
print ( 0 )
if (isPower( 2 , 30 )):
print ( 1 )
else :
print ( 0 )

# This code is contributed
# by Sam007.
```





C#
--

















```
// C# program to check if a number
// is power of another number
using System;

class GFG
{

// Returns true if y is a power of x
public static bool isPower ( int x, int y)
{
// The only power of 1 is 1 itself
if (x == 1)
return (y == 1);

// Repeatedly compute power of x
int pow = 1;
while (pow < y)
pow = pow * x;

// Check if power of x becomes y
return (pow == y);
}

// Driver Code
public static void Main ()
{
//check the result for true/false and print.
Console.WriteLine(isPower(10, 1) ? 1 : 0);
Console.WriteLine(isPower(1, 20) ? 1 : 0);
Console.WriteLine(isPower(2, 128) ? 1 : 0);
Console.WriteLine(isPower(2, 30) ? 1 : 0);
}

}

// This code is contributed by Sam007
```





PHP
---

















```
<?php
// PHP program to check if a
// number is power of another number

/* Returns 1 if y is a power of x */
function isPower( $x , $y )
{
// The only power of 1 is 1 itself
if ( $x == 1)
return ( $y == 1 ? 1 : 0);

// Repeatedly comput power of x
$pow = 1;
while ( $pow < $y )
$pow *= $x ;

// Check if power of x becomes y
return ( $pow == $y ? 1 : 0);
}

// Driver Code
echo isPower(10, 1) . "\\n" ;
echo isPower(1, 20) . "\\n" ;
echo isPower(2, 128) . "\\n" ;
echo isPower(2, 30) . "\\n" ;

// This code is contributed by mits
?>
```





Javascript
----------

















```
<script>

// JavaScript program to check if a number
// is power of another number

/* Returns true if y is a power of x */
function isPower(x, y)
{
// The only power of 1 is 1 itself
if (x == 1)
return (y == 1);

// Repeatedly compute power of x
let pow = 1;
while (pow < y)
pow = pow * x;

// Check if power of x becomes y
return (pow == y);
}


// Driver Code

//check the result for true/false and print.
document.write((isPower(10, 1) ? 1 : 0) + "<br/>" );
document.write((isPower(1, 20) ? 1 : 0) + "<br/>" );
document.write((isPower(2, 128) ? 1 : 0) + "<br/>" );
document.write((isPower(2, 30) ? 1 : 0) + "<br/>" );

</script>
```







**Output**
```
1
0
1
0
```

**Time complexity:**
O(Log
x
y)


**Auxiliary space:**
O(1)

**Optimization:**


We can optimize above solution to work in O(Log Log y). The idea is to do squaring of power instead of multiplying it with x, i.e., compare y with x^2, x^4, x^8, …etc. If x becomes equal to y, return true. If x becomes more than y, then we do binary search for power of x between previous power and current power, i.e., between x^i and x^(i/2).


Following are detailed step.

```
1) Initialize pow = x, i = 1
2) while (pow < y)
   {
      pow = pow*pow
      i *= 2
   }
3) If pow == y
     return true;
4) Else construct an array of powers
   from x^i to x^(i/2)
5) Binary Search for y in array constructed
   in step 4. If not found, return false.
   Else return true.
```

**Alternate Solution :**


The idea is to take log of y in base x. If it turns out to be an integer, we return true. Else false.

C++
---

















```
// CPP program to check given number y
// is power of x
#include <iostream>
#include <math.h>
using namespace std;

bool isPower( int x, int y)
{
// logarithm function to calculate value
float res1 = log (y) / log (x);
return res1== floor (res1);
}

// Driven program
int main()
{
cout << isPower(2, 128) << endl;
return 0;
}
//This code is contributed by Anand Agarwal
```





Java
----

















```
// Java program to check given
// number y is power of x

class GFG
{
static boolean isPower( int x,
int y)
{
// logarithm function to
// calculate value
float res1 = ( float )(Math.log(y) /
Math.log(x));

return (res1% 1 == 0 );
}

// Driver Code
public static void main(String args[])
{
if (isPower( 2 , 128 ))
System.out.println( "1" );
else
System.out.println( "0" );
}
}

// This code is contributed by Sam007
// This code is Corrected by Anand Agarwal
```





Python3
-------

















```
# Python program to check if given number y
# is power of x
import math

def is_power(x, y):
# logarithm function to calculate value
res1 = math.log(y) / math.log(x)
res2 = math.log(y) / math.log(x) # Note: this is float

# compare to the result1 or result2 both are equal
return res1 = = res2

# Driven program
if __name__ = = "__main__" :
print (is_power( 2 , 128 ))
```





C#
--

















```
using System;

namespace ConsoleApp1
{
class Program
{

// Function to check if a number is power of another number
static bool IsPower( int x, int y)
{

// Use logarithm function to calculate the value
double res1 = Math.Log(y) / Math.Log(x);

// Note : this is double
double res2 = Math.Log(y) / Math.Log(x);

// Compare the result1 or result2, they should be equal
return (res1 == res2);
}

static void Main( string [] args)
{
// Check if 128 is power of 2
if (IsPower(2, 128))
Console.WriteLine( "1" );
else
Console.WriteLine( "0" );
}
}
}

// This code is contributed by vinayetbi1.
```





PHP
---

















```
<?php
// PHP program to check
// given number y
function isPower( $x , $y )
{
// logarithm function to
// calculate value
$res1 = log( $y ) / log( $x );

// Note : this is double
$res2 = log( $y ) / log( $x );

// compare to the result1 or
// result2 both are equal
return ( $res1 == $res2 );
}

// Driver Code
echo isPower(2, 128) ;

// This code is contributed by Sam007
?>
```





Javascript
----------

















```
// JavaScript program to check given number y
// is power of x

function isPower(x, y) {
// logarithm function to calculate value
const res1 = Math.log(y) / Math.log(x);
const res2 = Math.log(y) / Math.log(x);

// compare to the result1 or result2 both are equal
return (res1 === res2);
}

// Driven program
console.log(isPower(2, 128));
```







**Output**
```
1
```

**Time complexity**
: O(log Y)


**Auxiliary space**
: O(1)', '', 'Check if a number is a power of another number', 9, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('3346a2ba-c1c6-4b4f-bde7-37811686b1c0', e'
Given a number

****N****
, print all numbers in the range from 1 to N having exactly 3 divisors.


****Examples:****


> ****Input:****
> N = 16
>
>
>
> ****Output:****
> 4 9
>
>
>
> ****Explanation****
> : 4 and 9 have exactly three divisors.
>
>
> ****Input:****
> N = 49
>
>
>
> ****Output:****
> 4 9 25 49
>
>
>
> ****Explanation:****
> 4, 9, 25 and 49 have exactly three divisors.

Recommended Practice

[3 Divisors](https://practice.geeksforgeeks.org/problems/3-divisors3942/1)


[Try It!](https://practice.geeksforgeeks.org/problems/3-divisors3942/1)


****Mathematical approach to find Numbers with exactly 3 divisors:****
----------------------------------------------------------------------


To solve the problem follow the below idea:


> ****Idea:****
> After having a close look at the examples mentioned above, you have noticed that all the required numbers are perfect squares and that too of only prime numbers.
>
>
> ****Proof:****
> Suppose the number is N, and it is a perfect square with square root X such that X is prime.
>
>
> Now if we find the factors of N, it will always have following combinations:
>
>
> * 1\\*N
> * X\\*X
>
>
> Therefore the required numbers will have only three numbers as their divisors:
>
>
> * 1,
> * that number itself, and
> * just a single divisor in between 1 and the number.

****Algorithm:****
We can generate all primes within a set using any sieve method efficiently and then we should take all primes i, such that

****i\\*i <=N****
.


Follow the below steps to solve the problem:


* Generate the prime numbers from 1 to N using any sieve method efficiently
* Print all the prime numbers(X) between 1 to N, such as X

  2
  is less than or equal to N


Below is the implementation of the above approach:


C++

````
// C++ program to print all
// three-primes smaller than
// or equal to N using Sieve
// of Eratosthenes
#include <bits/stdc++.h>
using namespace std;

// Generates all primes upto N and
// prints their squares
void numbersWith3Divisors(int N)
{
    bool prime[N + 1];
    memset(prime, true, sizeof(prime));
    prime[0] = prime[1] = 0;

    for (int p = 2; p * p <= N; p++) {
        // If prime[p] is not changed,
        // then it is a prime
        if (prime[p] == true) {
            // Update all multiples of p
            for (int i = p * 2; i <= N; i += p)
                prime[i] = false;
        }
    }

    // Print squares of primes upto n.
    cout << "Numbers with 3 divisors :\\n";
    for (int i = 0; i * i <= N; i++)
        if (prime[i])
            cout << i * i << " ";
}

// Driver code
int main()
{
    int N = 96;

    // Function call
    numbersWith3Divisors(N);

    return 0;
}

````

Java

````
// Java program to print all
// three-primes smaller than
// or equal to N using Sieve
// of Eratosthenes
import java.io.*;
import java.util.*;

class GFG {

    // Generates all primes upto N
    // and prints their squares
    static void numbersWith3Divisors(int N)
    {
        boolean[] prime = new boolean[N + 1];
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;

        for (int p = 2; p * p <= N; p++) {

            // If prime[p] is not changed,
            // then it is a prime
            if (prime[p] == true) {
                // Update all multiples of p
                for (int i = p * 2; i <= N; i += p)
                    prime[i] = false;
            }
        }

        // print squares of primes upto n
        System.out.println("Numbers with 3 divisors : ");
        for (int i = 0; i * i <= N; i++)
            if (prime[i])
                System.out.print(i * i + " ");
    }

    // Driver code
    public static void main(String[] args)
    {
        int N = 96;

        // Function call
        numbersWith3Divisors(N);
    }
}

// Contributed by Pramod Kumar

````

Python

````
# Python3 program to print
# all three-primes smaller than
# or equal to n using Sieve
# of Eratosthenes

# Generates all primes upto n
# and prints their squares


def numbersWith3Divisors(N):

    prime = [True]*(N+1)
    prime[0] = prime[1] = False
    p = 2
    while (p*p <= N):

        # If prime[p] is not changed,
        # then it is a prime
        if (prime[p] == True):

            # Update all multiples of p
            for i in range(p*2, N+1, p):
                prime[i] = False
        p += 1

    # print squares of primes upto n.
    print("Numbers with 3 divisors :")
    i = 0
    while (i*i <= N):
        if (prime[i]):
            print(i*i, end=" ")
        i += 1


# Driver code
if __name__ == "__main__":
    N = 96

    # Function call
    numbersWith3Divisors(N)

# This code is contributed by mits

````

C#

````
// C# program to print all
// three-primes smaller than
// or equal to n using Sieve
// of Eratosthenes

class GFG {

    // Generates all primes upto n
    // and prints their squares
    static void numbersWith3Divisors(int N)
    {
        bool[] prime = new bool[N + 1];
        prime[0] = prime[1] = true;

        for (int p = 2; p * p <= N; p++) {

            // If prime[p] is not changed,
            // then it is a prime
            if (prime[p] == false) {
                // Update all multiples of p
                for (int i = p * 2; i <= N; i += p)
                    prime[i] = true;
            }
        }

        // print squares of primes upto n
        System.Console.WriteLine(
            "Numbers with 3 divisors : ");
        for (int i = 0; i * i <= N; i++)
            if (!prime[i])
                System.Console.Write(i * i + " ");
    }

    // Driver code
    public static void Main()
    {
        int N = 96;

        // Function call
        numbersWith3Divisors(N);
    }
}

// This code is Contributed by mits

````

JavaScript

````
// Javascript program to print all
    // three-primes smaller than
    // or equal to n using Sieve
    // of Eratosthenes

    // Generates all primes upto n and
    // prints their squares
    function numbersWith3Divisors(n)
    {
        let prime = new Array(n+1);
        prime.fill(true);
        prime[0] = prime[1] = 0;

        for (let p = 2; p*p <= n; p++)
        {
            // If prime[p] is not changed,
            // then it is a prime
            if (prime[p] == true)
            {
               // Update all multiples of p
               for (let i = p*2; i <= n; i += p)
                  prime[i] = false;
            }
        }

        // print squares of primes upto n.
        document.write("Numbers with 3 divisors :" + "</br>");
        for (let i = 0;  i*i <= n ; i++)
            if (prime[i])
              document.write(i*i + " ");
    }

    // sieve();
    let n = 96;
    numbersWith3Divisors(n);

     // This code is contributed by mukesh07.

````

PHP

````
<?php
// PHP program to print all three-primes
// smaller than or equal to n using Sieve
// of Eratosthenes

// Generates all primes upto n and
// prints their squares
function numbersWith3Divisors($N)
{
    $prime = array_fill(0, $N + 1, true);
    $prime[0] = $prime[1] = false;

    for ($p = 2; $p * $p <= $N; $p++)
    {
        // If prime[p] is not changed,
        // then it is a prime
        if ($prime[$p] == true)
        {
        // Update all multiples of p
        for ($i = $p * 2; $i <= $N; $i += $p)
            $prime[$i] = false;
        }
    }

    // print squares of primes upto n.
    echo "Numbers with 3 divisors :\\n";
    for ($i = 0; $i * $i <= $N ; $i++)
        if ($prime[$i])
        echo $i * $i . " ";
}

// Driver Code
$N = 96;

// Function call
numbersWith3Divisors($N);

// This code is contributed by mits
?>

````




**Output**
```
Numbers with 3 divisors :
4 9 25 49
```

****Time Complexity:****
O(N\\*log(log(N)))



****Auxiliary Space:****
O(N)


****Numbers with exactly 3 divisors using constant space:****
-------------------------------------------------------------

> Run a loop from 2 to sqrt(N) and check if the current element is prime or not, if it is so then print that number, but this method will increase the time complexity of the solution


Follow the below steps to solve the problem:


* Start a loop for integer

  ****i****
  from

  ****2****
  to

  ****N.****
* Check if

  ****i****
  is prime or not, which can be done easily using the

  [****isPrime(n)****](https://www.geeksforgeeks.org/prime-numbers)

  method.
* If

  ****i****
  is prime, check if its square is less than or equal to the given number. This will be reviewed only for squares of prime numbers, therefore reducing the number of checks.
* If the above condition is satisfied, the number will be printed and the loop will continue till

  ****i <= n.****


Below is the implementation of the above approach:


C++

````
// C++ program to print all
// three-primes smaller than
// or equal to n without using
// extra space
#include <bits/stdc++.h>
using namespace std;

void numbersWith3Divisors(int);
bool isPrime(int);

// Generates all primes upto n and
// prints their squares
void numbersWith3Divisors(int N)
{
    cout << "Numbers with 3 divisors : " << endl;

    for (int i = 2; i * i <= N; i++) {

        // Check prime
        if (isPrime(i)) {
                // Print numbers in
                // the order of
                // occurrence
                cout << i * i << " ";
        }
    }
}

// Check if a number is prime or not
bool isPrime(int N)
{
    for (int i = 2; i * i <= N; i++) {
        if (N % i == 0)
            return false;
    }
    return true;
}

// Driver code
int main()
{
    int N = 122;

    // Function call
    numbersWith3Divisors(N);

    return 0;
}

// This code is contributed by vishu2908

````

Java

````
// Java program to print all
// three-primes smaller than
// or equal to N without using
// extra space
import java.util.*;

class GFG {

    // 3 divisor logic implementation
    // check if a number is
    // prime or not
    // if it is a prime then
    // check if its square
    // is less than or equal to
    // the given number
    static void numbersWith3Divisors(int N)
    {
        System.out.println("Numbers with 3 divisors : ");

        for (int i = 2; i * i <= N; i++) {

            // Check prime
            if (isPrime(i)) {
                    // Print numbers in
                    // the order of
                    // occurrence
                    System.out.print(i * i + " ");
            }
        }
    }

    // Check if a number is prime or not
    public static boolean isPrime(int N)
    {
        for (int i = 2; i * i <= N; i++) {
            if (N % i == 0)
                return false;
        }
        return true;
    }

    // Driver code
    public static void main(String[] args)
    {
        int N = 122;

        // Function call
        numbersWith3Divisors(N);
    }
}

// Contributed by Parag Pallav Singh

````

Python

````
# Python3 program to print all
# three-primes smaller than
# or equal to N without using
# extra space

# 3 divisor logic implementation
# check if a number is  prime or
# not if it is a prime then check
# if its square is less than or
# equal to the given number


def numbersWith3Divisors(N):

    print("Numbers with 3 divisors : ")

    i = 2
    while i * i <= N:

        # Check prime
        if (isPrime(i)):
                # Print numbers in the order
                # of occurrence
                print(i * i, end=" ")

        i += 1

# Check if a number is prime or not


def isPrime(N):

    i = 2
    while i * i <= N:
        if N % i == 0:
            return False

        i += 1

    return True


# Driver code
if __name__ == "__main__":
    N = 122

    # Function call
    numbersWith3Divisors(N)

# This code is contributed by divyesh072019

````

C#

````
// C# program to print all
// three-primes smaller than
// or equal to N without using
// extra space
using System;

class GFG {

    // 3 divisor logic implementation
    // check if a number is prime or
    // not if it is a prime then check
    // if its square is less than or
    // equal to the given number
    static void numbersWith3Divisors(int N)
    {
        Console.WriteLine("Numbers with 3 divisors : ");

        for (int i = 2; i * i <= N; i++) {

            // Check prime
            if (isPrime(i)) {
                    // Print numbers in the order
                    // of occurrence
                    Console.Write(i * i + " ");
            }
        }
    }

    // Check if a number is prime or not
    public static bool isPrime(int N)
    {
        for (int i = 2; i * i <= N; i++) {
            if (N % i == 0)
                return false;
        }
        return true;
    }

    // Driver code
    static void Main()
    {
        int N = 122;

        // Function call
        numbersWith3Divisors(N);
    }
}

// This code is contributed by divyeshrabadiya07

````

JavaScript

````
// Javascript program to print all
    // three-primes smaller than
    // or equal to n without using
    // extra space

      // 3 divisor logic implementation
    // check if a number is prime or
    // not if it is a prime then check
    // if its square is less than or
    // equal to the given number
    function numbersWith3Divisors(n)
    {
        document.write("Numbers with 3 divisors : ");

        for(let i = 2; i * i <= n; i++)
        {

            // Check prime
            if (isPrime(i))
            {
                    // Print numbers in the order
                    // of occurrence
                    document.write(i * i + " ");
            }
        }
    }

    // Check if a number is prime or not
    function isPrime(n)
    {
        if (n == 0 || n == 1)
            return false;

        for(let i = 2; i * i <= n; i++)
        {
            if (n % i == 0)
                return false;
        }
        return true;
    }

    let n = 122;

    numbersWith3Divisors(n);

// This code is contributed by suresh07.

````




**Output**
```
Numbers with 3 divisors :
4 9 25 49 121
```

****Time Complexity:****
O(sqrt N

2
)



****Auxiliary Space:****
O(1)


', '', 'Find numbers from 1 to N with exactly 3 divisors', 10, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('723f7734-7503-4850-8863-e4f4887152a7', e'
A

[****prime number****](https://www.geeksforgeeks.org/prime-numbers/)
is a natural number greater than 1 that has exactly two factors:

****1****
and

****itself****
. This article explores the properties of prime numbers, various methods to check for primality, and related problems.


> ****Input****
> : n = 10
>
>
>
> ****Output****
> : False
>
>
>
> 10 is divisible by 2 and 5
>
>
> ****Input****
> : n = 11
>
>
>
> ****Output****
> : True
>
>
>
> 11 is divisible by 1 and 11 only
>
>
> ****Input****
> : n = 1
>
>
>
> ****Output****
> : False
>
>
>
> [1 is neither composite nor prime](https://www.geeksforgeeks.org/is-1-a-prime-number-or-a-composite-number/)
>
> ****Input****
> : n = 0
>
>
>
> ****Output****
> : False
>
>
>
> [0 is neither composite nor prime](https://www.geeksforgeeks.org/is-0-a-prime-number/)

Table of Content

* [Different Methods to Check for Prime Number](#what-is-prime-number)

+ [[Naive Approach] Basic Trial Division Method – O(n) time and O(1) space](#naive-approach-basic-trial-division-method)
+ [[Efficient Approach – 1] Trial Division Method – O(√n) time and O(1) space](#efficient-approach-1-trial-division-method)
+ [[Expected Approach – 2] Optimized Trial Division Method – O(√n) time and O(1) space](#expected-approach-2-optimized-trial-division-method)

* [Primality Testing Methods](#primality-testing-methods)
* [Sieve Algorithms for Prime Number Generation](#sieve-algorithms-for-prime-number-generation)
* [Prime Number Algorithms and Related Problems](#prime-number-algorithms-and-related-problems)

Different Methods to Check for Prime Number
-------------------------------------------


To check if a number is prime, we can use the key property of prime numbers that is, a prime number has exactly two factors, 1 and itself. If a number has more than two factors, it is not considered prime. There are several approaches to check if a number is prime, each varying in complexity and efficiency. Lets explore these approaches one by one.



### [Naive Approach] Basic Trial Division Method – O(n) time and O(1) space

> The simplest method to check if a number
>
> ****n****
> is prime by checking every number from
>
> ****2****
> to
>
> ****n-1.****
> If the number
>
> ****n****
> is divisible by any of these, it’s not prime.


Step-by-step approach:


* If

  ****n****
  is less than 2, return

  ****false****
  (0 and 1 are not prime).
* Loop through numbers from

  ****2****
  to

  ****n-1.****
  + If

    ****n****
    is divisible by any of these numbers, return

    ****false****
    .
* If no divisors are found, return

  ****true****
  .


Below is the implementation of the above approach:


C++

````
#include <iostream>
using namespace std;

// Function to check whether a number is prime or not
bool isPrime(int n) {
    if (n <= 1)
        return false;

    // Check divisibility from 2 to n-1
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            return false;

    return true;
}

int main() {
    int n = 11;
    cout << isPrime(n);
    return 0;
}

````

C

````
#include <stdio.h>
#include <stdbool.h>

// Function to check whether a number is prime or not
bool isPrime(int n) {
    if (n <= 1)
        return false;

    // Check divisibility from 2 to n-1
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            return false;

    return true;
}

int main() {
    int n = 11;
    printf("%d", isPrime(n));
    return 0;
}

````

Java

````
public class GfG {

    // Function to check whether a number is prime or not
    static boolean isPrime(int n) {
        if (n <= 1)
            return false;

        // Check divisibility from 2 to n-1
        for (int i = 2; i < n; i++)
            if (n % i == 0)
                return false;

        return true;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(isPrime(n));
    }
}

````

Python

````
# Function to check whether a number is prime or not
def is_prime(n):
    if n <= 1:
        return False

    # Check divisibility from 2 to n-1
    for i in range(2, n):
        if n % i == 0:
            return False

    return True

n = 11
print(is_prime(n))

````

C#

````
using System;

class GfG {
    // Function to check whether a number is prime or not
    static bool IsPrime(int n) {
        if (n <= 1)
            return false;

        // Check divisibility from 2 to n-1
        for (int i = 2; i < n; i++)
            if (n % i == 0)
                return false;

        return true;
    }

    static void Main(string[] args) {
        int n = 11;
        Console.WriteLine(IsPrime(n));
    }
}

````

JavaScript

````
// Function to check whether a number is prime or not
function isPrime(n) {
    if (n <= 1)
        return false;

    // Check divisibility from 2 to n-1
    for (let i = 2; i < n; i++)
        if (n % i === 0)
            return false;

    return true;
}

let n = 11;
console.log(isPrime(n));

````




**Output**
```
1
```

****Time Complexity:****
O(n)



****Auxiliary Space:****
O(1)


### [Efficient Approach – 1] Trial Division Method – O(√n) time and O(1) space

> There is an observation that if we take any number
>
> ****n****
> and find its divisors then divisors would appear in pairs. For example, if
>
> ****4****
> is a divisor of
>
> ****28****
> , then
>
> ****28/4=7****
> is also a divisor. So we have the pair (4,7).
>
>
> This means that for any divisor
>
> ****d****
> of
>
> ****n****
> , there is a corresponding divisor
>
> ****n/d****
> . If
>
> ****d****
> is less than or equal to the
>
> ****√n****
> , then
>
> ****n/d****
> will be greater than or equal to the
>
> ****√n****
> . Therefore, we only need to check for divisors up to the
>
> ****√n****
> . If
>
> ****n****
> has a divisor larger than its square root, the paired divisor must be smaller than the square root, which we would have already checked.


For example, if

****n = 36****
, its square root is

****6****
. The divisors are

****1,2,3,4,6,9,12,18,36****
. We only need to check

****1,2,3,4,6****
because any larger divisor will have a smaller paired divisor that we’ve already checked.


Below is the implementation of the above approach:


C++14

````
#include <iostream>
#include <cmath>
using namespace std;

// Function to check whether a number is prime or not
bool isPrime(int n) {

    // Numbers less than or equal to 1 are not prime
    if (n <= 1)
        return false;

    // Check divisibility from 2 to the square root of n
    for (int i = 2; i <= sqrt(n); i++)
        if (n % i == 0)
            return false;

    // If no divisors were found, n is prime
    return true;
}

int main() {
    int n = 11;
    cout << isPrime(n);
    return 0;
}

````

C

````
#include <stdio.h>
#include <stdbool.h>
#include <math.h>

// Function to check whether a number is prime or not
bool isPrime(int n) {
    // Numbers less than or equal to 1 are not prime
    if (n <= 1)
        return false;

    // Check divisibility from 2 to the square root of n
    for (int i = 2; i <= sqrt(n); i++)
        if (n % i == 0)
            return false;

    // If no divisors were found, n is prime
    return true;
}

int main() {
    int n = 11;
    printf("%d", isPrime(n));
    return 0;
}

````

Java

````
class Main {

    // Function to check whether a number is prime or not
    static boolean isPrime(int n) {

        // Numbers less than or equal to 1 are not prime
        if (n <= 1)
            return false;

        // Check divisibility from 2 to the square root of n
        for (int i = 2; i <= Math.sqrt(n); i++)
            if (n % i == 0)
                return false;

        // If no divisors were found, n is prime
        return true;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(isPrime(n));
    }
}

````

Python

````
import math

# Function to check whether a number is prime or not
def is_prime(n):

    # Numbers less than or equal to 1 are not prime
    if n <= 1:
        return False

    # Check divisibility from 2 to the square root of n
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False

    # If no divisors were found, n is prime
    return True

n = 11
print(is_prime(n))

````

C#

````
using System;

class GfG {
    // Function to check whether a number is prime or not
    static bool IsPrime(int n) {

        // Numbers less than or equal to 1 are not prime
        if (n <= 1)
            return false;

        // Check divisibility from 2 to the square root of n
        for (int i = 2; i <= Math.Sqrt(n); i++)
            if (n % i == 0)
                return false;

        // If no divisors were found, n is prime
        return true;
    }

    static void Main(string[] args) {
        int n = 11;
        Console.WriteLine(IsPrime(n));
    }
}

````

Javascript

````
// Function to check whether a number is prime or not
function isPrime(n) {

    // Numbers less than or equal to 1 are not prime
    if (n <= 1)
        return false;

    // Check divisibility from 2 to the square root of n
    for (let i = 2; i <= Math.sqrt(n); i++)
        if (n % i === 0)
            return false;

    // If no divisors were found, n is prime
    return true;
}

let n = 11;
console.log(isPrime(n));

````




**Output**
```
1
```

****Time Complexity:****
O(sqrt(n))



****Auxiliary Space:****
O(1)


### [Expected Approach – 2] Optimized Trial Division Method – O(√n) time and O(1) space

> We know that any integer number can be written in the form of
>
> ****6k+i,****
> where
>
> ****k****
> is a nonnegative integer (like 0, 1, 2, 3,…) and
>
> ****i****
> is a number between 0 and 5 (so i can be 0, 1, 2, 3, 4, or 5). If we look closely, we’ll notice that when
>
> ****i****
> is 0, 2, 3, or 4, the numbers
>
> ****6k, 6k+2, 6k+3,****
> and
>
> ****6k+4****
> are all divisible by either 2 or 3. But prime numbers greater than
>
> ****3****
> can’t be divisible by
>
> ****2****
> or
>
> ****3****
> . Therefore, the only forms left that a prime number can have are
>
> ****6k+1****
> or
>
> ****6k+5****
> (since these forms are not divisible by 2 or 3).
>
>
> Instead of checking every number up to the √n to see if it divides
>
> ****n****
> , we only check numbers of the form
>
> ****6k+1****
> and
>
> ****6k+5.****
> This reduces the number of checks needed.


Step-by-step approach:


* Check if

  ****n == 1****
  or

  ****n == 0****
  then return

  ****false****
  .
* Check if

  ****n****
  is

  ****2****
  or

  ****3****
  and return

  ****true****
  .
* Check if

  ****n****
  is divisible by

  ****2****
  or

  ****3****
  and return

  ****false****
  .
* Loop from

  ****5****
  to

  ****√n****
  ​, incrementing by

  ****6****
  .
  + Checks if

    ****n****
    is divisible by

    ****i****
    (which corresponds to

    ****6k+1****
    ) or by

    ****i+2****
    (which corresponds to

    ****6k+5****
    ).
* If no divisors are found, return

  ****true****
  .


Below is the implementation of the above approach:


C++

````
#include <iostream>
#include <cmath>
using namespace std;

// Function to check whether a number is prime or not
bool isPrime(int n) {
    // Check if n is 1 or 0
    if (n <= 1)
        return false;

    // Check if n is 2 or 3
    if (n == 2 || n == 3)
        return true;

    // Check whether n is divisible by 2 or 3
    if (n % 2 == 0 || n % 3 == 0)
        return false;

    // Check from 5 to square root of n
    // Iterate i by (i+6)
    for (int i = 5; i <= sqrt(n); i = i + 6)
        if (n % i == 0 || n % (i + 2) == 0)
            return false;

    return true;
}

int main() {
    int n = 11;
    cout << isPrime(n);
    return 0;
}

````

C

````
#include <stdio.h>
#include <stdbool.h>
#include <math.h>

// Function to check whether a number is prime or not
bool isPrime(int n) {
    // Check if n is 1 or 0
    if (n <= 1)
        return false;

    // Check if n is 2 or 3
    if (n == 2 || n == 3)
        return true;

    // Check whether n is divisible by 2 or 3
    if (n % 2 == 0 || n % 3 == 0)
        return false;

    // Check from 5 to square root of n
    // Iterate i by (i+6)
    for (int i = 5; i <= sqrt(n); i = i + 6)
        if (n % i == 0 || n % (i + 2) == 0)
            return false;

    return true;
}

int main() {
    int n = 11;
    printf("%d", isPrime(n));
    return 0;
}

````

Java

````
class GfG {

    // Function to check whether a number is prime or not
    static boolean isPrime(int n) {
        // Check if n is 1 or 0
        if (n <= 1)
            return false;

        // Check if n is 2 or 3
        if (n == 2 || n == 3)
            return true;

        // Check whether n is divisible by 2 or 3
        if (n % 2 == 0 || n % 3 == 0)
            return false;

        // Check from 5 to square root of n
        // Iterate i by (i+6)
        for (int i = 5; i <= Math.sqrt(n); i = i + 6)
            if (n % i == 0 || n % (i + 2) == 0)
                return false;

        return true;
    }

    public static void main(String[] args) {
        int n = 11;
        System.out.println(isPrime(n));
    }
}

````

Python

````
import math

# Function to check whether a number is prime or not
def is_prime(n):
    # Check if n is 1 or 0
    if n <= 1:
        return False

    # Check if n is 2 or 3
    if n == 2 or n == 3:
        return True

    # Check whether n is divisible by 2 or 3
    if n % 2 == 0 or n % 3 == 0:
        return False

    # Check from 5 to square root of n
    # Iterate i by (i+6)
    i = 5
    while i <= math.sqrt(n):
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6

    return True

n = 11
print(is_prime(n))

````

C#

````
using System;

class Program {
    // Function to check whether a number is prime or not
    static bool IsPrime(int n) {
        // Check if n is 1 or 0
        if (n <= 1)
            return false;

        // Check if n is 2 or 3
        if (n == 2 || n == 3)
            return true;

        // Check whether n is divisible by 2 or 3
        if (n % 2 == 0 || n % 3 == 0)
            return false;

        // Check from 5 to square root of n
        // Iterate i by (i+6)
        for (int i = 5; i <= Math.Sqrt(n); i += 6)
            if (n % i == 0 || n % (i + 2) == 0)
                return false;

        return true;
    }

    static void Main(string[] args) {
        int n = 11;
        Console.WriteLine(IsPrime(n));
    }
}

````

Javascript

````
// Function to check whether a number is prime or not
function isPrime(n) {
    // Check if n is 1 or 0
    if (n <= 1)
        return false;

    // Check if n is 2 or 3
    if (n === 2 || n === 3)
        return true;

    // Check whether n is divisible by 2 or 3
    if (n % 2 === 0 || n % 3 === 0)
        return false;

    // Check from 5 to square root of n
    // Iterate i by (i+6)
    for (let i = 5; i <= Math.sqrt(n); i += 6)
        if (n % i === 0 || n % (i + 2) === 0)
            return false;

    return true;
}

let n = 11;
console.log(isPrime(n));

````




**Output**
```
1
```

****Time Complexity:****
O(sqrt(n))



****Auxiliary Space:****
O(1)


****Primality Testing Methods****
---------------------------------

* [Primality Test | Set 1 (Introduction and School Method)](https://www.geeksforgeeks.org/primality-test-set-1-introduction-and-school-method/)
* [Primality Test | Set 2 (Fermat Method)](https://www.geeksforgeeks.org/primality-test-set-2-fermet-method/)
* [Primality Test | Set 3 (Miller–Rabin)](https://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/)
* [Primality Test | Set 4 (Solovay-Strassen)](https://www.geeksforgeeks.org/primality-test-set-4-solovay-strassen/)
* [Lucas Primality Test](https://www.geeksforgeeks.org/lucas-primality-test/)

Sieve Algorithms for Prime Number Generation
--------------------------------------------

* [Sieve of Eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)
* [Sieve of Eratosthenes in O(n) time complexity](https://www.geeksforgeeks.org/sieve-eratosthenes-0n-time-complexity/)
* [Segmented Sieve](https://www.geeksforgeeks.org/segmented-sieve/)
* [Sieve of Sundaram](https://www.geeksforgeeks.org/sieve-sundaram-print-primes-smaller-n/)
* [Bitwise Sieve](https://www.geeksforgeeks.org/bitwise-sieve/)


For more related article on Sieve algorithms , please refer to

[Recent Articles on Sieve](https://www.geeksforgeeks.org/tag/sieve/)


****Prime Number Algorithms and Related Problems****
----------------------------------------------------

* [Find two distinct prime numbers with](https://www.geeksforgeeks.org/find-two-distinct-prime-numbers-with-given-product/)
  a

  [given product](https://www.geeksforgeeks.org/find-two-distinct-prime-numbers-with-given-product/)
* [Print all prime numbers less than or equal to N](https://www.geeksforgeeks.org/print-all-prime-numbers-less-than-or-equal-to-n/)
* [Recursive program for prime number](https://www.geeksforgeeks.org/recursive-program-prime-number/)
* [Find two prime numbers with](https://www.geeksforgeeks.org/find-two-prime-numbers-with-given-sum/)
  a

  [given sum](https://www.geeksforgeeks.org/find-two-prime-numbers-with-given-sum/)
* [Find the highest occurring digit in prime numbers in a range](https://www.geeksforgeeks.org/find-highest-occurring-digit-prime-numbers-range/)
* [Prime Factorization using Sieve O(log n) for multiple queries](https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/)
* [Program to print all prime factors of a given number](https://www.geeksforgeeks.org/print-all-prime-factors-of-a-given-number/)
* [Least prime factor of numbers till n](https://www.geeksforgeeks.org/least-prime-factor-of-numbers-till-n/)
* [Prime factors of LCM of array elements](https://www.geeksforgeeks.org/prime-factors-lcm-array-elements/)
* [Program for Goldbach’s Conjecture](https://www.geeksforgeeks.org/program-for-goldbachs-conjecture-two-primes-with-given-sum/)
* [Prime numbers and Fibonacci](https://www.geeksforgeeks.org/prime-numbers-fibonacci/)
* [Composite Number](https://www.geeksforgeeks.org/composite-number/)


For more related problems on prime number, please refer to


[Recent Articles on Prime Numbers](https://www.geeksforgeeks.org/tag/prime-number/)

  ', '', 'Check for Prime Number', 11, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('e463ed6b-9b9c-4b7f-aaa9-d9607492b53e', e'Given a number

****n****
, find the sum of its digits.


****Examples :****

> ****Input:****
> n = 687
>
>
>
> ****Output:****
> 21
>
>
>
> ****Explanation:****
> **The sum of its digits are: 6 + 8 + 7 = 21**
>
> ****Input:****
> n = 12
>
>
>
> ****Output:****
> 3
>
>
>
> ****Explanation:****
> **The sum of its digits are: 1 + 2 = 3**

Table of Content

* [[Expected Approach] Sum of the digits of a given number using recursion](#expected-approach-sum-of-the-digits-of-a-given-number-using-recursion)
* [[Alternate Approach] Sum of the digits of a given number using tail recursion](#alternate-approach-sum-of-the-digits-of-a-given-number-using-tail-recursion)
* [[Alternate Approach] Converting Number to String](#sum-of-the-digits-of-a-given-number-with-input-as-string)
### ****[Expected Approach] Sum of the digits using recursion****

> **The idea is to count the digits by removing the digits from the input number starting from**
> ****right(least significant digit)****
> **to**
> ****left(most significant digit)****
> **till the number is reduced to 0 because the rightmost digit can be removed simply by performing**
> ****integer division by 10****
> **. For eg: n = 1567, then 1567 / 10 = 156.7 = 156(Integer Division).**

C++

````
#include <iostream>
using namespace std;

int sumDigits(int no) {
    if (no == 0) {
        return 0;
    }

    return (no % 10) + sumDigits(no / 10);
}

int main(void) {
    cout << sumDigits(687);
    return 0;
}

````

C

````
#include <stdio.h>

int sumDigits(int no) {
    if (no == 0) {
        return 0;
    }

    return (no % 10) + sumDigits(no / 10);
}

int main() {
    printf("%d", sumDigits(687));
    return 0;
}

````

Java

````
import java.io.*;

class GfG {
    static int sumDigits(int no) {
        if (no == 0) {
            return 0;
        }

        return (no % 10) + sumDigits(no / 10);
    }

    public static void main(String[] args) {
        System.out.println(sumDigits(687));
    }
}

````

Python

````
def sumDigits(no):

    return 0 if no == 0 else int(no % 10) + sumDigits(int(no/10))

if __name__ == "__main__":

    print(sumDigits(687))

````

C#

````
using System;

 class GfG {

    static int sumDigits(int n) {
        return n == 0 ? 0 : n % 10 + sumDigits(n / 10);
    }

  static void  Main() {
        Console.Write(sumDigits(687));
    }
}

````

JavaScript

````

  function sumDigits(no) {
       if(no == 0){
         return 0 ;
       }

      return (no % 10) + sumDigits(parseInt(no/10)) ;
  }

// Driver code
      console.log(sumDigits(687));


````




**Output**
```
21
```

****Time Complexity:****
O(log n)



****Auxiliary Space:****
O(log n)


### ****[Alternate Approach] Using tail recursion****

> This approach ensures that the recursive call is the last operation, allowing for better memory efficiency and preventing stack overflow.

C++

````
// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;

int sumOfDigit(int n, int val) {
    if (n < 10) {
        val = val + n;
        return val;
    }
    return sumOfDigit(n / 10, (n % 10) + val);
}

int main() {
    int num = 12345;

    int result = sumOfDigit(num, 0);
    cout <<  result;
    return 0;
}

````

C

````
// C program for the above approach
#include <stdio.h>

int sumOfDigit(int n, int val)
{
    if (n < 10) {
        val = val + n;
        return val;
    }
    return sumOfDigit(n / 10, (n % 10) + val);
}

int main() {
    int num = 12345;
    int result = sumOfDigit(num, 0);
    printf("%d", result);
    return 0;
}

````

Java

````
// Java program for the above approach
import java.io.*;
import java.lang.*;
import java.util.*;

class GfG {

    static int sumOfDigit(int n, int val)  {
        if (n < 10) {
            val = val + n;
            return val;
        }
        return sumOfDigit(n / 10, (n % 10) + val);
    }

    public static void main(String args[]) {
        int num = 12345;
        int result = sumOfDigit(num, 0);
        System.out.println( result);
    }
}

````

Python

````
# Python3 program for the above approach

def sumOfDigit(n, val):

    if (n < 10):
        val = val + n
        return val

    return sumOfDigit(n // 10, (n % 10) + val)


if __name__ == "__main__":
    num = 12345

    result = sumOfDigit(num, 0)

    print(result)

````

C#

````
// C# program for the above approach
using System;

class GfG {

    static int sumOfDigit(int n, int val) {
        if (n < 10) {
            val = val + n;
            return val;
        }
        return sumOfDigit(n / 10, (n % 10) + val);
    }

    public static void Main() {
        int num = 12345;

        int result = sumOfDigit(num, 0);
        Console.Write( result);
    }
}

````

JavaScript

````
// Javascript program for the above approach

function sumOfDigit(n, val)
{
    if (n < 10)
    {
        val = val + n;
        return val;
    }
    return sumOfDigit(parseInt(n / 10),
    (n % 10) + val);
}

// Driver code
    let num = 12345;
    let result = sumOfDigit(num, 0);

    console.log( result);

````




**Output**
```
15
```

****Time Complexity:****
O(log n)



****Auxiliary Space:****
O(log n)


### ****[Alternate Approach]**** Converting Number to String

> When the number of digits of that number exceeds 10
>
> 19
> , we can’t take that number as an integer since the range of long long int doesn’t satisfy the given number. So take input as a string, run a loop from start to the length of the string and increase the sum with that character(in this case it is numeric)

C++14

````
// C++ implementation of the above approach
#include <bits/stdc++.h>
using namespace std;

int getSum(string s) {
    int sum = 0;

    // Traversing through the string
    for (int i = 0; i < s.length(); i++) {
        // Since ascii value of  numbers starts
        // from 48 so we subtract it from sum
        sum = sum + s[i] - 48;
    }
    return sum;
}

int main() {
    string s = "123456789123456789123422";

    cout << getSum(s);
    return 0;
}

````

Java

````
// Java implementation of the above approach
import java.io.*;
class GfG {

    static int getSum(String s) {
        int sum = 0;

        for (int i = 0; i < s.length(); i++) {

            // Since ascii value of numbers starts
            //  from 48 so we subtract it from sum
            sum = sum + s.charAt(i) - 48;
        }
        return sum;
    }

    public static void main(String[] args)  {
        String s = "123456789123456789123422";

        System.out.print(getSum(s));
    }
}

````

Python

````
# Python3 implementation of the above approach
def getSum(n):
    sum = 0

    # Traversing through string
    for i in n:

        # Converting char to int
        sum = sum + int(i)

    return sum

if __name__ == "__main__":
    n = "123456789123456789123422"

    print(getSum(n))

````

C#

````
// C# implementation of the above approach
using System;
class GfG {
    static int getSum(String s) {
        int sum = 0;

        for (int i = 0; i < s.Length; i++) {

            // Since ascii value of numbers starts
            //  from 48 so we subtract it from sum
            sum = sum + s[i] - 48;
        }
        return sum;
    }

    static public void Main()  {
        String st = "123456789123456789123422";
        Console.Write(getSum(st));
    }
}

````

JavaScript

````
// Javascript implementation of the above approach

function getSum(s)
{
    let sum = 0;

    // Traversing through the string
    for (let i = 0; i < s.length; i++)
    {

        // Since ascii value of  numbers starts from
        //48 so we subtract it from sum
        sum = sum + parseInt(s[i]);
    }
    return sum;
}

// Driver Code
let st = "123456789123456789123422";
console.log(getSum(st));

````




**Output**
```
104
```

****Time Complexity:****
O(n)



****Auxiliary Space:****
O(1)

', '', 'Program for Sum of the digits of a given number', 12, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('96fc2a66-d810-48cb-9c86-1f28415e1e5b', e'
Given the radius of a circle, find the area of that circle.


![Area-of-circle](https://media.geeksforgeeks.org/wp-content/cdn-uploads/Area-of-circle-300x283.png)
> The area of a circle can simply be evaluated using the following formula.
>
>
> [Tex]Area = \\pi r^2[/Tex]
>
>
> where r is radius of circle and it maybe in float because value of pie is 3.14

****Approach****
: Using the given radius, find the area using the above formula: (pi \\* r \\* r) and print the result in float.





C++

````
// C++ program to find area
// of circle
#include <iostream>
const double pi = 3.14159265358979323846;
using namespace std;

// function to calculate the area of circle
float findArea(float r)
{
    return (pi * r * r);
}
// driver code
int main()
{
    float r, Area;
    r = 5;

    // function calling
    Area = findArea(r);
    // displaying the area
    cout << "Area of Circle is :" << Area;
    return 0;
}

````

C

````
// C program to find area
// of circle
#include <stdio.h>
#include <math.h>
#define PI 3.142

double findArea(int r)
{
   return PI * pow(r, 2);
}

int main()
{
    printf("Area is %f", findArea(5));
    return 0;
}

````

Java

````
// Java program to find area
// of circle

class Test
{
    static final double PI = Math.PI;

    static double findArea(int r)
    {
       return PI * Math.pow(r, 2);
    }

    // Driver method
    public static void main(String[] args)
    {
        System.out.println("Area is " +  findArea(5));
    }
}

````

Python

````
# Python3 program to find Area of a circle

def findArea(r):
    PI = 3.142
    return PI * (r*r);

# Driver method
print("Area is %.6f" % findArea(5));

# This code is contributed by Chinmoy Lenka

````

C#

````
// C# program to find area of circle
using System;

class GFG
{
    static double PI = Math.PI;

    static double findArea(int r)
    {
    return PI * Math.Pow(r, 2);
    }

    // Driver method
    static void Main()
    {
        Console.Write("Area is " + findArea(5));
    }
}

// This code is contributed by Sam007.

````

JavaScript

````
<script>

// Javascript program to find area
// of circle

let pi = 3.14159265358979323846;

// function to calculate the area of circle
function findArea(r)
{
    return (pi * r * r);
}

// Driver code
    let r, Area;
    r = 5;

    // function calling
    Area = findArea(r);

    // displaying the area
    document.write("Area of Circle is :" + Area);

// This code is contributed by Mayank Tyagi

</script>

````

PHP

````
<?php
// PHP program to find area
// of circle

function findArea( $r)
{
    $PI =3.142;
    return $PI * pow($r, 2);
}

// Driver Code
echo("Area is ");
echo(findArea(5));
return 0;

// This code is contributed by vt_m.
?>

````




**Output**
```
Area of Circle is :78.5398
```

****Time Complexity:****
O(1)



****Auxiliary Space:****
O(1), since no extra space has been taken.
', '', 'Program to find area of a circle', 13, null, '598d78e5-c34f-437f-88fb-31557168c07b', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('9ce7941f-e32e-4913-80e3-3b055b6a56da', e'# Define of Tree data structure
**Tree data structure** is a hierarchical structure that is used to represent and organize data in the form of parent child relationship. The following are some real world situations which are naturally a tree.

-   Folder structure in an operating system.
-   Tag structure in an HTML (root tag the as html tag) or XML document.

The topmost node of the tree is called the **root**, and the nodes below it are called the child nodes. Each node can have multiple child nodes, and these child nodes can also have their own child nodes, forming a recursive structure.

![Introduction-to-tree-](https://media.geeksforgeeks.org/wp-content/uploads/20240424125622/Introduction-to-tree-.webp)

# Basic Terminologies In Tree Data Structure:

-   **Parent Node:** The node which is an immediate predecessor of a node is called the parent node of that node. **{B}** is the parent node of **{D, E}**.
-   **Child Node:** The node which is the immediate successor of a node is called the child node of that node. Examples: **{D, E}** are the child nodes of **{B}.**
-   **Root Node:** The topmost node of a tree or the node which does not have any parent node is called the root node. {**A**} is the root node of the tree. A non-empty tree must contain exactly one root node and exactly one path from the root to all other nodes of the tree.
-   **Leaf Node or External Node:** The nodes which do not have any child nodes are called leaf nodes. **{I, J, K, F, G, H}** are the leaf nodes of the tree.
-   **Ancestor of a Node:** Any predecessor nodes on the path of the root to that node are called Ancestors of that node. **{A,B}** are the ancestor nodes of the node **{E}**
-   **Descendant:** A node x is a descendant of another node y if and only if y is an ancestor of x.
-   **Sibling:** Children of the same parent node are called siblings. **{D,E}** are called siblings.
-   **Level of a node:** The count of edges on the path from the root node to that node. The root node has level **0**.
-   **Internal node:** A node with at least one child is called Internal Node.
-   **Neighbour of a Node:** Parent or child nodes of that node are called neighbors of that node.
-   **Subtree**: Any node of the tree along with its descendant.

![treeTerminologies](https://media.geeksforgeeks.org/wp-content/uploads/20250214120937877633/treeTerminologies.webp)


# Why Tree is considered a non-linear data structure?

The data in a tree are not stored in a sequential manner i.e., they are not stored linearly. Instead, they are arranged on multiple levels or we can say it is a hierarchical structure. For this reason, the tree is considered to be a [non-linear data structure](https://www.geeksforgeeks.org/difference-between-linear-and-non-linear-data-structures).

> We strongly recommend to study a [Binary Tree](https://www.geeksforgeeks.org/binary-tree-data-structure/) first as a Binary Tree has structure and code implementation compared to a general tree.

# Representation of Tree Data Structure

A tree consists of a root node, and zero or more subtrees T$_1$, T$_2$, ... , T$_k$ such that there is an edge from the root node of the tree to the root node of each subtree. Subtree of a node X consists of all the nodes which have node X as the ancestor node.

![Representation-of-Tree-Data-Structure](https://media.geeksforgeeks.org/wp-content/uploads/20240424105009/Representation-of-Tree-Data-Structure.webp)


# Representation of a Node in Tree Data Structure:

A tree can be represented using a collection of nodes. Each of the nodes can be represented with the help of class or structs. Below is the representation of Node in different languages:

```cpp
class Node {
public:
    int data;
    Node* first_child;
    Node* second_child;
    Node* third_child;
    .
    .
    .
    Node* nth_child;
};
```
```c
struct Node {
    int data;
    struct Node* first_child;
    struct Node* second_child;
    struct Node* third_child;
    .
    .
    .
    struct Node* nth_child;
};
```
```java
public static class Node {
    int data;
    Node first_child;
    Node second_child;
    Node third_child;
      .
    .
    .
    Node nth_child;
}
```
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.children = []
```
```javascript
class Node {
    constructor(data) {
        this.data = data;
        this.children = [];
    }
}
```

# Importance for Tree Data Structure

One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer: The [DOM model](https://www.geeksforgeeks.org/dom-document-object-model/) of an HTML page is also tree where we have html tag as root, head and body its children and these tags, then have their own children.Please refer [Applications, Advantages and Disadvantages of Tree](https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-tree/) for details.

# Types of Tree data structures

Tree data structure can be classified into three types based upon the number of children each node of the tree can have. The types are:

-   [**Binary tree**](https://www.geeksforgeeks.org/types-of-trees-in-data-structures)**:** In a binary tree, each node can have a maximum of two children linked to it. Some common types of binary trees include full binary trees, complete binary trees, balanced binary trees, and degenerate or pathological binary trees. Examples of Binary Tree are Binary Search Tree and Binary Heap.
-   [**Ternary Tree**](https://www.geeksforgeeks.org/ternary-tree)**:** A Ternary Tree is a tree data structure in which each node has at most three child nodes, usually distinguished as “left”, “mid” and “right”.
-   [**N-ary Tree or Generic Tree**](https://www.geeksforgeeks.org/generic-treesn-array-trees)**:** Generic trees are a collection of nodes where each node is a data structure that consists of records and a list of references to its children(duplicate references are not allowed). Unlike the linked list, each node stores the address of multiple nodes.


# Basic Operations Of Tree Data Structure:

-   **Create** – create a tree in the data structure.
-   **Insert** − Inserts data in a tree.
-   **Search** − Searches specific data in a tree to check whether it is present or not.
-   **Traversal**:
    -   [Depth-First-Search Traversal](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph)
    -   [Breadth-First-Search Traversal](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph)

# Implementation of Tree Data Structure

```cpp
// C++ program to demonstrate some of the above
// terminologies
#include <bits/stdc++.h>
using namespace std;

// Function to add an edge between vertices x and y
void addEdge(int x, int y, vector<vector<int> >& adj)
{
    adj[x].push_back(y);
    adj[y].push_back(x);
}

// Function to print the parent of each node
void printParents(int node, vector<vector<int> >& adj,
                  int parent)
{
    // current node is Root, thus, has no parent
    if (parent == 0)
        cout << node << "->Root" << endl;
    else
        cout << node << "->" << parent << endl;
  
    // Using DFS
    for (auto cur : adj[node])
        if (cur != parent)
            printParents(cur, adj, node);
}

// Function to print the children of each node
void printChildren(int Root, vector<vector<int> >& adj)
{
    // Queue for the BFS
    queue<int> q;
  
    // pushing the root
    q.push(Root);
  
    // visit array to keep track of nodes that have been
    // visited
    int vis[adj.size()] = { 0 };
  
    // BFS
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        vis[node] = 1;
        cout << node << "-> ";
        for (auto cur : adj[node])
            if (vis[cur] == 0) {
                cout << cur << " ";
                q.push(cur);
            }
        cout << endl;
    }
}

// Function to print the leaf nodes
void printLeafNodes(int Root, vector<vector<int> >& adj)
{
    // Leaf nodes have only one edge and are not the root
    for (int i = 1; i < adj.size(); i++)
        if (adj[i].size() == 1 && i != Root)
            cout << i << " ";
    cout << endl;
}

// Function to print the degrees of each node
void printDegrees(int Root, vector<vector<int> >& adj)
{
    for (int i = 1; i < adj.size(); i++) {
        cout << i << ": ";
      
        // Root has no parent, thus, its degree is equal to
        // the edges it is connected to
        if (i == Root)
            cout << adj[i].size() << endl;
        else
            cout << adj[i].size() - 1 << endl;
    }
}
// Driver code
int main()
{
    // Number of nodes
    int N = 7, Root = 1;
    // Adjacency list to store the tree
    vector<vector<int> > adj(N + 1, vector<int>());
    // Creating the tree
    addEdge(1, 2, adj);
    addEdge(1, 3, adj);
    addEdge(1, 4, adj);
    addEdge(2, 5, adj);
    addEdge(2, 6, adj);
    addEdge(4, 7, adj);
  
    // Printing the parents of each node
    cout << "The parents of each node are:" << endl;
    printParents(Root, adj, 0);

    // Printing the children of each node
    cout << "The children of each node are:" << endl;
    printChildren(Root, adj);

    // Printing the leaf nodes in the tree
    cout << "The leaf nodes of the tree are:" << endl;
    printLeafNodes(Root, adj);

    // Printing the degrees of each node
    cout << "The degrees of each node are:" << endl;
    printDegrees(Root, adj);

    return 0;
}
```
```java
// java code for above approach
import java.io.*;
import java.util.*;

class GFG {

    // Function to print the parent of each node
    public static void
    printParents(int node, Vector<Vector<Integer> > adj,
                 int parent)
    {

        // current node is Root, thus, has no parent
        if (parent == 0)
            System.out.println(node + "->Root");
        else
            System.out.println(node + "->" + parent);

        // Using DFS
        for (int i = 0; i < adj.get(node).size(); i++)
            if (adj.get(node).get(i) != parent)
                printParents(adj.get(node).get(i), adj,
                             node);
    }

    // Function to print the children of each node
    public static void
    printChildren(int Root, Vector<Vector<Integer> > adj)
    {

        // Queue for the BFS
        Queue<Integer> q = new LinkedList<>();

        // pushing the root
        q.add(Root);

        // visit array to keep track of nodes that have been
        // visited
        int vis[] = new int[adj.size()];

        Arrays.fill(vis, 0);

        // BFS
        while (q.size() != 0) {
            int node = q.peek();
            q.remove();
            vis[node] = 1;
            System.out.print(node + "-> ");

            for (int i = 0; i < adj.get(node).size(); i++) {
                if (vis[adj.get(node).get(i)] == 0) {
                    System.out.print(adj.get(node).get(i)
                                     + " ");
                    q.add(adj.get(node).get(i));
                }
            }
            System.out.println();
        }
    }

    // Function to print the leaf nodes
    public static void
    printLeafNodes(int Root, Vector<Vector<Integer> > adj)
    {

        // Leaf nodes have only one edge and are not the
        // root
        for (int i = 1; i < adj.size(); i++)
            if (adj.get(i).size() == 1 && i != Root)
                System.out.print(i + " ");

        System.out.println();
    }

    // Function to print the degrees of each node
    public static void
    printDegrees(int Root, Vector<Vector<Integer> > adj)
    {
        for (int i = 1; i < adj.size(); i++) {
            System.out.print(i + ": ");

            // Root has no parent, thus, its degree is
            // equal to the edges it is connected to
            if (i == Root)
                System.out.println(adj.get(i).size());
            else
                System.out.println(adj.get(i).size() - 1);
        }
    }

    // Driver code
    public static void main(String[] args)
    {

        // Number of nodes
        int N = 7, Root = 1;

        // Adjacency list to store the tree
        Vector<Vector<Integer> > adj
            = new Vector<Vector<Integer> >();
        for (int i = 0; i < N + 1; i++) {
            adj.add(new Vector<Integer>());
        }

        // Creating the tree
        adj.get(1).add(2);
        adj.get(2).add(1);

        adj.get(1).add(3);
        adj.get(3).add(1);

        adj.get(1).add(4);
        adj.get(4).add(1);

        adj.get(2).add(5);
        adj.get(5).add(2);

        adj.get(2).add(6);
        adj.get(6).add(2);

        adj.get(4).add(7);
        adj.get(7).add(4);

        // Printing the parents of each node
        System.out.println("The parents of each node are:");
        printParents(Root, adj, 0);

        // Printing the children of each node
        System.out.println(
            "The children of each node are:");
        printChildren(Root, adj);

        // Printing the leaf nodes in the tree
        System.out.println(
            "The leaf nodes of the tree are:");
        printLeafNodes(Root, adj);

        // Printing the degrees of each node
        System.out.println("The degrees of each node are:");
        printDegrees(Root, adj);
    }
}

// This code is contributed by rj13to.
```
```python
from collections import deque

# Function to add an edge between vertices x and y
def addEdge(x, y, adj):
    adj[x].append(y)
    adj[y].append(x)

# Function to print the parent of each node
def printParents(node, adj, parent):
    # current node is Root, thus, has no parent
    if parent == 0:
        print("{}->Root".format(node))
    else:
        print("{}->{}".format(node, parent))

    # Using DFS
    for cur in adj[node]:
        if cur != parent:
            printParents(cur, adj, node)

# Function to print the children of each node
def printChildren(Root, adj):
    # Queue for the BFS
    q = deque()
    # pushing the root
    q.append(Root)
    # visit array to keep track of nodes that have been
    # visited
    vis = [0] * len(adj)
    # BFS
    while q:
        node = q.popleft()
        vis[node] = 1
        print("{}->".format(node)),
        for cur in adj[node]:
            if vis[cur] == 0:
                print(cur),
                q.append(cur)
        print()

# Function to print the leaf nodes
def printLeafNodes(Root, adj):
    # Leaf nodes have only one edge and are not the root
    for i in range(1, len(adj)):
        if len(adj[i]) == 1 and i != Root:
            print(i),

# Function to print the degrees of each node
def printDegrees(Root, adj):
    for i in range(1, len(adj)):
        print(i, ":"),
        # Root has no parent, thus, its degree is equal to
        # the edges it is connected to
        if i == Root:
            print(len(adj[i]))
        else:
            print(len(adj[i]) - 1)

# Driver code
N = 7
Root = 1
# Adjacency list to store the tree
adj = [[] for _ in range(N + 1)]
# Creating the tree
addEdge(1, 2, adj)
addEdge(1, 3, adj)
addEdge(1, 4, adj)
addEdge(2, 5, adj)
addEdge(2, 6, adj)
addEdge(4, 7, adj)

# Printing the parents of each node
print("The parents of each node are:")
printParents(Root, adj, 0)

# Printing the children of each node
print("The children of each node are:")
printChildren(Root, adj)

# Printing the leaf nodes in the tree
print("The leaf nodes of the tree are:")
printLeafNodes(Root, adj)

# Printing the degrees of each node
print("The degrees of each node are:")
printDegrees(Root, adj)
```
```javascript
// Number of nodes
let n = 7, root = 1;

// Adjacency list to store the tree
let adj = new Array(n + 1).fill(null).map(() => []);

// Creating the tree
addEdge(1, 2, adj);
addEdge(1, 3, adj);
addEdge(1, 4, adj);
addEdge(2, 5, adj);
addEdge(2, 6, adj);
addEdge(4, 7, adj);

// Function to add an edge between vertices x and y
function addEdge(x, y, arr) {
    arr[x].push(y);
    arr[y].push(x);
}

// Function to print the parent of each node
function printParents(node, arr, parent) {
    // current node is Root, thus, has no parent
    if (parent == 0)
        console.log(`${node}->root`);
    else
        console.log(`${node}->${parent}`);
        
    // Using DFS
    for (let cur of arr[node])
        if (cur != parent)
            printParents(cur, arr, node);
}

// Function to print the children of each node
function printChildren(root, arr) {
    // Queue for the BFS
    let q = [];
    
    // pushing the root
    q.push(root);
    
    // visit array to keep track of nodes
    // that have been visited
    let vis = new Array(arr.length).fill(0);
    
    // BFS
    while (q.length > 0) {
        let node = q.shift();
        vis[node] = 1;
        console.log(`${node}-> `);
        for (let cur of arr[node])
            if (vis[cur] == 0) {
                console.log(cur + " ");
                q.push(cur);
            }
        console.log("\\n");
    }
}

// Function to print the leaf nodes
function printLeafNodes(root, arr) {
    // Leaf nodes have only one edge
    // and are not the root
    for (let i = 1; i < arr.length; i++)
        if (arr[i].length == 1 &&
        i != root)
            console.log(i + " ");
    console.log("\\n");
}

// Function to print the degrees of each node
function printDegrees(Root, arr) {
    for (let i = 1; i < arr.length; i++) {
        console.log(`${i}: `);
        
        // Root has no parent, thus, its degree is equal to
        // the edges it is connected to
        if (i == root)
            console.log(arr[i].length + "\\n");
        else
            console.log(arr[i].length - 1 + "\\n");
    }
}

// Function to print the tree in a hierarchical format
function printTree(node, arr, parent, level) {
    // Indent based on the level of the node
    console.log("  ".repeat(level) + "└── " + node);

    // Recursively print children
    for (let cur of arr[node])
        if (cur != parent)
            printTree(cur, arr, node, level + 1);
}

// Driver code

// Printing the tree in a hierarchical format
console.log("Tree Structure:");
printTree(root, adj, 0, 0);

// Printing the parents of each node
console.log("\\nThe parents of each node are:");
printParents(root, adj, 0);

// Printing the children of each node
console.log("\\nThe children of each node are:");
printChildren(root, adj);

// Printing the leaf nodes in the tree
console.log("\\nThe leaf nodes of the tree are:");
printLeafNodes(root, adj);

// Printing the degrees of each node
console.log("\\nThe degrees of each node are:");
printDegrees(root, adj);
```


```Output
The parents of each node are:
1-&gt;Root
2-&gt;1
5-&gt;2
6-&gt;2
3-&gt;1
4-&gt;1
7-&gt;4
The children of each node are:
1-&gt; 2 3 4 
2-&gt; 5 6 
3-&gt; 
4-&gt; 7 
5-&gt; 
6-&gt; 
7-&gt; 
The leaf nodes of the tree are:
3 5 6 7 
The degrees o...
```

# Properties of Tree Data Structure:

**Number of edges:** An edge can be defined as the connection between two nodes. If a tree has N nodes then it will have (N-1) edges. There is only one path from each node to any other node of the tree.

**Depth of a node:** The depth of a node is defined as the length of the path from the root to that node. Each edge adds 1 unit of length to the path. So, it can also be defined as the number of edges in the path from the root of the tree to the node.

-   **Height of a node:** The height of a node can be defined as the length of the longest path from the node to a leaf node of the tree.
-   **Height of the Tree:** The height of a tree is the length of the longest path from the root of the tree to a leaf node of the tree.
-   **Degree of a Node:** The total count of subtrees attached to that node is called the degree of the node. The degree of a leaf node must be **0**. The degree of a tree is the maximum degree of a node among all the nodes in the tree.', 'Tree data structure is a hierarchical structure that is used to represent and organize data in the form of parent child relationship. ', 'Introduction to Tree Data Structure', 3, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('b91776fa-fc82-490d-aae4-195256b99705', e'![Tree-Traversal-Techniques-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240429140116/Tree-Traversal-Techniques-(1).webp)

# Tree Traversal

Tree Traversal refers to the process of visiting or accessing each node of the tree exactly once in a certain order. Tree traversal algorithms help us visit and process all the nodes of the tree. Since a tree is not a linear data structure, there can be multiple choices for the next node to be visited. Hence we have many ways to traverse a tree.

![Tree-Traversal-Techniques](https://media.geeksforgeeks.org/wp-content/uploads/20240429124251/Tree-Traversal-Techniques.webp)

There are multiple tree traversal techniques that decide the order in which the nodes of the tree are to be visited. These are defined below:

-   Depth First Search or DFS
    -   Inorder Traversal
    -   Preorder Traversal
    -   Postorder Traversal
-   Level Order Traversal or Breadth First Search or BFS

# Inorder Traversal

Inorder traversal visits the node in the order: ****Left -> Root -> Right****

****Algorithm for Inorder Traversal****

```Pseucode
Inorder(tree )
	Traverse the left subtree, i.e., call Inorder(left->subtree)  
	Visit the root.  
	Traverse the right subtree, i.e., call Inorder(right->subtree)
```

![Inorder-Traversal-of-Binary-Tree-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250310153932992164/Inorder-Traversal-of-Binary-Tree-1.webp)![Inorder-Traversal-of-Binary-Tree-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250311103958166587/Inorder-Traversal-of-Binary-Tree-8.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310153933776732/Inorder-Traversal-of-Binary-Tree-3-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250311103958416787/Inorder-Traversal-of-Binary-Tree-10.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310153934246402/Inorder-Traversal-of-Binary-Tree-5-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310153934426883/Inorder-Traversal-of-Binary-Tree-6-.webp)



****Uses of Inorder Traversal****

-   In the case of binary search trees (BST), Inorder traversal gives nodes in non-decreasing order.
-   To get nodes of BST in non-increasing order, a variation of Inorder traversal where Inorder traversal is reversed can be used.
-   Inorder traversal can be used to evaluate arithmetic expressions stored in expression trees.

> Refer [Inorder Traversal of Binary Tree](https://www.geeksforgeeks.org/inorder-traversal-of-binary-tree/) for more

# Preorder Traversal

Preorder traversal visits the node in the order: ****Root -> Left -> Right****

****Algorithm for Preorder Traversal****
```Pseucode
Preorder(tree)
    Visit the root.  
    Traverse the left subtree, i.e., call Preorder(left->subtree)  
    Traverse the right subtree, i.e., call Preorder(right->subtree)
```

![Preorder-Traversal-of-Binary-Tree-1-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250310154630694049/Preorder-Traversal-of-Binary-Tree-1-.webp)![Preorder-Traversal-of-Binary-Tree-1-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250310154632899819/Preorder-Traversal-of-Binary-Tree-2-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310154632502335/Preorder-Traversal-of-Binary-Tree-3-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310154632071474/Preorder-Traversal-of-Binary-Tree-4-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310154631667836/Preorder-Traversal-of-Binary-Tree-5-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310154631182997/Preorder-Traversal-of-Binary-Tree-6-.webp)



****Uses of Preorder Traversal****

-   Preorder traversal is used to create a copy of the tree.
-   Preorder traversal is also used to get prefix expressions on an expression tree.

> Refer [Preorder Traversal of Binary Tree](https://www.geeksforgeeks.org/preorder-traversal-of-binary-tree/) for more

# Postorder Traversal

Postorder traversal visits the node in the order: ****Left -> Right -> Root****

****Algorithm for Postorder Traversal:****

```pseucode
Postorder(tree)
	Traverse the left subtree, i.e., call Postorder(left->subtree)  
	Traverse the right subtree, i.e., call Postorder(right->subtree)  
	Visit the root
```

![Postorder-Traversal-of-Binary-Tree-1-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250310154150849148/Postorder-Traversal-of-Binary-Tree-1-.webp)![Postorder-Traversal-of-Binary-Tree-1-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250310154151367864/Postorder-Traversal-of-Binary-Tree-2-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310154151614462/Postorder-Traversal-of-Binary-Tree-3-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310154151807451/Postorder-Traversal-of-Binary-Tree-4-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310154152102563/Postorder-Traversal-of-Binary-Tree-5-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310154152327501/Postorder-Traversal-of-Binary-Tree-6-.webp)


****Uses of Postorder Traversal****

-   Postorder traversal is used to delete the tree.
-   Postorder traversal is also useful to get the postfix expression of an expression tree.
-   Postorder traversal can help in garbage collection algorithms, particularly in systems where manual memory management is used.

> Refer [Postorder Traversal of Binary Tree](https://www.geeksforgeeks.org/postorder-traversal-of-binary-tree/) for more

# Level Order Traversal

Level Order Traversal visits all nodes present in the same level completely before visiting the next level.

![Level-Order-Traversal-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250310155917296023/Level-Order-Traversal-01-.webp)![Level-Order-Traversal-01-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250310155917074025/Level-Order-Traversal-2-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310155916873831/Level-Order-Traversal-3-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310155916483553/Level-Order-Traversal-4-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310155916064920/Level-Order-Traversal-5-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310155915682892/Level-Order-Traversal-6-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310155915682892/Level-Order-Traversal-6-.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250310155914939286/Level-Order-Traversal-8-.webp)


****Algorithm for Level Order Traversal****
```PseuCode
LevelOrder(tree)
	Create an empty queue Q  
	Enqueue the root node of the tree to Q  
	Loop while Q is not empty  
		Dequeue a node from Q and visit it  
		Enqueue the left child of the dequeued node if it exists  
		Enqueue the right child of the dequeued node if it exists
```

****Uses of Level Traversal****

1.  Level-wise node processing, like finding maximum/minimum at each level.
2.  Tree serialization/deserialization for efficient storage and reconstruction.
3.  Solving problems like calculating the "maximum width of a tree" by processing nodes level by level.

> Refer [Level Order Traversal (Breadth First Search or BFS) of Binary Tree](https://www.geeksforgeeks.org/level-order-tree-traversal/) for more

# Other Tree Traversals

1.  Boundary Traversal
2.  Diagonal Traversal

## 1. Boundary Traversal

****Boundary Traversal**** of a Tree includes

-   left boundary (nodes on left excluding leaf nodes)
-   leaves (consist of only the leaf nodes)
-   right boundary (nodes on right excluding leaf nodes)

****Algorithm for Boundary Traversal:****

```Pseucode
BoundaryTraversal(tree)
	If root is not null:  
		Print root\'s data  
		PrintLeftBoundary(root->left) // Print the left boundary nodes  
		PrintLeafNodes(root->left) // Print the leaf nodes of left subtree  
		PrintLeafNodes(root->right) // Print the leaf nodes of right subtree  
		PrintRightBoundary(root->right) // Print the right boundary nodes
```
****Uses of Boundary Traversal****

-   Boundary traversal helps visualize the outer structure of a binary tree, providing insights into its shape and boundaries.
-   Boundary traversal provides a way to access and modify these nodes, enabling operations such as pruning or repositioning of boundary nodes.

> Refer [Boundary Traversal of binary tree](https://www.geeksforgeeks.org/boundary-traversal-of-binary-tree/) for more

## 2. Diagonal Traversal

In the Diagonal Traversal of a Tree, all the nodes in a single diagonal will be printed one by one.

****Algorithm for Diagonal Traversal****

```pseucode
DiagonalTraversal(tree):
	If root is not null:  
		Create an empty map  
		DiagonalTraversalUtil(root, 0, M) // Call helper function with initial diagonal level 0  
		For each key-value pair (diagonalLevel, nodes) in M:  
			For each node in nodes:  
				Print node\'s data

DiagonalTraversalUtil(node, diagonalLevel, M):
	If node is null  
		Return  
	If diagonalLevel is not present in M:  
		Create a new list in M for diagonalLevel  
	Append node\'s data to the list at M[diagonalLevel]  
	DiagonalTraversalUtil(node->left, diagonalLevel + 1, M) // Traverse left child with increased diagonal level  
	DiagonalTraversalUtil(node->right, diagonalLevel, M) // Traverse right child with same diagonal level
```
****Uses of Diagonal Traversal****

-   Diagonal traversal helps in visualizing the hierarchical structure of binary trees, particularly in tree-based data structures like binary search trees (BSTs) and heap trees.
-   Diagonal traversal can be utilized to calculate path sums along diagonals in a binary tree.

> Refer [Diagonal Traversal of Binary Tree](https://www.geeksforgeeks.org/diagonal-traversal-of-binary-tree/) for more

', 'Discussing all the tree traversal techniques along with their uses.', 'Tree Traversal Techniques', 4, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('4e311fc0-4f15-4827-80dc-fbd8fdbc1f9c', e'# Types of Trees

![tree](https://media.geeksforgeeks.org/wp-content/uploads/20250320165045376989/tree.webp)


# The main types of trees in data structure are:

## 1. Binary Tree

> A binary tree is a tree data structure where each node has at most ****two children****. These two children are usually referred to as the ****left child**** and ****right child****. It is widely used in applications such as binary search trees and heaps.

****Example:**** Consider the tree below. Since each node of this tree has only 2 children, it can be said that this tree is a [Binary Tree](https://www.geeksforgeeks.org/binary-tree-data-structure/)

![Binary Tree](https://media.geeksforgeeks.org/wp-content/uploads/20221124091613/binary.png)


***Examples/Types of Binary Tree:***

-   ****Complete Binary Tree****: A binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. For example, a [heap](https://www.geeksforgeeks.org/heap-data-structure/) is a complete binary tree that satisfies the heap property (either max-heap or min-heap).
-   ****Full Binary Tree****: A binary tree where every node has either 0 or 2 children.
-   ****Degenerate Binary Tree (or Pathological Tree)****: A tree in which each parent node has only one child. This essentially forms a linked list, which leads to inefficient operations.
-   ****Binary Search Tree (BST) and its Variations****: A [BST](https://www.geeksforgeeks.org/binary-search-tree-data-structure/) is a binary tree where each node has at most two children, and for each node, the left child’s value is smaller than the node’s value, and the right child’s value is greater. An [AVL Tree](https://www.geeksforgeeks.org/introduction-to-avl-tree/) is a self-balancing BST where the heights of the two child subtrees of any node differ by no more than one. [Red Black Tree](https://www.geeksforgeeks.org/introduction-to-red-black-tree/) and [Splay Tree](https://www.geeksforgeeks.org/introduction-to-splay-tree-data-structure/) are more example variations of BST.
-   ****Binary Indexed Tree (****[****Fenwick Tree****](https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/)****)****: A data structure that uses a binary tree to efficiently compute and update prefix sums in an array.
-   ****Perfect Binary Tree****: A binary tree where all internal nodes have two children and all leaf nodes are at the same level.
-   ****Balanced Binary Tree****: A binary tree where the difference in heights between the left and right subtrees of any node is minimal (often defined as at most 1). Examples of Balanced Binary Tree are [AVL Tree,](https://www.geeksforgeeks.org/introduction-to-avl-tree/) [Red Black Tree](https://www.geeksforgeeks.org/introduction-to-red-black-tree/) and [Splay Tree](https://www.geeksforgeeks.org/introduction-to-splay-tree-data-structure/)
-   ****Segment Tree****: A [segment tree](https://www.geeksforgeeks.org/segment-tree-data-structure/) is a binary tree used for storing intervals or segments. It allows efficient querying and updating of ranges of values, making it particularly useful for problems that involve finding the sum, minimum, maximum, or other operations over a range of elements in an array.

![Segment Tree](https://media.geeksforgeeks.org/wp-content/uploads/20230111155155/segment.png)

> To know more about the types of the binary trees, please refer to this detailed article: [Types of Binary Tree](https://www.geeksforgeeks.org/types-of-binary-tree/).

## 2. Ternary Tree

> A Ternary Tree is a tree data structure in which each node has at most three child nodes, usually distinguished as “left”, “mid” and “right”.

****Example:**** Consider the tree below. Since each node of this tree has only 3 children, it can be said that this tree is a [Ternary Tree](https://www.geeksforgeeks.org/what-is-ternary-tree/).  
![Ternary Tree](https://media.geeksforgeeks.org/wp-content/uploads/20221125131351/ternary1.png)

***Examples of Ternary Tree:***

-   ****Ternary Search Tree****: A [ternary search tree](https://www.geeksforgeeks.org/ternary-search-tree/) is a special trie data structure where the child nodes of a standard trie are ordered as a binary search tree.
-   ****Ternary Heap****: A type of heap where each node can have up to three children, though less common than binary heaps.

## 3. N-ary Tree (Generic Tree)

> [Generic trees](https://www.geeksforgeeks.org/generic-treesn-array-trees/) are a collection of nodes where each node is a data structure that consists of records and a list of references to its children(duplicate references are not allowed). Unlike the linked list, each node stores the address of multiple nodes. 

Every node stores the addresses of its children and the very first node’s address will be stored in a separate pointer called root.

 1. Many children at every node.  
 2. The number of nodes for each node is not known in advance.

****Example****:

![N-ary Tree](https://media.geeksforgeeks.org/wp-content/uploads/20221124092620/Nary.png)


***Examples of N-ary Trees:***

-   ****B-tree****: A [self-balancing search tree](https://www.geeksforgeeks.org/self-balancing-binary-search-trees/) where nodes can have multiple children, usually used for indexing large databases.
-   ****B+ Tree****: A [B+ tree](https://www.geeksforgeeks.org/introduction-of-b-tree/) is a variation of the B-tree that only stores data in the leaf nodes, making range queries more efficient.
-   ****Trie (Prefix Tree)****: A tree where each node represents a character, and paths from the root to leaves represent strings. It can have a variable number of children for each node, making it an N-ary tree.', 'A tree in data structures is a hierarchical data structure that consists of nodes connected by edges. ', 'Types of Trees in Data Structures', 5, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('353fe8b3-17ac-4d50-87a6-ea3cbf990264', e'# Basic Operations on BST (additional)
## Searching in Binary Search Tree (BST)
Given a **BST**, the task is to search a node in this **BST**. For searching a value in BST, consider it as a sorted array. Now we can easily perform search operation in BST using [**Binary Search Algorithm**](https://www.geeksforgeeks.org/binary-search/).  

**Input**: Root of the below BST

![Searching-Example-1](https://media.geeksforgeeks.org/wp-content/uploads/20240925070913/Searching-Example-1.webp)

**Output**: True  
**Explanation**: 8 is present in the BST as right child of root

**Input**: Root of the below BST

![Searching-Example-2](https://media.geeksforgeeks.org/wp-content/uploads/20240925070912/Searching-Example-2.webp)

**Output**: False  
**Explana
tion**: 14 is not present in the BST

### Algorithm to search for a key in a given Binary Search Tree

Let\'s say we want to search for the number **X,** We start at the root. Then:

-   We compare the value to be searched with the value of the root. 
    -   If it\'s equal we are done with the search if it\'s smaller we know that we need to go to the left subtree because in a binary search tree all the elements in the left subtree are smaller and all the elements in the right subtree are larger. 
-   Repeat the above step till no more traversal is possible
-   If at any iteration, key is found, return True. Else False.

### Illustration of searching in a BST:

See the illustration below for a better understanding:

![Searching-In-BST-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240806163347/Searching-In-BST-1.webp)![Searching-In-BST-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240806163348/Searching-In-BST-2.webp)![Searching-In-BST-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240806163348/Searching-In-BST-3.webp)![Searching-In-BST-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240806163349/Searching-In-BST-4.webp)


### Recursive Program to implement search in BST:

```cpp
#include <iostream>
using namespace std;

struct Node {
    int key;
    Node* left;
    Node* right;
    Node(int item) {
        key = item;
        left = right = NULL;
    }
};

// function to search a key in a BST
Node* search(Node* root, int key) {
  
    // Base Cases: root is null or key 
    // is present at root
    if (root == NULL || root->key == key)
        return root;

    // Key is greater than root\'s key
    if (root->key < key)
        return search(root->right, key);

    // Key is smaller than root\'s key
    return search(root->left, key);
}

// Driver Code
int main() {
  
    // Creating a hard coded tree for keeping 
    // the length of the code small. We need 
    // to make sure that BST properties are 
    // maintained if we try some other cases.
    Node* root = new Node(50);
    root->left = new Node(30);
    root->right = new Node(70);
    root->left->left = new Node(20);
    root->left->right = new Node(40);
    root->right->left = new Node(60);
    root->right->right = new Node(80);
  
    (search(root, 19) != NULL)? cout << "Found\\n": 
                               cout << "Not Found\\n";

  
    (search(root, 80) != NULL)? cout << "Found\\n": 
                               cout << "Not Found\\n";

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int key;
    struct Node* left;
    struct Node* right;
};

// Constructor to create a new BST node
struct Node* newNode(int item)
{
    struct Node* temp
        = (struct Node*)malloc(sizeof(struct Node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
}

// function to search a key in a BST
struct Node* search(struct Node* root, int key)
{

    // Base Cases: root is null or key is
    // present at root
    if (root == NULL || root->key == key)
        return root;

    // Key is greater than root\'s key
    if (root->key < key)
        return search(root->right, key);

    // Key is smaller than root\'s key
    return search(root->left, key);
}

// Driver Code
int main()
{
    // Creating a hard coded tree for keeping 
    // the length of the code small. We need 
    // to make sure that BST properties are 
    // maintained if we try some other cases.
    struct Node* root = newNode(50);
    root->left = newNode(30);
    root->right = newNode(70);
    root->left->left = newNode(20);
    root->left->right = newNode(40);
    root->right->left = newNode(60);
    root->right->right = newNode(80);

    printf(search(root, 19) != NULL ? "Found\\n"
                                    : "Not Found\\n");
    printf(search(root, 80) != NULL ? "Found\\n"
                                    : "Not Found\\n");

    return 0;
}
```
```java
class Node {
    int key;
    Node left, right;

    public Node(int item)
    {
        key = item;
        left = right = null;
    }
}
class GfG {

    // function to search a key in a BST
    static Node search(Node root, int key)
    {
        // Base Cases: root is null or key is present at
        // root
        if (root == null || root.key == key)
            return root;

        // Key is greater than root\'s key
        if (root.key < key)
            return search(root.right, key);

        // Key is smaller than root\'s key
        return search(root.left, key);
    }

    public static void main(String[] args)
    {
        
        // Creating a hard coded tree for keeping 
        // the length of the code small. We need 
        // to make sure that BST properties are 
        // maintained if we try some other cases.
        Node root = new Node(50);
        root.left = new Node(30);
        root.right = new Node(70);
        root.left.left = new Node(20);
        root.left.right = new Node(40);
        root.right.left = new Node(60);
        root.right.right = new Node(80);

        // Searching for keys in the BST
        System.out.println(search(root, 19) != null
                               ? "Found"
                               : "Not Found");
        System.out.println(search(root, 80) != null
                               ? "Found"
                               : "Not Found");
    }
}
```
```python
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

# function to search a key in a BST
def search(root, key):
  
    # Base Cases: root is null or key 
    # is present at root
    if root is None or root.key == key:
        return root
    
    # Key is greater than root\'s key
    if root.key < key:
        return search(root.right, key)
    
    # Key is smaller than root\'s key
    return search(root.left, key)


 # Creating a hard coded tree for keeping 
 # the length of the code small. We need 
 # to make sure that BST properties are 
 # maintained if we try some other cases.
root = Node(50)
root.left = Node(30)
root.right = Node(70)
root.left.left = Node(20)
root.left.right = Node(40)
root.right.left = Node(60)
root.right.right = Node(80)

# Searching for keys in the BST
print("Found" if search(root, 19) else "Not Found")
print("Found" if search(root, 80) else "Not Found")
```
```csharp
using System;

public class Node
{
    public int Key;
    public Node Left, Right;

    public Node(int item)
    {
        Key = item;
        Left = Right = null;
    }
}

public class GfG
{
    // function to search a key in a BST
    public static Node Search(Node root, int key)
    {
        // Base Cases: root is null or key is
        // present at root
        if (root == null || root.Key == key)
            return root;

        // Key is greater than root\'s key
        if (root.Key < key)
            return Search(root.Right, key);

        // Key is smaller than root\'s key
        return Search(root.Left, key);
    }

    // Driver Code
    public static void Main()
    {

        // Creating a hard coded tree for keeping 
        // the length of the code small. We need 
        // to make sure that BST properties are 
        // maintained if we try some other cases.
        Node root = new Node(50);
        root.Left = new Node(30);
        root.Right = new Node(70);
        root.Left.Left = new Node(20);
        root.Left.Right = new Node(40);
        root.Right.Left = new Node(60);
        root.Right.Right = new Node(80);

        // Searching for keys in the BST
        Console.WriteLine(Search(root, 19) != null ? "Found" : "Not Found");
        Console.WriteLine(Search(root, 80) != null ? "Found" : "Not Found");
    }
}
```
```javascript
class Node {
    constructor(key)
    {
        this.key = key;
        this.left = null;
        this.right = null;
    }
}

// function to search a key in a BST
function search(root, key)
{

    // Base Cases: root is null or key is 
    // present at root
    if (root === null || root.key === key)
        return root;

    // Key is greater than root\'s key
    if (root.key < key)
        return search(root.right, key);

    // Key is smaller than root\'s key
    return search(root.left, key);
}


// Creating a hard coded tree for keeping 
// the length of the code small. We need 
// to make sure that BST properties are 
// maintained if we try some other cases.
let root = new Node(50);
root.left = new Node(30);
root.right = new Node(70);
root.left.left = new Node(20);
root.left.right = new Node(40);
root.right.left = new Node(60);
root.right.right = new Node(80);

// Searching for keys in the BST
console.log(search(root, 19) !== null ? "Found"
                                      : "Not Found");
console.log(search(root, 80) !== null ? "Found"
                                      : "Not Found");
```

```output
Not Found
Found
```

**Time complexity:** O(h), where h is the height of the BST.  
**Auxiliary Space:** O(h) This is because of the space needed to store the recursion stack.

We can avoid the auxiliary space and recursion overhead withe help of iterative implementation. Below is link for the iterative implementation that works in O(h) time and O(1) auxiliary space.

### Iterative Program to implement search in BST.
**Approach:**

> The idea is to traverse the **Binary search tree**, starting from the **root** node. If the **current** node\'s data is equal to **key**, then **return true**. If node\'s value is **less** than key, then traverse the **right subtree** by updateing current as current\'right. Else, set current as current\'left to travrese in **left subtree.** If current becomes NULL , key is **not present** in the BST, return false.

> Continue in the following lesson', 'Searching in Binary Search Tree', 'Binary Search Tree Part 3: Searching Operation', 9, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('ff4db851-5e60-40f5-9ff9-ab98645fc05c', e'# What is a Circular Linked List?

A circular linked list is a special type of linked list where all the nodes are connected to form a circle. Unlike a regular linked list, which ends with a node pointing to NULL, the last node in a circular linked list points back to the first node. This means that you can keep traversing the list without ever reaching a NULL value.

# Types of Circular Linked Lists

We can create a circular linked list from both [singly linked lists](https://www.geeksforgeeks.org/introduction-to-singly-linked-list/) and [doubly linked lists](https://www.geeksforgeeks.org/doubly-linked-list-tutorial-2/). So, circular linked lists are basically of two types:

#### **1. Circular Singly Linked List**

In Circular Singly Linked List, each node has just one pointer called the "next" pointer. The next pointer of the last node points back to the first node and this results in forming a circle. In this type of Linked list, we can only move through the list in one direction.

![Representation-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806130914/Representation-of-circular-linked-list.webp)

Representation of Circular Singly Linked List

#### **2. Circular Doubly Linked List:**

In circular doubly linked list, each node has two pointers prev and next, similar to doubly linked list. The prev pointer points to the previous node and the next points to the next node. Here, in addition to the last node storing the address of the first node, the first node will also store the address of the last node.

![Representation-of-circular-doubly-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145223/Representation-of-circular-doubly-linked-list.webp)

**Note:** In this article, we will use the singly linked list to explain the working of circular linked lists.

# Representation of a Circular Singly Linked List

Let\'s take a look on the structure of a circular linked list.

![Node-structure-of-circular-linked-list](https://media.geeksforgeeks.org/wp-content/uploads/20240806145414/Node-structure-of-circular-linked-list.webp)

# Create/Declare a Node of Circular Linked List


Syntax to Declare a Circular Linked List in Different Languages:
```C++
// Node structure
struct Node {
  int data;
  Node *next;

  Node(int value) {
    data = value;
    next = nullptr;
  }
};

```
```C
    // Node structure
    struct Node {
  int data;
  struct Node *next;
};

// Function to create a new node
struct Node *createNode(int value) {
  // Allocate memory
  struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));

  // Set the data
  newNode->data = value;

  // Initialize next to NULL
  newNode->next = NULL;

  // Return the new node
  return newNode;
}

```
```Java
 class Node {
  int data;
  Node next;

  Node(int data) {
    this.data = data;
    this.next = null;
  }
}

```
```Python
 class Node : def
                   __init__(self, data)
    : self.data = data self.next = None

```
```C #
 public class Node {
 public
  int data;
 public
  Node next;

 public
  Node(int data) {
    this.data = data;
    this.next = null;
  }
}

```
```JavaScript
 class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}
```

In the code above, each node has **data** and a **pointer** to the next node. When we create multiple nodes for a circular linked list, we only need to connect the last node back to the first one.

#### Example of Creating a Circular Linked List

Here’s an example of creating a circular linked list with three nodes (2, 3, 4):

![Circular-Linked-List](https://media.geeksforgeeks.org/wp-content/uploads/20240806111438/Circular-Linked-List.png)

Created a circular linked list with 3 nodes

```C++
// Initilize and allocate memory for nodes
first = new Node(2);
second = new Node(3);
last = new Node(4);

// Connect nodes
first->next = second;
second->next = last;

// Connect last node to first node
last->next = first;

```
```C
// Allocate memory for nodes
struct Node *first = 
  (struct Node *)malloc(sizeof(struct Node));
struct Node *second =
  (struct Node *)malloc(sizeof(struct Node));
struct Node *last =
  (struct Node *)malloc(sizeof(struct Node));

// Initilize nodes
first->data = 2;
second->data = 3;
last->data = 4;

// Connect nodes
first->next = second;
second->next = last;
last->next = first;

```
```Java
// Initilize and allocate memory for nodes
Node first = new Node(2);
Node second = new Node(3);
Node last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

```
```Python
#Initilize and allocate memory for nodes
first = Node(2)
second = Node(3)
last = Node(4)

#Connect nodes
first.next = second
second.next = last
last.next = first

```
```C#
// Initilize and allocate memory for nodes
Node first = new Node(2);
Node second = new Node(3);
Node last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

```
```JavaScript
// Initilize and allocate memory for nodes
let first = new Node(2);
let second = new Node(3);
let last = new Node(4);

// Connect nodes
first.next = second;
second.next = last;
last.next = first;

```

  
In the above code, we have created three nodes first, second, and last having values 2, 3, and 4 respectively.

-   After creating three nodes, we have connected these node in a series.
-   Connect the first node "first" to "second" node by storing the address of "second" node into first\'s next
-   Connect the second node "second" to "third" node by storing the address of "third" node into second\'s next
-   After connecting all the nodes, we reach the key characteristic of a circular linked list: linking the last node back to the first node. Therefore, we store the address of the "first" node in the "last" node.

# Why have we taken a pointer that points to the last node instead of the first node? 

For the insertion of a node at the beginning, we need to traverse the whole list. Also, for insertion at the end, the whole list has to be traversed. If instead of the start pointer, we take a pointer to the last node, then in both cases there won\'t be any need to traverse the whole list. So insertion at the beginning or at the end takes constant time, irrespective of the length of the list.

# Advantages of Circular Linked Lists

-   In circular linked list, the last node points to the first node. There are no null references, making traversal easier and reducing the chances of encountering null pointer exceptions.
-   We can traverse the list from any node and return to it without needing to restart from the head, which is useful in applications requiring a circular iteration.
-   Circular linked lists can easily implement circular queues, where the last element connects back to the first, allowing for efficient resource management.
-   In a circular linked list, each node has a reference to the next node in the sequence. Although it doesn\'t have a direct reference to the previous node like a doubly linked list, we can still find the previous node by traversing the list.

# Disadvantages of Circular Linked Lists

-   Circular linked lists are more complex to implement than singly linked lists.
-   Traversing a circular linked list without a clear stopping condition can lead to infinite loops if not handled carefully.
-   Debugging can be more challenging due to the circular nature, as traditional methods of traversing linked lists may not apply.

# Applications of Circular Linked Lists

-   It is used for time-sharing among different users, typically through a **Round-Robin scheduling mechanism.**
-   In multiplayer games, a circular linked list can be used to switch between players. After the last player\'s turn, the list cycles back to the first player.
-   Circular linked lists are often used in buffering applications, such as streaming data, where data is continuously produced and consumed.
-   In media players, circular linked lists can manage playlists, this allowing users to loop through songs continuously.
-   Browsers use circular linked lists to manage the cache. This allows you to navigate back through your browsing history efficiently by pressing the BACK button.', 'A circular linked list is a data structure where the last node connects back to the first, forming a loop.', 'Circular Linked List', 8, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('b8165176-c256-44f6-bc1a-a32a3626fad5', e'# What is Algorithm
The word **Algorithm** means **"A set of finite rules or instructions to be followed in calculations or other problem-solving operations"** Or **"A procedure for solving a mathematical problem in a finite number of steps that frequently involves recursive operations"**.

Therefore Algorithm refers to a sequence of finite steps to solve a particular problem.

![](https://media.geeksforgeeks.org/wp-content/uploads/20250429120929479720/What-is-an-Algorithm_.webp)

Please refer [**Complete Data Structures & Algorithms Tutorial**](https://www.geeksforgeeks.org/dsa-tutorial-learn-data-structures-and-algorithms/) for topic-wise guide, practice problems and interview questions.

# Use of the Algorithms

Algorithms play a crucial role in various fields and have many applications. Some of the key areas where algorithms are used include:

1.  **Computer Science:** Algorithms form the basis of computer programming and are used to solve problems ranging from simple sorting and searching to complex tasks such as artificial intelligence and machine learning.
2.  **Mathematics:** Algorithms are used to solve mathematical problems, such as finding the optimal solution to a system of linear equations or finding the shortest path in a graph.
3.  **Operations Research**: Algorithms are used to optimize and make decisions in fields such as transportation, logistics, and resource allocation.
4.  **Artificial Intelligence:** Algorithms are the foundation of artificial intelligence and machine learning, and are used to develop intelligent systems that can perform tasks such as image recognition, natural language processing, and decision-making.
5.  **Data Science:** Algorithms are used to analyze, process, and extract insights from large amounts of data in fields such as marketing, finance, and healthcare.

These are just a few examples of the many applications of algorithms. The use of algorithms is continually expanding as new technologies and fields emerge, making it a vital component of modern society.

Algorithms can be simple and complex depending on what you want to achieve.

- It can be understood by taking the example of cooking a new recipe. To cook a new recipe, one reads the instructions and steps and executes them one by one, in the given sequence. The result thus obtained is the new dish is cooked perfectly. Every time you use your phone, computer, laptop, or calculator you are using Algorithms. Similarly, algorithms help to do a task in programming to get the expected output.

- The Algorithm designed are language-independent, i.e. they are just plain instructions that can be implemented in any language, and yet the output will be the same, as expected.

# What is the need for algorithms?

1.  Algorithms are necessary for solving complex problems efficiently and effectively. 
2.  They help to automate processes and make them more reliable, faster, and easier to perform.
3.  Algorithms also enable computers to perform tasks that would be difficult or impossible for humans to do manually.
4.  They are used in various fields such as mathematics, computer science, engineering, finance, and many others to optimize processes, analyze data, make predictions, and provide solutions to problems.

# What are the Characteristics of an Algorithm? 

![ ](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191016135220/Characteristics-of-an-Algorithm-1024x630.jpg)

As one would not follow any written instructions to cook the recipe, but only the standard one. Similarly, not all written instructions for programming are an algorithm. For some instructions to be an algorithm, it must have the following characteristics:

-   **Clear and Unambiguous**: The algorithm should be unambiguous. Each of its steps should be clear in all aspects and must lead to only one meaning.
-   **Well-Defined Inputs**: If an algorithm says to take inputs, it should be well-defined inputs. It may or may not take input.
-   **Well-Defined Outputs:** The algorithm must clearly define what output will be yielded and it should be well-defined as well. It should produce at least 1 output.
-   **Finite-ness:** The algorithm must be finite, i.e. it should terminate after a finite time.
-   **Feasible:** The algorithm must be simple, generic, and practical, such that it can be executed with the available resources. It must not contain some future technology or anything.
-   **Language Independent:** The Algorithm designed must be language-independent, i.e. it must be just plain instructions that can be implemented in any language, and yet the output will be the same, as expected.
-   **Input**: An algorithm has zero or more inputs. Each that contains a fundamental operator must accept zero or more inputs.
-    **Output**: An algorithm produces at least one output. Every instruction that contains a fundamental operator must accept zero or more inputs.
-   **Definiteness:** All instructions in an algorithm must be unambiguous, precise, and easy to interpret. By referring to any of the instructions in an algorithm one can clearly understand what is to be done. Every fundamental operator in instruction must be defined without any ambiguity.
-   **Finiteness:** An algorithm must terminate after a finite number of steps in all test cases. Every instruction which contains a fundamental operator must be terminated within a finite amount of time. Infinite loops or recursive functions without base conditions do not possess finiteness.
-   **Effectiveness:** An algorithm must be developed by using very basic, simple, and feasible operations so that one can trace it out by using just paper and pencil.

# Properties of Algorithm

-   It should terminate after a finite time.
-   It should produce at least one output.
-   It should take zero or more input.
-   It should be deterministic means giving the same output for the same input case.
-   Every step in the algorithm must be effective i.e. every step should do some work.

# Advantages of Algorithms 

-   It is easy to understand.
-   An algorithm is a step-wise representation of a solution to a given problem.
-   In an Algorithm the problem is broken down into smaller pieces or steps hence, it is easier for the programmer to convert it into an actual program.

# Disadvantages of Algorithms 

-   Writing an algorithm takes a long time so it is time-consuming.
-   Understanding complex logic through algorithms can be very difficult.
-   Branching and Looping statements are difficult to show in Algorithms**(imp)**.

# How to Design an Algorithm? 

To write an algorithm, the following things are needed as a pre-requisite: 

1.  The **problem** that is to be solved by this algorithm i.e. clear problem definition.
2.  The **constraints** of the problem must be considered while solving the problem.
3.  The **input** to be taken to solve the problem.
4.  The **output** is to be expected when the problem is solved.
5.  The **solution** to this problem is within the given constraints.

Then the algorithm is written with the help of the above parameters such that it solves the problem.

**Example:** Consider the example to add three numbers and print the sum.

### Step 1: Fulfilling the pre-requisites

As discussed above, to write an algorithm, its prerequisites must be fulfilled.   

1.  **The problem that is to be solved by this algorithm**: Add 3 numbers and print their sum.
2.  **The constraints of the problem that must be considered while solving the problem**: The numbers must contain only digits and no other characters.
3.  **The input to be taken to solve the problem:** The three numbers to be added.
4.  **The output to be expected when the problem is solved:** The sum of the three numbers taken as the input i.e. a single integer value.
5.  **The solution to this problem, in the given constraints:** The solution consists of adding the 3 numbers. It can be done with the help of the \'+\' operator, or bit-wise, or any other method.

### Step 2: Designing the algorithm

Now let\'s design the algorithm with the help of the above pre-requisites:

**Algorithm to add 3 numbers and print their sum:**   

1.  START
2.  Declare 3 integer variables num1, num2, and num3.
3.  Take the three numbers, to be added, as inputs in variables num1, num2, and num3 respectively.
4.  Declare an integer variable sum to store the resultant sum of the 3 numbers.
5.  Add the 3 numbers and store the result in the variable sum.
6.  Print the value of the variable sum
7.  END

### Step 3: Testing the algorithm by implementing it.

To test the algorithm, let\'s implement it in C language.
**Program:**
```C++
#include <bits/stdc++.h>
using namespace std;
 
int main()
{
    
    // Variables to take the input of 
    // the 3 numbers
    int num1, num2, num3;
 
    // Variable to store the resultant sum
    int sum;
 
    // Take the 3 numbers as input
    cout << "Enter the 1st number: ";
    cin >> num1;
    cout << " " << num1 << endl;
 
    cout << "Enter the 2nd number: ";
    cin >> num2;
    cout << " " << num2 << endl;
 
    cout << "Enter the 3rd number: ";
    cin >> num3;
    cout << " " << num3;
 
    // Calculate the sum using + operator
    // and store it in variable sum
    sum = num1 + num2 + num3;
 
    // Print the sum
    cout << "\\nSum of the 3 numbers is: " 
         << sum;
    return 0;
}
``` 
```C 


#include <stdio.h>

int main()
{
    // Variables to take the input of the 3 numbers
    int num1, num2, num3;

    // Variable to store the resultant sum
    int sum;

    // Take the 3 numbers as input
    printf("Enter the 1st number: ");
    scanf("%d", &num1);
    printf("%d\\n", num1);

    printf("Enter the 2nd number: ");
    scanf("%d", &num2);
    printf("%d\\n", num2);

    printf("Enter the 3rd number: ");
    scanf("%d", &num3);
    printf("%d\\n", num3);

    // Calculate the sum using + operator
    // and store it in variable sum
    sum = num1 + num2 + num3;

    // Print the sum
    printf("\\nSum of the 3 numbers is: %d", sum);

    return 0;
}
```
```Java 
import java.util.*;

class GFG {
    public static void main(String[] args)
    {
      
        // Variable to store the resultant sum
        int sum = 0;
      
        // Declare the object and initialize with
        // predefined standard input object
        Scanner sc
            = new Scanner(System.in); // Scanner definition
        
      // Variables to take the input of
        // the 3 numbers
        System.out.println("Enter the 1st number: ");
        int num1 = sc.nextInt(); 
      
      // input is an Integer
        // read by nextInt() function
        System.out.println(" " + num1);
        System.out.println("Enter the 2nd number: ");
        int num2 = sc.nextInt();
        System.out.println(" " + num2);
        System.out.println("Enter the 3rd number: ");
        int num3 = sc.nextInt();
        System.out.println(" " + num3);
      
        // Calculate the sum using + operator
        // and store it in variable sum
        sum = num1 + num2 + num3;
        System.out.println("Sum of the 3 numbers is = "
                           + sum);
    }
}

/*This code is contributed by Rishab Dugar*/
```
```Python 
if __name__ == "__main__":

    # Variables to take the input of
    # the 3 numbers
    num1 = num2 = num3 = 0

    # Variable to store the resultant sum
    sum = 0

    # Take the 3 numbers as input
    num1 = int(input("Enter the 1st number: "))

    num2 = int(input("Enter the 2nd number: "))

    num3 = int(input("Enter the 3rd number: "))

    # Calculate the sum using + operator
    # and store it in variable sum
    sum = num1 + num2 + num3

    # Print the sum
    print("\\nSum of the 3 numbers is:", sum)
```

```JavaScript
        // Variables to take the input of
        // the 3 numbers
        let num1 = 0, num2 = 0, num3 = 0;
    
        // Variable to store the resultant sum
        let sum = 0;
    
        // Take the 3 numbers as input
        console.log("Enter the 1st number: ");
        num1 = parseInt(prompt());
        console.log(" " + num1 + "<br>");
    
        console.log("Enter the 2nd number: ");
        num2=parseInt(prompt());
        console.log(" " + num2 + "<br>");
    
        console.log("Enter the 3rd number: ");
        num3=parseInt(prompt());
        console.log(" " + num3);
    
        // Calculate the sum using + operator
        // and store it in variable sum
        sum = num1 + num2 + num3;
    
        // Print the sum
        console.log("<br>Sum of the 3 numbers is: " + sum);
```

```output
Enter the 1st number: 0
Enter the 2nd number: 0
Enter the 3rd number: -1577141152

Sum of the 3 numbers is: -1577141152
```

**Here is the step-by-step algorithm of the code:**

1.  Declare three variables num1, num2, and num3 to store the three numbers to be added.
2.  Declare a variable sum to store the sum of the three numbers.
3.  Use the cout statement to prompt the user to enter the first number.
4.  Use the cin statement to read the first number and store it in num1.
5.  Use the cout statement to prompt the user to enter the second number.
6.  Use the cin statement to read the second number and store it in num2.
7.  Use the cout statement to prompt the user to enter the third number.
8.  Use the cin statement to read and store the third number in num3.
9.  Calculate the sum of the three numbers using the + operator and store it in the sum variable.
10.  Use the cout statement to print the sum of the three numbers.
11.  The main function returns 0, which indicates the successful execution of the program.

**Time complexity:** O(1)  
**Auxiliary Space:** O(1) 

**One problem, many solutions:** The solution to an algorithm can be or cannot be more than one. It means that while implementing the algorithm, there can be more than one method to implement it. For example, in the above problem of adding 3 numbers, the sum can be calculated in many ways:

-   [\\+] operator
-   Bit-wise operators
-   . . etc

# How to analyze an Algorithm?

For a standard algorithm to be good, it must be efficient. Hence the efficiency of an algorithm must be checked and maintained. It can be in two stages:

### 1. Priori Analysis:

"Priori" means "before". Hence Priori analysis means checking the algorithm before its implementation. In this, the algorithm is checked when it is written in the form of theoretical steps. This Efficiency of an algorithm is measured by assuming that all other factors, for example, processor speed, are constant and have no effect on the implementation. This is done usually by the algorithm designer. This analysis is independent of the type of hardware and language of the compiler. It gives the approximate answers for the complexity of the program.

### 2. Posterior Analysis:

"Posterior" means "after". Hence Posterior analysis means checking the algorithm after its implementation. In this, the algorithm is checked by implementing it in any programming language and executing it. This analysis helps to get the actual and real analysis report about correctness(for every possible input/s if it shows/returns correct output or not), space required, time consumed, etc. That is, it is dependent on the language of the compiler and the type of hardware used.

## What is Algorithm complexity and how to find it?

An algorithm is defined as complex based on the amount of Space and Time it consumes. Hence the Complexity of an algorithm refers to the measure of the time that it will need to execute and get the expected output, and the Space it will need to store all the data (input, temporary data, and output). Hence these two factors define the efficiency of an algorithm.   
**The two factors of Algorithm Complexity are:**

-   **Time Factor**: Time is measured by counting the number of key operations such as comparisons in the sorting algorithm.
-   **Space Factor**: Space is measured by counting the maximum memory space required by the algorithm to run/execute.

Therefore the complexity of an algorithm can be divided into two types:

**1. Space Complexity:** The space complexity of an algorithm refers to the amount of memory required by the algorithm to store the variables and get the result. This can be for inputs, temporary operations, or outputs. 

**How to calculate Space Complexity?**  
The space complexity of an algorithm is calculated by determining the following 2 components:   
 

-   **Fixed Part:** This refers to the space that is required by the algorithm. For example, input variables, output variables, program size, etc.
-   **Variable Part:** This refers to the space that can be different based on the implementation of the algorithm. For example, temporary variables, dynamic memory allocation, recursion stack space, etc.  
    Therefore Space complexity **S(P)** of any algorithm P is **S(P) = C + SP(I)**, where C is the fixed part and S(I) is the variable part of the algorithm, which depends on instance characteristic I.

**Example:** Consider the below algorithm for Linear Search

- Step 1: START
- Step 2: Get n elements of the array in arr and the number to be searched in x
- Step 3: Start from the leftmost element of arr[] and one by one compare x with each element of arr[]
- Step 4: If x matches with an element, Print True.
- Step 5: If x doesn’t match with any of the elements, Print False.
- Step 6: END  


**2. Time Complexity:** The time complexity of an algorithm refers to the amount of time required by the algorithm to execute and get the result. This can be for normal operations, conditional if-else statements, loop statements, etc.

**How to Calculate**, **Time Complexity?**  
The time complexity of an algorithm is also calculated by determining the following 2 components: 

-   **Constant time part:** Any instruction that is executed just once comes in this part. For example, input, output, if-else, switch, arithmetic operations, etc.
-   **Variable Time Part:** Any instruction that is executed more than once, say n times, comes in this part. For example, loops, recursion, etc.  
    Therefore Time complexity $T(P)$                        of any algorithm P is **T(P) = C + TP(I)**, where C is the constant time part and TP(I) is the variable part of the algorithm, which depends on the instance characteristic I.

**Example:** In the algorithm of Linear Search above, the time complexity is calculated as follows:

- Step 1: Constant Time   
- Step 2: Variable Time (Taking n inputs)   
- Step 3: Variable Time (Till the length of the Array (n) or the index of the found element)   
- Step 4: Constant Time 
- Step 5: Constant Time
- Step 6: Constant Time   Hence, T(P) = 1 + n + n(1 + 1) + 1 = 2 + 3n, which can be said as T(n).

## How to express an Algorithm?

1.  **Natural Language:** Here we express the Algorithm in the natural English language. It is too hard to understand the algorithm from it.
2.  **Flowchart:-** Here we express the Algorithm by making agraphical/pictorial representation of it. It is easier to understand than Natural Language.
3.  **Pseudo Code:-** Here we express the Algorithm in the form of annotations and informative text written in plain English which is very much similar to the real code but as it has no syntax like any of the programming languages, it can’t be compiled or interpreted by the computer. It is the best way to express an algorithm because it can be understood by even a layman with some school-level knowledge.', 'The word Algorithm means "A set of finite rules or instructions to be followed in calculations or other problem-solving operations" Or "A procedure for solving a mathematical problem in a finite number of steps that frequently involves recursive operations".', 'What is an Algorithm | Introduction to Algorithms', 1, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('1c6f4928-3c61-463e-8c84-f82e57915477', e'# Insertion Sort Introduction
****Insertion sort**** is a simple sorting algorithm that works by iteratively inserting each element of an unsorted list into its correct position in a sorted portion of the list. It is like sorting playing cards in your hands. You split the cards into two groups: the sorted cards and the unsorted cards. Then, you pick a card from the unsorted group and put it in the right place in the sorted group.

-   We start with the second element of the array as the first element is assumed to be sorted.
-   Compare the second element with the first element if the second element is smaller then swap them.
-   Move to the third element, compare it with the first two elements, and put it in its correct position
-   Repeat until the entire array is sorted.

![Insertion-Sort--2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250322120814021166/Insertion-Sort--1.webp)![Insertion-Sort--2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250322120813676040/Insertion-Sort--2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250322120813423266/Insertion-Sort--3.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250322120812765435/Insertion-Sort--4.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250322120812115216/Insertion-Sort--5.webp)

```cpp
// C++ program for implementation of Insertion Sort
#include <iostream>
using namespace std;

/* Function to sort array using insertion sort */
void insertionSort(int arr[], int n)
{
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;

        /* Move elements of arr[0..i-1], that are
           greater than key, to one position ahead
           of their current position */
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

/* A utility function to print array of size n */
void printArray(int arr[], int n)
{
    for (int i = 0; i < n; ++i)
        cout << arr[i] << " ";
    cout << endl;
}

// Driver method
int main()
{
    int arr[] = { 12, 11, 13, 5, 6 };
    int n = sizeof(arr) / sizeof(arr[0]);

    insertionSort(arr, n);
    printArray(arr, n);

    return 0;
}

/* This code is contributed by Hritik Shah. */
```
```c
// C program for implementation of Insertion Sort
#include <stdio.h>

/* Function to sort array using insertion sort */
void insertionSort(int arr[], int n)
{
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;

        /* Move elements of arr[0..i-1], that are
           greater than key, to one position ahead
           of their current position */
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

/* A utility function to print array of size n */
void printArray(int arr[], int n)
{
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);
    printf("\\n");
}

// Driver method
int main()
{
    int arr[] = { 12, 11, 13, 5, 6 };
    int n = sizeof(arr) / sizeof(arr[0]);

    insertionSort(arr, n);
    printArray(arr, n);

    return 0;
}

/* This code is contributed by Hritik Shah. */
```
```java
// Java program for implementation of Insertion Sort
public class InsertionSort {
    /* Function to sort array using insertion sort */
    void sort(int arr[])
    {
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;

            /* Move elements of arr[0..i-1], that are
               greater than key, to one position ahead
               of their current position */
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }

    /* A utility function to print array of size n */
    static void printArray(int arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n; ++i)
            System.out.print(arr[i] + " ");

        System.out.println();
    }

    // Driver method
    public static void main(String args[])
    {
        int arr[] = { 12, 11, 13, 5, 6 };

        InsertionSort ob = new InsertionSort();
        ob.sort(arr);

        printArray(arr);
    }
}

/* This code is contributed by Hritik Shah. */
```
```python
# Python program for implementation of Insertion Sort

# Function to sort array using insertion sort
def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1

        # Move elements of arr[0..i-1], that are
        # greater than key, to one position ahead
        # of their current position
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# A utility function to print array of size n
def printArray(arr):
    for i in range(len(arr)):
        print(arr[i], end=" ")
    print()

# Driver method
if __name__ == "__main__":
    arr = [12, 11, 13, 5, 6]
    insertionSort(arr)
    printArray(arr)

    # This code is contributed by Hritik Shah.
```
```csharp
// C# program for implementation of Insertion Sort
using System;

class InsertionSort {
    /* Function to sort array using insertion sort */
    void sort(int[] arr) {
        int n = arr.Length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;

            /* Move elements of arr[0..i-1], that are
               greater than key, to one position ahead
               of their current position */
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }

    /* A utility function to print array of size n */
    static void printArray(int[] arr) {
        int n = arr.Length;
        for (int i = 0; i < n; ++i)
            Console.Write(arr[i] + " ");

        Console.WriteLine();
    }

    // Driver method
    public static void Main() {
        int[] arr = { 12, 11, 13, 5, 6 };

        InsertionSort ob = new InsertionSort();
        ob.sort(arr);

        printArray(arr);
    }
}

/* This code is contributed by Hritik Shah. */
```
```javascript
// Javascript program for insertion sort 

// Function to sort array using insertion sort
function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        let key = arr[i];
        let j = i - 1;

        /* Move elements of arr[0..i-1], that are
           greater than key, to one position ahead
           of their current position */
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

// A utility function to print array of size n
function printArray(arr) {
    console.log(arr.join(" "));
}

// Driver method
let arr = [12, 11, 13, 5, 6];

insertionSort(arr);
printArray(arr);

// This code is contributed by Hritik Shah.
```

```output
5 6 11 12 13
```

# Illustration

![Insertion-sorting](https://media.geeksforgeeks.org/wp-content/uploads/20240802210251/Insertion-sorting.png)

> ****arr = {23, 1, 10, 5, 2}****
> 
> ****Initial:****
> 
> -   Current element is ****23****
> -   The first element in the array is assumed to be sorted.
> -   The sorted part until ****0th**** index is : ****[23]****
> 
> ****First Pass:****
> 
> -   Compare ****1**** with ****23**** (current element with the sorted part).
> -   Since ****1**** is smaller, insert ****1**** before ****23**** .
> -   The sorted part until ****1st**** index is: ****[1, 23]****
> 
> ****Second Pass:****
> 
> -   Compare ****10**** with ****1**** and ****23**** (current element with the sorted part).
> -   Since ****10**** is greater than ****1**** and smaller than ****23**** , insert ****10**** between ****1**** and ****23**** .
> -   The sorted part until ****2nd**** index is: ****[1, 10, 23]****
> 
> ****Third Pass:****
> 
> -   Compare ****5**** with ****1**** , ****10**** , and ****23**** (current element with the sorted part).
> -   Since ****5**** is greater than ****1**** and smaller than ****10**** , insert ****5**** between ****1**** and ****10****
> -   The sorted part until ****3rd**** index is ****: [1, 5, 10, 23]****
> 
> ****Fourth Pass:****
> 
> -   Compare ****2**** with ****1, 5, 10**** , and ****23**** (current element with the sorted part).
> -   Since ****2**** is greater than ****1**** and smaller than ****5**** insert ****2**** between ****1**** and ****5**** .
> -   The sorted part until ****4th**** index is: ****[1, 2, 5, 10, 23]****
> 
> ****Final Array:****
> 
> -   The sorted array is: ****[1, 2, 5, 10, 23]****

# Complexity Analysis of Insertion Sort

****Time Complexity****

-   ****Best case: O(n)****, If the list is already sorted, where n is the number of elements in the list.
-   ****Average case: O(n******<sup><strong>2</strong></sup>******)****, If the list is randomly ordered
-   ****Worst case: O(n******<sup><strong>2</strong></sup>******)****, If the list is in reverse order

****Space Complexity****

-   ****Auxiliary Space:**** O(1), Insertion sort requires ****O(1)**** additional space, making it a space-efficient sorting algorithm.

Please refer [Complexity Analysis of Insertion Sort](https://www.geeksforgeeks.org/time-and-space-complexity-of-insertion-sort-algorithm/) for details.

# Advantages and Disadvantages of Insertion Sort

****Advantages****

-   Simple and easy to implement.
-   ****Stable**** sorting algorithm.
-   Efficient for small lists and nearly sorted lists.
-   Space-efficient as it is an in-place algorithm.
-   Adoptive. the [number of inversions](https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/) is directly proportional to number of swaps. For example, no swapping happens for a sorted array and it takes O(n) time only.

****Disadvantages****

-   Inefficient for large lists.
-   Not as efficient as other sorting algorithms (e.g., merge sort, quick sort) for most cases.

### Applications ****of Insertion Sort****

Insertion sort is commonly used in situations where:

-   The list is small or nearly sorted.
-   Simplicity and stability are important.
-   Used as a subroutine in [Bucket Sort](https://www.geeksforgeeks.org/bucket-sort-2/)
-   Can be useful when array is already almost sorted (very few [inversions](https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/))
-   Since Insertion sort is suitable for small sized arrays, it is used in [Hybrid Sorting algorithms](https://www.geeksforgeeks.org/advanced-quick-sort-hybrid-algorithm/) along with other efficient algorithms like Quick Sort and Merge Sort. When the subarray size becomes small, we switch to insertion sort in these recursive algorithms. For example [IntroSort](https://www.geeksforgeeks.org/introsort-or-introspective-sort/) and [TimSort](https://www.geeksforgeeks.org/timsort/) use insertions sort.

****What are the Boundary Cases of the Insertion Sort algorithm?****

> Insertion sort takes the maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted.

****What is the Algorithmic Paradigm of the Insertion Sort algorithm?****

> The Insertion Sort algorithm follows an incremental approach.

****Is Insertion Sort an in-place sorting algorithm?****

> Yes, insertion sort is an in-place sorting algorithm.

****Is Insertion Sort a stable algorithm?****

> Yes, insertion sort is a stable sorting algorithm.

****When is the Insertion Sort algorithm used?****

> Insertion sort is used when number of elements is small. It can also be useful when the input array is almost sorted, and only a few elements are misplaced in a complete big array.', 'Insertion sort is a simple sorting algorithm that works by iteratively inserting each element of an unsorted list into its correct position in a sorted portion of the list', 'Insertion Sort', 13, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('0436340a-ef23-4fd2-9d0b-e233b60563e6', e'# Merge Sort Introduction
****Merge sort**** is a popular sorting algorithm known for its efficiency and stability. It follows the [****divide-and-conquer****](https://www.geeksforgeeks.org/introduction-to-divide-and-conquer-algorithm-data-structure-and-algorithm-tutorials/) approach. It works by recursively dividing the input array into two halves, recursively sorting the two halves and finally merging them back together to obtain the sorted array.

![Merge-Sort-Algorithm-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20230706153706/Merge-Sort-Algorithm-(1).png)


# How does Merge Sort work?

Here\'s a step-by-step explanation of how merge sort works:

> 1.  ****Divide:**** Divide the list or array recursively into two halves until it can no more be divided.
> 2.  ****Conquer:**** Each subarray is sorted individually using the merge sort algorithm.
> 3.  ****Merge:**** The sorted subarrays are merged back together in sorted order. The process continues until all elements from both subarrays have been merged.

# Illustration of Merge Sort:

Let\'s sort the array or list ****[38, 27, 43, 10]**** using Merge Sort

![Merge-Sort-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240627163910/Merge-Sort-1.webp)![Merge-Sort-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240627163910/Merge-Sort-2.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20240627163911/Merge-Sort-3.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240627163912/Merge-Sort-4.webp)

> Let\'s look at the working of above example:
> 
> ****Divide:****
> 
> -   ****[38, 27, 43, 10]**** is divided into ****[38, 27**** ] and ****[43, 10]**** .
> -   ****[38, 27]**** is divided into ****[38]**** and ****[27]**** .
> -   ****[43, 10]**** is divided into ****[43]**** and ****[10]**** .
> 
> ****Conquer:****
> 
> -   ****[38]**** is already sorted.
> -   ****[27]**** is already sorted.
> -   ****[43]**** is already sorted.
> -   ****[10]**** is already sorted.
> 
> ****Merge:****
> 
> -   Merge ****[38]**** and ****[27]**** to get ****[27, 38]**** .
> -   Merge ****[43]**** and ****[10]**** to get ****[10,43]**** .
> -   Merge ****[27, 38]**** and ****[10,43]**** to get the final sorted list ****[10, 27, 38, 43]****
> 
> Therefore, the sorted list is ****[10, 27, 38, 43]**** .

# Implementation of Merge Sort

```cpp
#include <bits/stdc++.h>
using namespace std;

// Merges two subarrays of arr[].
// First subarray is arr[left..mid]
// Second subarray is arr[mid+1..right]
void merge(vector<int>& arr, int left, 
                     int mid, int right)
{
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Create temp vectors
    vector<int> L(n1), R(n2);

    // Copy data to temp vectors L[] and R[]
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    int i = 0, j = 0;
    int k = left;

    // Merge the temp vectors back 
    // into arr[left..right]
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], 
    // if there are any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], 
    // if there are any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// begin is for left index and end is right index
// of the sub-array of arr to be sorted
void mergeSort(vector<int>& arr, int left, int right)
{
    if (left >= right)
        return;

    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

// Function to print a vector
void printVector(vector<int>& arr)
{
    for (int i = 0; i < arr.size(); i++)
        cout << arr[i] << " ";
    cout << endl;
}

// Driver code
int main()
{
    vector<int> arr = { 12, 11, 13, 5, 6, 7 };
    int n = arr.size();

    cout << "Given vector is \\n";
    printVector(arr);

    mergeSort(arr, 0, n - 1);

    cout << "\\nSorted vector is \\n";
    printVector(arr);
    return 0;
}
```
```c
// C program for Merge Sort
#include <stdio.h>
#include <stdlib.h>

// Merges two subarrays of arr[].
// First subarray is arr[l..m]
// Second subarray is arr[m+1..r]
void merge(int arr[], int l, int m, int r)
{
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    // Create temp arrays
    int L[n1], R[n2];

    // Copy data to temp arrays L[] and R[]
    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    // Merge the temp arrays back into arr[l..r
    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[],
    // if there are any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[],
    // if there are any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// l is for left index and r is right index of the
// sub-array of arr to be sorted
void mergeSort(int arr[], int l, int r)
{
    if (l < r) {
        int m = l + (r - l) / 2;

        // Sort first and second halves
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);

        merge(arr, l, m, r);
    }
}

// Function to print an array
void printArray(int A[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", A[i]);
    printf("\\n");
}

// Driver code
int main()
{
    int arr[] = { 12, 11, 13, 5, 6, 7 };
    int arr_size = sizeof(arr) / sizeof(arr[0]);

    printf("Given array is \\n");
    printArray(arr, arr_size);

    mergeSort(arr, 0, arr_size - 1);

    printf("\\nSorted array is \\n");
    printArray(arr, arr_size);
    return 0;
}
```
```java
// Java program for Merge Sort
import java.io.*;

class GfG {

    // Merges two subarrays of arr[].
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    static void merge(int arr[], int l, int m, int r)
    {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        // Create temp arrays
        int L[] = new int[n1];
        int R[] = new int[n2];

        // Copy data to temp arrays
        for (int i = 0; i < n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];

        // Merge the temp arrays

        // Initial indices of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarray array
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            }
            else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        // Copy remaining elements of L[] if any
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        // Copy remaining elements of R[] if any
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that sorts arr[l..r] using
    // merge()
    static void sort(int arr[], int l, int r)
    {
        if (l < r) {

            // Find the middle point
            int m = l + (r - l) / 2;

            // Sort first and second halves
            sort(arr, l, m);
            sort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

    // A utility function to print array of size n
    static void printArray(int arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n; ++i)
            System.out.print(arr[i] + " ");
        System.out.println();
    }

    // Driver code
    public static void main(String args[])
    {
        int arr[] = { 12, 11, 13, 5, 6, 7 };

        System.out.println("Given array is");
        printArray(arr);

        sort(arr, 0, arr.length - 1);

        System.out.println("\\nSorted array is");
        printArray(arr);
    }
}
```
```python
def merge(arr, left, mid, right):
    n1 = mid - left + 1
    n2 = right - mid

    # Create temp arrays
    L = [0] * n1
    R = [0] * n2

    # Copy data to temp arrays L[] and R[]
    for i in range(n1):
        L[i] = arr[left + i]
    for j in range(n2):
        R[j] = arr[mid + 1 + j]

    i = 0  # Initial index of first subarray
    j = 0  # Initial index of second subarray
    k = left  # Initial index of merged subarray

    # Merge the temp arrays back
    # into arr[left..right]
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    # Copy the remaining elements of L[],
    # if there are any
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1

    # Copy the remaining elements of R[], 
    # if there are any
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1

def merge_sort(arr, left, right):
    if left < right:
        mid = (left + right) // 2

        merge_sort(arr, left, mid)
        merge_sort(arr, mid + 1, right)
        merge(arr, left, mid, right)

def print_list(arr):
    for i in arr:
        print(i, end=" ")
    print()

# Driver code
if __name__ == "__main__":
    arr = [12, 11, 13, 5, 6, 7]
    print("Given array is")
    print_list(arr)

    merge_sort(arr, 0, len(arr) - 1)

    print("\\nSorted array is")
    print_list(arr)
```
```csharp
// C# program for Merge Sort
using System;

class GfG {

    // Merges two subarrays of []arr.
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    static void merge(int[] arr, int l, int m, int r)
    {
        // Find sizes of two
        // subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        // Create temp arrays
        int[] L = new int[n1];
        int[] R = new int[n2];
        int i, j;

        // Copy data to temp arrays
        for (i = 0; i < n1; ++i)
            L[i] = arr[l + i];
        for (j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];

        // Merge the temp arrays

        // Initial indexes of first
        // and second subarrays
        i = 0;
        j = 0;

        // Initial index of merged
        // subarray array
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            }
            else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        // Copy remaining elements
        // of L[] if any
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        // Copy remaining elements
        // of R[] if any
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that
    // sorts arr[l..r] using
    // merge()
    static void mergeSort(int[] arr, int l, int r)
    {
        if (l < r) {

            // Find the middle point
            int m = l + (r - l) / 2;

            // Sort first and second halves
            mergeSort(arr, l, m);
            mergeSort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

    // A utility function to
    // print array of size n
    static void printArray(int[] arr)
    {
        int n = arr.Length;
        for (int i = 0; i < n; ++i)
            Console.Write(arr[i] + " ");
        Console.WriteLine();
    }

    // Driver code
    public static void Main(String[] args)
    {
        int[] arr = { 12, 11, 13, 5, 6, 7 };
        Console.WriteLine("Given array is");
        printArray(arr);
        mergeSort(arr, 0, arr.Length - 1);
        Console.WriteLine("\\nSorted array is");
        printArray(arr);
    }
}
```
```javascript
function merge(arr, left, mid, right) {
    const n1 = mid - left + 1;
    const n2 = right - mid;

    // Create temp arrays
    const L = new Array(n1);
    const R = new Array(n2);

    // Copy data to temp arrays L[] and R[]
    for (let i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (let j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    let i = 0, j = 0;
    let k = left;

    // Merge the temp arrays back into arr[left..right]
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], if there are any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], if there are any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

function mergeSort(arr, left, right) {
    if (left >= right)
        return;

    const mid = Math.floor(left + (right - left) / 2);
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

function printArray(arr) {
    console.log(arr.join(" "));
}

// Driver code
const arr = [12, 11, 13, 5, 6, 7];
console.log("Given array is");
printArray(arr);

mergeSort(arr, 0, arr.length - 1);

console.log("\\nSorted array is");
printArray(arr);
```


```output
Given array is 
12 11 13 5 6 7 

Sorted array is 
5 6 7 11 12 13 
```

# Recurrence Relation of Merge Sort

The recurrence relation of merge sort is:  
$T(n) = \\begin{cases} \\theta(1) & \\text{if } n = 1 \\\\ 2T\\left(\\frac{n}{2}\\right) + \\theta(n) & \\text{if } n > 1 \\end{cases}$

-   T(n) Represents the total time time taken by the algorithm to sort an array of size n.
-   2T(n/2) represents time taken by the algorithm to recursively sort the two halves of the array. Since each half has n/2 elements, we have two recursive calls with input size as (n/2).
-   O(n) represents the time taken to merge the two sorted halves

# Complexity Analysis of Merge Sort

-   ****Time Complexity:****
    -   ****Best Case:**** O(n log n), When the array is already sorted or nearly sorted.
    -   ****Average Case:**** O(n log n), When the array is randomly ordered.
    -   ****Worst Case:**** O(n log n), When the array is sorted in reverse order.
-   ****Auxiliary Space:**** O(n), Additional space is required for the temporary array used during merging.

# Applications of Merge Sort:

-   Sorting large datasets
-   [External sorting](https://www.geeksforgeeks.org/external-sorting/) (when the dataset is too large to fit in memory)
-   [Inversion counting](https://www.geeksforgeeks.org/inversion-count-in-array-using-merge-sort/)
-   Merge Sort and its variations are used in library methods of programming languages.
    -   Its variation [TimSort](https://www.geeksforgeeks.org/timsort/) is used in Python, Java Android and Swift. The main reason why it is preferred to sort non-primitive types is stability which is not there in QuickSort.
    -   [Arrays.sort in Java](https://www.geeksforgeeks.org/arrays-sort-in-java-with-examples/) uses QuickSort while [Collections.sort](https://www.geeksforgeeks.org/collections-sort-java-examples/) uses MergeSort.
-   It is a preferred algorithm for sorting Linked lists.
-   It can be easily parallelized as we can independently sort subarrays and then merge.
-   The merge function of merge sort to efficiently solve the problems like [union and intersection of two sorted arrays](https://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/).

# Advantages and Disadvantages of Merge Sort

## Advantages

-   ****Stability**** : Merge sort is a stable sorting algorithm, which means it maintains the relative order of equal elements in the input array.
-   ****Guaranteed worst-case performance:**** Merge sort has a worst-case time complexity of ****O(N logN)**** , which means it performs well even on large datasets.
-   ****Simple to implement:**** The divide-and-conquer approach is straightforward.
-   ****Naturally Parallel**** : We independently merge subarrays that makes it suitable for parallel processing.

## Disadvantages

-   ****Space complexity:**** Merge sort requires additional memory to store the merged sub-arrays during the sorting process.
-   ****Not in-place:**** Merge sort is not an in-place sorting algorithm, which means it requires additional memory to store the sorted data. This can be a disadvantage in applications where memory usage is a concern.
-   Merge Sort is ****Slower than QuickSort in general as**** QuickSort is more cache friendly because it works in-place.
', 'Merge sort is a popular sorting algorithm known for its efficiency and stability. ', 'Merge Sort', 14, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('d97a24b1-50c8-4526-abc6-95289be9e511', e'# Quick Sort Introduction

**QuickSort** is a sorting algorithm based on the Divide and Conquer that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.

It works on the principle of **divide and conquer**, breaking down the problem into smaller sub-problems.

There are mainly three steps in the algorithm:

1.  **Choose a Pivot:** Select an element from the array as the pivot. The choice of pivot can vary (e.g., first element, last element, random element, or median).
2.  **Partition the Array:** Rearrange the array around the pivot. After partitioning, all elements smaller than the pivot will be on its left, and all elements greater than the pivot will be on its right. The pivot is then in its correct position, and we obtain the index of the pivot.
3.  **Recursively Call:** Recursively apply the same process to the two partitioned sub-arrays (left and right of the pivot).
4.  **Base Case:** The recursion stops when there is only one element left in the sub-array, as a single element is already sorted.

Here’s a basic overview of how the QuickSort algorithm works.

![Heap-Sort-Recursive-Illustration](https://media.geeksforgeeks.org/wp-content/uploads/20240926172924/Heap-Sort-Recursive-Illustration.webp)

# Choice of Pivot

There are many different choices for picking pivots.

-   [Always pick the first (or last) element as a pivot](https://www.geeksforgeeks.org/implement-quicksort-with-first-element-as-pivot/). The below implementation picks the last element as pivot. The problem with this approach is it ends up in the worst case when array is already sorted.
-   [Pick a random element as a pivot](https://www.geeksforgeeks.org/quicksort-using-random-pivoting/). This is a preferred approach because it does not have a pattern for which the worst case happens.
-   Pick the median element is pivot. This is an ideal approach in terms of time complexity as [we can find median in linear time](https://www.geeksforgeeks.org/kth-smallest-largest-element-in-unsorted-array-worst-case-linear-time/) and the partition function will always divide the input array into two halves. But it takes more time on average as median finding has high constants.

# Partition Algorithm

The key process in **quickSort** is a **partition().** There are three common algorithms to partition. All these algorithms have O(n) time complexity.

1.  [**Naive Partition**](https://www.geeksforgeeks.org/naive-partition-algorithm/): Here we create copy of the array. First put all smaller elements and then all greater. Finally we copy the temporary array back to original array. This requires O(n) extra space.
2.  [**Lomuto Partition**](https://www.geeksforgeeks.org/lomuto-partition-algorithm/): We have used this partition in this article. This is a simple algorithm, we keep track of index of smaller elements and keep swapping. We have used it here in this article because of its simplicity.
3.  [**Hoare\'s Partition**](https://www.geeksforgeeks.org/hoare-s-partition-algorithm/): This is the fastest of all. Here we traverse array from both sides and keep swapping greater element on left with smaller on right while the array is not partitioned. Please refer [Hoare’s vs Lomuto](https://www.geeksforgeeks.org/hoares-vs-lomuto-partition-scheme-quicksort/) for details.

# Working of Lomuto Partition Algorithm with Illustration

> The logic is simple, we start from the leftmost element and keep track of the index of smaller (or equal) elements as **i** . While traversing, if we find a smaller element, we swap the current element with **arr[i]**. Otherwise, we ignore the current element.

Let us understand the working of partition algorithm with the help of the following example:

![quick-sort-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241111171208918304/quick-sort-1.webp)![quick-sort-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241111171209045220/quick-sort-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20241220154252629076/quick-sort-3-1.png)![](https://media.geeksforgeeks.org/wp-content/uploads/20241111171209255614/quick-sort-4.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20241213175652062597/quick-sort.png)![](https://media.geeksforgeeks.org/wp-content/uploads/20241111171209465155/quick-sort-6.webp)


# Illustration of QuickSort Algorithm

In the previous step, we looked at how the **partitioning** process rearranges the array based on the chosen **pivot**. Next, we apply the same method recursively to the smaller sub-arrays on the **left** and **right** of the pivot. Each time, we select new pivots and partition the arrays again. This process continues until only one element is left, which is always sorted. Once every element is in its correct position, the entire array is sorted.

Below image illustrates, how the recursive method calls for the smaller sub-arrays on the **left** and **right** of the **pivot**:

![quick-sort--images](https://media.geeksforgeeks.org/wp-content/uploads/20240925173636/quick-sort--images.webp)

**Quick Sort** is a crucial algorithm in the industry, but there are other sorting algorithms that may be more optimal in different cases.

```cpp
#include <bits/stdc++.h>
using namespace std;

int partition(vector<int>& arr, int low, int high) {
  
    // Choose the pivot
    int pivot = arr[high];
  
    // Index of smaller element and indicates 
    // the right position of pivot found so far
    int i = low - 1;

    // Traverse arr[low..high] and move all smaller
    // elements on left side. Elements from low to 
    // i are smaller after every iteration
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    
    // Move pivot after smaller elements and
    // return its position
    swap(arr[i + 1], arr[high]);  
    return i + 1;
}

// The QuickSort function implementation
void quickSort(vector<int>& arr, int low, int high) {
  
    if (low < high) {
      
        // pi is the partition return index of pivot
        int pi = partition(arr, low, high);

        // Recursion calls for smaller elements
        // and greater or equals elements
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    vector<int> arr = {10, 7, 8, 9, 1, 5};
    int n = arr.size();
    quickSort(arr, 0, n - 1);
  
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    return 0;
}
```
```c
#include <stdio.h>

void swap(int* a, int* b);

// Partition function
int partition(int arr[], int low, int high) {
    
    // Choose the pivot
    int pivot = arr[high];
    
    // Index of smaller element and indicates 
    // the right position of pivot found so far
    int i = low - 1;

    // Traverse arr[low..high] and move all smaller
    // elements to the left side. Elements from low to 
    // i are smaller after every iteration
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    
    // Move pivot after smaller elements and
    // return its position
    swap(&arr[i + 1], &arr[high]);  
    return i + 1;
}

// The QuickSort function implementation
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        
        // pi is the partition return index of pivot
        int pi = partition(arr, low, high);

        // Recursion calls for smaller elements
        // and greater or equals elements
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

void swap(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);

    quickSort(arr, 0, n - 1);
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    
    return 0;
}
```
```java
import java.util.Arrays;

class GfG {

    // Partition function
    static int partition(int[] arr, int low, int high) {
        
        // Choose the pivot
        int pivot = arr[high];
        
        // Index of smaller element and indicates 
        // the right position of pivot found so far
        int i = low - 1;

        // Traverse arr[low..high] and move all smaller
        // elements to the left side. Elements from low to 
        // i are smaller after every iteration
        for (int j = low; j <= high - 1; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        // Move pivot after smaller elements and
        // return its position
        swap(arr, i + 1, high);  
        return i + 1;
    }

    // Swap function
    static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // The QuickSort function implementation
    static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            
            // pi is the partition return index of pivot
            int pi = partition(arr, low, high);

            // Recursion calls for smaller elements
            // and greater or equals elements
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    public static void main(String[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        int n = arr.length;
      
        quickSort(arr, 0, n - 1);
        
        for (int val : arr) {
            System.out.print(val + " ");  
        }
    }
}
```
```python
# Partition function
def partition(arr, low, high):
    
    # Choose the pivot
    pivot = arr[high]
    
    # Index of smaller element and indicates 
    # the right position of pivot found so far
    i = low - 1
    
    # Traverse arr[low..high] and move all smaller
    # elements to the left side. Elements from low to 
    # i are smaller after every iteration
    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            swap(arr, i, j)
    
    # Move pivot after smaller elements and
    # return its position
    swap(arr, i + 1, high)
    return i + 1

# Swap function
def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]

# The QuickSort function implementation
def quickSort(arr, low, high):
    if low < high:
        
        # pi is the partition return index of pivot
        pi = partition(arr, low, high)
        
        # Recursion calls for smaller elements
        # and greater or equals elements
        quickSort(arr, low, pi - 1)
        quickSort(arr, pi + 1, high)

# Main driver code
if __name__ == "__main__":
    arr = [10, 7, 8, 9, 1, 5]
    n = len(arr)

    quickSort(arr, 0, n - 1)
    
    for val in arr:
        print(val, end=" ")
```
```csharp
using System;

class GfG {

    // Partition function
    static int Partition(int[] arr, int low, int high) {
        
        // Choose the pivot
        int pivot = arr[high];
        
        // Index of smaller element and indicates 
        // the right position of pivot found so far
        int i = low - 1;

        // Traverse arr[low..high] and move all smaller
        // elements to the left side. Elements from low to 
        // i are smaller after every iteration
        for (int j = low; j <= high - 1; j++) {
            if (arr[j] < pivot) {
                i++;
                Swap(arr, i, j);
            }
        }
        
        // Move pivot after smaller elements and
        // return its position
        Swap(arr, i + 1, high);  
        return i + 1;
    }

    // Swap function
    static void Swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // The QuickSort function implementation
    static void QuickSort(int[] arr, int low, int high) {
        if (low < high) {
            
            // pi is the partition return index of pivot
            int pi = Partition(arr, low, high);

            // Recursion calls for smaller elements
            // and greater or equals elements
            QuickSort(arr, low, pi - 1);
            QuickSort(arr, pi + 1, high);
        }
    }

    static void Main(string[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        int n = arr.Length;

        QuickSort(arr, 0, n - 1);
        foreach (int val in arr) {
            Console.Write(val + " "); 
        }
    }
}
```
```javascript
// Partition function
function partition(arr, low, high)
{

    // Choose the pivot
    let pivot = arr[high];

    // Index of smaller element and indicates
    // the right position of pivot found so far
    let i = low - 1;

    // Traverse arr[low..high] and move all smaller
    // elements to the left side. Elements from low to
    // i are smaller after every iteration
    for (let j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr, i, j);
        }
    }

    // Move pivot after smaller elements and
    // return its position
    swap(arr, i + 1, high);
    return i + 1;
}

// Swap function
function swap(arr, i, j)
{
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

// The QuickSort function implementation
function quickSort(arr, low, high)
{
    if (low < high) {

        // pi is the partition return index of pivot
        let pi = partition(arr, low, high);

        // Recursion calls for smaller elements
        // and greater or equals elements
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Main driver code
let arr = [ 10, 7, 8, 9, 1, 5 ];
let n = arr.length;

// Call QuickSort on the entire array
quickSort(arr, 0, n - 1);
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i] + " ");
}
```


```output
Sorted Array
1 5 7 8 9 10 
```

# Complexity Analysis of Quick Sort

**Time Complexity:**

-   **Best Case:** (Ω(n log n)), Occurs when the pivot element divides the array into two equal halves.
-   **Average Case** (θ(n log n)), On average, the pivot divides the array into two parts, but not necessarily equal.
-   **Worst Case:** (O(n²)), Occurs when the smallest or largest element is always chosen as the pivot (e.g., sorted arrays).

**Auxiliary Space:** O(n), due to recursive call stack

Please refer [Time and Space Complexity Analysis of Quick Sort](https://www.geeksforgeeks.org/time-and-space-complexity-analysis-of-quick-sort/) for more details.

# Advantages of Quick Sort

-   It is a divide-and-conquer algorithm that makes it easier to solve problems.
-   It is efficient on large data sets.
-   It has a low overhead, as it only requires a small amount of memory to function.
-   It is Cache Friendly as we work on the same array to sort and do not copy data to any auxiliary array.
-   Fastest general purpose algorithm for large data when stability is not required.
-   It is [**tail recursive**](https://www.geeksforgeeks.org/tail-recursion/) and hence all the [tail call optimization](https://www.geeksforgeeks.org/quicksort-tail-call-optimization-reducing-worst-case-space-log-n/) can be done.

# Disadvantages of Quick Sort

-   It has a worst-case time complexity of O(n<sup><span>2</span></sup>), which occurs when the pivot is chosen poorly.
-   It is not a good choice for small data sets.
-   It is not a stable sort, meaning that if two elements have the same key, their relative order will not be preserved in the sorted output in case of quick sort, because here we are swapping elements according to the pivot\'s position (without considering their original positions).

', 'QuickSort is a sorting algorithm based on the Divide and Conquer that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.', 'Quick Sort', 15, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('b8b1a21f-9233-4784-8dc7-fe1a6ee5a9a7', e'# Heap Sort Introduction

****Heap sort**** is a comparison-based sorting technique based on [Binary Heap Data Structure](http://www.geeksforgeeks.org/binary-heap/). It can be seen as an optimization over [selection sort](http://www.geeksforgeeks.org/selection-sort/) where we first find the max (or min) element and swap it with the last (or first). We repeat the same process for the remaining elements. In Heap Sort, we use Binary Heap so that we can quickly find and move the max element in O(Log n) instead of O(n) and hence achieve the O(n Log n) time complexity.

# Heap Sort Algorithm

First convert the array into a [max heap](https://www.geeksforgeeks.org/introduction-to-max-heap-data-structure/) using ****heapify****, Please note that this happens in-place. The array elements are re-arranged to follow heap properties. Then one by one delete the root node of the Max-heap and replace it with the last node and ****heapify****. Repeat this process while size of heap is greater than 1.

-   Rearrange array elements so that they form a Max Heap.
-   Repeat the following steps until the heap contains only one element:
    -   Swap the root element of the heap (which is the largest element in current heap) with the last element of the heap.
    -   Remove the last element of the heap (which is now in the correct position). We mainly reduce heap size and do not remove element from the actual array.
    -   Heapify the remaining elements of the heap.
-   Finally we get sorted array.

# Detailed Working of Heap Sort

## Step 1: Treat the Array as a Complete Binary Tree

We first need to visualize the array as a ****complete binary tree****. For an array of size ****n****, the root is at index ****0****, the left child of an element at index ****i**** is at ****2i + 1****, and the right child is at ****2i + 2****.

![Visualize-the-array-as-a-complete-binary-tree](https://media.geeksforgeeks.org/wp-content/uploads/20240928160744/Visualize-the-array-as-a-complete-binary-tree.webp)

## Step 2: Build a Max Heap

![Heapify-Binary-Tree-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240927200909/Heapify-Binary-Tree-1.webp)![Heapify-Binary-Tree-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240927200909/Heapify-Binary-Tree-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240927200910/Heapify-Binary-Tree-3.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240927200911/Heapify-Binary-Tree-4.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240927200911/Heapify-Binary-Tree-5.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240927200912/Heapify-Binary-Tree-6.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240927200913/Heapify-Binary-Tree-8.webp)


## Step 3: Sort the array by placing largest element at end of unsorted array.

![Remove-from-Max-Heap-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240928160827/Remove-from-Max-Heap-1.webp)![Remove-from-Max-Heap-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240928160828/Remove-from-Max-Heap-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240928160828/Remove-from-Max-Heap-3.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240928160829/Remove-from-Max-Heap-4.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240928160830/Remove-from-Max-Heap-5.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240928160830/Remove-from-Max-Heap-6.webp)


In the illustration above, we have shown some steps to sort the array. We need to keep repeating these steps until there’s only one element left in the heap.

# Implementation of Heap Sort

```cpp
// C++ program for implementation of Heap Sort using vector

#include <bits/stdc++.h>
using namespace std;

// To heapify a subtree rooted with node i
// which is an index in arr[].
void heapify(vector<int>& arr, int n, int i){

    // Initialize largest as root
    int largest = i;

    // left index = 2*i + 1
    int l = 2 * i + 1;

    // right index = 2*i + 2
    int r = 2 * i + 2;

    // If left child is larger than root
    if (l < n && arr[l] > arr[largest])
        largest = l;

    // If right child is larger than largest so far
    if (r < n && arr[r] > arr[largest])
        largest = r;

    // If largest is not root
    if (largest != i) {
        swap(arr[i], arr[largest]);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Main function to do heap sort
void heapSort(vector<int>& arr){
    int n = arr.size();

    // Build heap (rearrange vector)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {

        // Move current root to end
        swap(arr[0], arr[i]);

        // Call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

// A utility function to print vector of size n
void printArray(vector<int>& arr){
    for (int i = 0; i < arr.size(); ++i)
        cout << arr[i] << " ";
    cout << "\\n";
}

// Driver\'s code
int main(){
    vector<int> arr = { 9, 4, 3, 8, 10, 2, 5 };

    // Function call
    heapSort(arr);

    cout << "Sorted array is \\n";
    printArray(arr);
}
```
```c
#include <stdio.h>

// To heapify a subtree rooted with node i
// which is an index in arr[].
void heapify(int arr[], int n, int i) {

    // Initialize largest as root
    int largest = i; 

    // left index = 2*i + 1
    int l = 2 * i + 1; 

    // right index = 2*i + 2
    int r = 2 * i + 2;

    // If left child is larger than root
    if (l < n && arr[l] > arr[largest]) {
        largest = l;
    }

    // If right child is larger than largest so far
    if (r < n && arr[r] > arr[largest]) {
        largest = r;
    }

    // If largest is not root
    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Main function to do heap sort
void heapSort(int arr[], int n) {

    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {

        // Move current root to end
        int temp = arr[0]; 
        arr[0] = arr[i];
        arr[i] = temp;

        // Call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

// A utility function to print array of size n
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\\n");
}

// Driver\'s code
int main() {
    int arr[] = {9, 4, 3, 8, 10, 2, 5}; 
    int n = sizeof(arr) / sizeof(arr[0]);

    heapSort(arr, n);

    printf("Sorted array is \\n");
    printArray(arr, n);
    return 0;
}
```
```java
import java.util.Arrays;

class GfG {
  
    // To heapify a subtree rooted with node i
    // which is an index in arr[].
    static void heapify(int arr[], int n, int i) {

        // Initialize largest as root
        int largest = i; 

        // left index = 2*i + 1
        int l = 2 * i + 1; 

        // right index = 2*i + 2
        int r = 2 * i + 2;

        // If left child is larger than root
        if (l < n && arr[l] > arr[largest]) {
            largest = l;
        }

        // If right child is larger than largest so far
        if (r < n && arr[r] > arr[largest]) {
            largest = r;
        }

        // If largest is not root
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;

            // Recursively heapify the affected sub-tree
            heapify(arr, n, largest);
        }
    }

    // Main function to do heap sort
    static void heapSort(int arr[]) {
        int n = arr.length;

        // Build heap (rearrange array)
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }

        // One by one extract an element from heap
        for (int i = n - 1; i > 0; i--) {

            // Move current root to end
            int temp = arr[0]; 
            arr[0] = arr[i];
            arr[i] = temp;

            // Call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }

    // A utility function to print array of size n
    static void printArray(int arr[]) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    // Driver\'s code
    public static void main(String args[]) {
        int arr[] = {9, 4, 3, 8, 10, 2, 5}; 
        heapSort(arr);
        System.out.println("Sorted array is ");
        printArray(arr);
    }
}
```
```python
# Python program for implementation of heap Sort

# To heapify a subtree rooted with node i
# which is an index in arr[].
def heapify(arr, n, i):
    
     # Initialize largest as root
    largest = i 
    
    #  left index = 2*i + 1
    l = 2 * i + 1 
    
    # right index = 2*i + 2
    r = 2 * i + 2  

    # If left child is larger than root
    if l < n and arr[l] > arr[largest]:
        largest = l

    # If right child is larger than largest so far
    if r < n and arr[r] > arr[largest]:
        largest = r

    # If largest is not root
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # Swap

        # Recursively heapify the affected sub-tree
        heapify(arr, n, largest)

# Main function to do heap sort
def heapSort(arr):
    
    n = len(arr) 

    # Build heap (rearrange array)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract an element from heap
    for i in range(n - 1, 0, -1):
      
        # Move root to end
        arr[0], arr[i] = arr[i], arr[0] 

        # Call max heapify on the reduced heap
        heapify(arr, i, 0)

def printArray(arr):
    for i in arr:
        print(i, end=" ")
    print()

# Driver\'s code
arr = [9, 4, 3, 8, 10, 2, 5] 
heapSort(arr)
print("Sorted array is ")
printArray(arr)
```
```csharp
using System;

class GfG {
    // To heapify a subtree rooted with node i
    // which is an index in arr[].
    static void Heapify(int[] arr, int n, int i) {
      
         // Initialize largest as root
        int largest = i;
      
        // left index = 2*i + 1
        int l = 2 * i + 1; 
      
        // right index = 2*i + 2
        int r = 2 * i + 2; 

        // If left child is larger than root
        if (l < n && arr[l] > arr[largest]) {
            largest = l;
        }

        // If right child is larger than largest so far
        if (r < n && arr[r] > arr[largest]) {
            largest = r;
        }

        // If largest is not root
        if (largest != i) {
            int temp = arr[i]; // Swap
            arr[i] = arr[largest];
            arr[largest] = temp;

            // Recursively heapify the affected sub-tree
            Heapify(arr, n, largest);
        }
    }

    // Main function to do heap sort
    static void HeapSortArray(int[] arr) {
        int n = arr.Length;

        // Build heap (rearrange array)
        for (int i = n / 2 - 1; i >= 0; i--) {
            Heapify(arr, n, i);
        }

        // One by one extract an element from heap
        for (int i = n - 1; i > 0; i--) {
          
            // Move current root to end
            int temp = arr[0]; 
            arr[0] = arr[i];
            arr[i] = temp;

            // Call max heapify on the reduced heap
            Heapify(arr, i, 0);
        }
    }

    // A utility function to print array of size n
    static void PrintArray(int[] arr) {
        foreach (int value in arr) {
            Console.Write(value + " ");
        }
        Console.WriteLine();
    }

    // Driver\'s code
    public static void Main(string[] args) {
        int[] arr = {9, 4, 3, 8, 10, 2, 5};
        HeapSortArray(arr);
        Console.WriteLine("Sorted array is ");
        PrintArray(arr);
    }
}
```
```javascript
// To heapify a subtree rooted with node i
// which is an index in arr[].
function heapify(arr, n, i) {

    // Initialize largest as root
    let largest = i;
    
    // left index = 2*i + 1
    let l = 2 * i + 1; 
    
    // right index = 2*i + 2
    let r = 2 * i + 2; 

    // If left child is larger than root
    if (l < n && arr[l] > arr[largest]) {
        largest = l;
    }

    // If right child is larger than largest so far
    if (r < n && arr[r] > arr[largest]) {
        largest = r;
    }

    // If largest is not root
    if (largest !== i) {
        let temp = arr[i]; // Swap
        arr[i] = arr[largest];
        arr[largest] = temp;

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Main function to do heap sort
function heapSort(arr) {
    let n = arr.length;

    // Build heap (rearrange array)
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // One by one extract an element from heap
    for (let i = n - 1; i > 0; i--) {
    
        // Move current root to end
        let temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // Call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

// A utility function to print array of size n
function printArray(arr) {
    for (let i = 0; i < arr.length; i++) {
        console.log(arr[i] + " ");
    }
    console.log();
}

// Driver\'s code
let arr = [9, 4, 3, 8, 10, 2, 5];
heapSort(arr);
console.log("Sorted array is ");
printArray(arr);
```


```Output
Sorted array is 
2 3 4 5 8 9 10 
```

# Complexity Analysis of ****Heap Sort****

****Time Complexity:**** O(n log n)  
****Auxiliary Space:**** O(log n), due to the recursive call stack. However, auxiliary space can be O(1) for iterative implementation.

# Important points about Heap Sort

-   Heap sort is an in-place algorithm.
-   Its typical implementation is not stable but can be made stable (See [this](https://www.geeksforgeeks.org/stability-in-sorting-algorithms/))
-   Typically 2-3 times slower than well-implemented [QuickSort](http://www.geeksforgeeks.org/quick-sort/). The reason for slowness is a lack of locality of reference.

# Advantages of Heap Sort

-   ****Efficient Time Complexity:**** Heap Sort has a time complexity of O(n log n) in all cases. This makes it efficient for sorting large datasets. The ****log n**** factor comes from the height of the binary heap, and it ensures that the algorithm maintains good performance even with a large number of elements.
-   ****Memory Usage:**** Memory usage can be minimal (by writing an iterative heapify() instead of a recursive one). So apart from what is necessary to hold the initial list of items to be sorted, it needs no additional memory space to work
-   ****Simplicity:**** It is simpler to understand than other equally efficient sorting algorithms because it does not use advanced computer science concepts such as recursion.

# Disadvantages of Heap Sort

-   ****Costly****: Heap sort is costly as the constants are higher compared to merge sort even if the time complexity is O(n Log n) for both.
-   ****Unstable****: Heap sort is unstable. It might rearrange the relative order.
-   ****Inefficient:**** Heap Sort is not very efficient because of the high constants in the time complexity.

  ', 'Heap sort is a comparison-based sorting technique based on Binary Heap Data Structure.', 'Heap Sort', 16, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('dbd09cb2-94d4-4454-ae0e-6dba45aa6160', e'# Counting Sort Introduction
**Counting Sort** is a **non-comparison-based** sorting algorithm. It is particularly efficient when the range of input values is small compared to the number of elements to be sorted. The basic idea behind **Counting Sort** is to count the **frequency** of each distinct element in the input array and use that information to place the elements in their correct sorted positions.

-   For example, for input [1, 4, 3, 2, 2, 1], the output should be [1, 1, 2, 2, 3, 4]. The important thing to notice is that the range of input elements is small and comparable to the size of the array.
-   If the max element is of order more than n Log n where n is size of the array, then we can better sort the array using a standard comparison based sorting algorithm.

# Working of Counting Sort

#### **Step1 :**

-   Find out the **maximum** element from the given array.

![Finding maximum element in inputArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230920182425/1.png)

#### **Step 2:**

-   Initialize a **countArray[]** of length **max+1** with all elements as **0**. This array will be used for storing the occurrences of the elements of the input array.

![Initialize countArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230920182436/2.png)

#### **Step 3:**

-   In the **countArray[]**, store the count of each unique element of the input array at their respective indices.
-   **For Example:** The count of element **2** in the input array is **2.** So, store **2** at index **2** in the **countArray[]**. Similarly, the count of element **5** in the input array is **1**, hence store **1** at index **5** in the **countArray[]**.

![Maintain count of each element in countArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230922132754/3.png)

#### **Step 4:**

-   Store the **cumulative sum** or **prefix sum** of the elements of the **countArray[]** by doing **countArray[i] = countArray[i - 1] + countArray[i].** This will help in placing the elements of the input array at the correct index in the output array.

![Store the cumulative sum in countArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230920182646/4.png)

#### **Step 5:**

-   Iterate from end of the input array and because traversing input array from end preserves the order of equal elements, which eventually makes this sorting algorithm **stable**.

> -   Update **outputArray[ countArray[ inputArray[i] ] - 1] = inputArray[i]**.
> -   Also, update **countArray[ inputArray[i] ]** **= countArray[ inputArray[i] ]**- -.

![5](https://media.geeksforgeeks.org/wp-content/uploads/20230920182656/5.png)

#### **Step 6: For i = 6,**

> Update **outputArray[ countArray[ inputArray[6] ] - 1] = inputArray[6]**  
> Also, update **countArray[ inputArray[6] ] = countArray[ inputArray[6] ]- -**

![Placing inputArray[6] at it correct position in outputArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230920182724/6.png)

#### **Step 7: For i = 5,**

> Update **outputArray[ countArray[ inputArray[5] ] - 1] = inputArray[5]**  
> Also, update **countArray[ inputArray[5] ] = countArray[ inputArray[5] ]- -**

![Placing inputArray[5] at it correct position in outputArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230920182741/7.png)

#### **Step 8: For i = 4,**

> Update **outputArray[ countArray[ inputArray[4] ] - 1] = inputArray[4]**  
> Also, update **countArray[ inputArray[4] ] = countArray[ inputArray[4] ]- -**

![Placing inputArray[4] at it correct position in outputArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230920182752/8.png)

#### **Step 9: For i = 3,**

> Update **outputArray[ countArray[ inputArray[3] ] - 1] = inputArray[3]**  
> Also, update **countArray[ inputArray[3] ] = countArray[ inputArray[3] ]- -**

![Placing inputArray[3] at it correct position in outputArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230920182807/9.png)

#### **Step 10: For i = 2,**

> Update **outputArray[ countArray[ inputArray[2] ] - 1] = inputArray[2]**  
> Also, update **countArray[ inputArray[2] ] = countArray[ inputArray[2] ]- -**

![Placing inputArray[2] at it correct position in outputArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230920182827/10.png)

#### **Step 11: For i = 1,**

> Update **outputArray[ countArray[ inputArray[1] ] - 1] = inputArray[1]**  
> Also, update **countArray[ inputArray[1] ] = countArray[ inputArray[1] ]- -**

![Placing inputArray[1] at it correct position in outputArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230920182855/11.png)

#### **Step 12: For i = 0,**

> Update **outputArray[ countArray[ inputArray[0] ] - 1] = inputArray[0]**  
> Also, update **countArray[ inputArray[0] ] = countArray[ inputArray[0] ]- -**

![Placing inputArray[0] at it correct position in outputArray[]](https://media.geeksforgeeks.org/wp-content/uploads/20230920182910/12.png)

# Counting Sort Algorithm 

-   Declare an auxiliary array **countArray[]** of size **max(inputArray[])+1** and initialize it with **0**.
-   Traverse array **inputArray[]** and map each element of **inputArray[]** as an index of **countArray[]** array, i.e., execute **countArray[inputArray[i]]++** for **0 <= i < N**.
-   Calculate the prefix sum at every index of array **inputArray**[].
-   Create an array **outputArray[]** of size **N**.
-   Traverse array **inputArray[]** from end and update **outputArray[ countArray[ inputArray[i] ] - 1] = inputArray[i]**. Also, update **countArray[ inputArray[i] ] = countArray[ inputArray[i] ]- -** .

Below is the implementation of the above algorithm:

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> countSort(vector<int>& inputArray)
{

    int N = inputArray.size();

    // Finding the maximum element of array inputArray[].
    int M = 0;

    for (int i = 0; i < N; i++)
        M = max(M, inputArray[i]);

    // Initializing countArray[] with 0
    vector<int> countArray(M + 1, 0);

    // Mapping each element of inputArray[] as an index
    // of countArray[] array

    for (int i = 0; i < N; i++)
        countArray[inputArray[i]]++;

    // Calculating prefix sum at every index
    // of array countArray[]
    for (int i = 1; i <= M; i++)
        countArray[i] += countArray[i - 1];

    // Creating outputArray[] from countArray[] array
    vector<int> outputArray(N);

    for (int i = N - 1; i >= 0; i--)

    {
        outputArray[countArray[inputArray[i]] - 1]
            = inputArray[i];

        countArray[inputArray[i]]--;
    }

    return outputArray;
}

// Driver code
int main()

{

    // Input array
    vector<int> inputArray = { 4, 3, 12, 1, 5, 5, 3, 9 };

    // Output array
    vector<int> outputArray = countSort(inputArray);

    for (int i = 0; i < inputArray.size(); i++)
        cout << outputArray[i] << " ";

    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

void countSort(int inputArray[], int N) {
  
    // Finding the maximum element of 
    // array inputArray[]
    int M = 0;
    for (int i = 0; i < N; i++)
        if (inputArray[i] > M)
            M = inputArray[i];
    
    // Initializing countArray[] with 0
    int* countArray = (int*)calloc(M + 1, sizeof(int));
    
    // Mapping each element of inputArray[] 
    // as an index of countArray[] array
    for (int i = 0; i < N; i++)
        countArray[inputArray[i]]++;
    
    // Calculating prefix sum at every index
    // of array countArray[]
    for (int i = 1; i <= M; i++)
        countArray[i] += countArray[i - 1];
    
    // Creating outputArray[] from countArray[] array
    int* outputArray = (int*)malloc(N * sizeof(int));
    for (int i = N - 1; i >= 0; i--) {
        outputArray[countArray[inputArray[i]] - 1] = inputArray[i];
        countArray[inputArray[i]]--;
    }
    
    // Copying sorted elements back to inputArray[]
    for (int i = 0; i < N; i++)
        inputArray[i] = outputArray[i];
    
    // Freeing dynamically allocated memory
    free(countArray);
    free(outputArray);
}

// Driver code
int main() {
  
    // Input array
    int inputArray[] = {4, 3, 12, 1, 5, 5, 3, 9};
    int N = sizeof(inputArray) / sizeof(inputArray[0]);
    
    // Sorting the array
    countSort(inputArray, N);
    
    // Printing the sorted array
    for (int i = 0; i < N; i++)
        printf("%d ", inputArray[i]);
    
    return 0;
}
```
```java
import java.util.Arrays;

public class CountSort {
    public static int[] countSort(int[] inputArray) {
        int N = inputArray.length;
        int M = 0;

        for (int i = 0; i < N; i++) {
            M = Math.max(M, inputArray[i]);
        }

        int[] countArray = new int[M + 1];

        for (int i = 0; i < N; i++) {
            countArray[inputArray[i]]++;
        }

        for (int i = 1; i <= M; i++) {
            countArray[i] += countArray[i - 1];
        }

        int[] outputArray = new int[N];

        for (int i = N - 1; i >= 0; i--) {
            outputArray[countArray[inputArray[i]] - 1] = inputArray[i];
            countArray[inputArray[i]]--;
        }

        return outputArray;
    }

    public static void main(String[] args) {
        int[] inputArray = {4, 3, 12, 1, 5, 5, 3, 9};
        int[] outputArray = countSort(inputArray);

        for (int i = 0; i < inputArray.length; i++) {
            System.out.print(outputArray[i] + " ");
        }
    }
}
```
```python
def count_sort(input_array):
    # Finding the maximum element of input_array.
    M = max(input_array)

    # Initializing count_array with 0
    count_array = [0] * (M + 1)

    # Mapping each element of input_array as an index of count_array
    for num in input_array:
        count_array[num] += 1

    # Calculating prefix sum at every index of count_array
    for i in range(1, M + 1):
        count_array[i] += count_array[i - 1]

    # Creating output_array from count_array
    output_array = [0] * len(input_array)

    for i in range(len(input_array) - 1, -1, -1):
        output_array[count_array[input_array[i]] - 1] = input_array[i]
        count_array[input_array[i]] -= 1

    return output_array

# Driver code
if __name__ == "__main__":
    # Input array
    input_array = [4, 3, 12, 1, 5, 5, 3, 9]

    # Output array
    output_array = count_sort(input_array)

    for num in output_array:
        print(num, end=" ")
```
```csharp
using System;
using System.Collections.Generic;

class GFG
{
    static List<int> CountSort(List<int> inputArray)
    {
        int N = inputArray.Count;
        // Finding the maximum element of the array inputArray[].
        int M = 0;
        for (int i = 0; i < N; i++)
            M = Math.Max(M, inputArray[i]);
        // Initializing countArray[] with 0
        List<int> countArray = new List<int>(new int[M + 1]);
        // Mapping each element of inputArray[] as an index
        // of countArray[] array
        for (int i = 0; i < N; i++)
            countArray[inputArray[i]]++;
        // Calculating prefix sum at every index
        // of array countArray[]
        for (int i = 1; i <= M; i++)
            countArray[i] += countArray[i - 1];
        // Creating outputArray[] from the countArray[] array
        List<int> outputArray = new List<int>(new int[N]);
        for (int i = N - 1; i >= 0; i--)
        {
            outputArray[countArray[inputArray[i]] - 1] = inputArray[i];
            countArray[inputArray[i]]--;
        }
        return outputArray;
    }
    // Driver code
    static void Main()
    {
        // Input array
        List<int> inputArray = new List<int> { 4, 3, 12, 1, 5, 5, 3, 9 };
        // Output array
        List<int> outputArray = CountSort(inputArray);
        for (int i = 0; i < inputArray.Count; i++)
            Console.Write(outputArray[i] + " ");
        Console.WriteLine();
    }
}
```
```javascript
function countSort(inputArray) {
    const N = inputArray.length;

    // Finding the maximum element of inputArray
    let M = 0;
    for (let i = 0; i < N; i++) {
        M = Math.max(M, inputArray[i]);
    }

    // Initializing countArray with 0
    const countArray = new Array(M + 1).fill(0);

    // Mapping each element of inputArray as an index of countArray
    for (let i = 0; i < N; i++) {
        countArray[inputArray[i]]++;
    }

    // Calculating prefix sum at every index of countArray
    for (let i = 1; i <= M; i++) {
        countArray[i] += countArray[i - 1];
    }

    // Creating outputArray from countArray
    const outputArray = new Array(N);
    for (let i = N - 1; i >= 0; i--) {
        outputArray[countArray[inputArray[i]] - 1] = inputArray[i];
        countArray[inputArray[i]]--;
    }

    return outputArray;
}

// Driver code
const inputArray = [4, 3, 12, 1, 5, 5, 3, 9];

// Sorting the input array
const outputArray = countSort(inputArray);

// Printing the sorted array
console.log(outputArray.join(\' \'));
//This code is contributed by Utkarsh
```


```output
1 3 3 4 5 5 9 12
```
# Complexity Analysis of Counting Sort:

-   **Time Complexity**: O(N+M), where **N** and **M** are the size of **inputArray[]** and **countArray[]** respectively.
    -   Worst-case: O(N+M).
    -   Average-case: O(N+M).
    -   Best-case: O(N+M).
-   **Auxiliary Space:** O(N+M), where **N** and **M** are the space taken by **outputArray[]** and **countArray[]** respectively.

# Advantage of Counting Sort:

-   Counting sort generally performs faster than all comparison-based sorting algorithms, such as merge sort and quicksort, if the range of input is of the order of the number of input.
-   Counting sort is easy to code
-   Counting sort is a **stable algorithm**.

# Disadvantage of Counting Sort:

-   Counting sort doesn’t work on decimal values.
-   Counting sort is inefficient if the range of values to be sorted is very large.
-   Counting sort is not an **In-place sorting** algorithm, It uses extra space for sorting the array elements.

# Applications of Counting Sort:

-   It is a commonly used algorithm for the cases where we have limited range items. For example, sort students by grades, sort a events by time, days, months, years, etc
-   It is used as a subroutine in [Radix Sort](https://www.geeksforgeeks.org/radix-sort/)
-   The idea of counting sort is used in [Bucket Sort](https://www.geeksforgeeks.org/bucket-sort-2/) to divide elements into different buckets.
', 'Counting Sort is a non-comparison-based sorting algorithm', 'Counting Sort', 17, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('4e10759d-86ea-4fa7-aff2-eaad28f14730', e'# Radix Sort Introduction
****Radix Sort**** is a linear sorting algorithm that sorts elements by processing them digit by digit. It is an efficient sorting algorithm for integers or strings with fixed-size keys. 

Rather than comparing elements directly, Radix Sort distributes the elements into buckets based on each digit\'s value. By repeatedly sorting the elements by their significant digits, from the least significant to the most significant, Radix Sort achieves the final sorted order.

# Radix Sort Algorithm

The key idea behind Radix Sort is to exploit the concept of place value. It assumes that sorting numbers digit by digit will eventually result in a fully sorted list. Radix Sort can be performed using different variations, such as Least Significant Digit (LSD) Radix Sort or Most Significant Digit (MSD) Radix Sort.

# How does Radix Sort Algorithm work?

To perform radix sort on the array [170, 45, 75, 90, 802, 24, 2, 66], we follow these steps:

![](https://media.geeksforgeeks.org/wp-content/uploads/20230609164537/Radix-Sort.png)

How does Radix Sort Algorithm work | Step 1

****Step 1:**** Find the largest element in the array, which is 802. It has three digits, so we will iterate three times, once for each significant place.

****Step 2:**** Sort the elements based on the unit place digits (X=0). We use a stable sorting technique, such as counting sort, to sort the digits at each significant place. It\'s important to understand that the default implementation of counting sort is unstable i.e. same keys can be in a different order than the input array. To solve this problem, We can iterate the input array in reverse order to build the output array. This strategy helps us to keep the same keys in the same order as they appear in the input array.

****Sorting based on the unit place:****

-   Perform counting sort on the array based on the unit place digits.
-   The sorted array based on the unit place is [170, 90, 802, 2, 24, 45, 75, 66].

![](https://media.geeksforgeeks.org/wp-content/uploads/20230609164536/Radix-Sort--1.png)

How does Radix Sort Algorithm work | Step 2

****Step 3:**** Sort the elements based on the tens place digits.

****Sorting based on the tens place:****

-   Perform counting sort on the array based on the tens place digits.
-   The sorted array based on the tens place is [802, 2, 24, 45, 66, 170, 75, 90].

![](https://media.geeksforgeeks.org/wp-content/uploads/20230609164535/Radix-Sort--2.png)

How does Radix Sort Algorithm work | Step 3

****Step 4:**** Sort the elements based on the hundreds place digits.

****Sorting based on the hundreds place:****

-   Perform counting sort on the array based on the hundreds place digits.
-   The sorted array based on the hundreds place is [2, 24, 45, 66, 75, 90, 170, 802].

![](https://media.geeksforgeeks.org/wp-content/uploads/20230609164535/Radix-Sort--3.png)

How does Radix Sort Algorithm work | Step 4

****Step 5:**** The array is now sorted in ascending order.

The final sorted array using radix sort is [2, 24, 45, 66, 75, 90, 170, 802].

![](https://media.geeksforgeeks.org/wp-content/uploads/20230609164534/Radix-Sort--4.png)

How does Radix Sort Algorithm work | Step 5

Below is the implementation for the above illustrations:

```cpp
// C++ implementation of Radix Sort

#include <iostream>
using namespace std;

// A utility function to get maximum
// value in arr[]
int getMax(int arr[], int n)
{
    int mx = arr[0];
    for (int i = 1; i < n; i++)
        if (arr[i] > mx)
            mx = arr[i];
    return mx;
}

// A function to do counting sort of arr[]
// according to the digit
// represented by exp.
void countSort(int arr[], int n, int exp)
{

    // Output array
    int output[n];
    int i, count[10] = { 0 };

    // Store count of occurrences
    // in count[]
    for (i = 0; i < n; i++)
        count[(arr[i] / exp) % 10]++;

    // Change count[i] so that count[i]
    // now contains actual position
    // of this digit in output[]
    for (i = 1; i < 10; i++)
        count[i] += count[i - 1];

    // Build the output array
    for (i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }

    // Copy the output array to arr[],
    // so that arr[] now contains sorted
    // numbers according to current digit
    for (i = 0; i < n; i++)
        arr[i] = output[i];
}

// The main function to that sorts arr[]
// of size n using Radix Sort
void radixsort(int arr[], int n)
{

    // Find the maximum number to
    // know number of digits
    int m = getMax(arr, n);

    // Do counting sort for every digit.
    // Note that instead of passing digit
    // number, exp is passed. exp is 10^i
    // where i is current digit number
    for (int exp = 1; m / exp > 0; exp *= 10)
        countSort(arr, n, exp);
}

// A utility function to print an array
void print(int arr[], int n)
{
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
}

// Driver Code
int main()
{
    int arr[] = { 170, 45, 75, 90, 802, 24, 2, 66 };
    int n = sizeof(arr) / sizeof(arr[0]);

    // Function Call
    radixsort(arr, n);
    print(arr, n);
    return 0;
}
```
```c
#include <stdio.h>

// A utility function to get the maximum 
// value in arr[]
int getMax(int arr[], int n) {
    int mx = arr[0];
    for (int i = 1; i < n; i++)
        if (arr[i] > mx)
            mx = arr[i];
    return mx;
}

// A function to do counting sort of arr[] 
// according to the digit represented by exp
void countSort(int arr[], int n, int exp) {
    int output[n]; // Output array
    int count[10] = {0}; // Initialize count array as 0

    // Store count of occurrences in count[]
    for (int i = 0; i < n; i++)
        count[(arr[i] / exp) % 10]++;

    // Change count[i] so that count[i] now 
    // contains actual position of this digit
    // in output[]
    for (int i = 1; i < 10; i++)
        count[i] += count[i - 1];

    // Build the output array
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }

    // Copy the output array to arr[], 
    // so that arr[] now contains sorted 
    // numbers according to current digit
    for (int i = 0; i < n; i++)
        arr[i] = output[i];
}

// The main function to sort arr[] of size 
// n using Radix Sort
void radixSort(int arr[], int n) {
  
    // Find the maximum number to know 
    // the number of digits
    int m = getMax(arr, n); 

    // Do counting sort for every digit
    // exp is 10^i where i is the current 
    // digit number
    for (int exp = 1; m / exp > 0; exp *= 10)
        countSort(arr, n, exp);
}

// A utility function to print an array
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\\n");
}

// Driver code
int main() {
    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};
    int n = sizeof(arr) / sizeof(arr[0]);

    // Function call
    radixSort(arr, n);
    printArray(arr, n);
    return 0;
}
```
```java
// Radix sort Java implementation

import java.io.*;
import java.util.*;

class Radix {

    // A utility function to get maximum value in arr[]
    static int getMax(int arr[], int n)
    {
        int mx = arr[0];
        for (int i = 1; i < n; i++)
            if (arr[i] > mx)
                mx = arr[i];
        return mx;
    }

    // A function to do counting sort of arr[] according to
    // the digit represented by exp.
    static void countSort(int arr[], int n, int exp)
    {
        int output[] = new int[n]; // output array
        int i;
        int count[] = new int[10];
        Arrays.fill(count, 0);

        // Store count of occurrences in count[]
        for (i = 0; i < n; i++)
            count[(arr[i] / exp) % 10]++;

        // Change count[i] so that count[i] now contains
        // actual position of this digit in output[]
        for (i = 1; i < 10; i++)
            count[i] += count[i - 1];

        // Build the output array
        for (i = n - 1; i >= 0; i--) {
            output[count[(arr[i] / exp) % 10] - 1] = arr[i];
            count[(arr[i] / exp) % 10]--;
        }

        // Copy the output array to arr[], so that arr[] now
        // contains sorted numbers according to current
        // digit
        for (i = 0; i < n; i++)
            arr[i] = output[i];
    }

    // The main function to that sorts arr[] of
    // size n using Radix Sort
    static void radixsort(int arr[], int n)
    {
        // Find the maximum number to know number of digits
        int m = getMax(arr, n);

        // Do counting sort for every digit. Note that
        // instead of passing digit number, exp is passed.
        // exp is 10^i where i is current digit number
        for (int exp = 1; m / exp > 0; exp *= 10)
            countSort(arr, n, exp);
    }

    // A utility function to print an array
    static void print(int arr[], int n)
    {
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + " ");
    }

    // Main driver method
    public static void main(String[] args)
    {
        int arr[] = { 170, 45, 75, 90, 802, 24, 2, 66 };
        int n = arr.length;

        // Function Call
        radixsort(arr, n);
        print(arr, n);
    }
}
```
```python
# Python program for implementation of Radix Sort
# A function to do counting sort of arr[] according to
# the digit represented by exp.


def countingSort(arr, exp1):

    n = len(arr)

    # The output array elements that will have sorted arr
    output = [0] * (n)

    # initialize count array as 0
    count = [0] * (10)

    # Store count of occurrences in count[]
    for i in range(0, n):
        index = arr[i] // exp1
        count[index % 10] += 1

    # Change count[i] so that count[i] now contains actual
    # position of this digit in output array
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Build the output array
    i = n - 1
    while i >= 0:
        index = arr[i] // exp1
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1

    # Copying the output array to arr[],
    # so that arr now contains sorted numbers
    i = 0
    for i in range(0, len(arr)):
        arr[i] = output[i]

# Method to do Radix Sort


def radixSort(arr):

    # Find the maximum number to know number of digits
    max1 = max(arr)

    # Do counting sort for every digit. Note that instead
    # of passing digit number, exp is passed. exp is 10^i
    # where i is current digit number
    exp = 1
    while max1 / exp >= 1:
        countingSort(arr, exp)
        exp *= 10


# Driver code
arr = [170, 45, 75, 90, 802, 24, 2, 66]

# Function Call
radixSort(arr)

for i in range(len(arr)):
    print(arr[i], end=" ")

# This code is contributed by Mohit Kumra
# Edited by Patrick Gallagher
```
```csharp
// C# implementation of Radix Sort
using System;

class GFG {
    public static int getMax(int[] arr, int n)
    {
        int mx = arr[0];
        for (int i = 1; i < n; i++)
            if (arr[i] > mx)
                mx = arr[i];
        return mx;
    }

    // A function to do counting sort of arr[] according to
    // the digit represented by exp.
    public static void countSort(int[] arr, int n, int exp)
    {
        int[] output = new int[n]; // output array
        int i;
        int[] count = new int[10];

        // initializing all elements of count to 0
        for (i = 0; i < 10; i++)
            count[i] = 0;

        // Store count of occurrences in count[]
        for (i = 0; i < n; i++)
            count[(arr[i] / exp) % 10]++;

        // Change count[i] so that count[i] now contains
        // actual
        //  position of this digit in output[]
        for (i = 1; i < 10; i++)
            count[i] += count[i - 1];

        // Build the output array
        for (i = n - 1; i >= 0; i--) {
            output[count[(arr[i] / exp) % 10] - 1] = arr[i];
            count[(arr[i] / exp) % 10]--;
        }

        // Copy the output array to arr[], so that arr[] now
        // contains sorted numbers according to current
        // digit
        for (i = 0; i < n; i++)
            arr[i] = output[i];
    }

    // The main function to that sorts arr[] of size n using
    // Radix Sort
    public static void radixsort(int[] arr, int n)
    {
        // Find the maximum number to know number of digits
        int m = getMax(arr, n);

        // Do counting sort for every digit. Note that
        // instead of passing digit number, exp is passed.
        // exp is 10^i where i is current digit number
        for (int exp = 1; m / exp > 0; exp *= 10)
            countSort(arr, n, exp);
    }

    // A utility function to print an array
    public static void print(int[] arr, int n)
    {
        for (int i = 0; i < n; i++)
            Console.Write(arr[i] + " ");
    }

    // Driver Code
    public static void Main()
    {
        int[] arr = { 170, 45, 75, 90, 802, 24, 2, 66 };
        int n = arr.Length;

        // Function Call
        radixsort(arr, n);
        print(arr, n);
    }

    // This code is contributed by DrRoot_
}
```
```javascript
// Radix sort JavaScript implementation

"use strict";

// A utility function to get maximum value in arr[]
function getMax(arr) {
  const length = arr.length;
  let mx = arr[0];
  for (let i = 1; i < length; i++) {
    if (arr[i] > mx) mx = arr[i];
  }
  return mx;
}

// A function to do counting sort of arr[] according to
// the digit represented by exp.
function countSort(arr, exp) {
  const length = arr.length;
  let output = Array(length); // output array
  let count = Array(10).fill(0, 0);

  // Store count of occurrences in count[]
  for (let i = 0; i < length; i++) {
    const digit = Math.floor(arr[i] / exp) % 10;
    count[digit]++;
  }

  // Change count[i] so that count[i] now contains
  // actual position of this digit in output[]
  for (let i = 1; i < 10; i++) {
    count[i] += count[i - 1];
  }

  // Build the output array
  for (let i = length - 1; i >= 0; i--) {
    const digit = Math.floor(arr[i] / exp) % 10;
    output[count[digit] - 1] = arr[i];
    count[digit]--;
  }

  return output;
}

// The main function to that sorts arr[] using Radix Sort
function radixSort(arr) {
  // Find the maximum number to know number of digits
  const maxNumber = getMax(arr);
  // Create a shallow copy where the sorted values will be kept
  let sortedArr = [...arr];

  // Do counting sort for every digit. Note that
  // instead of passing digit number, exp is passed.
  // exp is 10^i where i is current digit number
  for (let exp = 1; Math.floor(maxNumber / exp) > 0; exp *= 10) {
    // Get the Count sort iteration
    const sortedIteration = countSort(sortedArr, exp);
    sortedArr = sortedIteration;
  }

  return sortedArr;
}

/*Driver Code*/
const arr = [170, 45, 75, 90, 802, 24, 2, 66];

// Function Call
const sortedArr = radixSort(arr);

console.log(sortedArr.join(" "));

// This code is contributed by beeduhboodee
```


```Output
2 24 45 66 75 90 170 802 
```

# Complexity Analysis of Radix Sort

****Time Complexity:**** 

-   Radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping the keys by the individual digits which share the same significant position and value. It has a time complexity of ****O(d * (n + b))****, where d is the number of digits, n is the number of elements, and b is the base of the number system being used.
-   In practical implementations, radix sort is often faster than other comparison-based sorting algorithms, such as quicksort or merge sort, for large datasets, especially when the keys have many digits. However, its time complexity grows linearly with the number of digits, and so it is not as efficient for small datasets.

****Auxiliary Space:**** 

-   Radix sort also has a space complexity of ****O(n + b),**** where n is the number of elements and b is the base of the number system. This space complexity comes from the need to create buckets for each digit value and to copy the elements back to the original array after each digit has been sorted.

[Refer for more detail](https://www.geeksforgeeks.org/time-and-space-complexity-of-radix-sort-algorithm/)

# Applications of Radix Sort
-   In a typical computer, which is a sequential random-access machine, where the records are keyed by multiple fields radix sort is used. For eg., you want to sort on three keys month, day, and year. You could compare two records on year, then on a tie on month and finally on the date. Alternatively, sorting the data three times using Radix sort first on the date, then on month, and finally on year could be used.
-   It was used in card sorting machines with 80 columns, and in each column, the machine could punch a hole only in 12 places. The sorter was then programmed to sort the cards, depending upon which place the card had been punched. This was then used by the operator to collect the cards which had the 1st row punched, followed by the 2nd row, and so on.
# Key points about Radix Sort
-   It makes assumptions about the data like the data must be between a range of elements.
-   The input array must have elements with the same radix and width.
-   Radix sort works on sorting based on an individual digit or letter position.
-   We must start sorting from the rightmost position and use a stable algorithm at each position.
-   Radix sort is not an in-place algorithm as it uses a temporary count array
# Advantages of Radix Sort

-   Radix sort has a linear time complexity, which makes it faster than comparison-based sorting algorithms such as quicksort and merge sort for large data sets.
-   It is a stable sorting algorithm, meaning that elements with the same key value maintain their relative order in the sorted output.
-   Radix sort is efficient for sorting large numbers of integers or strings.
-   It can be easily parallelized.

# Disadvantages of Radix Sort

-   Radix sort is not efficient for sorting floating-point numbers or other types of data that cannot be easily mapped to a small number of digits.
-   It requires a significant amount of memory to hold the count of the number of times each digit value appears.
-   It is not efficient for small data sets or data sets with a small number of unique keys.
-   It requires that the data being sorted can be represented in a fixed number of digits, which may not be the case for some types of data.', 'Radix Sort is a linear sorting algorithm that sorts elements by processing them digit by digit. It is an efficient sorting algorithm for integers or strings with fixed-size keys. ', 'Radix Sort', 18, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('f404008a-dcff-4a0e-8835-c8f4121aa7c7', e'![collision-in-hashing](https://media.geeksforgeeks.org/wp-content/uploads/20241220115555333222/collision-in-hashing.webp)

# Collision Resolution Techniques

There are mainly two methods to handle collision:
1. Separate Chaining
2. Open Addressing

  

![Collision-Resolution-Techniques](https://media.geeksforgeeks.org/wp-content/uploads/20240514124402/Collision-Resolution-Techniques.webp)

  

## 1) Separate Chaining

  

The idea behind [Separate Chaining](https://www.geeksforgeeks.org/hashing-set-2-separate-chaining/) is to make each cell of the hash table point to a linked list of records that have the same hash function value. Chaining is simple but requires additional memory outside the table.

  

****Example****: We have given a hash function and we have to insert some elements in the hash table using a separate chaining method for collision resolution technique.

  

> Hash function = key % 5,
> Elements = 12, 15, 22, 25 and 37.

  

Let\'s see step by step approach to how to solve the above problem:

  
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122112343763/Separate-Chaining-1.webp)
![Separate-Chaining-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241220122112514567/Separate-Chaining-2.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122112638135/Separate-Chaining-3.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122112766037/Separate-Chaining-4.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122112889463/Separate-Chaining-5.webp)
  

> Please [You Own Hash Table with Chaining](https://www.geeksforgeeks.org/c-program-hashing-chaining/) for implementation of this technique

  

## 2) Open Addressing

  

In [open addressing](https://www.geeksforgeeks.org/open-addressing-collision-handling-technique-in-hashing/), all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we examine the table slots one by one until the desired element is found or it is clear that the element is not in the table.

  

#### 2.a) Linear Probing

  

In linear probing, the hash table is searched sequentially that starts from the original location of the hash. If in case the location that we get is already occupied, then we check for the next location.

  

****Algorithm:****
> 1. Calculate the hash key. i.e. ****key = data % size****
> 2. Check, if ****hashTable\\[key\\]**** is empty - store the value directly by ****hashTable\\[key\\] = data****
> 3. If the hash index already has some value then - check for next index using ****key = (key+1) % size****
> 4. Check, if the next index is available hashTable\\[key\\] then store the value. Otherwise try for next index.
> 5. Do the above process till we find the space.

  

****Example:**** Let us consider a simple hash function as “key mod 5” and a sequence of keys that are to be inserted are 50, 70, 76, 85, 93.

  
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122551147667/1.webp)
![2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241220122551274637/2.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122551413874/3.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122551549856/4.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122551676035/5.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122551803028/6.webp)

  
  

> Please refer [Your Own Hash Table with Linear Probing in Open Addressing](https://www.geeksforgeeks.org/implementing-hash-table-open-addressing-linear-probing-cpp/) for implementation details.

  

#### 2.b) Quadratic Probing

  

Quadratic probing is an open addressing scheme in computer programming for resolving hash collisions in hash tables. Quadratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open slot is found.
An example sequence using quadratic probing is:
$$
H + 1^2 , H + 2^2 , H + 3^2 , H + 4^2 … H + k^2
$$
  

This method is also known as the mid-square method because in this method we look for $i^2-th$ probe (slot) in $i-th$ iteration and the value of $i = 0, 1, . . . n – 1$. We always start from the original hash location. If only the location is occupied then we check the other slots.
Let hash(x) be the slot index computed using the hash function and n be the size of the hash table.

> If the slot hash(x) % n is full, then we try (hash(x) + $1^2$ ) % n.
> If (hash(x) + $1^2$ ) % n is also full, then we try (hash(x) + $2^2$ ) % n.
> If (hash(x) + $2^2$ ) % n is also full, then we try (hash(x) + $3^2$ ) % n.
> This process will be repeated for all the values of i until an empty slot is found

  

Example: Let us consider table Size = 7, hash function as Hash(x) = x % 7 and collision resolution strategy to be $f(i) = i^2$. Insert = 22, 30, and 50

  

![Quadratic-Probing-4.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241220122701019360/Quadratic-Probing-1.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122701176068/Quadratic-Probing-2.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122701318326/Quadratic-Probing-3.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241220122701445462/Quadratic-Probing-4.webp)

 
> Please refer [Your Own Hash Table with Quadratic Probing in Open Addressing](https://www.geeksforgeeks.org/quadratic-probing-in-hashing/) for implementation.


#### 2.c) Double Hashing
Double hashing is a collision resolving technique in [Open Addressed](https://www.geeksforgeeks.org/hashing-set-3-open-addressing/) Hash tables. Double hashing make use of two hash function.
- The first hash function is $h1(k)$ which takes the key and gives out a location on the hash table. But if the new location is not occupied or empty then we can easily place our key.

- But in case the location is occupied (collision) we will use secondary hash-function $h2(k)$ in combination with the first hash-function $h1(k)$ to find the new location on the hash table.

This combination of hash functions is of the form

> ***h(k, i) = (h1(k) + i \\* h2(k)) % n***

where
- i is a non-negative integer that indicates a collision number,
- k = element/key which is being hashed
- n = hash table size.
****Complexity of the Double hashing algorithm:****
> Time complexity: O(n)

  

****Example:**** Insert the keys 27, 43, 692, 72 into the Hash Table of size 7. where first hash-function is ****h1(k) = k mod 7**** and second hash-function is ****h2(k) = 1 + (k mod 5)****

  

![3_1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241220122806911858/1_1.webp)![3_1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241220122807122672/2_1.webp)
![3_1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241220122807317089/3_1.webp)
![3_1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241220122807516193/4_1.webp)
![3_1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241220122807649533/5_1.webp)


  
  

> Please refer [Double Hashing](https://www.geeksforgeeks.org/double-hashing/) for Implementation.', 'When two or more keys have the same hash value, a collision happens. To handle this collision, we use Collision Resolution Techniques.', 'Collision Resolution Techniques', 1, null, '2d282726-865b-41fb-8cf5-7a2116099466', true);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('06f436bd-4fb7-4909-bf38-af1a0e308830', e'# What is Double hashing
Double hashing is a collision resolution technique used in hash tables. It works by using two hash functions to compute two different hash values for a given key. The first hash function is used to compute the initial hash value, and the second hash function is used to compute the step size for the probing sequence.

Double hashing has the ability to have a low collision rate, as it uses two hash functions to compute the hash value and the step size. This means that the probability of a collision occurring is lower than in other collision resolution techniques such as linear probing or quadratic probing.

However, double hashing has a few drawbacks. First, it requires the use of two hash functions, which can increase the computational complexity of the insertion and search operations. Second, it requires a good choice of hash functions to achieve good performance. If the hash functions are not well-designed, the collision rate may still be high.

# Advantages of Double hashing

-   The advantage of Double hashing is that it is one of the best forms of probing, producing a uniform distribution of records throughout a hash table.
-   This technique does not yield any clusters.
-   It is one of the effective methods for resolving collisions.

> Double hashing can be done using :   
> ****(hash1(key) + i \\* hash2(key)) % TABLE\\_SIZE****   
> Here hash1() and hash2() are hash functions and TABLE\\_SIZE   
> is size of hash table.   
> (We repeat by increasing i when collision occurs)

**Method 1:** First hash function is typically hash1(key) = key % TABLE\\_SIZE  
A popular second hash function is ***hash2(key) = PRIME - (key % PRIME)*** where PRIME is a prime smaller than the TABLE\\_SIZE.  
A good second Hash function is: 

-   It must never evaluate to zero
-   Just make sure that all cells can be probed 

![](https://media.geeksforgeeks.org/wp-content/uploads/double-hash-function.png)

Below is the implementation of the above approach:

```CPP
/*
** Handling of collision via open addressing
** Method for Probing: Double Hashing
*/

#include <iostream>
#include <vector>
#include <bitset>
using namespace std;
#define MAX_SIZE 10000001ll

class doubleHash {

    int TABLE_SIZE, keysPresent, PRIME;
    vector<int> hashTable;
    bitset<MAX_SIZE> isPrime;

    /* Function to set sieve of Eratosthenes. */
    void __setSieve(){
        isPrime[0] = isPrime[1] = 1;
        for(long long i = 2; i*i <= MAX_SIZE; i++)
            if(isPrime[i] == 0)
                for(long long j = i*i; j <= MAX_SIZE; j += i)
                    isPrime[j] = 1;

    }

    int inline hash1(int value){
        return value%TABLE_SIZE;
    }
    
    int inline hash2(int value){       
        return PRIME - (value%PRIME);
    }

    bool inline isFull(){
        return (TABLE_SIZE == keysPresent);
    }

    public: 

    doubleHash(int n){
        __setSieve();
        TABLE_SIZE = n;

        /* Find the largest prime number smaller than hash table\'s size. */
        PRIME = TABLE_SIZE - 1;
        while(isPrime[PRIME] == 1)
            PRIME--;

        keysPresent = 0;

        /* Fill the hash table with -1 (empty entries). */
        for(int i = 0; i < TABLE_SIZE; i++)
            hashTable.push_back(-1); 
    }

    void __printPrime(long long n){
        for(long long i = 0; i <= n; i++)
            if(isPrime[i] == 0)
                cout<<i<<", ";
        cout<<endl;
    }

    /* Function to insert value in hash table */
    void insert(int value){

        if(value == -1 || value == -2){
            cout<<("ERROR : -1 and -2 can\'t be inserted in the table\\n");  
        }

        if(isFull()){
            cout<<("ERROR : Hash Table Full\\n");
            return;
        }
        
        int probe = hash1(value), offset = hash2(value); // in linear probing offset = 1;
        
        while(hashTable[probe] != -1){
            if(-2 == hashTable[probe])                  
                break;                                  // insert at deleted element\'s location
            probe = (probe+offset) % TABLE_SIZE;
        }

        hashTable[probe] = value;
        keysPresent += 1;
    }

    void erase(int value){
        /* Return if element is not present */
        if(!search(value))
            return;     
        
        int probe = hash1(value), offset = hash2(value);

        while(hashTable[probe] != -1)
            if(hashTable[probe] == value){
                hashTable[probe] = -2;          // mark element as deleted (rather than unvisited(-1)).
                keysPresent--;
                return;
            }
            else
                probe = (probe + offset) % TABLE_SIZE; 

    }

    bool search(int value){
        int probe = hash1(value), offset = hash2(value), initialPos = probe;
        bool firstItr = true;

        while(1){
            if(hashTable[probe] == -1)                   // Stop search if -1 is encountered.
                break;
            else if(hashTable[probe] == value)           // Stop search after finding the element.
                return true;
            else if(probe == initialPos && !firstItr)    // Stop search if one complete traversal of hash table is completed.
                return false;
            else
                probe = ((probe + offset) % TABLE_SIZE);  // if none of the above cases occur then update the index and check at it.

            firstItr = false;
        }
        return false;
    }

    /* Function to display the hash table. */
    void print(){
        for(int i = 0; i < TABLE_SIZE; i++)
            cout<<hashTable[i]<<", ";
        cout<<"\\n";
    }

};

int main(){
    doubleHash myHash(13); // creates an empty hash table of size 13

    /* Inserts random element in the hash table */
    
    int insertions[] = {115, 12, 87, 66, 123}, 
        n1 = sizeof(insertions)/sizeof(insertions[0]);
    
    for(int i = 0; i < n1; i++)
        myHash.insert(insertions[i]);
    
    cout<< "Status of hash table after initial insertions : "; myHash.print();
    

    /* 
    ** Searches for random element in the hash table,
    ** and prints them if found.
    */
    
    int queries[] = {1, 12, 2, 3, 69, 88, 115},
        n2 = sizeof(queries)/sizeof(queries[0]);
    
    cout<<"\\n"<<"Search operation after insertion : \\n";

    for(int i = 0; i < n2; i++)
        if(myHash.search(queries[i]))
            cout<<queries[i]<<" present\\n";
    

    /* Deletes random element from the hash table. */
    
    int deletions[] = {123, 87, 66},
        n3 = sizeof(deletions)/sizeof(deletions[0]);
    
    for(int i = 0; i < n3; i++)
        myHash.erase(deletions[i]);

    cout<< "Status of hash table after deleting elements : "; myHash.print();
    
    return 0;
}
```
``` Java 
import java.util.BitSet;
import java.util.Vector;

class DoubleHash {

    private int TABLE_SIZE, keysPresent, PRIME;
    private Vector<Integer> hashTable;
    private BitSet isPrime;
    private static final long MAX_SIZE = 10000001L;

    /* Function to set sieve of Eratosthenes. */
    private void setSieve() {
        isPrime.set(0, true);
        isPrime.set(1, true);
        for (long i = 2; i * i <= MAX_SIZE; i++)
            if (!isPrime.get((int) i))
                for (long j = i * i; j <= MAX_SIZE; j += i)
                    isPrime.set((int) j);
    }

    private int hash1(int value) {
        return value % TABLE_SIZE;
    }

    private int hash2(int value) {
        return PRIME - (value % PRIME);
    }

    private boolean isFull() {
        return (TABLE_SIZE == keysPresent);
    }

    public DoubleHash(int n) {
        isPrime = new BitSet((int) MAX_SIZE);
        setSieve();
        TABLE_SIZE = n;

        /* Find the largest prime number smaller than hash table\'s size. */
        PRIME = TABLE_SIZE - 1;
        while (isPrime.get(PRIME))
            PRIME--;

        keysPresent = 0;

        /* Fill the hash table with -1 (empty entries). */
        hashTable = new Vector<>();
        for (int i = 0; i < TABLE_SIZE; i++)
            hashTable.add(-1);
    }

    private void printPrime(long n) {
        for (long i = 0; i <= n; i++)
            if (!isPrime.get((int) i))
                System.out.print(i + ", ");
        System.out.println();
    }

    /* Function to insert value in hash table */
    public void insert(int value) {

        if (value == -1 || value == -2) {
            System.out.println("ERROR : -1 and -2 can\'t be inserted in the table");
        }

        if (isFull()) {
            System.out.println("ERROR : Hash Table Full");
            return;
        }

        int probe = hash1(value), offset = hash2(value); // in linear probing offset = 1;

        while (hashTable.get(probe) != -1) {
            if (-2 == hashTable.get(probe))
                break; // insert at deleted element\'s location
            probe = (probe + offset) % TABLE_SIZE;
        }

        hashTable.set(probe, value);
        keysPresent += 1;
    }

    public void erase(int value) {
        /* Return if element is not present */
        if (!search(value))
            return;

        int probe = hash1(value), offset = hash2(value);

        while (hashTable.get(probe) != -1)
            if (hashTable.get(probe) == value) {
                hashTable.set(probe, -2); // mark element as deleted (rather than unvisited(-1)).
                keysPresent--;
                return;
            } else
                probe = (probe + offset) % TABLE_SIZE;

    }

    public boolean search(int value) {
        int probe = hash1(value), offset = hash2(value), initialPos = probe;
        boolean firstItr = true;

        while (true) {
            if (hashTable.get(probe) == -1) // Stop search if -1 is encountered.
                break;
            else if (hashTable.get(probe) == value) // Stop search after finding the element.
                return true;
            else if (probe == initialPos && !firstItr) // Stop search if one complete traversal of hash table is
                                                        // completed.
                return false;
            else
                probe = ((probe + offset) % TABLE_SIZE); // if none of the above cases occur then update the index and
                                                            // check at it.

            firstItr = false;
        }
        return false;
    }

    /* Function to display the hash table. */
    public void print() {
        for (int i = 0; i < TABLE_SIZE; i++)
            System.out.print(hashTable.get(i) + ", ");
        System.out.println();
    }
}

public class Main {
    public static void main(String[] args) {
        DoubleHash myHash = new DoubleHash(13); // creates an empty hash table of size 13

        /* Inserts random element in the hash table */

        int[] insertions = { 115, 12, 87, 66, 123 };
        int n1 = insertions.length;

        for (int i = 0; i < n1; i++)
            myHash.insert(insertions[i]);

        System.out.print("Status of hash table after initial insertions : ");
        myHash.print();

        /*
         ** Searches for random element in the hash table,
         ** and prints them if found.
         */

        int[] queries = { 1, 12, 2, 3, 69, 88, 115 };
        int n2 = queries.length;

        System.out.println("\\n" + "Search operation after insertion : ");

        for (int i = 0; i < n2; i++)
            if (myHash.search(queries[i]))
                System.out.println(queries[i] + " present");

        /* Deletes random element from the hash table. */

        int[] deletions = { 123, 87, 66 };
        int n3 = deletions.length;

        for (int i = 0; i < n3; i++)
            myHash.erase(deletions[i]);

        System.out.print("Status of hash table after deleting elements : ");
        myHash.print();
    }
}
```
```Python3
from typing import List
import math

MAX_SIZE = 10000001

class DoubleHash:
    def __init__(self, n: int):
        self.TABLE_SIZE = n
        self.PRIME = self.__get_largest_prime(n - 1)
        self.keysPresent = 0
        self.hashTable = [-1] * n

    def __get_largest_prime(self, limit: int) -> int:
        is_prime = [True] * (limit + 1)
        is_prime[0], is_prime[1] = False, False
        for i in range(2, int(math.sqrt(limit)) + 1):
            if is_prime[i]:
                for j in range(i * i, limit + 1, i):
                    is_prime[j] = False
        for i in range(limit, -1, -1):
            if is_prime[i]:
                return i

    def __hash1(self, value: int) -> int:
        return value % self.TABLE_SIZE

    def __hash2(self, value: int) -> int:
        return self.PRIME - (value % self.PRIME)

    def is_full(self) -> bool:
        return self.TABLE_SIZE == self.keysPresent

    def insert(self, value: int) -> None:
        if value == -1 or value == -2:
            print("ERROR : -1 and -2 can\'t be inserted in the table")
            return
        if self.is_full():
            print("ERROR : Hash Table Full")
            return
        probe, offset = self.__hash1(value), self.__hash2(value)
        while self.hashTable[probe] != -1:
            if -2 == self.hashTable[probe]:
                break
            probe = (probe + offset) % self.TABLE_SIZE
        self.hashTable[probe] = value
        self.keysPresent += 1

    def erase(self, value: int) -> None:
        if not self.search(value):
            return
        probe, offset = self.__hash1(value), self.__hash2(value)
        while self.hashTable[probe] != -1:
            if self.hashTable[probe] == value:
                self.hashTable[probe] = -2
                self.keysPresent -= 1
                return
            else:
                probe = (probe + offset) % self.TABLE_SIZE

    def search(self, value: int) -> bool:
        probe, offset, initialPos, firstItr = self.__hash1(value), self.__hash2(value), self.__hash1(value), True
        while True:
            if self.hashTable[probe] == -1:
                break
            elif self.hashTable[probe] == value:
                return True
            elif probe == initialPos and not firstItr:
                return False
            else:
                probe = (probe + offset) % self.TABLE_SIZE
            firstItr = False
        return False

    def print(self) -> None:
        print(*self.hashTable,sep=\', \')

if __name__ == \'__main__\':
    myHash = DoubleHash(13)

    # Inserts random element in the hash table
    insertions = [115, 12, 87, 66, 123]
    for insertion in insertions:
        myHash.insert(insertion)
    print("Status of hash table after initial insertions : ", end="")
    myHash.print()

    # Searches for random element in the hash table, and prints them if found.
    queries = [1, 12, 2, 3, 69, 88, 115]
    n2 = len(queries)
    print("\\nSearch operation after insertion : ")
    
    for i in range(n2):
        if myHash.search(queries[i]):
            print(queries[i], "present")
            
    # Deletes random element from the hash table.
    deletions = [123, 87, 66]
    n3 = len(deletions)
    
    for i in range(n3):
        myHash.erase(deletions[i])
        
    print("Status of hash table after deleting elements : ",end=\'\')
    myHash.print()
```
```JavaScript
// JS code
const MAX_SIZE = 10000001;

// Set sieve of Eratosthenes
let isPrime = new Array(MAX_SIZE).fill(0);
isPrime[0] = isPrime[1] = 1;
for (let i = 2; i * i <= MAX_SIZE; i++) {
  if (isPrime[i] === 0) {
    for (let j = i * i; j <= MAX_SIZE; j += i) {
      isPrime[j] = 1;
    }
  }
}

// Create DoubleHash Class
class DoubleHash {
  constructor(n) {
    this.TABLE_SIZE = n;
    this.PRIME = this.TABLE_SIZE - 1;
    while (isPrime[this.PRIME] === 1) {
      this.PRIME--;
    }
    this.keysPresent = 0;
    this.hashTable = new Array(this.TABLE_SIZE).fill(-1);
  }
  isFull(){
  return this.TABLE_SIZE==this.keysPresent;
  }
   hash1(value) {
    return value % this.TABLE_SIZE;
}

 hash2(value) {
    return this.PRIME - (value % this.PRIME);
}

  // Function to print prime numbers
  __printPrime(n) {
    for (let i = 0; i <= n; i++) {
      if (isPrime[i] === 0) {
        console.log(i + ", ");
      }
    }
    console.log("\\n");
  }

  // Function to insert value in hash table
  insert(value) {
    if (value === -1 || value === -2) {
      console.log("ERROR : -1 and -2 can\'t be inserted in the table\\n");
    }
    if (this.isFull()) {
      console.log("ERROR : Hash Table Full\\n");
      return;
    }
    let probe = this.hash1(value),
      offset = this.hash2(value); // in linear probing offset = 1;

    while (this.hashTable[probe] !== -1) {
      if (-2 === this.hashTable[probe]) break; // insert at deleted element\'s location
      probe = (probe + offset) % this.TABLE_SIZE;
    }

    this.hashTable[probe] = value;
    this.keysPresent += 1;
  }

  erase(value) {
    // Return if element is not present
    if (!this.search(value)) return;

    let probe = this.hash1(value),
      offset = this.hash2(value);

    while (this.hashTable[probe] !== -1) {
      if (this.hashTable[probe] === value) {
        this.hashTable[probe] = -2; // mark element as deleted (rather than unvisited(-1)).
        this.keysPresent--;
        return;
      } else {
        probe = (probe + offset) % this.TABLE_SIZE;
      }
    }
  }

  search(value) {
    let probe = this.hash1(value),
      offset = this.hash2(value),
      initialPos = probe;
    let firstItr = true;

    while (1) {
      if (this.hashTable[probe] === -1) break; // Stop search if -1 is encountered.
      else if (this.hashTable[probe] === value) return true; // Stop search after finding the element.
      else if (probe === initialPos && !firstItr)
        return false; // Stop search if one complete traversal of hash table is completed.
      else probe = (probe + offset) % this.TABLE_SIZE; // if none of the above cases occur then update the index and check at it.
      firstItr = false;
    }
    return false;
  }

  // Function to display the hash table.
  print() {
    for (let i = 0; i < this.TABLE_SIZE; i++) console.log(this.hashTable[i] + ", ");
    console.log("\\n");
  }
}

// Main function
function main() {
  let myHash = new DoubleHash(13); // creates an empty hash table of size 13

  // Inserts random element in the hash table
  let insertions = [115, 12, 87, 66, 123],
    n1 = insertions.length;

  for (let i = 0; i < n1; i++) myHash.insert(insertions[i]);

  console.log("Status of hash table after initial insertions : ");
  myHash.print();

  // Searches for random element in the hash table, and prints them if found.
  let queries = [1, 12, 2, 3, 69, 88, 115],
    n2 = queries.length;

  console.log("\\n" + "Search operation after insertion : \\n");

  for (let i = 0; i < n2; i++)
    if (myHash.search(queries[i])) console.log(queries[i] + " present\\n");

  // Deletes random element from the hash table.
  let deletions = [123, 87, 66],
    n3 = deletions.length;

  for (let i = 0; i < n3; i++) myHash.erase(deletions[i]);

  console.log("Status of hash table after deleting elements : ");
  myHash.print();

  return 0;
}

main();

// This code is contributed by ishankhandelwals.
```


```output
Status of hash table after initial insertions : -1, 66, -1, -1, -1, -1, 123, -1, -1, 87, -1, 115, 12, 

Search operation after insertion : 
12 present
115 present
Status of hash table after deleting elements : -1, -2, -1, -1, -1, -1, -2, -1, -1, -2, -1, 115, 12, 

```

**Time Complexity:**

-   ***Insertion:*** O(n)
-   ***Search:*** O(n)
-   ***Deletion:*** O(n)

**Auxiliary Space:** O(size of the hash table).', 'One of Collision Resolution Techniques.', 'Double Hashing', 2, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('ab91b418-625b-45dc-a814-fb50d26249a0', e'![Introduction-to-Matrix](https://media.geeksforgeeks.org/wp-content/uploads/20240416133310/Introduction-to-Matrix.webp)

# Representation of Matrix Data Structure

As you can see from the below image, the elements are organized in rows and columns. As shown in the image, the cell a[0][0] is the first element of the first row and first column.

![Representation-of-Matrix](https://media.geeksforgeeks.org/wp-content/uploads/20240415190237/Representation-of-Matrix.webp)

## Declaration of Matrix Data Structure

Declaration of a Matrix or two-dimensional array is very much similar to that of a one-dimensional array, given as follows.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    // Defining number of rows and columns in matrix
    int rows = 3, cols = 3;

    // Vector of vectors declaration
    vector<vector<int>> arr(rows, vector<int>(cols));

    return 0;
}
```
```c
#include <stdio.h>

int main() {

    // Defining number of rows and columns in matrix
    int rows = 3, cols = 3;
  
    // Array Declaration
    int arr[rows][cols];
  
    return 0;
}
```
```java
/*package whatever //do not write package name here */

import java.io.*;

class GFG {
    public static void main(String[] args)
    {
        // Defining number of rows and columns in matrix
        int rows = 3, cols = 3;
      
        // Array Declaration
        int[][] arr
            = new int[rows][cols];
    }
}
```
```python
# Defining number of rows and columns in matrix
rows = 3
cols = 3

# Declaring a matrix of size 3 X 3, and 
# initializing it with value zero
rows, cols = (3, 3)
arr = [[0]*cols]*rows
print(arr)
```
```csharp
using System;

public class GFG {

    static public void Main()
    {
        // Defining number of rows and columns in matrix
        int rows = 3, cols = 3;
      
        // Array Declaration
        int[, ] arr
            = new int[rows, cols];
    }
}
```
```javascript
// Defining number of rows and columns in matrix
rows = 3,
cols = 3;

// Declare a 2D array using array constructor
let arr = new Array(3); 

// Python declaration
for (let i = 0; i < arr.length; i++) {
    arr[i] = new Array(3); // Each row has 3 columns
}
```

# Initializing Matrix Data Structure 

In initialization, we assign some initial value to all the cells of the matrix. Below is the implementation to initialize a matrix in different languages:

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
  
    // Initializing a 2-D vector with values
    vector<vector<int>> arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    
    return 0;
}
```
```c
#include <stdio.h>

int main() {

    // Initializing a 2-D array with values
    int arr[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    return 0;
}
```
```java
/*package whatever //do not write package name here */

import java.io.*;

class GFG {
    public static void main(String[] args)
    {
        // Initializing a 2-D array with values
        int arr[][]
            = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
    }
}
```
```python
# Initializing a 2-D array with values
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
```
```csharp
using System;

public class GFG {

    static public void Main()
    {
        int[, ] arr = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
    }
}
```
```javascript
// Initializing a 2-D array with values
let arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
```

# Operations on Matrix Data Structure 

We can perform a variety of operations on the Matrix Data Structure. Some of the most common operations are:

-   Access elements of Matrix
-   Traversal of a Matrix
-   Searching in a Matrix
-   Sorting a Matrix

## 1. Access elements of Matrix Data Structure:

Like one-dimensional arrays, matrices can be accessed randomly by using their indices to access the individual elements. A cell has two indices, one for its ****row number****, and the other for its ****column number****. We can use ****arr[i][j]**** to access the element which is at the ****ith**** row and ****jth**** column of the matrix.

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    // Initializing a 2-D vector with values
    vector<vector<int>> arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

    // Accessing elements of 2-D vector
    cout << "First element of first row: " << arr[0][0] << "\\n";
    cout << "Third element of second row: " << arr[1][2] << "\\n";
    cout << "Second element of third row: " << arr[2][1] << "\\n";

    return 0;
}
```
```c
#include <stdio.h>

int main()
{
    // Initializing a 2-D array with values
    int arr[3][3]
        = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };

    // Accessing elements of 2-D array
    printf("First element of first row: %d\\n", arr[0][0]);
    printf("Third element of second row: %d\\n", arr[1][2]);
    printf("Second element of third row: %d\\n", arr[2][1]);
    return 0;
}
```
```java
/*package whatever //do not write package name here */

import java.io.*;

class GFG {
    public static void main(String[] args)
    {

        // Initializing a 2-D array with values
        int[][] arr
            = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };

        // Accessing elements of 2-D array
        System.out.println("First element of first row: "
                           + arr[0][0]);
        System.out.println("Third element of second row: "
                           + arr[1][2]);
        System.out.println("Second element of third row: "
                           + arr[2][1]);
    }
}
```
```python
# Initializing a 2-D array with values
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Accessing elements of 2-D array
print("First element of first row:", arr[0][0])
print("Third element of second row:", arr[1][2])
print("Second element of third row:", arr[2][1])
```
```csharp
using System;

public class GFG {

    static public void Main()
    {

        // Initializing a 2-D array with values
        int[, ] arr
            = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };

        // Accessing elements of 2-D array
        Console.WriteLine("First element of first row: "
                          + arr[0, 0]);
        Console.WriteLine("Third element of second row: "
                          + arr[1, 2]);
        Console.WriteLine("Second element of third row: "
                          + arr[2, 1]);
    }
}
```
```javascript
// Initializing a 2-D array with values
let arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];

// Accessing elements of 2-D array
console.log("First element of first row: " + arr[0][0]);
console.log("Third element of second row: " + arr[1][2]);
console.log("Second element of third row: " + arr[2][1]);
```

## 2. Traversal of a Matrix Data Structure:

We can traverse all the elements of a matrix or two-dimensional array by using two for-loops.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    // Initializing a 2-D vector with values
    vector<vector<int>> arr = { { 1, 2, 3, 4 },
                                { 5, 6, 7, 8 },
                                { 9, 10, 11, 12 } };

    // Traversing over all the rows
    for (int i = 0; i < arr.size(); i++) {
      
        // Traversing over all the columns of each row
        for (int j = 0; j < arr[i].size(); j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```
```c
#include <stdio.h>

int main()
{

    int arr[3][4] = { { 1, 2, 3, 4 },
                      { 5, 6, 7, 8 },
                      { 9, 10, 11, 12 } };
    // Traversing over all the rows
    for (int i = 0; i < 3; i++) {
        // Traversing over all the columns of each row
        for (int j = 0; j < 4; j++) {
            printf("%d ", arr[i][j]);
        }
        printf("\\n");
    }
    return 0;
}
```
```java
/*package whatever //do not write package name here */
import java.io.*;

class GFG {
    public static void main(String[] args)
    {
        int[][] arr = { { 1, 2, 3, 4 },
                        { 5, 6, 7, 8 },
                        { 9, 10, 11, 12 } };
        // Traversing over all the rows
        for (int i = 0; i < 3; i++) {
            // Traversing over all the columns of each row
            for (int j = 0; j < 4; j++) {
                System.out.print(arr[i][j] + " ");
            }
            System.out.println();
        }
    }
}

// This code is contributed by lokesh
```
```python
# Initializing a 2-D list with values
arr = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

# Traversing each row
for row in arr:
  
    # Traversing each element
    # in the current row
    for x in row:
        print(x, end=" ")
    print()
```
```csharp
using System;

public class GFG {

    static public void Main()
    {
        int[, ] arr = new int[3, 4] { { 1, 2, 3, 4 },
                                      { 5, 6, 7, 8 },
                                      { 9, 10, 11, 12 } };
        // Traversing over all the rows
        for (int i = 0; i < 3; i++) {
            // Traversing over all the columns of each row
            for (int j = 0; j < 4; j++) {
                Console.Write(arr[i, j]);
                Console.Write(" ");
            }
            Console.WriteLine(" ");
        }
    }
}

// This code is contributed by akashish__
```
```javascript
// JS code for above approach
let arr = [[1, 2, 3, 4],
           [5, 6, 7, 8],
           [9, 10, 11, 12]];
           
// Traversing over all the rows
for (let i = 0; i < 3; i++) {
let s="";
    // Traversing over all the columns of each row
    for (let j = 0; j < 4; j++) {
        s+=(arr[i][j]+" ");
    }
    console.log(s);
}

// This code is contributed by ishankhandelwals.
```


```Output
1 2 3 4 
5 6 7 8 
9 10 11 12 
```

## 3. Searching in a Matrix Data Structure:

We can search an element in a matrix by traversing all the elements of the matrix.

Below is the implementation to search an element in a matrix:

```cpp
#include <bits/stdc++.h>
using namespace std;

bool searchInMatrix(vector<vector<int> >& arr, int x)
{
    int m = arr.size(), n = arr[0].size();

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (arr[i][j] == x)
                return true;
        }
    }
    return false;
}

// Driver program to test above
int main()
{
    int x = 8;
    vector<vector<int> > arr
        = { { 0, 6, 8, 9, 11 },
            { 20, 22, 28, 29, 31 },
            { 36, 38, 50, 61, 63 },
            { 64, 66, 100, 122, 128 } };

    if (searchInMatrix(arr, x))
        cout << "YES" << endl;
    else
        cout << "NO" << endl;

    return 0;
}
```
```java
// Java code for the above approach

import java.io.*;

class GFG {

  static boolean searchInMatrix(int[][] arr, int x)
  {
    int m = arr.length, n = arr[0].length;

    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        if (arr[i][j] == x)
          return true;
      }
    }
    return false;
  }

  public static void main(String[] args)
  {
    int x = 8;
    int[][] arr = { { 0, 6, 8, 9, 11 },
                   { 20, 22, 28, 29, 31 },
                   { 36, 38, 50, 61, 63 },
                   { 64, 66, 100, 122, 128 } };

    if (searchInMatrix(arr, x)) {
      System.out.println("YES");
    }
    else {
      System.out.println("NO");
    }
  }
}

// This code is contributed by lokeshmvs21.
```
```python
# Function to search for an element in a 2-D list
def search_in_matrix(arr, x):
    rows, cols = len(arr), len(arr[0])

    # Traverse each row and column
    for i in range(rows):
        for j in range(cols):
            if arr[i][j] == x:
                return True
    return False

# Driver code to test the function
x = 8
arr = [
    [0, 6, 8, 9, 11],
    [20, 22, 28, 29, 31],
    [36, 38, 50, 61, 63],
    [64, 66, 100, 122, 128]
]

if search_in_matrix(arr, x):
    print("YES")
else:
    print("NO")
```
```csharp
// C# code for the above approach

using System;

public class GFG {
    static bool searchInMatrix(int[,] arr, int x) {
        int m = arr.GetLength(0), n = arr.GetLength(1);

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (arr[i, j] == x)
                    return true;
            }
        }
        return false;
    }

    public static void Main(string[] args) {
        int x = 8;
        int[,] arr = { { 0, 6, 8, 9, 11 },
            { 20, 22, 28, 29, 31 },
            { 36, 38, 50, 61, 63 },
            { 64, 66, 100, 122, 128 }
        };

        if (searchInMatrix(arr, x)) {
            Console.WriteLine("YES");
        } else {
            Console.WriteLine("NO");
        }
    }
}
```
```javascript
// JavaScript code for the above approach

function searchInMatrix(arr, x)
{
    let m = arr.length, n = arr[0].length;

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (arr[i][j] == x)
                return true;
        }
    }
    return false;
}

// Driver program to test above
let x = 8;
let arr = [
    [ 0, 6, 8, 9, 11 ],
    [ 20, 22, 28, 29, 31 ],
    [ 36, 38, 50, 61, 63 ],
    [ 64, 66, 100, 122, 128 ]
];
if (searchInMatrix(arr, x))
    console.log("YES");
else
    console.log("NO");
```

```output
YES
```
', 'Matrix Data Structure is a two-dimensional array arranged in rows and columns. ', 'Matrix Data Structure', 5, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', true);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('2b55a666-302b-4c46-8d3a-3fdaefcca1e7', e'# Approach
****Stack**** is a [****linear data structure****](https://www.geeksforgeeks.org/introduction-to-linear-data-structures/) which follows [****LIFO****](https://www.geeksforgeeks.org/lifo-last-in-first-out-approach-in-programming/) principle. To implement a stack using an array, initialize an array and treat its end as the stack’s top. Implement ****push**** (add to end), ****pop**** (remove from end), and ****peek**** (check end) operations, handling cases for an ****empty**** or f****ull stack****.

****Step-by-step approach:****

1.  ****Initialize an array**** to represent the stack.
2.  Use the ****end of the array**** to represent the ****top of the stack****.
3.  Implement ****push**** (add to end), ****pop**** (remove from the end), and ****peek**** (check end) operations, ensuring to handle empty and full stack conditions.

Here are the following operations of implement stack using array:

# Push Operation in Stack

Adds an item to the stack. If the stack is full, then it is said to be an ****Overflow condition.****

> -   Before pushing the element to the stack, we check if the stack is ****full**** .
> -   If the stack is full ****(top == capacity-1)**** , then ****Stack Overflows**** and we cannot insert the element to the stack.
> -   Otherwise, we increment the value of top by 1 ****(top = top + 1)**** and the new value is inserted at ****top position**** .
> -   The elements can be pushed into the stack till we reach the ****capacity**** of the stack.

![](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-2.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-3.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20240415123026/pop-operation-in-stack-4.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20240415123026/pop-operation-in-stack-5.webp)![push-operation-in-stack-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415114219/push-operation-in-stack-1.webp)


# Pop Operation in Stack:

Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an ****Underflow condition.****

> -   Before popping the element from the stack, we check if the stack is ****empty**** .
> -   If the stack is empty (top == -1), then ****Stack Underflows**** and we cannot remove any element from the stack.
> -   Otherwise, we store the value at top, decrement the value of top by 1 ****(top = top – 1)**** and return the stored top value.

![pop-operation-in-stack-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-1.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-2.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20240415123025/pop-operation-in-stack-3.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20240415123026/pop-operation-in-stack-4.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20240415123026/pop-operation-in-stack-5.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20240415123027/pop-operation-in-stack-6.webp)


# Top or Peek Operation in Stack:

Returns the top element of the stack.

> -   Before returning the top element from the stack, we check if the stack is empty.
> -   If the stack is empty (top == -1), we simply print “Stack is empty”.
> -   Otherwise, we return the element stored at ****index = top**** .

# isEmpty Operation in Stack:

Returns true if the stack is empty, else false.=

> -   Check for the value of ****top**** in stack.
> -   If ****(top == -1)**** , then the stack is ****empty**** so return ****true**** .
> -   Otherwise, the stack is not empty so return ****false**** .

# isFull Operation in Stack

Returns true if the stack is full, else false.

> -   Check for the value of ****top**** in stack.
> -   If ****(top == capacity-1),**** then the stack is ****full**** so return ****true**** .
> -   Otherwise, the stack is not full so return ****false.****

# Implementation using Fixed Sized Array

In this implementation, we use a fixed sized array. We take capacity as argument when we create a stack. We create an array with size equal to given capacity. If number of elements go beyond capacity, we throw an overflow error.

```c++
// C++ program to create a stack with
// given capacity
#include <bits/stdc++.h>
using namespace std; 

class Stack { 
    int top, cap; 
    int *a; 

public: 
    Stack(int cap) { 
        this->cap = cap; 
        top = -1; 
        a = new int[cap]; 
    } 

    ~Stack() { 
        delete[] a; 
    } 

    bool push(int x) { 
        if (top >= cap - 1) { 
            cout << "Stack Overflow\\n"; 
            return false; 
        } 
        a[++top] = x; 
        return true; 
    } 

    int pop() { 
        if (top < 0) { 
            cout << "Stack Underflow\\n"; 
            return 0; 
        } 
        return a[top--]; 
    } 

    int peek() { 
        if (top < 0) { 
            cout << "Stack is Empty\\n"; 
            return 0; 
        } 
        return a[top]; 
    } 

    bool isEmpty() { 
        return top < 0; 
    } 
}; 

int main() { 
    Stack s(5); 
    s.push(10); 
    s.push(20); 
    s.push(30); 
    cout << s.pop() << " popped from stack\\n"; 

    cout << "Top element is: " << s.peek() << endl; 

    cout << "Elements present in stack: "; 
    while (!s.isEmpty()) { 
        cout << s.peek() << " "; 
        s.pop(); 
    } 

    return 0; 
}
```
```c
// C program to create a stack with given capacity
#include <stdio.h>
#include <stdlib.h>

struct Stack {
    int top, cap;
    int *a;
};

struct Stack* createStack(int cap) {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->cap = cap;
    stack->top = -1;
    stack->a = (int*)malloc(cap * sizeof(int));
    return stack;
}

void deleteStack(struct Stack* stack) {
    free(stack->a);
    free(stack);
}

int isFull(struct Stack* stack) {
    return stack->top >= stack->cap - 1;
}

int isEmpty(struct Stack* stack) {
    return stack->top < 0;
}

int push(struct Stack* stack, int x) {
    if (isFull(stack)) {
        printf("Stack Overflow\\n");
        return 0;
    }
    stack->a[++stack->top] = x;
    return 1;
}

int pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack Underflow\\n");
        return 0;
    }
    return stack->a[stack->top--];
}

int peek(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf("Stack is Empty\\n");
        return 0;
    }
    return stack->a[stack->top];
}

int main() {
    struct Stack* s = createStack(5);
    push(s, 10);
    push(s, 20);
    push(s, 30);
    printf("%d popped from stack\\n", pop(s));

    printf("Top element is: %d\\n", peek(s));

    printf("Elements present in stack: ");
    while (!isEmpty(s)) {
        printf("%d ", peek(s));
        pop(s);
    }

    deleteStack(s);
    return 0;
}
```
```java
// Java program to create a stack with given capacity
class Stack { 
    int top, cap; 
    int[] a; 

    public Stack(int cap) { 
        this.cap = cap; 
        top = -1; 
        a = new int[cap]; 
    } 

    public boolean push(int x) { 
        if (top >= cap - 1) { 
            System.out.println("Stack Overflow"); 
            return false; 
        } 
        a[++top] = x; 
        return true; 
    } 

    public int pop() { 
        if (top < 0) { 
            System.out.println("Stack Underflow"); 
            return 0; 
        } 
        return a[top--]; 
    } 

    public int peek() { 
        if (top < 0) { 
            System.out.println("Stack is Empty"); 
            return 0; 
        } 
        return a[top]; 
    } 

    public boolean isEmpty() { 
        return top < 0; 
    } 
} 

public class Main { 
    public static void main(String[] args) { 
        Stack s = new Stack(5); 
        s.push(10); 
        s.push(20); 
        s.push(30); 
        System.out.println(s.pop() + " popped from stack"); 

        System.out.println("Top element is: " + s.peek()); 

        System.out.print("Elements present in stack: "); 
        while (!s.isEmpty()) { 
            System.out.print(s.peek() + " "); 
            s.pop(); 
        } 
    } 
}
```
```python
# Create a stack with given capacity
class Stack:
    def __init__(self, cap):
        self.cap = cap
        self.top = -1
        self.a = [0] * cap

    def push(self, x):
        if self.top >= self.cap - 1:
            print("Stack Overflow")
            return False
        self.top += 1
        self.a[self.top] = x
        return True

    def pop(self):
        if self.top < 0:
            print("Stack Underflow")
            return 0
        popped = self.a[self.top]
        self.top -= 1
        return popped

    def peek(self):
        if self.top < 0:
            print("Stack is Empty")
            return 0
        return self.a[self.top]

    def is_empty(self):
        return self.top < 0

s = Stack(5)
s.push(10)
s.push(20)
s.push(30)
print(s.pop(), "popped from stack")

print("Top element is:", s.peek())

print("Elements present in stack:", end=" ")
while not s.is_empty():
    print(s.peek(), end=" ")
    s.pop()
```
```c#
// Create a stack with given capacity
using System;

class Stack {
    private int top, cap;
    private int[] a;

    public Stack(int cap) {
        this.cap = cap;
        top = -1;
        a = new int[cap];
    }

    public bool Push(int x) {
        if (top >= cap - 1) {
            Console.WriteLine("Stack Overflow");
            return false;
        }
        a[++top] = x;
        return true;
    }

    public int Pop() {
        if (top < 0) {
            Console.WriteLine("Stack Underflow");
            return 0;
        }
        return a[top--];
    }

    public int Peek() {
        if (top < 0) {
            Console.WriteLine("Stack is Empty");
            return 0;
        }
        return a[top];
    }

    public bool IsEmpty() {
        return top < 0;
    }
}

class Program {
    static void Main() {
        Stack s = new Stack(5);
        s.Push(10);
        s.Push(20);
        s.Push(30);
        Console.WriteLine(s.Pop() + " popped from stack");

        Console.WriteLine("Top element is: " + s.Peek());

        Console.Write("Elements present in stack: ");
        while (!s.IsEmpty()) {
            Console.Write(s.Peek() + " ");
            s.Pop();
        }
    }
}
```
```javascript
// Create a stack with given capacity
class Stack {
    constructor(cap) {
        this.cap = cap;
        this.top = -1;
        this.a = new Array(cap);
    }

    push(x) {
        if (this.top >= this.cap - 1) {
            console.log("Stack Overflow");
            return false;
        }
        this.a[++this.top] = x;
        return true;
    }

    pop() {
        if (this.top < 0) {
            console.log("Stack Underflow");
            return 0;
        }
        return this.a[this.top--];
    }

    peek() {
        if (this.top < 0) {
            console.log("Stack is Empty");
            return 0;
        }
        return this.a[this.top];
    }

    isEmpty() {
        return this.top < 0;
    }
}

let s = new Stack(5);
s.push(10);
s.push(20);
s.push(30);
console.log(s.pop() + " popped from stack");

console.log("Top element is:", s.peek());

console.log("Elements present in stack:");
while (!s.isEmpty()) {
    console.log(s.peek() + " ");
    s.pop();
}
```



```output
30 popped from stack
Top element is: 20
Elements pre
sent in stack: 20 10 
```

# Implementation using Dynamic Sized Array

In this implementation, we use a dynamic sized array like [vector in C++](https://www.geeksforgeeks.org/vector-in-cpp-stl/), [ArrayList in Java](https://www.geeksforgeeks.org/arraylist-in-java/), [List in Python](https://www.geeksforgeeks.org/python-lists/) and [Array in JavaScript](https://www.geeksforgeeks.org/javascript-arrays/). This is a simpler implementation but less efficient compared to the previous one if we know capacity in advance.

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> s;

    // Push elements
    s.push_back(10);
    s.push_back(20);
    s.push_back(30);

    // Pop and print the top element
    cout << s.back() << " popped from stack\\n";
    s.pop_back();

    // Peek at the top element
    cout << "Top element is: " << s.back() << endl;

    // Print all elements in the stack
    cout << "Elements present in stack: ";
    while (!s.empty()) {
        cout << s.back() << " ";
        s.pop_back();
    }

    return 0;
}
```
```c
// No dynamic array support
```
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<Integer> s = new ArrayList<>();

        // Push elements
        s.add(10);
        s.add(20);
        s.add(30);

        // Pop and print the top element
        System.out.println(s.get(s.size() - 1) + " popped from stack");
        s.remove(s.size() - 1);

        // Peek at the top element
        System.out.println("Top element is: " + s.get(s.size() - 1));

        // Print all elements in the stack
        System.out.print("Elements present in stack: ");
        while (!s.isEmpty()) {
            System.out.print(s.get(s.size() - 1) + " ");
            s.remove(s.size() - 1);
        }
    }
}
```
```python
s = []

# Push elements
s.append(10)
s.append(20)
s.append(30)

# Pop and print the top element
print(f\'{s[-1]} popped from stack\')
s.pop()

# Peek at the top element
print(f\'Top element is: {s[-1]}\')

# Print all elements in the stack
print(\'Elements present in stack: \', end=\'\')
while s:
    print(s.pop(), end=\' \')
```
```c#
using System;
using System.Collections.Generic;

class GfG {
    static void Main() {
        Stack<int> s = new Stack<int>();

        // Push elements
        s.Push(10);
        s.Push(20);
        s.Push(30);

        // Pop and print the top element
        Console.WriteLine(s.Peek() + " popped from stack");
        s.Pop();

        // Peek at the top element
        Console.WriteLine("Top element is: " + s.Peek());

        // Print all elements in the stack
        Console.WriteLine("Elements present in stack: ");
        while (s.Count > 0) {
            Console.Write(s.Pop() + " ");
        }
    }
}
```
```javascript
// Using an array to simulate stack behavior
let s = [];

// Push elements
s.push(10);
s.push(20);
s.push(30);

// Pop and print the top element
console.log(s[s.length - 1] + " popped from stack");
s.pop();

// Peek at the top element
console.log("Top element is: " + s[s.length - 1]);

// Print all elements in the stack
console.log("Elements present in stack: ");
while (s.length > 0) {
    console.log(s[s.length - 1] + " ");
    s.pop();
}
```


# Comparison of the two Implementations

-   The first implementation should be preferred if we know capacity or have a close upper bound on number of elements.
-   The second one is simple and has amortized (average over n operations) time complexities as O(1) for push and pop. However it can have a particular push and pop very costly.

# Complexity Analysis:

-   ****Time Complexity****:
    -   `push`: O(1)
    -   `pop`: O(1)
    -   `peek`: O(1)
    -   `is_empty`: O(1)
    -   is\\_full: O(1)
-   ****Auxiliary Space****: O(n), where n is the number of items in the stack.

# Advantages of Array Implementation:

-   Easy to implement.
-   Memory is saved as pointers are not involved.

# Disadvantages of Array Implementation:

-   It is not dynamic i.e., it doesn’t grow and shrink depending on needs at runtime. \\[But in case of dynamic sized arrays like vector in C++, list in Python, ArrayList in Java, stacks can grow and shrink with array implementation as well\\]. But with dynamic sized arrays, we get amortized time complexity as O(1), not the worst case. If we use linked list, we get worst case time complexities as O(1).
-   The total size of the stack must be defined beforehand.', e'Stack is a linear data structurewhich follows LIFO principle. In this article, we will learn how to implement Stack using
Arrays. In Array-based approach, all stack-related operations are
executed using arrays. Let’s see how we can implement each operation on
the stack utilizing the Array Data Structure.', 'Implement Stack using Array', 12, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('fe47d547-098c-4d93-a52b-09f5533ea97c', e'# FIFO Principle in Queue
FIFO Principle states that the first element added to the Queue will be the first one to be removed or processed. So, Queue is like a line of people waiting to purchase tickets, where the first person in line is the first person served. (i.e. First Come First Serve).

 
![FIFO-Principle-First-In-First-Out-1](https://media.geeksforgeeks.org/wp-content/uploads/20241213121625618949/FIFO-Principle-First-In-First-Out-1.webp)

 
# Basic Terminologies of Queue
- ****Front:**** Position of the entry in a queue ready to be served, that is, the first entry that will be removed from the queue, is called the ****front**** of the queue. It is also referred as the ****head**** of the queue.

- ****Rear:**** Position of the last entry in the queue, that is, the one most recently added, is called the ****rear**** of the queue. It is also referred as the ****tail**** of the queue.

- ****Size:**** Size refers to the ****current**** number of elements in the queue.

- ****Capacity:**** Capacity refers to the ****maximum**** number of elements the queue can hold.

  

## Representation of Queue

  

![Representation-of-Queue-Data-Structure](https://media.geeksforgeeks.org/wp-content/uploads/20241212130245410876/Representation-of-Queue-Data-Structure-768.webp)

  

## Queue Operations

  

1. ****Enqueue****: Adds an element to the end (rear) of the queue. If the queue is full, an overflow error occurs.

2. ****Dequeue****: Removes the element from the front of the queue. If the queue is empty, an underflow error occurs.

3. ****Peek/Front****: Returns the element at the front without removing it.

4. ****Size****: Returns the number of elements in the queue.

5. ****isEmpty****: Returns `true` if the queue is empty, otherwise `false`.

6. ****isFull****: Returns `true` if the queue is full, otherwise `false`.

  

> For detailed steps and more information on each operation, Read [Basic Operations for Queue in Data Structure](https://www.geeksforgeeks.org/basic-operations-for-queue-in-data-structure/).

  

# Implementation of Queue Data Structure

  

Queue can be implemented using following data structures:

  

- [Simple Array implementation of Queue](https://www.geeksforgeeks.org/array-implementation-of-queue-simple/)

- [Efficient Array Implementation of Queue](https://www.geeksforgeeks.org/introduction-to-circular-queue/)

- [Implementation of Queue using Linked List](https://www.geeksforgeeks.org/queue-linked-list-implementation)

  

## Complexity Analysis of Operations on Queue

  

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****enqueue**** | O(1) | O(1) |
| ****dequeue**** | O(1) | O(1) |
| front |O(1) |O(1) |
| size | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| isFull | O(1) |O(1) |

  

## Types of Queues

  

Queue data structure can be classified into 4 types:

  

1. ****Simple Queue:**** Simple Queue simply follows ****FIFO**** Structure. We can only insert the element at the back and remove the element from the front of the queue. A simple queue is efficiently implemented either using a linked list or a circular array.

2. ****Double-Ended Queue (Deque):**** In a [double-ended queue](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/) the insertion and deletion operations, both can be performed from both ends. They are of two types:

- ****Input Restricted Queue:**** This is a simple queue. In this type of queue, the input can be taken from only one end but deletion can be done from any of the ends.

- ****Output Restricted Queue:**** This is also a simple queue. In this type of queue, the input can be taken from both ends but deletion can be done from only one end.

3. ****Priority Queue:**** A [priority queue](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/) is a special queue where the elements are accessed based on the priority assigned to them. They are of two types:

  

- ****Ascending Priority Queue:**** In Ascending Priority Queue, the elements are arranged in increasing order of their priority values. Element with smallest priority value is popped first.

  

- ****Descending Priority Queue:**** In Descending Priority Queue, the elements are arranged in decreasing order of their priority values. Element with largest priority is popped first.

  

![Types-of-Queue](https://media.geeksforgeeks.org/wp-content/uploads/20241212125924381216/Types-of-Queue-660.webp)

  
  

# Applications of Queue Data Structure

  

Application of queue is common. In a computer system, there may be queues of tasks waiting for the printer, for access to disk storage, or even in a time-sharing system, for use of the CPU. Within a single program, there may be multiple requests to be kept in a queue, or one task may create other tasks, which must be done in turn by keeping them in a queue.

  

- A Queue is always used as a buffer when we have a speed mismatch between a producer and consumer. For example keyboard and CPU.

- Queue can be used where we have a single resource and multiple consumers like a single CPU and multiple processes.

- In a network, a queue is used in devices such as a router/switch and mail queue.

- Queue can be used in various algorithm techniques like Breadth First Search, Topological Sort, etc.', 'Queue is a linear data structure that follows FIFO (First In First Out) Principle', 'Introduction to Queue Data Structure', 14, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('9a7d3527-1c48-4e9d-8aac-990f873ca15d', e'# Basic Operations on Queue

Some of the basic operations for Queue in Data Structure are:
* **enqueue() –**  Insertion of elements to the queue.
* **dequeue() –**  Removal of elements from the queue.
* **peek() or front()-**  Acquires the data element available at the front node of the queue without deleting it.
* **rear() –**  This operation returns the element at the rear end without removing it.
* **isFull() –**  Validates if the queue is full.
* **isEmpty() –**  Checks if the queue is empty.
* **size():**  This operation returns the size of the queue i.e. the total number of elements it contains.

![](https://media.geeksforgeeks.org/wp-content/uploads/20221209094646/Queue-768.png)

## Operation 1: enqueue()

Inserts an element at the end of the queue i.e. at the rear end.
The following steps should be taken to enqueue (insert) data into a queue:
* Check if the queue is full.
* If the queue is full, return overflow error and exit.
* If the queue is not full, increment the rear pointer to point to the next empty space.
* Add the data element to the queue location, where the rear is pointing.
* return success.
* ![](https://media.geeksforgeeks.org/wp-content/uploads/20250328115918785686/Enqueue-Operation-in-Queue-1.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20250328115918927176/Enqueue-Operation-in-Queue-2.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20250328115919060458/Enqueue-Operation-in-Queue-3.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20250328115919253776/Enqueue-Operation-in-Queue-4.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20250328115919410670/Enqueue-Operation-in-Queue-5.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20250328115919612752/Enqueue-Operation-in-Queue-6.webp)




Below is the Implementation of the above approach:
```C++
void queueEnqueue(int data) {
  // Check queue is full or not
  if (capacity == rear) {
    printf("\\nQueue is full\\n");
    return;
  }

  // Insert element at the rear
  else {
    queue[rear] = data;
    rear++;
  }
  return;
}
```
```Java
Comming soon...
```
```C
// Function to add an item to the queue.
// It changes rear and size
void enqueue(struct Queue* queue, int item) {
  if (isFull(queue)) return;
  queue->rear = (queue->rear + 1) % queue->capacity;
  queue->array[queue->rear] = item;
  queue->size = queue->size + 1;
  printf("%d enqueued to queue\\n", item);
}

// This code is contributed by Susobhan Akhuli
```
```C#
// Function to add an item to the queue.
// It changes rear and size
public void enqueue(int item)
{
    if (rear == max - 1)
    {
        Console.WriteLine("Queue Overflow");
        return;
    }
    else
    {
        ele[++rear] = item;
    }
}

// This code is contributed by Susobhan Akhuli
```
```Javascript
Comming soon...
```







**Complexity Analysis:**
* **Time Complexity:** O(1)
 
* **Space Complexity:** O(N)

## Operation 2: dequeue()

This operation removes and returns an element that is at the front end of the queue.

The following steps are taken to perform the dequeue operation:

* Check if the queue is empty.
* If the queue is empty, return the underflow error and exit.
* If the queue is not empty, access the data where the front is pointing.
* Increment the front pointer to point to the next available data element.
* The Return success.

![Dequeue operation](https://media.geeksforgeeks.org/wp-content/uploads/20220805122625/fifo2-660x371.png)

Dequeue operation

Below is the Implementation of above approach:
```C++
void queueDequeue() {
  // If queue is empty
  if (front == rear) {
    printf("\\nQueue is empty\\n");
    return;
  }

  // Shift all the elements from index 2
  // till rear to the left by one
  else {
    for (int i = 0; i < rear - 1; i++) {
      queue[i] = queue[i + 1];
    }

    // decrement rear
    rear--;
  }
  return;
}
```
```Java
Comming soon...
```
```C
// Function to remove an item from queue.
// It changes front and size
int dequeue(struct Queue* queue) {
  if (isEmpty(queue)) {
    printf("\\nQueue is empty\\n");
    return;
  }
  int item = queue->array[queue->front];
  queue->front = (queue->front + 1) % queue->capacity;
  queue->size = queue->size - 1;
  return item;
}

// This code is contributed by Susobhan Akhuli
```
```C#
// Function to remove an item from queue.
// It changes front and size
public int dequeue()
{
    if (front == rear + 1)
    {
        Console.WriteLine("Queue is Empty");
        return -1;
    }
    else
    {
        int p = ele[front++];
        return p;
    }
}
// This code is contributed by Susobhan Akhuli
```
```Javascript
Comming soon...
```







**Complexity Analysis:**
* **Time Complexity:** O(1)
* **Space Complexity:** O(N)

## Operation 3: front()

This operation returns the element at the front end without removing it.

The following steps are taken to perform the front operation:

* If the queue is empty return the most minimum value.
* otherwise, return the front value.

Below is the Implementation of the above approach:
```C++
// Function to get front of queue
int front(Queue* queue) {
  if (isempty(queue)) return INT_MIN;
  return queue->arr[queue->front];
}
```
```Java
Comming soon...
```
```C
// Function to get front of queue
int front(struct Queue* queue) {
  if (isempty(queue)) return INT_MIN;
  return queue->arr[queue->front];
}

// This code is contributed by Susobhan Akhuli
```
```C#
// Function to get front of queue
public int front()
{
    if (isempty())
        return INT_MIN;
    return arr[front];
}

// This code is contributed By Susobhan Akhuli
```
```Javascript
Comming soon...
```







**Complexity Analysis:**
 * **Time Complexity:** O(1)
* **Space Complexity:** O(N)

## Operation 4 : rear()

This operation returns the element at the rear end without removing it.

The following steps are taken to perform the rear operation:

* If the queue is empty return the most minimum value.
* otherwise, return the rear value.

Below is the Implementation of the above approach:
```C++
// Function to get rear of queue
int rear(Queue* queue) {
  if (isEmpty(queue)) return INT_MIN;
  return queue->arr[queue->rear];
}
```
```Java
Comming soon...
```
```C
// Function to get front of queue
int front(struct Queue* queue) {
  if (isempty(queue)) return INT_MIN;
  return queue->arr[queue->rear];
}

// This code is contributed by Susobhan Akhuli
```
```C#
// Function to get front of queue
public int front()
{
    if (isempty())
        return INT_MIN;
    return arr[rear];
}

// This code is contributed By Susobhan Akhuli
```
```Javascript
Comming soon...
```

**Complexity Analysis:**
  * **Time Complexity:** O(1)
  * **Space Complexity:** O(N)

## Operation 5: isEmpty():

This operation returns a boolean value that indicates whether the queue is empty or not.

The following steps are taken to perform the Empty operation:

* check if front value is equal to -1 or not, if yes then return true means queue is empty.
* Otherwise return false, means queue is not empty

Below is the implementation of the above approach:
```C++
// This function will check whether
// the queue is empty or not:
bool isEmpty() {
  if (front == -1)
    return true;
  else
    return false;
}
```
```Java
Comming soon...
```
```C#
// This function will check whether
// the queue is empty or not:
bool isEmpty()
{
    if (front == -1)
        return true;
    else
        return false;
}

// This code is contributed by lokeshmvs21.
```
```C
// Queue is empty when size is 0
bool isEmpty(struct Queue* queue) { return (queue->size == 0); }

// This code is contributed by Susobhan Akhuli
```
```Javascript
Comming soon...
```







**Complexity Analysis:**
* **Time Complexity:** O(1)
* **Space Complexity:** O(N)

## Operation 6 : isFull()

This operation returns a boolean value that indicates whether the queue is full or not.

The following steps are taken to perform the isFull() operation:

* Check if front value is equal to zero and rear is equal to the capacity of queue if yes then return true.
* otherwise return false

Below is the Implementation of the above approach:
```C++
// This function will check
// whether the queue is full or not.
bool isFull() {
  if (front == 0 && rear == MAX_SIZE - 1) {
    return true;
  }
  return false;
}
```
```Java
Comming soon...
```
```C
// Queue is full when size becomes
// equal to the capacity
bool isFull(struct Queue* queue) { return (queue->size == queue->capacity); }

// This code is contributed by Susobhan Akhuli
```
```C#
// Function to add an item to the queue.
// It changes rear and size
public bool isFull(int item) { return (rear == max - 1); }
// This code is contributed by Susobhan Akhuli
```
```Javascript
function isFull() {
  if (front == 0 && rear == MAX_SIZE - 1) {
    return true;
  }
  return false;
}

// This code is contributed by aadityamaharshi21.

```







**Complexity Analysis:**
* **Time Complexity:** O(1)
* **Space Complexity:** O(N)

## Operation 7: size()

This operation returns the size of the queue i.e. the total number of elements it contains.

```
queuename.size()
Parameters :
No parameters are passed
Returns : Number of elements in the container
```


```c++
// CPP program to illustrate
// Implementation of size() function
#include <iostream>
#include <queue>
using namespace std;

int main() {
  int sum = 0;
  queue<int> myqueue;
  myqueue.push(1);
  myqueue.push(8);
  myqueue.push(3);
  myqueue.push(6);
  myqueue.push(2);

  // Queue becomes 1, 8, 3, 6, 2

  cout << myqueue.size();

  return 0;
}
```
```Java
// Java program to illustrate implementation of size()
// function

import java.util.*;

public class Main {
  public static void main(String[] args) {
    int sum = 0;
    Queue<Integer> myqueue = new LinkedList<>();
    myqueue.add(1);
    myqueue.add(8);
    myqueue.add(3);
    myqueue.add(6);
    myqueue.add(2);

    // Queue becomes 1, 8, 3, 6, 2

    System.out.println(myqueue.size());
  }
}

// This code is contributed by lokesh.
```
```C#
using System;
using System.Collections.Generic;

namespace ConsoleApp1
{
    class MainClass
    {
        public static void Main(string[] args)
        {
            int sum = 0;
            Queue<int> myqueue = new Queue<int>();
            myqueue.Enqueue(1);
            myqueue.Enqueue(8);
            myqueue.Enqueue(3);
            myqueue.Enqueue(6);
            myqueue.Enqueue(2);

            // Queue becomes 1, 8, 3, 6, 2

            Console.WriteLine(myqueue.Count);
        }
    }
}

// This code is contributed by adityamaharshi21.
```
```Javascript
// Javascript code
let sum = 0;
let myqueue = [];
myqueue.push(1);
myqueue.push(8);
myqueue.push(3);
myqueue.push(6);
myqueue.push(2);

// Queue becomes 1, 8, 3, 6, 2

console.log(myqueue.length);

```

**Complexity Analysis:**
* **Time Complexity:** O(1)
* **Space Complexity:** O(N)

# Applications of Queue:

-   ****Multi programming:**** Multi programming means when multiple programs are running in the main memory. It is essential to organize these multiple programs and these multiple programs are organized as queues. 
-   ****Network:**** In a network, a queue is used in devices such as a router or a switch. another application of a queue is a mail queue which is a directory that stores data and controls files for mail messages.
-   ****Job Scheduling:**** The computer has a task to execute a particular number of jobs that are scheduled to be executed one after another. These jobs are assigned to the processor one by one which is organized using a queue.
-   ****Shared resources:**** Queues are used as waiting lists for a single shared resource.

# Real-time application of Queue

-   Working as a buffer between a slow and a fast device. For example keyboard and CPU, and two devices on network.
-   ATM Booth Line
-   Ticket Counter Line
-   CPU task scheduling
-   Waiting time of each customer at call centers.

## Advantages of Queue:

-   A large amount of data can be managed efficiently with ease.
-   Operations such as insertion and deletion can be performed with ease as it follows the first in first out rule.
-   Queues are useful when a particular service is used by multiple consumers.
-   Queues are fast in speed for data inter-process communication.
-   Queues can be used in the implementation of other data structures.

## Disadvantages of Queue:

-   The operations such as insertion and deletion of elements from the middle are time consuming.
-   In a classical queue, a new element can only be inserted when the existing elements are deleted from the queue.
-   Searching an element takes O(N) time.
-   Maximum size of a queue must be defined prior in case of array implementation.', 'Queue is a linear data structure that follows FIFO (First In First Out) Principle', 'Basic Operations on Queue', 15, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('2220549e-2da8-4f0c-9d38-2495ce6b234e', e'# Array implementation of queue – Simple

Please note that a simple array implementation discussed here is not used in practice as it is not efficient. In practice, we either use [Linked List Implementation of Queue](https://www.geeksforgeeks.org/queue-set-2-linked-list-implementation/) or [circular array implementation of queue](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/). The idea of this post is to give you a background as to why we need a circular array implementation.

- The queue uses an array with a fixed capacity, referred to as capacity, and tracks the current number of elements with a variable size.

- The variable front is initialized to 0 and represents the index of the first element in the array. In the dequeue operation, the element at this index is removed.

To implement a queue of size n using an array, the operations are as follows
- ****Enqueue:**** Adds new elements to the ****end**** of the queue. Checks if the queue has space before insertion, then increments the size.
- ****Dequeue:**** Removes the ****front element**** by shifting all remaining elements ****one position to the left.**** Decrements the queue size after removal.
- ****getFront:**** Returns the first element of the queue if it’s not empty. ****Returns -1**** if the queue is empty.
- ****Display:**** Iterates through the queue from the front to the current size and prints each element.

  
![](https://media.geeksforgeeks.org/wp-content/uploads/20241224111841540041/Array-implementation-of-queue-1.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241224111841680300/Array-implementation-of-queue-2.webp)
![Array-implementation-of-queue-3.webp](https://media.geeksforgeeks.org/wp-content/uploads/20241224111841223074/Array-implementation-of-queue-3.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241224111841395458/Array-implementation-of-queue-4.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241224111841081338/Array-implementation-of-queue-5.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20241224111840920211/Array-implementation-of-queue-6.webp)

  

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Queue {
    vector<int> q;

public:
    bool isEmpty() { return q.empty(); }

    void enqueue(int x) {
        q.push_back(x);
    }

    void dequeue() {
        if (!isEmpty()) q.erase(q.begin());
    }

    int getFront() {
        return isEmpty() ? -1 : q.front();
    }

    void display() {
        for (int x : q) cout << x << " ";
        cout << "\\n";
    }
};

int main() {
    Queue q;
    q.enqueue(1);
    q.enqueue(2);
    q.enqueue(3);
    cout << q.getFront() << endl;
    q.dequeue();
    q.enqueue(4);
    q.display();
}
```
```c
#include <stdio.h>
#include <stdlib.h>

struct Queue {
    int *arr;
    int front;
    int rear;
    int capacity;
};

struct Queue* createQueue(int capacity) {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    queue->capacity = capacity;
    queue->front = 0;
    queue->rear = -1;
    queue->arr = (int*)malloc(capacity * sizeof(int));
    return queue;
}

int isEmpty(struct Queue* queue) {
    return queue->front > queue->rear;
}

void enqueue(struct Queue* queue, int x) {
    if (queue->rear < queue->capacity - 1) {
        queue->arr[++queue->rear] = x;
    }
}

void dequeue(struct Queue* queue) {
    if (!isEmpty(queue)) {
        queue->front++;
    }
}

int getFront(struct Queue* queue) {
    return isEmpty(queue) ? -1 : queue->arr[queue->front];
}

void display(struct Queue* queue) {
    for (int i = queue->front; i <= queue->rear; i++) {
        printf("%d ", queue->arr[i]);
    }
    printf("\\n");
}

int main() {
    struct Queue* q = createQueue(100);
    enqueue(q, 1);
    enqueue(q, 2);
    enqueue(q, 3);
    printf("%d\\n", getFront(q));
    dequeue(q);
    enqueue(q, 4);
    display(q);
    return 0;
}
```
```java
// Java implementation of Queue
import java.util.LinkedList;
import java.util.Queue;

class MyQueue {
    private Queue<Integer> q = new LinkedList<>();

    public boolean isEmpty() { return q.isEmpty(); }

    public void enqueue(int x) { q.add(x); }

    public void dequeue() { if (!isEmpty()) q.poll(); }

    public int getFront() { return isEmpty() ? -1 : q.peek(); }

    public void display() { for (int x : q) System.out.print(x + " "); System.out.println(); }
}

public class Main {
    public static void main(String[] args) {
        MyQueue q = new MyQueue();
        q.enqueue(1);
        q.enqueue(2);
        q.enqueue(3);
        System.out.println(q.getFront());
        q.dequeue();
        q.enqueue(4);
        q.display();
    }
}
```
```python
# Python implementation of Queue
class Queue:
    def __init__(self):
        self.q = []

    def is_empty(self):
        return len(self.q) == 0

    def enqueue(self, x):
        self.q.append(x)

    def dequeue(self):
        if not self.is_empty():
            self.q.pop(0)

    def get_front(self):
        return -1 if self.is_empty() else self.q[0]

    def display(self):
        print(\' \'.join(map(str, self.q)))

if __name__ == \'__main__\':
    q = Queue()
    q.enqueue(1)
    q.enqueue(2)
    q.enqueue(3)
    print(q.get_front())
    q.dequeue()
    q.enqueue(4)
    q.display()
```
```csharp
// C# implementation of Queue
using System;
using System.Collections.Generic;

class Queue {
    private List<int> q = new List<int>();

    public bool IsEmpty() { return q.Count == 0; }

    public void Enqueue(int x) { q.Add(x); }

    public void Dequeue() { if (!IsEmpty()) q.RemoveAt(0); }

    public int GetFront() { return IsEmpty() ? -1 : q[0]; }

    public void Display() { Console.WriteLine(string.Join(" ", q)); }
}

class Program {
    static void Main() {
        Queue q = new Queue();
        q.Enqueue(1);
        q.Enqueue(2);
        q.Enqueue(3);
        Console.WriteLine(q.GetFront());
        q.Dequeue();
        q.Enqueue(4);
        q.Display();
    }
}
```
```javascript
class Queue {
    constructor() {
        this.q = [];
    }

    isEmpty() {
        return this.q.length === 0;
    }

    enqueue(x) {
        this.q.push(x);
    }

    dequeue() {
        if (!this.isEmpty()) this.q.shift();
    }

    getFront() {
        return this.isEmpty() ? -1 : this.q[0];
    }

    display() {
        console.log(this.q.join(\' \'));
    }
}

const q = new Queue();
q.enqueue(1);
q.enqueue(2);
q.enqueue(3);
console.log(q.getFront());
q.dequeue();
q.enqueue(4);
q.display();
```

  
****Time Complexity:**** O(1) for Enqueue (element insertion in the queue) as we simply increment pointer and put value in array, O(n) for Dequeue (element removing from the queue).

****Auxiliary Space:**** O(n), as here we are using an n size array for implementing Queue

  

> We can notice that the Dequeue operation is O(n) which is not acceptable. The enqueue and dequeue both operations should have O(1) time complexity. That is why if we wish to implement a queue using array (because of array advantages like cache friendliness and random access), we do [****circular array implementation of queue****](https://www.geeksforgeeks.org/circular-queue-set-1-introduction-array-implementation/)****.****

  

# Queue – Linked List Implementation
In this article, the Linked List implementation of the [queue data structure](https://www.geeksforgeeks.org/queue-data-structure/) is discussed and implemented. Print \'-1\' if the queue is empty.

****Approach:**** To solve the problem follow the below idea:

> we maintain two pointers, ****front**** and ****rear****. The front points to the first item of the queue and rear points to the last item.
> -   ****enQueue():**** This operation adds a new node after the rear and moves the rear to the next node.
> -   ****deQueue():**** This operation removes the front node and moves the front to the next node.


![Queue-Linked-List-Implementation_](https://media.geeksforgeeks.org/wp-content/uploads/20250325130840080788/Queue-Linked-List-Implementation_.webp)


Follow the below steps to solve the problem:

-   Create a class Node with data members integer data and Node\\* next
    -   A parameterized constructor that takes an integer x value as a parameter and sets data equal to x and next as NULL
-   Create a class Queue with data members Node front and rear
-   Enqueue Operation with parameter x:
    -   Initialize Node\\* temp with data = x
    -   If the rear is set to NULL then set the front and rear to temp and return(Base Case)
    -   Else set rear next to temp and then move rear to temp
-   Dequeue Operation:
    -   If the front is set to NULL return(Base Case)
    -   Initialize Node temp with front and set front to its next
    -   If the front is equal to NULL then set the rear to NULL
    -   Delete temp from the memory

Below is the Implementation of the above approach:

```c++
#include <iostream>
using namespace std;

// Node class definition
class Node {
public:
    int data;
    Node* next;
    Node(int new_data) {
        data = new_data;
        next = nullptr;
    }
};

// Queue class definition
class Queue {
private:
    Node* front;
    Node* rear;
public:
    Queue() {
        front = rear = nullptr;
    }

    // Function to check if the queue is empty
    bool isEmpty() {
        return front == nullptr;
    }

    // Function to add an element to the queue
    void enqueue(int new_data) {
        Node* new_node = new Node(new_data);
        if (isEmpty()) {
            front = rear = new_node;
            printQueue();
            return;
        }
        rear->next = new_node;
        rear = new_node;
        printQueue();
    }

    // Function to remove an element from the queue
    void dequeue() {
        if (isEmpty()) {
            return;
        }
        Node* temp = front;
        front = front->next;
        if (front == nullptr) rear = nullptr;
        delete temp;
        printQueue();
    }

    // Function to print the current state of the queue
    void printQueue() {
        if (isEmpty()) {
            cout << "Queue is empty" << endl;
            return;
        }
        Node* temp = front;
        cout << "Current Queue: ";
        while (temp != nullptr) {
            cout << temp->data << " ";
            temp = temp->next;
        }
        cout << endl;
    }
};

// Driver code to test the queue implementation
int main() {
    Queue q;

    // Enqueue elements into the queue
    q.enqueue(10);
    q.enqueue(20);

    // Dequeue elements from the queue
    q.dequeue();
    q.dequeue();

    // Enqueue more elements into the queue
    q.enqueue(30);
    q.enqueue(40);
    q.enqueue(50);

    // Dequeue an element from the queue (this should print 30)
    q.dequeue();
    
    return 0;
}
```
```c
#include <stdio.h>
#include <stdlib.h>

// Node structure definition
struct Node {
    int data;
    struct Node* next;
};

// Queue structure definition
struct Queue {
    struct Node* front;
    struct Node* rear;
};

// Function to create a new node
struct Node* newNode(int new_data) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node->data = new_data;
    node->next = NULL;
    return node;
}

// Function to initialize the queue
struct Queue* createQueue() {
    struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
    q->front = q->rear = NULL;
    return q;
}

// Function to check if the queue is empty
int isEmpty(struct Queue* q) {
    return q->front == NULL;
}

// Function to add an element to the queue
void enqueue(struct Queue* q, int new_data) {
    struct Node* new_node = newNode(new_data);
    if (isEmpty(q)) {
        q->front = q->rear = new_node;
        printQueue(q);
        return;
    }
    q->rear->next = new_node;
    q->rear = new_node;
    printQueue(q);
}

// Function to remove an element from the queue
void dequeue(struct Queue* q) {
    if (isEmpty(q)) {
        return;
    }
    struct Node* temp = q->front;
    q->front = q->front->next;
    if (q->front == NULL) q->rear = NULL;
    free(temp);
    printQueue(q);
}

// Function to print the current state of the queue
void printQueue(struct Queue* q) {
    if (isEmpty(q)) {
        printf("Queue is empty\\n");
        return;
    }
    struct Node* temp = q->front;
    printf("Current Queue: ");
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\\n");
}

// Driver code to test the queue implementation
int main() {
    struct Queue* q = createQueue();

    // Enqueue elements into the queue
    enqueue(q, 10);
    enqueue(q, 20);

    // Dequeue elements from the queue
    dequeue(q);
    dequeue(q);

    // Enqueue more elements into the queue
    enqueue(q, 30);
    enqueue(q, 40);
    enqueue(q, 50);

    // Dequeue an element from the queue (this should print 30)
    dequeue(q);
    
    return 0;
}
```
```java
// Node class definition
class Node {
    int data;
    Node next;
    Node(int new_data) {
        data = new_data;
        next = null;
    }
}

// Queue class definition
class Queue {
    private Node front;
    private Node rear;
    public Queue() {
        front = rear = null;
    }

    // Function to check if the queue is empty
    public boolean isEmpty() {
        return front == null;
    }

    // Function to add an element to the queue
    public void enqueue(int new_data) {
        Node new_node = new Node(new_data);
        if (isEmpty()) {
            front = rear = new_node;
            printQueue();
            return;
        }
        rear.next = new_node;
        rear = new_node;
        printQueue();
    }

    // Function to remove an element from the queue
    public void dequeue() {
        if (isEmpty()) {
            return;
        }
        Node temp = front;
        front = front.next;
        if (front == null) rear = null;
        temp = null;
        printQueue();
    }

    // Function to print the current state of the queue
    public void printQueue() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        Node temp = front;
        System.out.print("Current Queue: ");
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }
}

// Driver code to test the queue implementation
public class Main {
    public static void main(String[] args) {
        Queue q = new Queue();

        // Enqueue elements into the queue
        q.enqueue(10);
        q.enqueue(20);

        // Dequeue elements from the queue
        q.dequeue();
        q.dequeue();

        // Enqueue more elements into the queue
        q.enqueue(30);
        q.enqueue(40);
        q.enqueue(50);

        // Dequeue an element from the queue (this should print 30)
        q.dequeue();
    }
}
```
```python
class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

class Queue:
    def __init__(self):
        self.front = self.rear = None

    # Function to check if the queue is empty
    def isEmpty(self):
        return self.front is None

    # Function to add an element to the queue
    def enqueue(self, new_data):
        new_node = Node(new_data)
        if self.isEmpty():
            self.front = self.rear = new_node
            self.printQueue()
            return
        self.rear.next = new_node
        self.rear = new_node
        self.printQueue()

    # Function to remove an element from the queue
    def dequeue(self):
        if self.isEmpty():
            return
        temp = self.front
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        
        self.printQueue()

    # Function to print the current state of the queue
    def printQueue(self):
        if self.isEmpty():
            print("Queue is empty")
            return
        temp = self.front
        queue_string = "Current Queue: "
        while temp is not None:
            queue_string += str(temp.data) + " "
            temp = temp.next
        print(queue_string)

q = Queue()

# Enqueue elements into the queue
q.enqueue(10)
q.enqueue(20)

# Dequeue elements from the queue
q.dequeue()
q.dequeue()

# Enqueue more elements into the queue
q.enqueue(30)
q.enqueue(40)
q.enqueue(50)

# Dequeue an element from the queue
q.dequeue()
```
```javascript
// Node class
class Node {
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Queue class
class Queue {
    constructor() {
        this.front = this.rear = null;
    }

    // Function to check if the queue is empty
    isEmpty() {
        return this.front === null;
    }

    // Function to add an element to the queue
    enqueue(new_data) {
        const new_node = new Node(new_data);
        if (this.isEmpty()) {
            this.front = this.rear = new_node;
            this.printQueue();
            return;
        }
        this.rear.next = new_node;
        this.rear = new_node;
        this.printQueue();
    }

    // Function to remove an element from the queue
    dequeue() {
        if (this.isEmpty()) {
            return;
        }
        const temp = this.front;
        this.front = this.front.next;
        if (this.front === null) {
            this.rear = null;
        }
        this.printQueue();
    }

    // Function to print the current state of the queue
    printQueue() {
        if (this.isEmpty()) {
            console.log("Queue is empty");
            return;
        }
        let temp = this.front;
        let queue_string = "Current Queue: ";
        while (temp !== null) {
            queue_string += temp.data + " ";
            temp = temp.next;
        }
        console.log(queue_string);
    }
}

const q = new Queue();

// Enqueue elements into the queue
q.enqueue(10);
q.enqueue(20);

// Dequeue elements from the queue
q.dequeue();
q.dequeue();

// Enqueue more elements into the queue
q.enqueue(30);
q.enqueue(40);
q.enqueue(50);

// Dequeue an element from the queue
q.dequeue();
```


```Output
Current Queue: 10 
Current Queue: 10 20 
Current Queue: 20 
Queue is empty
Current Queue: 30 
Current Queue: 30 40 
Current Queue: 30 40 50 
Current Queue: 40 50 
```

****Time Complexity:**** O(1), The time complexity of both operations enqueue() and dequeue() is O(1) as it only changes a few pointers in both operations  
****Auxiliary Space:**** O(1), The auxiliary Space of both operations enqueue() and dequeue() is O(1) as constant extra space is required', 'Implement with Array and Linked List', ' Implementation of queue', 16, null, 'dc8c4016-8dba-4baf-afea-ada6f0c21ae4', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('8330ff0e-3103-48b6-afe4-9dcc5df76472', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 1, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('93d49a12-3653-4378-b419-b70cd092bbb8', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 18, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('5bdeaf80-2a0a-4799-b094-bc29df554f7b', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 19, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('f59995d1-11f4-41fc-b1dc-4343f67d0843', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 20, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('7b29b491-135b-4e04-b59f-14b14e42c328', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 21, null, 'aa613599-339e-4150-afe7-c11818e51f86', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('627ef438-4902-46e4-b991-f50b533d5b3e', e'# Introduction to Binary Search Tree
****Binary Search Tree**** is a data structure used in computer science for organizing and storing data in a sorted manner. Binary search tree follows all properties of binary tree and for every nodes, its ****left**** subtree contains values less than the node and the ****right**** subtree contains values greater than the node. This hierarchical structure allows for efficient ****Searching****, ****Insertion****, and ****Deletion**** operations on the data stored in the tree.

![Binary-Search-Tree](https://media.geeksforgeeks.org/wp-content/uploads/20240418110011/Binary-Search-Tree.webp)

## Properties of Binary Search Tree:

-   The left subtree of a node contains only nodes with keys less than the node\'s key.
-   The right subtree of a node contains only nodes with keys greater than the node\'s key.
-   The left and right subtree each must also be a binary search tree.  
-   There must be no duplicate nodes(BST may have duplicate values with different handling approaches).

## Test Your Understanding

Given a Binary Tree, find out if it is Binary Search Tree or not.

![Check-if-Binary-Tree-is-a-BST-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240809100806/Check-if-Binary-Tree-is-a-BST-1.webp)![Check-if-Binary-Tree-is-a-BST-2.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240809100806/Check-if-Binary-Tree-is-a-BST-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240809100807/Check-if-Binary-Tree-is-a-BST-3.webp)


## Important Points about BST

-   A Binary Search Tree is useful for maintaining sorted stream of data. It allows search, insert, delete, ceiling, max and min in O(h) time. Along with these, we can always traverse the tree items in sorted order.
-   With Self Balancing BSTs, we can ensure that the height of the BST is bound be Log n. Hence we achieve, the above mentioned O(h) operations in O(Log n) time.
-   When we need only search, insert and delete and do not need other operations, we prefer [Hash Table](https://www.geeksforgeeks.org/hash-table-data-structure/) over BST as a Hash Table supports these operations in O(1) time on average.

# Basic Operations on BST
## Insertion
Given a ****BST****, the task is to insert a new node in this ****BST****.

****Example:****

![Insertion-in-BST](https://media.geeksforgeeks.org/wp-content/uploads/20240924161600/Insertion-in-BST.webp)

### How to Insert a value in a Binary Search Tree:

A new key is always inserted at the leaf by maintaining the property of the binary search tree. We start searching for a key from the root until we hit a leaf node. Once a leaf node is found, the new node is added as a child of the leaf node. The below steps are followed while we try to insert a node into a binary search tree:

-   Initilize the current node (say, ****currNode or node****) with root node
-   Compare the ****key**** with the current node.
-   ****Move left**** if the ****key**** is less than or equal to the current node value.
-   ****Move right**** if the ****key**** is greater than current node value.
-   Repeat steps 2 and 3 until you reach a leaf node.
-   Attach the ****new key**** as a left or right child based on the comparison with the leaf node\'s value.

Follow the below illustration for a better understanding:

![Insertion-in-BST-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240924155200/Insertion-in-BST-1.webp)![Insertion-in-BST-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240924155200/Insertion-in-BST-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240924155201/Insertion-in-BST-3.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240924155201/Insertion-in-BST-4.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240924155202/Insertion-in-BST-5.webp)


### Insertion in Binary Search Tree using Recursion:

Below is the implementation of the insertion operation using recursion.

```cpp
#include <iostream>
using namespace std;

struct Node {
    int key;
    Node* left;
    Node* right;    
    Node(int item) {
        key = item;
        left = NULL;
        right = NULL;
    }
};

// A utility function to insert a new node with 
// the given key
Node* insert(Node* node, int key) {
  
    // If the tree is empty, return a new node
    if (node == NULL) 
        return new Node(key);    
    
    // If the key is already present in the tree,
    // return the node
    if (node->key == key) 
        return node;
    
    // Otherwise, recur down the tree/ If the key
    // to be inserted is greater than the node\'s key,
    // insert it in the right subtree
    if (node->key < key) 
        node->right = insert(node->right, key);
    
    // If the key to be inserted is smaller than 
    // the node\'s key,insert it in the left subtree
    else 
        node->left = insert(node->left, key);
    
    // Return the (unchanged) node pointer
    return node;
}

// A utility function to do inorder tree traversal
void inorder(Node* root) {
    if (root != NULL) {
        inorder(root->left);
        cout << root->key << " ";
        inorder(root->right);
    }
}

// Driver program to test the above functions
int main() {
    // Creating the following BST
    //      50
    //     /  \\
    //    30   70
    //   / \\   / \\
    //  20 40 60 80

    Node* root = new Node(50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    // Print inorder traversal of the BST
    inorder(root);

    return 0;
}
```
```java
class Node {
    int key;
    Node left, right;

    public Node(int item)
    {
        key = item;
        left = right = null;
    }
}

class GfG {

    // A utility function to insert a new node
    // with the given key
    static Node insert(Node root, int key)
    {

        // If the tree is empty, return a new node
        if (root == null)
            return new Node(key);

        // If the key is already present in the tree,
        // return the node
        if (root.key == key)
            return root;

        // Otherwise, recur down the tree
        if (key < root.key)
            root.left = insert(root.left, key);
        else
            root.right = insert(root.right, key);

        // Return the (unchanged) node pointer
        return root;
    }

    // A utility function to do inorder tree traversal
    static void inorder(Node root)
    {
        if (root != null) {
            inorder(root.left);
            System.out.print(root.key + " ");
            inorder(root.right);
        }
    }

    // Driver method
    public static void main(String[] args)
    {
        Node root = null;

        // Creating the following BST
        //      50
        //     /  \\
        //    30   70
        //   / \\   / \\
        //  20 40 60 80

        root = insert(root, 50);
        root = insert(root, 30);
        root = insert(root, 20);
        root = insert(root, 40);
        root = insert(root, 70);
        root = insert(root, 60);
        root = insert(root, 80);

        // Print inorder traversal of the BST
        inorder(root);
    }
}
```
```python
# Python program to demonstrate
# insert operation in binary search tree
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key


# A utility function to insert
# a new node with the given key
def insert(root, key):
    if root is None:
        return Node(key)
    if root.val == key:
            return root
    if root.val < key:
            root.right = insert(root.right, key)
    else:
            root.left = insert(root.left, key)
    return root


# A utility function to do inorder tree traversal
def inorder(root):
    if root:
        inorder(root.left)
        print(root.val, end=" ")
        inorder(root.right)


# Creating the following BST
#      50
#     /  \\
#    30   70
#   / \\   / \\
#  20 40 60 80
r = Node(50)
r = insert(r, 30)
r = insert(r, 20)
r = insert(r, 40)
r = insert(r, 70)
r = insert(r, 60)
r = insert(r, 80)

# Print inorder traversal of the BST
inorder(r)
```
```csharp
using System;

class Node {
    public int key;
    public Node left, right;

    public Node(int item) {
        key = item;
        left = right = null;
    }
}

class GfG {
  
    // A function to insert a new node with the given key
    public static Node Insert(Node node, int key) {
        if (node == null)
            return new Node(key);
      
        // Duplicates not allowed
        if (key == node.key)
            return node;
      
        if (key < node.key)
            node.left = Insert(node.left, key);
        else if (key > node.key)
            node.right = Insert(node.right, key);

        return node;
    }

    // A utility function to do inorder tree traversal
    public static void Inorder(Node root) {
        if (root != null) {
            Inorder(root.left);
            Console.Write(root.key + " ");
            Inorder(root.right);
        }
    }

    // Driver method
    public static void Main() {
        // Creating the following BST
        //      50
        //     /  \\
        //    30   70
        //   / \\   / \\
        //  20 40 60 80

        Node root = new Node(50);
        root = Insert(root, 30);
        root = Insert(root, 20);
        root = Insert(root, 40);
        root = Insert(root, 70);
        root = Insert(root, 60);
        root = Insert(root, 80);

        // Print inorder traversal of the BST
        Inorder(root);
    }
}
```
```javascript
class Node {
    constructor(key) {
        this.key = key;
        this.left = null;
        this.right = null;
    }
}

// A utility function to insert a new
// node with the given key
function insert(root, key) {

    if (root === null)
        return new Node(key);
        
    // Duplicates not allowed    
    if (root.key === key)
        return root;
        
    if (key < root.key)
        root.left = insert(root.left, key);
    else if (key > root.key)
        root.right = insert(root.right, key);

    return root;
}

// A utility function to do inorder
// tree traversal
function inorder(root) {
    if (root !== null) {
        inorder(root.left);
        console.log(root.key + " ");
        inorder(root.right);
    }
}

// Creating the following BST
//      50
//     /  \\
//    30   70
//   / \\   / \\
//  20 40 60 80

let root = new Node(50);
root = insert(root, 30);
root = insert(root, 20);
root = insert(root, 40);
root = insert(root, 70);
root = insert(root, 60);
root = insert(root, 80);

// Print inorder traversal of the BST
inorder(root);
```

```Output
20 30 40 50 60 70 80 
```

****Time Complexity:**** 

-   The worst-case time complexity of insert operations is ****O(h)**** where ****h**** is the height of the Binary Search Tree. 
-   In the worst case, we may have to travel from the root to the deepest leaf node. The height of a skewed tree may become ****n**** and the time complexity of insertion operation may become ****O(n).**** 

****Auxiliary Space:**** The auxiliary space complexity of insertion into a binary search tree is ****O(h),**** due to recursive stack.

### Insertion in Binary Search Tree using Iterative approach

Instead of using recursion, we can also implement the insertion operation iteratively using a ****while loop****. Below is the implementation using a while loop.

```cpp
#include <iostream>
using namespace std;

struct Node {
    int key;
    Node* left;
    Node* right;
    Node(int item)
    {
        key = item;
        left = NULL;
        right = NULL;
    }
};

Node* insert(Node* root, int x)
{

    Node* temp = new Node(x);

    // If tree is empty
    if (root == NULL)
        return temp;

    // Find the node who is going
    // to have the new node temp as
    // it child. The parent node is
    // mainly going to be a leaf node
    Node *parent = NULL, *curr = root;
    while (curr != NULL) {
        parent = curr;
        if (curr->key > x)
            curr = curr->left;
        else if (curr->key < x)
            curr = curr->right;
        else
            return root;
    }

    // If x is smaller, make it
    // left child, else right child
    if (parent->key > x)
        parent->left = temp;
    else
        parent->right = temp;
    return root;
}

// A utility function to do inorder
// tree traversal
void inorder(Node* root)
{
    if (root != NULL) {
        inorder(root->left);
        cout << root->key << " ";
        inorder(root->right);
    }
}

// Driver program
int main()
{
    // Creating the following BST
    //      50
    //     /  \\
    //    30   70
    //   / \\   / \\
    //  20 40 60 80

    Node* root = new Node(50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    // Print inorder traversal of the BST
    inorder(root);

    return 0;
}
```
```java
class Node {
    int key;
    Node left, right;
    public Node(int item)
    {
        key = item;
        left = right = null;
    }
}

class GfG {

    // Function to insert a new node with
    // the given key
    static Node insert(Node root, int x) {
        Node temp = new Node(x);

        // If tree is empty
        if (root == null) {
            return temp;
        }

        // Find the node who is going to have 
        // the new node temp as its child
        Node parent = null;
        Node curr = root;
        while (curr != null) {
            parent = curr;
            if (curr.key > x) {
                curr = curr.left;
            } else if (curr.key < x) {
                curr = curr.right;
            } else {
                return root; // Key already exists
            }
        }

        // If x is smaller, make it left 
        // child, else right child
        if (parent.key > x) {
            parent.left = temp;
        } else {
            parent.right = temp;
        }
        return root;
    }

    // A utility function to do inorder tree traversal
    static void inorder(Node root)
    {
        if (root != null) {
            inorder(root.left);
            System.out.print(root.key + " ");
            inorder(root.right);
        }
    }

    // Driver method
    public static void main(String[] args)
    {
        Node root = null;

        // Creating the following BST
        //      50
        //     /  \\
        //    30   70
        //   / \\   / \\
        //  20 40 60 80

        root = insert(root, 50);
        root = insert(root, 30);
        root = insert(root, 20);
        root = insert(root, 40);
        root = insert(root, 70);
        root = insert(root, 60);
        root = insert(root, 80);

        // Print inorder traversal of the BST
        inorder(root);
    }
}
```
```python
# Python program to demonstrate
# insert operation in binary search tree
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.key = key

def insert(root, key):
    temp = Node(key)

    # If tree is empty
    if root is None:
        return temp

    # Find the node who is going to 
    # have the new node temp as its child
    parent = None
    curr = root
    while curr is not None:
        parent = curr
        if curr.key > key:
            curr = curr.left
        elif curr.key < key:
            curr = curr.right
        else:
            return root  # Key already exists

    # If key is smaller, make it left 
    # child, else right child
    if parent.key > key:
        parent.left = temp
    else:
        parent.right = temp

    return root


# A utility function to do inorder tree traversal
def inorder(root):
    if root:
        inorder(root.left)
        print(root.key, end=" ")
        inorder(root.right)


# Creating the following BST
#      50
#     /  \\
#    30   70
#   / \\   / \\
#  20 40 60 80
r = Node(50)
r = insert(r, 30)
r = insert(r, 20)
r = insert(r, 40)
r = insert(r, 70)
r = insert(r, 60)
r = insert(r, 80)

# Print inorder traversal of the BST
inorder(r)
```
```csharp
using System;

class Node {
    public int key;
    public Node left, right;

    public Node(int item) {
        key = item;
        left = right = null;
    }
}

class GfG {
  
    // Function to insert a new node with the given key
    public static Node Insert(Node root, int x)
    {
        Node temp = new Node(x);

        // If tree is empty
        if (root == null)
            return temp;

        // Find the node who is going to 
        // have the new node temp as its child
        Node parent = null;
        Node curr = root;
        while (curr != null)
        {
            parent = curr;
            if (curr.key > x)
                curr = curr.left;
            else if (curr.key < x)
                curr = curr.right;
            else
                return root; // Key already exists
        }

        // If x is smaller, make it left 
        // child, else right child
        if (parent.key > x)
            parent.left = temp;
        else
            parent.right = temp;

        return root;
    }
  
    // A utility function to do inorder tree traversal
    public static void Inorder(Node root) {
        if (root != null) {
            Inorder(root.left);
            Console.Write(root.key + " ");
            Inorder(root.right);
        }
    }

    // Driver method
    public static void Main() {
        // Creating the following BST
        //      50
        //     /  \\
        //    30   70
        //   / \\   / \\
        //  20 40 60 80

        Node root = new Node(50);
        root = Insert(root, 30);
        root = Insert(root, 20);
        root = Insert(root, 40);
        root = Insert(root, 70);
        root = Insert(root, 60);
        root = Insert(root, 80);

        // Print inorder traversal of the BST
        Inorder(root);
    }
}
```
```javascript
class Node {
    constructor(key)
    {
        this.key = key;
        this.left = null;
        this.right = null;
    }
}

// Function to insert a new node with the given key
function insert(root, x)
{
    const temp = new Node(x);

    // If tree is empty
    if (root === null)
        return temp;

    // Find the node who is going to have
    // the new node temp as its child
    let parent = null;
    let curr = root;
    while (curr !== null) {
        parent = curr;
        if (curr.key > x)
            curr = curr.left;
        else if (curr.key < x)
            curr = curr.right;
        else
            return root; // Key already exists
    }

    // If x is smaller, make it left
    // child, else right child
    if (parent.key > x)
        parent.left = temp;
    else
        parent.right = temp;

    return root;
}

// A utility function to do inorder tree traversal
function inorder(root)
{
    if (root !== null) {
        inorder(root.left);
        console.log(root.key + " ");
        inorder(root.right);
    }
}

// Creating the following BST
//      50
//     /  \\
//    30   70
//   / \\   / \\
//  20 40 60 80

let root = new Node(50);
root = insert(root, 30);
root = insert(root, 20);
root = insert(root, 40);
root = insert(root, 70);
root = insert(root, 60);
root = insert(root, 80);

// Print inorder traversal of the BST
inorder(root);
```


```Output
20 30 40 50 60 70 80 
```

The ****time complexity**** of ****inorder traversal**** is ****O(h)****, where h is the height of the tree.  
The ****Auxiliary space**** is ****O(1)****

> Continue in the following lesson.
', 'Binary search tree follows all properties of binary tree and for every nodes, its left subtree contains values less than the node and the right subtree contains values greater than the node.', 'Binary Search Tree Part 1', 7, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('aaf04cd6-13a7-415f-ac21-67a4c001f409', e'Given two m x n matrices m1 and m2, the task is to subtract m2 from m1 and return res.


> ****Input:****
> m1 = {{1, 2},
>
>
>
> {3, 4}},
>
>
>
> m2 = {{4, 3},
>
>
>
> {2, 1}}
>
>
>
> ****Output:****
> {{-3, -1},
>
>
>
> {1, 3}}
>
>
>
>
>
> ****Input:****
> m1 = {{3, 3, 3},
>
>
>
> {3, 3, 3}},
>
>
>
> m1 = {{2, 2, 2},
>
>
>
> {1, 1, 1}},
>
>
>
> ****Output:****
> {{1, 1, 1},
>
>
>
> {2, 2, 2}},


We traverse both matrices element by element and subtract m2[i][j] from m1[i][j].


C++

````
#include <iostream>
#include <vector>
using namespace std;

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(vector<vector<int>>& m1,
              vector<vector<int>>& m2,
              vector<vector<int>>& res)
{
    int rows = m1.size();
    int cols = m1[0].size();

    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main()
{
    // Define two rectangular matrices
    vector<vector<int>> m1 = { {1, 2, 3},
                                {4, 5, 6} };
    vector<vector<int>> m2 = { {1, 1, 1},
                                {1, 1, 1} };

    // Result matrix with the same dimensions
    vector<vector<int>> res(m1.size(), vector<int>(m1[0].size()));

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    cout << "Result matrix is:" << endl;
    for (auto& row : res)
    {
        for (int val : row)
            cout << val << " ";
        cout << endl;
    }

    return 0;
}

````

C

````
#include <stdio.h>
#include <stdlib.h>

#define R 2 // Number of rows
#define C 3 // Number of columns

// This function subtracts m2 from m1 and
// stores the result in res
void subtract(int m1[R][C], int m2[R][C], int res[R][C]) {
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            res[i][j] = m1[i][j] - m2[i][j];
}

// Driver code
int main() {

    // Define two rectangular matrices
    int m1[R][C] = { {1, 2, 3},
                     {4, 5, 6} };
    int m2[R][C] = { {1, 1, 1},
                     {1, 1, 1} };

    // Result matrix with the same dimensions
    int res[R][C];

    // Perform the subtraction
    subtract(m1, m2, res);

    // Print the result matrix
    printf("Result matrix is:\\n");
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++)
            printf("%d ", res[i][j]);
        printf("\\n");
    }

    return 0;
}

````

Java

````
// This function subtracts m2 from m1 and
// stores the result in res
public class MatrixSubtraction {
    public static void subtract(int[][] m1, int[][] m2, int[][] res) {
        int rows = m1.length;
        int cols = m1[0].length;
        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i][j] = m1[i][j] - m2[i][j];
    }

    public static void main(String[] args) {
        // Define two rectangular matrices
        int[][] m1 = { {1, 2, 3}, {4, 5, 6} };
        int[][] m2 = { {1, 1, 1}, {1, 1, 1} };

        // Result matrix with the same dimensions
        int[][] res = new int[m1.length][m1[0].length];

        // Perform the subtraction
        subtract(m1, m2, res);

        // Print the result matrix
        System.out.println("Result matrix is:");
        for (int[] row : res) {
            for (int val : row)
                System.out.print(val + " ");
            System.out.println();
        }
    }
}

````

Python

````
# This function subtracts m2 from m1 and
# stores the result in res
def subtract(m1, m2):
    rows = len(m1)
    cols = len(m1[0])
    res = [[0] * cols for _ in range(rows)]
    for i in range(rows):
        for j in range(cols):
            res[i][j] = m1[i][j] - m2[i][j]
    return res

# Driver code
if __name__ == \'__main__\':

    # Define two rectangular matrices
    m1 = [[1, 2, 3], [4, 5, 6]]
    m2 = [[1, 1, 1], [1, 1, 1]]

    # Perform the subtraction
    res = subtract(m1, m2)

    # Print the result matrix
    print("Result matrix is:")
    for row in res:
        print(\' \'.join(map(str, row)))

````

C#

````
using System;
using System.Collections.Generic;

class Program {
    // This function subtracts m2 from m1 and
    // stores the result in res
    static void Subtract(int[,] m1, int[,] m2, int[,] res) {
        int rows = m1.GetLength(0);
        int cols = m1.GetLength(1);

        for (int i = 0; i < rows; i++)
            for (int j = 0; j < cols; j++)
                res[i, j] = m1[i, j] - m2[i, j];
    }

    // Driver code
    static void Main() {
        // Define two rectangular matrices
        int[,] m1 = { {1, 2, 3},
                       {4, 5, 6} };
        int[,] m2 = { {1, 1, 1},
                       {1, 1, 1} };

        // Result matrix with the same dimensions
        int[,] res = new int[m1.GetLength(0), m1.GetLength(1)];

        // Perform the subtraction
        Subtract(m1, m2, res);

        // Print the result matrix
        Console.WriteLine("Result matrix is:");
        for (int i = 0; i < res.GetLength(0); i++) {
            for (int j = 0; j < res.GetLength(1); j++)
                Console.Write(res[i, j] + " ");
            Console.WriteLine();
        }
    }
}

````

JavaScript

````
// This function subtracts m2 from m1 and
function subtract(m1, m2) {
    const rows = m1.length;
    const cols = m1[0].length;
    const res = Array.from({ length: rows }, () => Array(cols).fill(0));
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            res[i][j] = m1[i][j] - m2[i][j];
        }
    }
    return res;
}

// Driver code
const m1 = [[1, 2, 3], [4, 5, 6]];
const m2 = [[1, 1, 1], [1, 1, 1]];

// Perform the subtraction
const res = subtract(m1, m2);

// Print the result matrix
console.log(\'Result matrix is:\');
res.forEach(row => {
    console.log(row.join(\' \'));
});

````

PHP

````
<?php
// This function subtracts m2 from m1 and
// stores the result in res
function subtract($m1, $m2) {
    $rows = count($m1);
    $cols = count($m1[0]);
    $res = array();

    for ($i = 0; $i < $rows; $i++) {
        for ($j = 0; $j < $cols; $j++) {
            $res[$i][$j] = $m1[$i][$j] - $m2[$i][$j];
        }
    }
    return $res;
}

// Driver code
$m1 = array(array(1, 2, 3),
            array(4, 5, 6));
$m2 = array(array(1, 1, 1),
            array(1, 1, 1));

// Perform the subtraction
$res = subtract($m1, $m2);

// Print the result matrix
echo "Result matrix is:\\n";
foreach ($res as $row) {
    echo implode(\' \', $row) . "\\n";
}
?>

````




**Output**
```
Result matrix is:
0 1 2
3 4 5

```

****Time complexity: O(n****
****2****
****)****
', '', 'Program for subtraction of matrices', 1, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('ae57ac50-b459-499f-bb58-9f19b875bee5', e'![Introduction-to-Binary-Tree](https://media.geeksforgeeks.org/wp-content/uploads/20240811023816/Introduction-to-Binary-Tree.webp)

# Representation of Binary Tree

Each node in a Binary Tree has three parts:
-   Data
-   Pointer to the left child
-   Pointer to the right child

![Binary-Tree-Representation](https://media.geeksforgeeks.org/wp-content/uploads/20240811023858/Binary-Tree-Representation.webp)


# Create/Declare a Node of a Binary Tree

Syntax to declare a Node of Binary Tree in different languages:

```cpp
// Use any below method to implement Nodes of binary tree

// 1: Using struct
struct Node {
    int data;
    Node* left, * right;

    Node(int key) {
        data = key;
        left = nullptr;
        right = nullptr;
    }
};

// 2: Using class
class Node {
public:
    int data;
    Node* left, * right;

    Node(int key) {
        data = key;
        left = nullptr;
        right = nullptr;
    }
};
```
```java
// Class containing left and right child
// of current node and key value
class Node {
    int key;
    Node left, right;
    public Node(int item)
    {
        key = item;
        left = right = null;
    }
}
```

# Example for Creating a Binary Tree

Here’s an example of creating a Binary Tree with four nodes (2, 3, 4, 5)

![Binary-Tree-with-three-nodes](https://media.geeksforgeeks.org/wp-content/uploads/20240808115621/Binary-Tree-with-three-nodes.webp)

Creating a Binary Tree having three nodes

```cpp
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *left, *right;
    Node(int d){
        data = d;
        left = nullptr;
        right = nullptr;
    }
};

int main(){
    // Initilize and allocate memory for tree nodes
    Node* firstNode = new Node(2);
    Node* secondNode = new Node(3);
    Node* thirdNode = new Node(4);
    Node* fourthNode = new Node(5);

    // Connect binary tree nodes
    firstNode->left = secondNode;
    firstNode->right = thirdNode;
    secondNode->left = fourthNode;
    return 0;
}
```

In the above code, we have created four tree nodes ****firstNode****, ****secondNode****, ****thirdNode**** and ****fourthNode**** having values ****2****, ****3****, ****4**** and ****5**** respectively.

-   After creating three nodes, we have connected these node to form the tree structure like mentioned in above image.
-   Connect the ****secondNode**** to the left of ****firstNode**** by ****firstNode->left = secondNode****
-   Connect the ****thirdNode**** to the right of ****firstNode**** by ****firstNode->right = thirdNode****
-   Connect the ****fourthNode**** to the left of ****secondNode**** by ****secondNode->left = fourthNode****

# Terminologies in Binary Tree

-   ****Nodes:**** The fundamental part of a binary tree, where each node contains ****data**** and ****link**** to two child nodes.
-   ****Root****: The topmost node in a tree is known as the root node. It has no parent and serves as the starting point for all nodes in the tree.
-   ****Parent Node****: A node that has one or more child nodes. In a binary tree, each node can have at most two children.
-   ****Child Node****: A node that is a descendant of another node (its parent).
-   ****Leaf Node****: A node that does not have any children or both children are null.
-   ****Internal Node****: A node that has at least one child. This includes all nodes except the ****leaf**** nodes.
-   ****Depth of a Node****: The number of edges from a specific node to the root node. The depth of the ****root**** node is zero.
-   ****Height of a Binary Tree****: The number of nodes from the deepest leaf node to the root node.

The diagram below shows all these terms in a binary tree.

![Terminologies-in-Binary-Tree-in-Data-Structure_1](https://media.geeksforgeeks.org/wp-content/uploads/20240808120231/Terminologies-in-Binary-Tree-in-Data-Structure_1.webp)

Terminologies in Binary Tree in Data Structure

# Properties of Binary Tree

-   The maximum number of nodes at level ****L**** of a binary tree is ****2****$^L$
-   The maximum number of nodes in a binary tree of height ****H**** is ****2****$^H – 1$
-   Total number of leaf nodes in a binary tree = total number of nodes with 2 children + 1
-   In a Binary Tree with ****N**** nodes, the minimum possible height or the minimum number of levels is ****Log****$_2$****(N+1)****
-   A Binary Tree with ****L**** leaves has at least ****| Log2L |+ 1**** levels

Please refer [Properties of Binary Tree](https://www.geeksforgeeks.org/properties-of-binary-tree/) for more details.

# Types of Binary Tree

Binary Tree can be classified into multiples types based on multiple factors:

-   ****On the basis of Number of Children****
    -   [Full Binary Tree](https://www.geeksforgeeks.org/full-binary-tree/)
    -   [Degenerate Binary Tree](https://www.geeksforgeeks.org/introduction-to-degenerate-binary-tree/)
    -   [Skewed Binary Trees](https://www.geeksforgeeks.org/skewed-binary-tree/)
-   ****On the basis of Completion of Levels****
    -   Complete Binary Tree
    -   Perfect Binary Tree
    -   Balanced Binary Tree
-   ****On the basis of Node Values:****
    -   Binary Search Tree
    -   AVL Tree
    -   Red Black Tree
    -   B Tree
    -   B+ Tree
    -   [Segment Tree](https://www.geeksforgeeks.org/segment-tree-data-structure/)

# Operations On Binary Tree

Following is a list of common operations that can be performed on a binary tree:

#### ***1. Traversal in Binary Tree***

Traversal in Binary Tree involves visiting all the nodes of the binary tree. Tree Traversal algorithms can be classified broadly into two categories, ****DFS**** and ****BFS****:

****Depth-First Search (DFS) algorithms:**** DFS explores as far down a branch as possible before backtracking. It is implemented using recursion. The main traversal methods in DFS for binary trees are:

-   **Preorder Traversal (current-left-right):** Visits the ****node**** first, then ****left subtree****, then ****right subtree.****
-   **Inorder Traversal (left-current-right):** Visits ****left subtree****, then the ****node****, then the ****right subtree****.
-   **Postorder Traversal (left-right-current):** Visits ****left subtree****, then ****right subtree****, then the ****node****.

****Breadth-First Search (BFS) algorithms:**** BFS explores all nodes at the present depth before moving on to nodes at the next depth level. It is typically implemented using a queue. BFS in a binary tree is commonly referred to as **Level Order Traversal**.

Below is the implementation of traversals algorithm in binary tree:

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node* left, * right;

    Node(int d) {
        data = d;
        left = nullptr;
        right = nullptr;
    }
};

// In-order DFS: Left, Root, Right
void inOrderDFS(Node* node) {
    if (node == nullptr) return;

    inOrderDFS(node->left);
    cout << node->data << " ";
    inOrderDFS(node->right);
}

// Pre-order DFS: Root, Left, Right
void preOrderDFS(Node* node) {
    if (node == nullptr) return;

    cout << node->data << " ";
    preOrderDFS(node->left);
    preOrderDFS(node->right);
}

// Post-order DFS: Left, Right, Root
void postOrderDFS(Node* node) {
    if (node == nullptr) return;

    postOrderDFS(node->left);
    postOrderDFS(node->right);
    cout << node->data << " ";
}

void BFS(Node* root) {

    if (root == nullptr) return;
    queue<Node*> q;
    q.push(root);

    while (!q.empty()) {
        Node* node = q.front();
        q.pop(); 
        cout << node->data << " ";
        if (node->left != nullptr) q.push(node->left);
        if (node->right != nullptr) q.push(node->right);
        
    }
}

int main() {
    Node* root = new Node(2);
    root->left = new Node(3);
    root->right = new Node(4);
    root->left->left = new Node(5);

    cout << "In-order DFS: ";
    inOrderDFS(root);

    cout << "\\nPre-order DFS: ";
    preOrderDFS(root);
   
    cout << "\\nPost-order DFS: ";
    postOrderDFS(root);
  
    cout << "\\nLevel order: ";
    BFS(root);

    return 0;
}
```

```Output
In-order DFS: 5 3 2 4 
Pre-order DFS: 2 3 5 4 
Post-order DFS: 5 3 4 2 
Level order: 2 3 4 5 
```

#### ***2. Insertion in Binary Tree***

Inserting elements means add a new node into the binary tree. As we know that there is no such ordering of elements in the binary tree, So we do not have to worry about the ordering of node in the binary tree. We would first creates a ****root node**** in case of empty tree. Then subsequent insertions involve iteratively searching for an empty place at each level of the tree. When an empty ****left**** or ****right**** child is found then ****new node**** is inserted there. By convention, insertion always starts with the ****left**** child node.

![Insertion-in-Binary-Tree](https://media.geeksforgeeks.org/wp-content/uploads/20240808120403/Insertion-in-Binary-Tree.webp)

Insertion in Binary Tree

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node* left, * right;
    Node(int d) {
        data = d;
        left = right = nullptr;
    }
};

// Function to insert a new node in the binary tree
Node* insert(Node* root, int key) {
    // If the tree is empty, create the root node
    if (root == nullptr) {
        root = new Node(key);
        return root;
    }
    // Create a queue for level order traversal
    queue<Node*> q;
    q.push(root);

    // Do level order traversal until we find an empty place
    while (!q.empty()) {
        Node* temp = q.front();
        q.pop();

        // If left child is empty, insert the new node here
        if (temp->left == nullptr) {
            temp->left = new Node(key);
            break;
        } else {
            q.push(temp->left);
        }
        // If right child is empty, insert the new node here
        if (temp->right == nullptr) {
            temp->right = new Node(key);
            break;
        } else {
            q.push(temp->right);
        }
    }
    return root;
}

void inorder(Node* root) {
    if (root == nullptr) return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);
}

int main() {
    Node* root = new Node(2);
    root->left = new Node(3);
    root->right = new Node(4) ; 
    root->left->left = new Node(5);
  
    cout << "Inorder traversal before insertion: ";
    inorder(root);
    cout << endl;

    int key = 6;
    root = insert(root, key);

    cout << "Inorder traversal after insertion: ";
    inorder(root);
    cout << endl;

    return 0;
}
```

```Output
Inorder traversal before insertion: 5 3 2 4 
Inorder traversal after insertion: 5 3 6 2 4 
```

#### ***3. Searching in Binary Tree***

****Searching**** for a value in a binary tree means looking through the tree to find a node that has that value. Since binary trees do not have a specific order like binary search trees, we typically use any traversal method to search. The most common methods are ****depth-first search (DFS)**** and ****breadth-first search (BFS)****. In ****DFS****, we start from the ****root**** and explore the depth nodes first. In BFS, we explore all the nodes at the present depth level before moving on to the nodes at the next level. We continue this process until we either find the node with the desired value or reach the end of the tree. If the tree is empty or the value isn\'t found after exploring all possibilities, we conclude that the value does not exist in the tree.

Here is the implementation of searching in a binary tree using Depth-First Search (DFS)

```cpp
#include <iostream>
using namespace std;

struct Node{
    int data;
    Node *left, *right;
    Node(int d){
        data = d;
        left = right = nullptr;
    }
};

// Function to search for a value in the binary tree using DFS
bool searchDFS(Node *root, int value){
    // Base case: If the tree is empty or we\'ve reached a leaf node
    if (root == nullptr) return false;

    // If the node\'s data is equal to the value we are searching for
    if (root->data == value) return true;

    // Recursively search in the left and right subtrees
    bool left_res = searchDFS(root->left, value);
    bool right_res = searchDFS(root->right, value);

    return left_res || right_res;
}

int main()
{
    Node *root = new Node(2);
    root->left = new Node(3);
    root->right = new Node(4);
    root->left->left = new Node(5);
    root->left->right = new Node(6);

    int value = 6;
    if (searchDFS(root, value))
        cout << value << " is found in the binary tree" << endl;
    else
        cout << value << " is not found in the binary tree" << endl;

    return 0;
}
```

```Output
6 is found in the binary tree
```

#### ***4. Deletion in Binary Tree***

Deleting a node from a binary tree means removing a specific node while keeping the tree\'s structure. First, we need to find the node that want to delete by traversing through the tree using any traversal method. Then replace the node\'s value with the value of the last node in the tree (found by traversing to the rightmost leaf), and then delete that last node. This way, the tree structure won\'t be effected. And remember to check for special cases, like trying to delete from an empty tree, to avoid any issues.

****Note:**** There is no specific rule of deletion but we always make sure that during deletion the binary tree proper should be preserved.

![Deletion-in-Binary-Tree](https://media.geeksforgeeks.org/wp-content/uploads/20240808120736/Deletion-in-Binary-Tree.webp)

Deletion in Binary Tree

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node* left, * right;
    Node(int d) {
        data = d;
        left = right = nullptr;
    }
};

// Function to delete a node from the binary tree
Node* deleteNode(Node* root, int val) {
    if (root == nullptr) return nullptr; 
    // Use a queue to perform BFS
    queue<Node*> q;
    q.push(root);
    Node* target = nullptr;

    // Find the target node
    while (!q.empty()) {
        Node* curr = q.front();
        q.pop();

        // Check for current node is the target node to delete
        if (curr->data == val) {
            target = curr;
            break;
        }
        // Add children to the queue
        if (curr->left) q.push(curr->left);
        if (curr->right) q.push(curr->right);
    }
    // If target node is not found, return the original tree
    if (target == nullptr) return root;

    // Find the deepest rightmost node and its parent
    pair<Node*, Node*> last = {nullptr, nullptr};
    queue<pair<Node*, Node*>> q1;
    q1.push({root, nullptr});
  
    while (!q1.empty()) {
        auto curr = q1.front();
        q1.pop();

        // Update the last
        last = curr;
      
        if (curr.first->left) 
          q1.push({curr.first->left, curr.first});
        if (curr.first->right) 
          q1.push({curr.first->right, curr.first});
    }

    Node* lastNode = last.first;
    Node* lastParent = last.second;

    // Replace target\'s value with the last node\'s value
    target->data = lastNode->data;

    // Remove the last node
    if (lastParent) {
        if (lastParent->left==lastNode)lastParent->left = nullptr;
        else lastParent->right = nullptr;
        delete lastNode;
    } else {
        // If the last node was the root
        delete lastNode;
        return nullptr;
    }
    return root;  
}

void inOrder(Node* root) {
    if (root == nullptr) return;
    inOrder(root->left);
    cout << root->data << " ";
    inOrder(root->right);
}

int main() {
    // Creating a simple binary tree
    Node *root = new Node(2);
    root->left = new Node(3);
    root->right = new Node(4);
    root->left->left = new Node(5);
    root->left->right = new Node(6);

    cout << "Original tree (in-order): ";
    inOrder(root);

    int valToDel = 3;
    root = deleteNode(root, valToDel);

    cout <<"\\nTree after deleting " << valToDel << " (in-order): ";
    inOrder(root);
    cout << endl;

    return 0;
}
```

```Output
Original tree (in-order): 5 3 6 2 4 
Tree after deleting 3 (in-order): 5 6 2 4 
```

# Auxiliary Operations On Binary Tree

-   Finding the height of the tree
-   Find level of a node in a Binary tree
-   Finding the size of the entire tree

# Complexity Analysis of Binary Tree Operations

Here’s the complexity analysis for specific binary tree operations:

| ****Operation**** | ****Time Complexity**** | ****Auxiliary Space**** |
| --- | --- | --- |
| ****In-Order Traversal**** | O(n) | O(n) |
| ****Pre-Order Traversal**** | O(n) | O(n) |
| ****Post-Order Traversal**** | O(n) | O(n) |
| ****Insertion (Unbalanced)**** | O(n) | O(n) |
| ****Searching (Unbalanced)**** | O(n) | O(n) |
| ****Deletion (Unbalanced)**** | O(n) | O(n) |

****Note:**** We can use [****Morris Traversal****](https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/) to traverse all the nodes of the binary tree in O(n) time complexity but with O(1) auxiliary space.

# Advantages of Binary Tree

-   ****Efficient Search:**** [Binary Search Trees](https://www.geeksforgeeks.org/binary-search-tree-data-structure/) (a variation of Binary Tree) are efficient when searching for a specific element, as each node has at most two child nodes when compared to linked list and arrays
-   ****Memory Efficient:**** Binary trees require lesser memory as compared to other tree data structures, therefore memory-efficient.
-   Binary trees are relatively easy to implement and understand as each node has at most two children, left child and right child.

# Disadvantages of Binary Tree

-   ****Limited structure:**** Binary trees are limited to two child nodes per node, which can limit their usefulness in certain applications. For example, if a tree requires more than two child nodes per node, a different tree structure may be more suitable.
-   ****Unbalanced trees:**** Unbalanced binary trees, where one subtree is significantly larger than the other, can lead to inefficient search operations. This can occur if the tree is not properly balanced or if data is inserted in a non-random order.
-   ****Space inefficiency:**** Binary trees can be space inefficient when compared to other data structures like arrays and linked list. This is because each node requires two child references or pointers, which can be a significant amount of memory overhead for large trees.
-   ****Slow performance in worst-case scenarios:**** In the worst-case scenario, a binary tree can become degenerate or skewed, meaning that each node has only one child. In this case, search operations in [Binary Search Tree](https://www.geeksforgeeks.org/binary-search-tree-data-structure/) (a variation of Binary Tree) can degrade to O(n) time complexity, where n is the number of nodes in the tree.

# Applications of Binary Tree

-   Binary Tree can be used to ****represent hierarchical data****.
-   Huffman Coding trees are used in ****data compression algorithms****.
-   [Priority Queue](https://www.geeksforgeeks.org/priority-queue-set-1-introduction/) is another application of binary tree that is used for searching maximum or minimum in O(1) time complexity.
-   Useful for indexing segmented at the database is useful in storing cache in the system,
-   Binary trees can be used to implement decision trees, a type of machine learning algorithm used for classification and regression analysis.

# Conclusion:

Tree is a hierarchical data structure. Main uses of trees include maintaining hierarchical data, providing moderate access and insert/delete operations. Binary trees are special cases of tree where every node has at most two children.
', 'Binary Tree is a non-linear and hierarchical data structure where each node has at most two children referred to as the left child and the right child.  ', 'Introduction to Binary Tree', 6, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('e448951c-beac-4b37-85ff-79d400a94f20', e'# Definition of AVL tree node:

```cpp
struct AVLwithparent {

    // Pointer to the left and the
    // right subtree
    struct AVLwithparent* left;
    struct AVLwithparent* right;

    // Stores the data in the node
    int key;

    // Stores the parent pointer
    struct AVLwithparent* par;

    // Stores the height of the
    // current tree
    int height;
}
```
```java
class AVLwithParent {
    // Pointer to the left and the right subtree
    AVLwithParent left;
    AVLwithParent right;

    // Stores the data in the node
    int key;

    // Stores the parent pointer
    AVLwithParent par;

    // Stores the height of the current tree
    int height;
}
```
```python
# Python code

class AVLwithParent:
    def __init__(self):
        # Pointer to the left and the right subtree
        self.left = None
        self.right = None

        # Stores the data in the node
        self.key = None

        # Stores the parent pointer
        self.par = None

        # Stores the height of the current tree
        self.height = None

# This code is contributed by princekumaras
```
```javascript
class AVLwithParent {
    constructor() {
        // Pointer to the left and the right subtree
        this.left = null;
        this.right = null;

        // Stores the data in the node
        this.key = null;

        // Stores the parent pointer
        this.par = null;

        // Stores the height of the current tree
        this.height = null;
    }
}
```

# Representation of the Node

![](https://media.geeksforgeeks.org/wp-content/uploads/20210326184819/gfg2.jpg)

Below is the example of an AVL tree containing a parent pointer:

![](https://media.geeksforgeeks.org/wp-content/uploads/20210326141118/gfg1.jpg)


# Insert Operation
**Insert Operation:** The insertion procedure is similar to that of a normal AVL tree without a parent pointer, but in this case, the parent pointers need to be updated with every insertion and rotation accordingly. Follow the steps below to perform insert operation:

-   [Perform standard BST insert for the node](https://www.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/) to be placed at its correct position.
-   Increase the height of each node encountered by 1 while finding the correct position for the node to be inserted.
-   Update the parent and child pointers of the inserted node and its parent respectively.
-   Starting from the inserted node till the root node check if the AVL condition is satisfied for each node on this path.
-   If **w** is the node where the AVL condition is not satisfied then we have 4 cases:
    -   **Left Left Case:** (If the left subtree of the left child of **w** has the inserted node)
    -   **Left Right Case:** (If the right subtree of the left child of **w** has the inserted node)
    -   **Right Left Case:** (If the left subtree of the right child of **w** has the inserted node)
    -   **Right Right Case:** (If the right subtree of the right child of **w** has the inserted node)

**Below is the implementation of the above approach:**

```cpp
// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;

// AVL tree node
struct AVLwithparent {
    struct AVLwithparent* left;
    struct AVLwithparent* right;
    int key;
    struct AVLwithparent* par;
    int height;
};

// Function to update the height of
// a node according to its children\'s
// node\'s heights
void Updateheight(
    struct AVLwithparent* root)
{
    if (root != NULL) {

        // Store the height of the
        // current node
        int val = 1;

        // Store the height of the left
        // and right subtree
        if (root->left != NULL)
            val = root->left->height + 1;

        if (root->right != NULL)
            val = max(
                val, root->right->height + 1);

        // Update the height of the
        // current node
        root->height = val;
    }
}

// Function to handle Left Left Case
struct AVLwithparent* LLR(
    struct AVLwithparent* root)
{
    // Create a reference to the
    // left child
    struct AVLwithparent* tmpnode = root->left;

    // Update the left child of the
    // root to the right child of the
    // current left child of the root
    root->left = tmpnode->right;

    // Update parent pointer of the
    // left child of the root node
    if (tmpnode->right != NULL)
        tmpnode->right->par = root;

    // Update the right child of
    // tmpnode to root
    tmpnode->right = root;

    // Update parent pointer of
    // the tmpnode
    tmpnode->par = root->par;

    // Update the parent pointer
    // of the root
    root->par = tmpnode;

    // Update tmpnode as the left or the
    // right child of its parent pointer
    // according to its key value
    if (tmpnode->par != NULL
        && root->key < tmpnode->par->key) {
        tmpnode->par->left = tmpnode;
    }
    else {
        if (tmpnode->par != NULL)
            tmpnode->par->right = tmpnode;
    }

    // Make tmpnode as the new root
    root = tmpnode;

    // Update the heights
    Updateheight(root->left);
    Updateheight(root->right);
    Updateheight(root);
    Updateheight(root->par);

    // Return the root node
    return root;
}

// Function to handle Right Right Case
struct AVLwithparent* RRR(
    struct AVLwithparent* root)
{
    // Create a reference to the
    // right child
    struct AVLwithparent* tmpnode = root->right;

    // Update the right child of the
    // root as the left child of the
    // current right child of the root
    root->right = tmpnode->left;

    // Update parent pointer of the
    // right child of the root node
    if (tmpnode->left != NULL)
        tmpnode->left->par = root;

    // Update the left child of the
    // tmpnode to root
    tmpnode->left = root;

    // Update parent pointer of
    // the tmpnode
    tmpnode->par = root->par;

    // Update the parent pointer
    // of the root
    root->par = tmpnode;

    // Update tmpnode as the left or
    // the right child of its parent
    // pointer according to its key value
    if (tmpnode->par != NULL
        && root->key < tmpnode->par->key) {
        tmpnode->par->left = tmpnode;
    }
    else {
        if (tmpnode->par != NULL)
            tmpnode->par->right = tmpnode;
    }

    // Make tmpnode as the new root
    root = tmpnode;

    // Update the heights
    Updateheight(root->left);
    Updateheight(root->right);
    Updateheight(root);
    Updateheight(root->par);

    // Return the root node
    return root;
}

// Function to handle Left Right Case
struct AVLwithparent* LRR(
    struct AVLwithparent* root)
{
    root->left = RRR(root->left);
    return LLR(root);
}

// Function to handle right left case
struct AVLwithparent* RLR(
    struct AVLwithparent* root)
{
    root->right = LLR(root->right);
    return RRR(root);
}

// Function to insert a node in
// the AVL tree
struct AVLwithparent* Insert(
    struct AVLwithparent* root,
    struct AVLwithparent* parent,
    int key)
{

    if (root == NULL) {

        // Create and assign values
        // to a new node
        root = new struct AVLwithparent;

        // If the root is NULL
        if (root == NULL) {
            cout << "Error in memory"
                 << endl;
        }

        // Otherwise
        else {
            root->height = 1;
            root->left = NULL;
            root->right = NULL;
            root->par = parent;
            root->key = key;
        }
    }

    else if (root->key > key) {

        // Recur to the left subtree
        // to insert the node
        root->left = Insert(root->left,
                            root, key);

        // Store the heights of the
        // left and right subtree
        int firstheight = 0;
        int secondheight = 0;

        if (root->left != NULL)
            firstheight = root->left->height;

        if (root->right != NULL)
            secondheight = root->right->height;

        // Balance the tree if the
        // current node is not balanced
        if (abs(firstheight
                - secondheight)
            == 2) {

            if (root->left != NULL
                && key < root->left->key) {

                // Left Left Case
                root = LLR(root);
            }
            else {

                // Left Right Case
                root = LRR(root);
            }
        }
    }

    else if (root->key < key) {

        // Recur to the right subtree
        // to insert the node
        root->right = Insert(root->right,
                             root, key);

        // Store the heights of the
        // left and right subtree
        int firstheight = 0;
        int secondheight = 0;

        if (root->left != NULL)
            firstheight
                = root->left->height;

        if (root->right != NULL)
            secondheight = root->right->height;

        // Balance the tree if the
        // current node is not balanced
        if (abs(firstheight - secondheight) == 2) {
            if (root->right != NULL
                && key < root->right->key) {

                // Right Left Case
                root = RLR(root);
            }
            else {

                // Right Right Case
                root = RRR(root);
            }
        }
    }

    // Case when given key is already
    // in the tree
    else {
    }

    // Update the height of the
    // root node
    Updateheight(root);

    // Return the root node
    return root;
}

// Function to print the preorder
// traversal of the AVL tree
void printpreorder(
    struct AVLwithparent* root)
{
    // Print the node\'s value along
    // with its parent value
    cout << "Node: " << root->key
         << ", Parent Node: ";

    if (root->par != NULL)
        cout << root->par->key << endl;
    else
        cout << "NULL" << endl;

    // Recur to the left subtree
    if (root->left != NULL) {
        printpreorder(root->left);
    }

    // Recur to the right subtree
    if (root->right != NULL) {
        printpreorder(root->right);
    }
}

// Driver Code
int main()
{
    struct AVLwithparent* root;
    root = NULL;

    // Function Call to insert nodes
    root = Insert(root, NULL, 10);
    root = Insert(root, NULL, 20);
    root = Insert(root, NULL, 30);
    root = Insert(root, NULL, 40);
    root = Insert(root, NULL, 50);
    root = Insert(root, NULL, 25);

    // Function call to print the tree
    printpreorder(root);
}
```
```java
class AVLwithparent {
    int key;
    AVLwithparent left;
    AVLwithparent right;
    AVLwithparent par;
    int height;

    public AVLwithparent(int key) {
        this.key = key;
        this.left = null;
        this.right = null;
        this.par = null;
        this.height = 1;
    }
}

public class AVLTreeWithParent {

    // Function to update the height of a node based on its children\'s heights
    public static void updateHeight(AVLwithparent root) {
        if (root != null) {
            int leftHeight = (root.left != null) ? root.left.height : 0;
            int rightHeight = (root.right != null) ? root.right.height : 0;
            root.height = Math.max(leftHeight, rightHeight) + 1;
        }
    }

    // Left-Left Rotation (LLR) to balance the AVL tree
    public static AVLwithparent LLR(AVLwithparent root) {
        AVLwithparent tmpnode = root.left;
        root.left = tmpnode.right;
        if (tmpnode.right != null) {
            tmpnode.right.par = root;
        }
        tmpnode.right = root;
        tmpnode.par = root.par;
        root.par = tmpnode;
        if (tmpnode.par != null) {
            if (root.key < tmpnode.par.key) {
                tmpnode.par.left = tmpnode;
            } else {
                tmpnode.par.right = tmpnode;
            }
        }
        updateHeight(root);
        updateHeight(tmpnode);
        return tmpnode;
    }

    // Right-Right Rotation (RRR) to balance the AVL tree
    public static AVLwithparent RRR(AVLwithparent root) {
        AVLwithparent tmpnode = root.right;
        root.right = tmpnode.left;
        if (tmpnode.left != null) {
            tmpnode.left.par = root;
        }
        tmpnode.left = root;
        tmpnode.par = root.par;
        root.par = tmpnode;
        if (tmpnode.par != null) {
            if (root.key < tmpnode.par.key) {
                tmpnode.par.left = tmpnode;
            } else {
                tmpnode.par.right = tmpnode;
            }
        }
        updateHeight(root);
        updateHeight(tmpnode);
        return tmpnode;
    }

    // Left-Right Rotation (LRR) to balance the AVL tree
    public static AVLwithparent LRR(AVLwithparent root) {
        root.left = RRR(root.left);
        return LLR(root);
    }

    // Right-Left Rotation (RLR) to balance the AVL tree
    public static AVLwithparent RLR(AVLwithparent root) {
        root.right = LLR(root.right);
        return RRR(root);
    }

    // Function to insert a key into the AVL tree and balance the tree if needed
    public static AVLwithparent insert(AVLwithparent root, AVLwithparent parent, int key) {
        if (root == null) {
            root = new AVLwithparent(key);
            root.par = parent;
        } else if (root.key > key) {
            root.left = insert(root.left, root, key);
            int leftHeight = (root.left != null) ? root.left.height : 0;
            int rightHeight = (root.right != null) ? root.right.height : 0;
            if (Math.abs(leftHeight - rightHeight) == 2) {
                if (key < root.left.key) {
                    root = LLR(root);
                } else {
                    root = LRR(root);
                }
            }
        } else if (root.key < key) {
            root.right = insert(root.right, root, key);
            int leftHeight = (root.left != null) ? root.left.height : 0;
            int rightHeight = (root.right != null) ? root.right.height : 0;
            if (Math.abs(leftHeight - rightHeight) == 2) {
                if (key < root.right.key) {
                    root = RLR(root);
                } else {
                    root = RRR(root);
                }
            }
        }
        updateHeight(root);
        return root;
    }

    // Function to print the nodes of the AVL tree in preorder
    public static void printPreorder(AVLwithparent root) {
        if (root != null) {
            String parentKey = (root.par != null) ? Integer.toString(root.par.key) : "NULL";
            System.out.println("Node: " + root.key + ", Parent Node: " + parentKey);
            printPreorder(root.left);
            printPreorder(root.right);
        }
    }

    public static void main(String[] args) {
        AVLwithparent root = null;
        root = insert(root, null, 10);
        root = insert(root, null, 20);
        root = insert(root, null, 30);
        root = insert(root, null, 40);
        root = insert(root, null, 50);
        root = insert(root, null, 25);
        printPreorder(root);
    }
}
```
```python
class AVLwithparent:
    def __init__(self, key):
        # Initialize a node with key, left and right child, parent, and height.
        self.left = None
        self.right = None
        self.key = key
        self.par = None
        self.height = 1

# Function to update the height of a node based on its children\'s heights
def update_height(root):
    if root is not None:
        left_height = root.left.height if root.left else 0  # Get the height of the left child
        right_height = root.right.height if root.right else 0  # Get the height of the right child
        root.height = max(left_height, right_height) + 1  # Update the height of the current node

# Left-Left Rotation (LLR) to balance the AVL tree
def LLR(root):
    # Perform a left rotation and then a right rotation
    # to balance the tree when there\'s an imbalance in the left subtree
    tmpnode = root.left
    root.left = tmpnode.right
    if tmpnode.right:
        tmpnode.right.par = root
    tmpnode.right = root
    tmpnode.par = root.par
    root.par = tmpnode
    if tmpnode.par:
        if root.key < tmpnode.par.key:
            tmpnode.par.left = tmpnode
        else:
            tmpnode.par.right = tmpnode
    update_height(root)
    update_height(tmpnode)
    return tmpnode

# Right-Right Rotation (RRR) to balance the AVL tree
def RRR(root):
    # Perform a right rotation and then a left rotation
    # to balance the tree when there\'s an imbalance in the right subtree
    tmpnode = root.right
    root.right = tmpnode.left
    if tmpnode.left:
        tmpnode.left.par = root
    tmpnode.left = root
    tmpnode.par = root.par
    root.par = tmpnode
    if tmpnode.par:
        if root.key < tmpnode.par.key:
            tmpnode.par.left = tmpnode
        else:
            tmpnode.par.right = tmpnode
    update_height(root)
    update_height(tmpnode)
    return tmpnode

# Left-Right Rotation (LRR) to balance the AVL tree
def LRR(root):
    # Perform a right rotation on the left child and then a left rotation on the root
    root.left = RRR(root.left)
    return LLR(root)

# Right-Left Rotation (RLR) to balance the AVL tree
def RLR(root):
    # Perform a left rotation on the right child and then a right rotation on the root
    root.right = LLR(root.right)
    return RRR(root)

# Function to insert a key into the AVL tree and balance the tree if needed
def insert(root, parent, key):
    if root is None:
        root = AVLwithparent(key)  # Create a new node if the current node is None
        root.par = parent  # Set the parent of the new node
    elif root.key > key:
        # Insert the key into the left subtree and balance the tree if needed
        root.left = insert(root.left, root, key)
        left_height = root.left.height if root.left else 0
        right_height = root.right.height if root.right else 0
        if abs(left_height - right_height) == 2:
            if key < root.left.key:
                root = LLR(root)
            else:
                root = LRR(root)
    elif root.key < key:
        # Insert the key into the right subtree and balance the tree if needed
        root.right = insert(root.right, root, key)
        left_height = root.left.height if root.left else 0
        right_height = root.right.height if root.right else 0
        if abs(left_height - right_height) == 2:
            if key < root.right.key:
                root = RLR(root)
            else:
                root = RRR(root)
    update_height(root)  # Update the height of the current node after insertion
    return root  # Return the root of the updated subtree

# Function to print the nodes of the AVL tree in preorder
def print_preorder(root):
    if root:
        parent_key = root.par.key if root.par else "NULL"  # Get the key of the parent node or "NULL" if it\'s None
        print(f"Node: {root.key}, Parent Node: {parent_key}")  # Print the node and its parent
        print_preorder(root.left)  # Print the left subtree in preorder
        print_preorder(root.right)  # Print the right subtree in preorder

# Main function to demonstrate AVL tree operations
if __name__ == "__main__":
    root = None  # Initialize the root of the AVL tree as None
    # Insert keys into the AVL tree
    root = insert(root, None, 10)
    root = insert(root, None, 20)
    root = insert(root, None, 30)
    root = insert(root, None, 40)
    root = insert(root, None, 50)
    root = insert(root, None, 25)
    # Print the AVL tree in preorder
    print_preorder(root)
```


```output
Node: 30, Parent Node: NULL
Node: 20, Parent Node: 30
Node: 10, Parent Node: 20
Node: 25, Parent Node: 20
Node: 40, Parent Node: 30
Node: 50, Parent Node: 40
```

***Time Complexity:*** **O(log N), where N is the** [**number of nodes of the tree**](https://www.geeksforgeeks.org/relationship-number-nodes-height-binary-tree/)**.**  
***Auxiliary Space:*** **O(1)**

', 'Implementation AVL tree node and insert operation.', 'AVL Tree Implementation Part 1: Definition AVL tree node and Insert Operation', 13, null, '2d282726-865b-41fb-8cf5-7a2116099466', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('610cd734-a640-4ad0-9ed2-9360a01d068a', e'****Examples:****

    ```
    Input: board[] =  {\'X\', \'X\', \'O\',
    \'O\', \'O\', \'X\',
    \'X\', \'O\', \'X\'};
Output: Valid
Input: board[] =  {\'O\', \'X\', \'X\',
\'O\', \'X\', \'X\',
\'O\', \'O\', \'X\'};
Output: Invalid
(Both X and O cannot win)
Input: board[] =  {\'O\', \'X\', \' \',
\' \', \' \', \' \',
\' \', \' \', \' \'};
Output: Valid
(Valid board with only two moves played)

```
Recommended Practice

[Tic Tac Toe](https://www.geeksforgeeks.org/problems/tic-tac-toe2412/1/)


[Try It!](https://www.geeksforgeeks.org/problems/tic-tac-toe2412/1/)


Basically, to find the validity of an input grid, we can think of the conditions when an input grid is invalid. Let no. of “X”s be countX and no. of “O”s be countO. Since we know that the game starts with X, a given grid of Tic-Tac-Toe game would be definitely invalid if following two conditions meet


1. countX != countO AND
2. countX != countO + 1
   * Since “X” is always the first move, second condition is also required.
   * Now does it mean that all the remaining board positions are valid one? The answer is NO. Think of the cases when input grid is such that both X and O are making straight lines. This is also not
   * valid position because the game ends when one player wins. So we need to check the following condition as well
3. If input grid shows that both the players are in winning situation, it’s an invalid position.
4. If input grid shows that the player with O has put a straight-line (i.e. is in win condition) and countX != countO, it’s an invalid position. The reason is that O plays his move only after X plays his
   * move. Since X has started the game, O would win when both X and O has played equal no. of moves.
5. If input grid shows that X is in winning condition than xCount must be one greater that oCount.
   * Armed with above conditions i.e. a), b), c) and d), we can now easily formulate an algorithm/program to check the validity of a given Tic-Tac-Toe board position.

```
1)  countX == countO or countX == countO + 1
2)  If O is in win condition then check
     a)     If X also wins, not valid
     b)     If xbox != obox , not valid
3)  If X is in win condition then check if xCount is
     one more than oCount or not

```


Another way to find the validity of a given board is using ‘inverse method’ i.e. rule out all the possibilities when a given board is invalid.


C++
---

















```
// C++ program to check whether a given tic tac toe
// board is valid or not
#include <iostream>
using namespace std;

// This matrix is used to find indexes to check all
// possible winning triplets in board[0..8]
int win[8][3] = {{0, 1, 2}, // Check first row.
{3, 4, 5}, // Check second Row
{6, 7, 8}, // Check third Row
{0, 3, 6}, // Check first column
{1, 4, 7}, // Check second Column
{2, 5, 8}, // Check third Column
{0, 4, 8}, // Check first Diagonal
{2, 4, 6}}; // Check second Diagonal

// Returns true if character \'c\' wins. c can be either
// \'X\' or \'O\'
bool isCWin( char *board, char c)
{
// Check all possible winning combinations
for ( int i=0; i<8; i++)
if (board[win[i][0]] == c &&
board[win[i][1]] == c &&
board[win[i][2]] == c )
return true ;
return false ;
}

// Returns true if given board is valid, else returns false
bool isValid( char board[9])
{
// Count number of \'X\' and \'O\' in the given board
int xCount=0, oCount=0;
for ( int i=0; i<9; i++)
{
if (board[i]== \'X\' ) xCount++;
if (board[i]== \'O\' ) oCount++;
}

// Board can be valid only if either xCount and oCount
// is same or count is one more than oCount
if (xCount==oCount || xCount==oCount+1)
{
// Check if \'O\' is winner
if (isCWin(board, \'O\' ))
{
// Check if \'X\' is also winner, then
// return false
if (isCWin(board, \'X\' ))
return false ;

// Else return true xCount and yCount are same
return (xCount == oCount);
}

// If \'X\' wins, then count of X must be greater
if (isCWin(board, \'X\' ) && xCount != oCount + 1)
return false ;

// If \'O\' is not winner, then return true
return true ;
}
return false ;
}

// Driver program
int main()
{
char board[] = { \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' };
(isValid(board))? cout << "Given board is valid" :
cout << "Given board is not valid" ;
return 0;
}
```





Java
----

















```
// Java program to check whether a given tic tac toe
// board is valid or not
import java.io.*;
class GFG {

// This matrix is used to find indexes to check all
// possible winning triplets in board[0..8]
static int win[][] = {{ 0 , 1 , 2 }, // Check first row.
{ 3 , 4 , 5 }, // Check second Row
{ 6 , 7 , 8 }, // Check third Row
{ 0 , 3 , 6 }, // Check first column
{ 1 , 4 , 7 }, // Check second Column
{ 2 , 5 , 8 }, // Check third Column
{ 0 , 4 , 8 }, // Check first Diagonal
{ 2 , 4 , 6 }}; // Check second Diagonal

// Returns true if character \'c\' wins. c can be either
// \'X\' or \'O\'
static boolean isCWin( char [] board, char c) {
// Check all possible winning combinations
for ( int i = 0 ; i < 8 ; i++) {
if (board[win[i][ 0 ]] == c
&& board[win[i][ 1 ]] == c
&& board[win[i][ 2 ]] == c) {
return true ;
}
}
return false ;
}

// Returns true if given board is valid, else returns false
static boolean isValid( char board[]) {
// Count number of \'X\' and \'O\' in the given board
int xCount = 0 , oCount = 0 ;
for ( int i = 0 ; i < 9 ; i++) {
if (board[i] == \'X\' ) {
xCount++;
}
if (board[i] == \'O\' ) {
oCount++;
}
}

// Board can be valid only if either xCount and oCount
// is same or count is one more than oCount
if (xCount == oCount || xCount == oCount + 1 ) {
// Check if \'O\' is winner
if (isCWin(board, \'O\' )) {
// Check if \'X\' is also winner, then
// return false
if (isCWin(board, \'X\' )) {
return false ;
}

// Else return true xCount and yCount are same
return (xCount == oCount);
}

// If \'X\' wins, then count of X must be greater
if (isCWin(board, \'X\' ) && xCount != oCount + 1 ) {
return false ;
}

// If \'O\' is not winner, then return true
return true ;
}
return false ;
}

// Driver program
public static void main(String[] args) {
char board[] = { \'X\' , \'X\' , \'O\' , \'O\' , \'O\' , \'X\' , \'X\' , \'O\' , \'X\' };

if ((isValid(board))) {
System.out.println( "Given board is valid" );
} else {
System.out.println( "Given board is not valid" );
}
}
}
//this code contributed by PrinciRaj1992
```





Python3
-------

















```
# Python3 program to check whether a given tic tac toe
# board is valid or not

# Returns true if char wins. Char can be either
# \'X\' or \'O\'
def win_check(arr, char):
# Check all possible winning combinations
matches = [[ 0 , 1 , 2 ], [ 3 , 4 , 5 ],
[ 6 , 7 , 8 ], [ 0 , 3 , 6 ],
[ 1 , 4 , 7 ], [ 2 , 5 , 8 ],
[ 0 , 4 , 8 ], [ 2 , 4 , 6 ]]

for i in range ( 8 ):
if (arr[(matches[i][ 0 ])] = = char and
arr[(matches[i][ 1 ])] = = char and
arr[(matches[i][ 2 ])] = = char):
return True
return False

def is_valid(arr):
# Count number of \'X\' and \'O\' in the given board
xcount = arr.count( \'X\' )
ocount = arr.count( \'O\' )

# Board can be valid only if either xcount and ocount
# is same or count is one more than oCount
if (xcount = = ocount + 1 or xcount = = ocount):
# Check if O wins
if win_check(arr, \'O\' ):
# Check if X wins, At a given point only one can win,
# if X also wins then return Invalid
if win_check(arr, \'X\' ):
return "Invalid"

# O can only win if xcount == ocount in case where whole
# board has values in each position.
if xcount = = ocount:
return "Valid"

# If X wins then it should be xc == oc + 1,
# If not return Invalid
if win_check(arr, \'X\' ) and xcount ! = ocount + 1 :
return "Invalid"

# if O is not the winner return Valid
if not win_check(arr, \'O\' ):
return "valid"

# If nothing above matches return invalid
return "Invalid"


# Driver Code
arr = [ \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' ]
print ( "Given board is " + is_valid(arr))
```





C#
--

















```
// C# program to check whether a given
// tic tac toe board is valid or not
using System;

class GFG
{

// This matrix is used to find indexes
// to check all possible winning triplets
// in board[0..8]
public static int [][] win = new int [][]
{
new int [] {0, 1, 2},
new int [] {3, 4, 5},
new int [] {6, 7, 8},
new int [] {0, 3, 6},
new int [] {1, 4, 7},
new int [] {2, 5, 8},
new int [] {0, 4, 8},
new int [] {2, 4, 6}
};

// Returns true if character \'c\'
// wins. c can be either \'X\' or \'O\'
public static bool isCWin( char [] board,
char c)
{
// Check all possible winning
// combinations
for ( int i = 0; i < 8; i++)
{
if (board[win[i][0]] == c &&
board[win[i][1]] == c &&
board[win[i][2]] == c)
{
return true ;
}
}
return false ;
}

// Returns true if given board
// is valid, else returns false
public static bool isValid( char [] board)
{
// Count number of \'X\' and
// \'O\' in the given board
int xCount = 0, oCount = 0;
for ( int i = 0; i < 9; i++)
{
if (board[i] == \'X\' )
{
xCount++;
}
if (board[i] == \'O\' )
{
oCount++;
}
}

// Board can be valid only if either
// xCount and oCount is same or count
// is one more than oCount
if (xCount == oCount ||
xCount == oCount + 1)
{
// Check if \'O\' is winner
if (isCWin(board, \'O\' ))
{
// Check if \'X\' is also winner,
// then return false
if (isCWin(board, \'X\' ))
{
return false ;
}

// Else return true xCount
// and yCount are same
return (xCount == oCount);
}

// If \'X\' wins, then count of
// X must be greater
if (isCWin(board, \'X\' ) &&
xCount != oCount + 1)
{
return false ;
}

// If \'O\' is not winner,
// then return true
return true ;
}
return false ;
}

// Driver Code
public static void Main( string [] args)
{
char [] board = new char [] { \'X\' , \'X\' , \'O\' , \'O\' , \'O\' ,
\'X\' , \'X\' , \'O\' , \'X\' };

if ((isValid(board)))
{
Console.WriteLine( "Given board is valid" );
}
else
{
Console.WriteLine( "Given board is not valid" );
}
}
}

// This code is contributed by Shrikant13
```





Javascript
----------

















```
<script>
// Javascript program to check whether a given
// tic tac toe board is valid or not

// This matrix is used to find indexes
// to check all possible winning triplets
// in board[0..8]

// Returns true if character \'c\' wins.
// c can be either \'X\' or \'O\'
function isCWin(board, c)
{
let win = new Array( new Array(0, 1, 2), // Check first row.
new Array(3, 4, 5), // Check second Row
new Array(6, 7, 8), // Check third Row
new Array(0, 3, 6), // Check first column
new Array(1, 4, 7), // Check second Column
new Array(2, 5, 8), // Check third Column
new Array(0, 4, 8), // Check first Diagonal
new Array(2, 4, 6)); // Check second Diagonal

// Check all possible winning combinations
for (let i = 0; i < 8; i++)
if (board[win[i][0]] == c &&
board[win[i][1]] == c &&
board[win[i][2]] == c )
return true ;
return false ;
}

// Returns true if given board is
// valid, else returns false
function isValid(board)
{
// Count number of \'X\' and \'O\'
// in the given board
let xCount = 0;
let oCount = 0;
for (let i = 0; i < 9; i++)
{
if (board[i] == \'X\' ) xCount++;
if (board[i] == \'O\' ) oCount++;
}

// Board can be valid only if either
// xCount and oCount is same or count
// is one more than oCount
if (xCount == oCount || xCount == oCount + 1)
{
// Check if \'O\' is winner
if (isCWin(board, \'O\' ))
{
// Check if \'X\' is also winner,
// then return false
if (isCWin(board, \'X\' ))
return false ;

// Else return true xCount and
// yCount are same
return (xCount == oCount);
}

// If \'X\' wins, then count of X
// must be greater
if (isCWin(board, \'X\' ) &&
xCount != oCount + 1)
return false ;

// If \'O\' is not winner, then
// return true
return true ;
}
return false ;
}

// Driver Code
let board = new Array( \'X\' , \'X\' , \'O\' , \'O\' ,
\'O\' , \'X\' , \'X\' , \'O\' , \'X\' );
if (isValid(board))
document.write( "Given board is valid" );
else
document.write( "Given board is not valid" );

// This code is contributed
// by Saurabh Jaiswal
</script>
```





PHP
---

















```
<?php
// PHP program to check whether a given
// tic tac toe board is valid or not

// This matrix is used to find indexes
// to check all possible winning triplets
// in board[0..8]

// Returns true if character \'c\' wins.
// c can be either \'X\' or \'O\'
function isCWin( $board , $c )
{
$win = array ( array (0, 1, 2), // Check first row.
array (3, 4, 5), // Check second Row
array (6, 7, 8), // Check third Row
array (0, 3, 6), // Check first column
array (1, 4, 7), // Check second Column
array (2, 5, 8), // Check third Column
array (0, 4, 8), // Check first Diagonal
array (2, 4, 6)); // Check second Diagonal

// Check all possible winning combinations
for ( $i = 0; $i < 8; $i ++)
if ( $board [ $win [ $i ][0]] == $c &&
$board [ $win [ $i ][1]] == $c &&
$board [ $win [ $i ][2]] == $c )
return true;
return false;
}

// Returns true if given board is
// valid, else returns false
function isValid(& $board )
{
// Count number of \'X\' and \'O\'
// in the given board
$xCount = 0;
$oCount = 0;
for ( $i = 0; $i < 9; $i ++)
{
if ( $board [ $i ] == \'X\' ) $xCount ++;
if ( $board [ $i ] == \'O\' ) $oCount ++;
}

// Board can be valid only if either
// xCount and oCount is same or count
// is one more than oCount
if ( $xCount == $oCount || $xCount == $oCount + 1)
{
// Check if \'O\' is winner
if (isCWin( $board , \'O\' ))
{
// Check if \'X\' is also winner,
// then return false
if (isCWin( $board , \'X\' ))
return false;

// Else return true xCount and
// yCount are same
return ( $xCount == $oCount );
}

// If \'X\' wins, then count of X
// must be greater
if (isCWin( $board , \'X\' ) &&
$xCount != $oCount + 1)
return false;

// If \'O\' is not winner, then
// return true
return true;
}
return false;
}

// Driver Code
$board = array ( \'X\' , \'X\' , \'O\' , \'O\' ,
\'O\' , \'X\' , \'X\' , \'O\' , \'X\' );
if (isValid( $board ))
echo ( "Given board is valid" );
else
echo ( "Given board is not valid" );

// This code is contributed
// by Shivi_Aggarwal
?>
```







**Output**

```
Given board is valid







```

****Time complexity:****
O(1)



****Auxiliary Space:****
O(1), since no extra space has been taken.


****Approach 2:****


The algorithm to check if a Tic-Tac-Toe board is valid or not is as follows:


* Initialize a 2D array win of size 8×3, which contains all possible winning combinations in Tic-Tac-Toe. Each row of the win array represents a winning combination, and each element in a row represents a cell index on the board.
* Define a function isCWin(board, c) which takes a board configuration board and a character c (‘X’ or ‘O’) as inputs, and returns true if character c has won on the board.
* Inside the isCWin function, iterate over each row of the win array. Check if the board has the same character c at all three cell indices of the current row. If yes, return true, as the character c has won.
* Define a function isValid(board) which takes a board configuration board as input, and returns true if the board is valid, else returns false.
* Inside the isValid function, count the number of ‘X’ and ‘O’ characters on the board, and store them in xCount and oCount variables, respectively.
* The board can be valid only if either xCount and oCount are the same, or xCount is one more than oCount.
* If ‘O’ is a winner on the board, check if ‘X’ is also a winner. If yes, return false as both ‘X’ and ‘O’ cannot win at the same time. If not, return true if xCount and oCount are the same, else return false.
* If ‘X’ is a winner on the board, then xCount must be one more than oCount. If not, return false.
* If ‘O’ is not a winner, return true as the board is valid.


Here is the code of the above approach:


C++
---

















```
// Returns true if character \'c\' wins. c can be either
// \'X\' or \'O\'
#include<bits/stdc++.h>
using namespace std;
bool isWinner( char *board, char c)
{
// Check all possible winning combinations
if ((board[0] == c && board[1] == c && board[2] == c) ||
(board[3] == c && board[4] == c && board[5] == c) ||
(board[6] == c && board[7] == c && board[8] == c) ||
(board[0] == c && board[3] == c && board[6] == c) ||
(board[1] == c && board[4] == c && board[7] == c) ||
(board[2] == c && board[5] == c && board[8] == c) ||
(board[0] == c && board[4] == c && board[8] == c) ||
(board[2] == c && board[4] == c && board[6] == c))
return true ;

return false ;
}

// Returns true if given board is valid, else returns false
bool isValid( char board[9])
{
// Count number of \'X\' and \'O\' in the given board
int xCount=0, oCount=0;
for ( int i=0; i<9; i++)
{
if (board[i]== \'X\' ) xCount++;
if (board[i]== \'O\' ) oCount++;
}

// Board can be valid only if either xCount and oCount
// is same or count is one more than oCount
if (xCount==oCount || xCount==oCount+1)
{
// Check if there is only one winner
if (isWinner(board, \'X\' ) && isWinner(board, \'O\' ))
return false ;

// If \'X\' wins, then count of X must be greater
if (isWinner(board, \'X\' ) && xCount != oCount + 1)
return false ;

// If \'O\' wins, then count of X must be same as oCount
if (isWinner(board, \'O\' ) && xCount != oCount)
return false ;

return true ;
}
return false ;
}

// Driver program
int main()
{
char board[] = { \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' };
(isValid(board))? cout << "Given board is valid" :
cout << "Given board is not valid" ;
return 0;
}
```





Java
----

















```
import java.util.Arrays;

public class TicTacToe {

// Returns true if character \'c\' wins. c can be either \'X\' or \'O\'
public static boolean isWinner( char [] board, char c) {
// Check all possible winning combinations
if ((board[ 0 ] == c && board[ 1 ] == c && board[ 2 ] == c) ||
(board[ 3 ] == c && board[ 4 ] == c && board[ 5 ] == c) ||
(board[ 6 ] == c && board[ 7 ] == c && board[ 8 ] == c) ||
(board[ 0 ] == c && board[ 3 ] == c && board[ 6 ] == c) ||
(board[ 1 ] == c && board[ 4 ] == c && board[ 7 ] == c) ||
(board[ 2 ] == c && board[ 5 ] == c && board[ 8 ] == c) ||
(board[ 0 ] == c && board[ 4 ] == c && board[ 8 ] == c) ||
(board[ 2 ] == c && board[ 4 ] == c && board[ 6 ] == c))
return true ;

return false ;
}

// Returns true if given board is valid, else returns false
public static boolean isValid( char [] board) {
// Count number of \'X\' and \'O\' in the given board
int xCount = 0 , oCount = 0 ;
for ( int i = 0 ; i < 9 ; i++) {
if (board[i] == \'X\' )
xCount++;
if (board[i] == \'O\' )
oCount++;
}

// Board can be valid only if either xCount and oCount is same or count is one more than oCount
if (xCount == oCount || xCount == oCount + 1 ) {
// Check if there is only one winner
if (isWinner(board, \'X\' ) && isWinner(board, \'O\' ))
return false ;

// If \'X\' wins, then count of X must be greater
if (isWinner(board, \'X\' ) && xCount != oCount + 1 )
return false ;

// If \'O\' wins, then count of X must be same as oCount
if (isWinner(board, \'O\' ) && xCount != oCount)
return false ;

return true ;
}
return false ;
}

// Driver program
public static void main(String[] args) {
char [] board = { \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' };

if (isValid(board))
System.out.println( "Given board is valid" );
else
System.out.println( "Given board is not valid" );
}
}
```





Python3
-------

















```
# Python Program for the above approach
def isWinner(board, c):
# Check all possible winning combinations
if (board[ 0 ] = = c and board[ 1 ] = = c and board[ 2 ] = = c) or \\
(board[ 3 ] = = c and board[ 4 ] = = c and board[ 5 ] = = c) or \\
(board[ 6 ] = = c and board[ 7 ] = = c and board[ 8 ] = = c) or \\
(board[ 0 ] = = c and board[ 3 ] = = c and board[ 6 ] = = c) or \\
(board[ 1 ] = = c and board[ 4 ] = = c and board[ 7 ] = = c) or \\
(board[ 2 ] = = c and board[ 5 ] = = c and board[ 8 ] = = c) or \\
(board[ 0 ] = = c and board[ 4 ] = = c and board[ 8 ] = = c) or \\
(board[ 2 ] = = c and board[ 4 ] = = c and board[ 6 ] = = c):
return True

return False


def isValid(board):
# Count number of \'X\' and \'O\' in the given board
xCount = 0
oCount = 0
for i in range ( 9 ):
if board[i] = = \'X\' :
xCount + = 1
if board[i] = = \'O\' :
oCount + = 1

# Board can be valid only if either xCount and oCount
# is same or count is one more than oCount
if xCount = = oCount or xCount = = oCount + 1 :
# Check if there is only one winner
if isWinner(board, \'X\' ) and isWinner(board, \'O\' ):
return False

# If \'X\' wins, then count of X must be greater
if isWinner(board, \'X\' ) and xCount ! = oCount + 1 :
return False

# If \'O\' wins, then count of X must be same as oCount
if isWinner(board, \'O\' ) and xCount ! = oCount:
return False

return True

return False


# Driver program
board = [ \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' ]

if isValid(board):
print ( "Given board is valid" )
else :
print ( "Given board is not valid" )
# THIS CODE IS CONTRIBUTED BY KIRTI AGARWAL
```





C#
--

















```
using System;

public class TicTacToe {

// Returns true if character \'c\' wins. c can be either \'X\' or \'O\'
public static bool IsWinner( char [] board, char c) {
// Check all possible winning combinations
if ((board[0] == c && board[1] == c && board[2] == c) ||
(board[3] == c && board[4] == c && board[5] == c) ||
(board[6] == c && board[7] == c && board[8] == c) ||
(board[0] == c && board[3] == c && board[6] == c) ||
(board[1] == c && board[4] == c && board[7] == c) ||
(board[2] == c && board[5] == c && board[8] == c) ||
(board[0] == c && board[4] == c && board[8] == c) ||
(board[2] == c && board[4] == c && board[6] == c))
return true ;

return false ;
}

// Returns true if given board is valid, else returns false
public static bool IsValid( char [] board) {
// Count number of \'X\' and \'O\' in the given board
int xCount = 0, oCount = 0;
for ( int i = 0; i < 9; i++) {
if (board[i] == \'X\' )
xCount++;
if (board[i] == \'O\' )
oCount++;
}

// Board can be valid only if either xCount and oCount is same or count is one more than oCount
if (xCount == oCount || xCount == oCount + 1) {
// Check if there is only one winner
if (IsWinner(board, \'X\' ) && IsWinner(board, \'O\' ))
return false ;

// If \'X\' wins, then count of X must be greater
if (IsWinner(board, \'X\' ) && xCount != oCount + 1)
return false ;

// If \'O\' wins, then count of X must be same as oCount
if (IsWinner(board, \'O\' ) && xCount != oCount)
return false ;

return true ;
}
return false ;
}

// Driver program
public static void Main( string [] args) {
char [] board = { \'X\' , \'X\' , \'O\' ,
\'O\' , \'O\' , \'X\' ,
\'X\' , \'O\' , \'X\' };

if (IsValid(board))
Console.WriteLine( "Given board is valid" );
else
Console.WriteLine( "Given board is not valid" );
}
}
```





Javascript
----------

















```
// Returns true if character \'c\' wins. c can be either \'X\' or \'O\'
function isWinner(board, c) {
// Check all possible winning combinations
if (
(board[0] === c && board[1] === c && board[2] === c) ||
(board[3] === c && board[4] === c && board[5] === c) ||
(board[6] === c && board[7] === c && board[8] === c) ||
(board[0] === c && board[3] === c && board[6] === c) ||
(board[1] === c && board[4] === c && board[7] === c) ||
(board[2] === c && board[5] === c && board[8] === c) ||
(board[0] === c && board[4] === c && board[8] === c) ||
(board[2] === c && board[4] === c && board[6] === c)
) {
return true ;
}

return false ;
}

// Returns true if given board is valid, else returns false
function isValid(board) {
// Count number of \'X\' and \'O\' in the given board
let xCount = 0;
let oCount = 0;
for (let i = 0; i < 9; i++) {
if (board[i] === \'X\' ) xCount++;
if (board[i] === \'O\' ) oCount++;
}

// Board can be valid only if either xCount and oCount
// is same or count is one more than oCount
if (xCount == oCount || xCount == oCount + 1) {
// Check if there is only one winner
if (isWinner(board, \'X\' ) && isWinner(board, \'O\' )) {
return false ;
}

// If \'X\' wins, then count of X must be greater
if (isWinner(board, \'X\' ) && xCount !== oCount + 1) {
return false ;
}

// If \'O\' wins, then count of X must be same as oCount
if (isWinner(board, \'O\' ) && xCount !== oCount) {
return false ;
}

return true ;
}

return false ;
}

// Driver program
const board = [ \'X\' , \'X\' , \'O\' , \'O\' , \'O\' , \'X\' , \'X\' , \'O\' , \'X\' ];
isValid(board) ? console.log( \'Given board is valid\' ) : console.log( \'Given board is not valid\' );
```







**Output**
```
Given board is valid







```

****Time complexity: O(N^2)****


****Auxiliary Space: O(N)****
', e'A Tic-Tac-Toe board is given after some moves are played. Find out if the given board is valid, i.e., is it possible to reach this board position after some moves or not.
', 'Validity of a given Tic-Tac-Toe board configuration', 12, null, '4e26b4bd-d406-4641-9d68-3ba8e1c39c97', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('7d5f99f3-4391-444d-92b9-28764219d6c9', e'# Need of Recursion

-   Recursion helps in logic building. Recursive thinking helps in solving complex problems by breaking them into smaller subproblems.
-   Recursive solutions work as a a basis for Dynamic Programming and Divide and Conquer algorithms.
-   Certain problems can be solved quite easily using recursion like [Towers of Hanoi (TOH)](https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/), [Inorder/Preorder/Postorder Tree Traversals](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/), [DFS of Graph](https://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/), etc.

# Steps to Implement Recursion

> ****Step1 - Define a base case:**** Identify the simplest (or base) case for which the solution is known or trivial. This is the stopping condition for the recursion, as it prevents the function from infinitely calling itself.
> 
> ****Step2 - Define a recursive case:**** Define the problem in terms of smaller subproblems. Break the problem down into smaller versions of itself, and call the function recursively to solve each subproblem.
> 
> ****Step3 - Ensure the recursion terminates:**** Make sure that the recursive function eventually reaches the base case, and does not enter an infinite loop.
> 
> ****Step4 - Combine the solutions:**** Combine the solutions of the subproblems to solve the original problem.

#### Example 1 : Sum of Natural Numbers

Let us consider a problem to find the sum of natural numbers, there are several ways of doing that but the simplest approach is simply to add the numbers starting from 0 to n.

![Sum-of-first-N-Natural-Numbers-1-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250418121303070670/Sum-of-first-N-Natural-Numbers-1-.webp)![Sum-of-first-N-Natural-Numbers-1-.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250418121303309221/Sum-of-first-N-Natural-Numbers-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250418121303602399/Sum-of-first-N-Natural-Numbers-3.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250418121304388951/Sum-of-first-N-Natural-Numbers-4.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250418121304005556/Sum-of-first-N-Natural-Numbers-5.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250418104001180384/sum_of_first_n_natural_numbers_06.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250418103902004504/sum_of_first_n_natural_numbers_7.webp)


## Comparison of Recursive and Iterative Approaches

| Approach | Complexity | Memory Usage |
| --- | --- | --- |
| *Iterative Approach* | O(n) | O(1) |
| *Recursive Approach* | O(n) | O(n) |

```C++
#include <iostream>
using namespace std;

// Recursive function to find the sum of 
// numbers from 0 to n
int findSum(int n)
{
    // Base case 
    if (n == 1) 
        return 1; 
  
    // Recursive case 
    return n + findSum(n - 1);
}

int main()
{
    int n = 5;
    cout << findSum(n);
    return 0;
}
``` 
```C
#include <stdio.h>

// Recursive function to find the sum of 
// numbers from 0 to n
int findSum(int n)
{
    // Base case 
    if (n == 1) 
        return 1; 
  
    // Recursive case 
    return n + findSum(n - 1);
}

int main()
{
    int n = 5;
    printf("%d", findSum(n));
    return 0;
}
``` 
```Java
public class Main {
    // Recursive function to find the sum of 
    // numbers from 0 to n
    static int findSum(int n) {
        // Base case 
        if (n == 1) 
            return 1; 
        
        // Recursive case 
        return n + findSum(n - 1);
    }

    public static void main(String[] args) {
        int n = 5;
        System.out.println(findSum(n));
    }
}
``` 
```Python
def findSum(n):
    # Base case 
    if n == 1:
        return 1
    
    # Recursive case 
    return n + findSum(n - 1)

n = 5
print(findSum(n))
```
```JavaScript
// Recursive function to find the sum of 
// numbers from 0 to n
function findSum(n) {
    // Base case 
    if (n === 1) 
        return 1;
    
    // Recursive case 
    return n + findSum(n - 1);
}

let n = 5;
console.log(findSum(n));
```

```output
15
```

# What is the base condition in recursion?   
A recursive program stops at a base condition. There can be more than one base conditions in a recursion. In the above program, the base condition is when n = 1.

## How a particular problem is solved using recursion?   
The idea is to represent a problem in terms of one or more smaller problems, and add one or more base conditions that stop the recursion.  

#### Example 2 : Factorial of a Number

The factorial of a number `n` (where `n >= 0`) is the product of all positive integers from 1 to `n`. To compute the factorial recursively, we calculate the factorial of `n` by using the factorial of `(n-1)`. The base case for the recursive function is when `n = 0`, in which case we return 1.

```cpp
#include <iostream>
using namespace std;

int fact(int n)
{
    // BASE CONDITION
    if (n == 0)
        return 1;
  
    return n * fact(n - 1);
}

int main()
{
    cout << "Factorial of 5 : " << fact(5);
    return 0;
}
```
```c
#include <stdio.h>

int fact(int n) {
  
    // BASE CONDITION
    if (n == 0)
        return 1;
  
    return n * fact(n - 1);
}

int main() {
    printf("Factorial of 5 : %d\\n", fact(5));
    return 0;
}
```
```java
public class GfG {
    public static int fact(int n) {
      
        // BASE CONDITION
        if (n == 0)
            return 1;
      
        return n * fact(n - 1);
    }

    public static void main(String[] args) {
        System.out.println("Factorial of 5 : " + fact(5));
    }
}
```
```python
def fact(n):
  
    # BASE CONDITION
    if n == 0:
        return 1
    return n * fact(n - 1)

print("Factorial of 5 : ", fact(5))
```
```javascript
function fact(n) {

    // BASE CONDITION
    if (n === 0)
        return 1;
    
    return n * fact(n - 1);
}

console.log("Factorial of 5 : " + fact(5));
```


```output
Factorial of 5 : 120
```

## Illustration of the above code

![factorial](https://media.geeksforgeeks.org/wp-content/uploads/20240924132748/factorial.webp)

## When does Stack Overflow error occur in recursion? 

If the base case is not reached or not defined, then the stack overflow problem may arise. Let us take an example to understand this.

```c
int fact(int n)  {  
	// wrong base case (it may cause stack overflow).  
	if (n == 100)  
		return 1;  
	else  
		return n*fact(n-1);  
}
```


-   In this example, if `fact(10)` is called, the function will recursively call `fact(9)`, then `fact(8)`, `fact(7)`, and so on. However, the base case checks if `n == 100`. Since `n` will never reach 100 during these recursive calls, the base case is never triggered. As a result, the recursion continues indefinitely.

-   This continuous recursion consumes memory on the function call stack. If the system\'s memory is exhausted due to these unending function calls, a ****stack overflow error**** occurs.

-   To prevent this, it\'s essential to define a proper base case, such as `if (n == 0)` to ensure that the recursion terminates and the function doesn\'t run out of memory.

# What is the difference between direct and indirect recursion?

A function is called ****direct recursive**** if it calls itself directly during its execution. In other words, the function makes a recursive call to itself within its own body.

An ****indirect recursive function**** is one that calls another function, and that other function, in turn, calls the original function either directly or through other functions. This creates a chain of recursive calls involving multiple functions, as opposed to direct recursion, where a function calls itself.

```c
// An example of direct recursion
void directRecFun() {   // Some code....
	directRecFun();
	// Some code...   
}
	// An example of indirect recursion
void indirectRecFun1(){  // Some code...	
	indirectRecFun2();
	// Some code...   
}   
void indirectRecFun2(){   
	// Some code...
	indirectRecFun1();
	// Some code...   
}
```

# What is the difference between tail and non-tail recursion?

A recursive function is tail recursive when a recursive call is the last thing executed by the function.

> Please refer [tail recursion](https://www.geeksforgeeks.org/tail-recursion/) for details. 

# How memory is allocated to different function calls in recursion?

Recursion uses more memory to store data of every recursive call in an internal function call stack.

-   Whenever we call a function, its record is added to the stack and remains there until the call is finished.
-   The internal systems use a [stack](https://www.geeksforgeeks.org/stack-data-structure/) because function calling follows LIFO structure, the last called function finishes first.

> When any function is called from main(), the memory is allocated to it on the stack. A recursive function calls itself, the memory for a called function is allocated on top of memory allocated to the calling function and a different copy of local variables is created for each function call. When the base case is reached, the function returns its value to the function by whom it is called and memory is de-allocated and the process continues.  
> Let us take the example of how recursion works by taking a simple function. 

```cpp
// A C++ program to demonstrate working of
// recursion
#include <bits/stdc++.h>
using namespace std;

void printFun(int test)
{
    if (test < 1)
        return;
    else {
        cout << test << " ";
        printFun(test - 1); // statement 2
        cout << test << " ";
        return;
    }
}

// Driver Code
int main()
{
    int test = 3;
    printFun(test);
}
```
```c
// A C program to demonstrate working of recursion
#include <stdio.h>

void printFun(int test)
{
    if (test < 1)
        return;
    else {
        printf("%d ", test);
        printFun(test - 1); // statement 2
        printf("%d ", test);
        return;
    }
}

// Driver Code
int main()
{
    int test = 3;
    printFun(test);
    return 0;
}
```
```java
// A Java program to demonstrate working of
// recursion
class GFG {
    static void printFun(int test)
    {
        if (test < 1)
            return;
        else {
            System.out.printf("%d ", test);
            printFun(test - 1); // statement 2
            System.out.printf("%d ", test);
            return;
        }
    }

    // Driver Code
    public static void main(String[] args)
    {
        int test = 3;
        printFun(test);
    }
}

// This code is contributed by
// Smitha Dinesh Semwal
```
```python
# A Python 3 program to
# demonstrate working of
# recursion


def printFun(test):

    if (test < 1):
        return
    else:

        print(test, end=" ")
        printFun(test-1)  # statement 2
        print(test, end=" ")
        return

# Driver Code
test = 3
printFun(test)

# This code is contributed by
# Smitha Dinesh Semwal
```
```javascript
// A JavaScript program to demonstrate working of recursion
function printFun(test) {
    if (test < 1)
        return;
    else {
        console.log(test);
        printFun(test - 1); // statement 2
        console.log(test);
        return;
    }
}

// Driver Code
let test = 3;
printFun(test);
```

```output
3 2 1 1 2 3
```

****Initial Call****: When `printFun(3)` is called from `main()`, memory is allocated for `printFun(3)`. The local variable `test` is initialized to 3, and statements 1 to 4 are pushed onto the stack.

****First Recursive Call****:

-   `printFun(3)` calls `printFun(2)`.
-   Memory for `printFun(2)` is allocated, the local variable `test` is initialized to 2, and statements 1 to 4 are pushed onto the stack.

****Second Recursive Call****:

-   `printFun(2)` calls `printFun(1)`.
-   Memory for `printFun(1)` is allocated, the local variable `test` is initialized to 1, and statements 1 to 4 are pushed onto the stack.

****Third Recursive Call****:

-   `printFun(1)` calls `printFun(0)`.
-   Memory for `printFun(0)` is allocated, the local variable `test` is initialized to 0, and statements 1 to 4 are pushed onto the stack.

****Base Case****: When `printFun(0)` is called, it hits the base case (if statement) and returns control to `printFun(1)`.

****Returning from Recursion****:

-   After returning from `printFun(0)`, the remaining statements of `printFun(1)` are executed and it returns control to `printFun(2)`.
-   Similarly, after returning from `printFun(2)`, control returns to `printFun(3)`.

****Output****: As a result, the output will print the values in the following order:

-   From 3 down to 1 (as the recursive calls are made).
-   Then from 1 back to 3 (as the recursive calls unwind).

The memory stack grows with each function call and shrinks as the recursion unwinds, following the LIFO structure.

![Recursion-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250319103918713990/Recursion-1.webp)![Recursion-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20250319103917789568/Recursion-2.webp)
![](https://media.geeksforgeeks.org/wp-content/uploads/20250319103918967763/Recursion-3.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250319103919474025/Recursion-4.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250319103919877930/Recursion-5.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250319103919667848/Recursion-6.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250319103919206948/Recursion-7.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20250319103918397321/Recursion-8.webp)



****Recursion VS Iteration****
|SR No. |Recursion|Iteration|
|---|---|---|
|1)|Terminates when the base case becomes true.|Terminates when the loop condition becomes false.|
|2)|Logic is built in terms of smaller problems.|Logic is built using iterating over something.|
|3)|Every recursive call needs extra space in the stack memory.|Every iteration does not require any extra space.|
|4)|Smaller code size.|Larger code size.|

## What are the advantages of recursive programming over iterative programming? 

-   Recursion provides a clean and simple way to write code.
-   Some problems are inherently recursive like [tree traversals](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/), [Tower of Hanoi](https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/), etc. For such problems, it is preferred to write recursive code. We can write such codes also iteratively with the help of a stack data structure.

## What are the disadvantages of recursive programming over iterative programming?

Note every recursive program can be written iteratively and vice versa is also true.

-   Recursive programs typically have more space requirements and also more time to maintain the recursion call stack.
-   Recursion can make the code more difficult to understand and debug, since it requires thinking about multiple levels of function calls..

#### Example 3 : Fibonacci with Recursion

Write a program and recurrence relation to find the [Fibonacci](https://www.geeksforgeeks.org/fibonacci-sequence/) series of n where n >= 0. 

****Mathematical Equation:****  

```c
n if n == 0, n == 1; 
fib(n) = fib(n-1) + fib(n-2) otherwise;
```

****Recurrence Relation:**** 

> `T(n) = T(n-1) + T(n-2) + O(1)`

```cpp
// C++ code to implement Fibonacci series
#include <bits/stdc++.h>
using namespace std;

// Function for fibonacci

int fib(int n)
{
    // Stop condition
    if (n == 0)
        return 0;

    // Stop condition
    if (n == 1 || n == 2)
        return 1;

    // Recursion function
    else
        return (fib(n - 1) + fib(n - 2));
}

// Driver Code
int main()
{
    // Initialize variable n.
    int n = 5;
    cout<<"Fibonacci series of 5 numbers is: ";

    // for loop to print the fibonacci series.
    for (int i = 0; i < n; i++) 
    {
        cout<<fib(i)<<" ";
    }
    return 0;
}
```
```c
// C code to implement Fibonacci series
#include <stdio.h>

// Function for fibonacci
int fib(int n)
{
    // Stop condition
    if (n == 0)
        return 0;

    // Stop condition
    if (n == 1 || n == 2)
        return 1;

    // Recursion function
    else
        return (fib(n - 1) + fib(n - 2));
}

// Driver Code
int main()
{
    // Initialize variable n.
    int n = 5;
    printf("Fibonacci series "
           "of %d numbers is: ",
           n);

    // for loop to print the fibonacci series.
    for (int i = 0; i < n; i++) {
        printf("%d ", fib(i));
    }
    return 0;
}
```
```java
// Java code to implement Fibonacci series
import java.util.*;

class GFG
{

// Function for fibonacci
static int fib(int n)
{
    // Stop condition
    if (n == 0)
        return 0;

    // Stop condition
    if (n == 1 || n == 2)
        return 1;

    // Recursion function
    else
        return (fib(n - 1) + fib(n - 2));
}

// Driver Code
public static void main(String []args)
{
  
    // Initialize variable n.
    int n = 5;
    System.out.print("Fibonacci series of 5 numbers is: ");

    // for loop to print the fibonacci series.
    for (int i = 0; i < n; i++) 
    {
        System.out.print(fib(i)+" ");
    }
}
}

// This code is contributed by rutvik_56.
```
```python
# Python code to implement Fibonacci series

# Function for fibonacci
def fib(n):

    # Stop condition
    if (n == 0):
        return 0

    # Stop condition
    if (n == 1 or n == 2):
        return 1

    # Recursion function
    else:
        return (fib(n - 1) + fib(n - 2))


# Driver Code

# Initialize variable n.
n = 5;
print("Fibonacci series of 5 numbers is :",end=" ")

# for loop to print the fibonacci series.
for i in range(0,n): 
    print(fib(i),end=" ")
```
```javascript
// Function for fibonacci
function fib(n) {
    // Stop condition
    if (n === 0) return 0;

    // Stop condition
    if (n === 1 || n === 2) return 1;

    // Recursion function
    return fib(n - 1) + fib(n - 2);
}

// Driver Code
let n = 5;
console.log("Fibonacci series of 5 numbers is:");

// for loop to print the fibonacci series.
for (let i = 0; i < n; i++) {
    console.log(fib(i) + " ");
}
```

```output
Fibonacci series of 5 numbers is: 0 1 1 2 3 
```

****Recursion Tree for the above Code:****

![Fibonacci-series](https://media.geeksforgeeks.org/wp-content/uploads/20250318141757504475/Fibonacci-series.webp)


# Common Applications of Recursion

1.  ****Tree and Graph Traversal****: Used for systematically exploring nodes/vertices in data structures like trees and graphs.
2.  ****Sorting Algorithms****: Algorithms like quicksort and merge sort divide data into subarrays, sort them recursively, and merge them.
3.  ****Divide-and-Conquer Algorithms****: Algorithms like binary search break problems into smaller subproblems using recursion.
4.  ****Fractal Generation****: Recursion helps generate fractal patterns, such as the Mandelbrot set, by repeatedly applying a recursive formula.
5.  ****Backtracking Algorithms****: Used for problems requiring a sequence of decisions, where recursion explores all possible paths and backtracks when needed.
6.  ****Memoization****: Involves caching results of recursive function calls to avoid recomputing expensive subproblems.

These are just a few examples of the many applications of recursion in computer science and programming. Recursion is a versatile and powerful tool that can be used to solve many different types of problems.

# Summary of Recursion:

-   There are two types of cases in recursion i.e. recursive case and a base case.
-   The base case is used to terminate the recursive function when the case turns out to be true.
-   Each recursive call makes a new copy of that method in the stack memory.
-   Infinite recursion may lead to running out of stack memory.
', e'The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function.

-   A recursive algorithm takes one step toward solution and then recursively call itself to further move. The algorithm stops once we reach the solution.
-   Since called function may further call itself, this process might continue forever. So it is essential to provide a base case to terminate this recursion process.', 'Introduction to Recursion', 2, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('0a6a3db2-efff-45ec-8886-b5862fbb75e1', e'# What is Tail recursion?
****Tail recursion**** is defined as a recursive function in which the recursive call is the last statement that is executed by the function. So basically nothing is left to execute after the recursion call.

For example the following function print() is tail recursive.

```cpp
// An example of tail recursive function

static void print(int n)
{
    if (n < 0)
        return;
    cout << " " << n;
 
    // The last executed statement is recursive call
    print(n - 1);
}
```
```c
// An example of tail recursive function

void print(int n)
{
    if (n < 0)
        return;
    printf("%d ", n);

    // The last executed statement is recursive call
    print(n - 1);
}
```
```java
// An example of tail recursive function

static void print(int n)
{
    if (n < 0)
        return;

    System.out.print(" " + n);

    // The last executed statement
    // is recursive call
    print(n - 1);
}
```
```python
# An example of tail recursive function


def prints(n):

    if (n < 0):
        return
    print(str(n), end=\' \')

    # The last executed statement is recursive call
    prints(n-1)
```
```csharp
// An example of tail recursive function

static void print(int n)
{
    if (n < 0)
        return;

    Console.Write(" " + n);

    // The last executed statement
    // is recursive call
    print(n - 1);
}
```
```javascript
function prints(n) {
    if (n < 0) {
        return;
    }
    console.log(n);
    
    // The last executed statement
    // is recursive call
    prints(n - 1);
}
```

# Need for Tail Recursion:

The tail recursive functions are considered better than non-tail recursive functions as tail-recursion can be optimized by the compiler. 

Compilers usually execute recursive procedures by using a ****stack****. This stack consists of all the pertinent information, including the parameter values, for each recursive call. When a procedure is called, its information is ****pushed**** onto a stack, and when the function terminates the information is ****popped**** out of the stack. Thus for the non-tail-recursive functions, the ****stack depth**** (maximum amount of stack space used at any time during compilation) is more. 

> The idea used by compilers to optimize tail-recursive functions is simple, since the recursive call is the last statement, there is nothing left to do in the current function, so saving the current function\'s stack frame is of no use (See [this](https://www.geeksforgeeks.org/tail-call-elimination/) for more details).

# Can a non-tail-recursive function be written as tail-recursive to optimize it?

Consider the following function to calculate the factorial of n. 

It is a non-tail-recursive function. Although it looks like a tail recursive at first look. If we take a closer look, we can see that the value returned by fact(n-1) is used in ****fact(n)****. So the call to ****fact(n-1)**** is not the last thing done by ****fact(n)****.

```cpp
#include <iostream>
using namespace std;

// A NON-tail-recursive function.  The function is not tail
// recursive because the value returned by fact(n-1) is used
// in fact(n) and call to fact(n-1) is not the last thing
// done by fact(n)
unsigned int fact(unsigned int n)
{
    if (n <= 0)
        return 1;

    return n * fact(n - 1);
}

// Driver program to test above function
int main()
{
    cout << fact(5);
    return 0;
}
```
```java
class GFG {

    // A NON-tail-recursive function.
    // The function is not tail
    // recursive because the value
    // returned by fact(n-1) is used
    // in fact(n) and call to fact(n-1)
    // is not the last thing done by
    // fact(n)
    static int fact(int n)
    {
        if (n == 0)
            return 1;

        return n * fact(n - 1);
    }

    // Driver program
    public static void main(String[] args)
    {
        System.out.println(fact(5));
    }
}

// This code is contributed by Smitha.
```
```python
# A NON-tail-recursive function.
# The function is not tail
# recursive because the value
# returned by fact(n-1) is used
# in fact(n) and call to fact(n-1)
# is not the last thing done by
# fact(n)


def fact(n):
    if (n == 0):
        return 1
    return n * fact(n-1)


# Driver program to test
# above function
if __name__ == \'__main__\':
    print(fact(5))
```
```csharp
using System;

class GFG {

    // A NON-tail-recursive function.
    // The function is not tail
    // recursive because the value
    // returned by fact(n-1) is used
    // in fact(n) and call to fact(n-1)
    // is not the last thing done by
    // fact(n)
    static int fact(int n)
    {
        if (n == 0)
            return 1;

        return n * fact(n - 1);
    }

    // Driver program to test
    // above function
    public static void Main() { Console.Write(fact(5)); }
}

// This code is contributed by Smitha
```
```javascript
// A NON-tail-recursive function
// The function is not tail
// recursive because the value
// returned by fact(n-1) is used
// in fact(n) and call to fact(n-1)
// is not the last thing done by
// fact(n)

function fact(n) {
    if (n === 0) {
        return 1;
    }
    return n * fact(n - 1);
}

// Driver program to test
// above function
console.log(fact(5));
```

```Output
120
```

The above function can be written as a tail-recursive function. The idea is to use one more argument and accumulate the factorial value in the second argument. When n reaches 0, return the accumulated value.

Below is the implementation using a tail-recursive function.

```cpp
#include <iostream>
using namespace std;

// A tail recursive function to calculate factorial
unsigned factTR(unsigned int n, unsigned int a)
{
    if (n <= 1)
        return a;

    return factTR(n - 1, n * a);
}

// A wrapper over factTR
unsigned int fact(unsigned int n) { return factTR(n, 1); }

// Driver program to test above function
int main()
{
    cout << fact(5);
    return 0;
}
```
```java
// Java Code for Tail Recursion

class GFG {

    // A tail recursive function
    // to calculate factorial
    static int factTR(int n, int a)
    {
        if (n <= 0)
            return a;

        return factTR(n - 1, n * a);
    }

    // A wrapper over factTR
    static int fact(int n) { return factTR(n, 1); }

    // Driver code
    static public void main(String[] args)
    {
        System.out.println(fact(5));
    }
}

// This code is contributed by Smitha.
```
```python
# A tail recursive function
# to calculate factorial


def fact(n, a=1):

    if (n <= 1):
        return a

    return fact(n - 1, n * a)


# Driver program to test
# above function
print(fact(5))

# This code is contributed
# by Smitha
# improved by Ujwal, ashish2021
```
```csharp
// C# Code for Tail Recursion

using System;

class GFG {

    // A tail recursive function
    // to calculate factorial
    static int factTR(int n, int a)
    {
        if (n <= 0)
            return a;

        return factTR(n - 1, n * a);
    }

    // A wrapper over factTR
    static int fact(int n) { return factTR(n, 1); }

    // Driver code
    static public void Main()
    {
        Console.WriteLine(fact(5));
    }
}

// This code is contributed by Ajit.
```
```javascript
<script>

// Javascript Code for Tail Recursion

// A tail recursive function
// to calculate factorial
function factTR(n, a)
{
    if (n <= 0)
        return a;
 
    return factTR(n - 1, n * a);
}
 
// A wrapper over factTR
function fact(n)
{
    return factTR(n, 1);
}

// Driver code 
document.write(fact(5));

// This code is contributed by rameshtravel07
    
</script>
```

```output
120
```', 'Tail recursion is a special form of recursion where the recursive call is the last operation in the function.', 'What is Tail Recursion', 4, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('c8c6920e-7046-48a4-8dbe-89905c592b0d', e'# Case Study
Given an array, ****arr**** of n integers, and an integer element ****x****, find whether element ****x**** is present in the array. Return the index of the first occurrence of ****x**** in the array, or -1 if it doesn\'t exist.

> ****Input****: arr[] = [1, 2, 3, 4], x = 3  
> ****Output****: 2  
> ****Explanation****: There is one test case with array as [1, 2, 3 4] and element to be searched as 3. Since 3 is present at index 2, the output is 2.

> ****Input****: arr[] = [10, 8, 30, 4, 5], x = 5  
> ****Output****: 4  
> ****Explanation****: For array [10, 8, 30, 4, 5], the element to be searched is 5 and it is at index 4. So, the output is 4.

> ****Input****: arr[] = [10, 8, 30], x = 6  
> ****Output****: -1  
> ****Explanation****: The element to be searched is 6 and its not present, so we return -1.



In Linear Search, we iterate over all the elements of the array and check if it the current element is equal to the target element. If we find any element to be equal to the target element, then return the index of the current element. Otherwise, if no element is equal to the target element, then return -1 as the element is not found. Linear search is also known as ****sequential search****.

****For example:**** Consider the array ****arr[] = {10, 50, 30, 70, 80, 20, 90, 40}**** and ****key**** = 30

![Linear-search-algorithm-1.webp](https://media.geeksforgeeks.org/wp-content/uploads/20240902185521/Linear-search-algorithm-1.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240902185522/Linear-search-algorithm-2.webp)![](https://media.geeksforgeeks.org/wp-content/uploads/20240902185522/Linear-search-algorithm-3.webp)

Below is the implementation of the linear search algorithm:

```cpp
#include <iostream>
#include <vector>
using namespace std;

int search(vector<int>& arr, int x) {
    for (int i = 0; i < arr.size(); i++)
        if (arr[i] == x)
            return i;
    return -1;
}

int main() {
    vector<int> arr = {2, 3, 4, 10, 40};
    int x = 10;
    int res = search(arr, x);
    if (res == -1)
       cout << "Not Present";
    else
       cout << "Present at Index " << res;
    return 0;
}
```
```c
// C code to linearly search x in arr[].

#include <stdio.h>

int search(int arr[], int N, int x)
{
    for (int i = 0; i < N; i++)
        if (arr[i] == x)
            return i;
    return -1;
}

// Driver code
int main(void)
{
    int arr[] = { 2, 3, 4, 10, 40 };
    int x = 10;
    int N = sizeof(arr) / sizeof(arr[0]);

    // Function call
    int result = search(arr, N, x);
    (result == -1)
        ? printf("Element is not present in array")
        : printf("Element is present at index %d", result);
    return 0;
}
```
```java
// Java code for linearly searching x in arr[]. 

import java.io.*;

class GFG {
    public static int search(int arr[], int N, int x)
    {
        for (int i = 0; i < N; i++) {
            if (arr[i] == x)
                return i;
        }
        return -1;
    }

    // Driver code
    public static void main(String args[])
    {
        int arr[] = { 2, 3, 4, 10, 40 };
        int x = 10;

        // Function call
        int result = search(arr, arr.length, x);
        if (result == -1)
            System.out.print(
                "Element is not present in array");
        else
            System.out.print("Element is present at index "
                             + result);
    }
}
```
```python
# Python3 code to linearly search x in arr[].


def search(arr, N, x):

    for i in range(0, N):
        if (arr[i] == x):
            return i
    return -1


# Driver Code
if __name__ == "__main__":
    arr = [2, 3, 4, 10, 40]
    x = 10
    N = len(arr)

    # Function call
    result = search(arr, N, x)
    if(result == -1):
        print("Element is not present in array")
    else:
        print("Element is present at index", result)
```
```csharp
// C# code to linearly search x in arr[].

using System;

class GFG {
    public static int search(int[] arr, int N, int x)
    {
        for (int i = 0; i < N; i++) {
            if (arr[i] == x)
                return i;
        }
        return -1;
    }

    // Driver\'s code
    public static void Main()
    {
        int[] arr = { 2, 3, 4, 10, 40 };
        int x = 10;

        // Function call
        int result = search(arr, arr.Length, x);
        if (result == -1)
            Console.WriteLine(
                "Element is not present in array");
        else
            Console.WriteLine("Element is present at index "
                              + result);
    }
}

// This code is contributed by DrRoot_
```
```javascript
// Javascript code to linearly search x in arr[].

function search(arr, n, x)
{
    for (let i = 0; i < n; i++)
        if (arr[i] == x)
            return i;
    return -1;
}

// Driver code

    let arr = [ 2, 3, 4, 10, 40 ];
    let x = 10;
    let n = arr.length;

    // Function call
    let result = search(arr, n, x);
    (result == -1)
        ? console.log("Element is not present in array")
        : console.log("Element is present at index " + result);

// This code is contributed by Manoj
```

# Time and Space Complexity of Linear Search Algorithm

****Time Complexity:****

-   ****Best Case:**** In the best case, the key might be present at the first index. So the best case complexity is O(1)
-   ****Worst Case:**** In the worst case, the key might be present at the last index i.e., opposite to the end from which the search has started in the list. So the worst-case complexity is O(N) where N is the size of the list.
-   ****Average Case:**** O(N)

****Auxiliary Space:**** O(1) as except for the variable to iterate through the list, no other variable is used. 

# Applications of Linear Search Algorithm:

-   ****Unsorted Lists:**** When we have an unsorted array or list, linear search is most commonly used to find any element in the collection.
-   ****Small Data Sets:**** Linear Search is preferred over binary search when we have small data sets with
-   ****Searching Linked Lists:**** In linked list implementations, linear search is commonly used to find elements within the list. Each node is checked sequentially until the desired element is found.
-   ****Simple Implementation:**** Linear Search is much easier to understand and implement as compared to Binary Search or Ternary Search.

# Advantages of Linear Search Algorithm

-   Linear search can be used irrespective of whether the array is sorted or not. It can be used on arrays of any data type.
-   Does not require any additional memory.
-   It is a well-suited algorithm for small datasets.

# Disadvantages of Linear Search Algorithm

-   Linear search has a time complexity of O(N), which in turn makes it slow for large datasets.
-   Not suitable for large arrays.

# When to use Linear Search Algorithm?

-   When we are dealing with a small dataset.
-   When you are searching for a dataset stored in contiguous memory.', 'Linear Search is a simple algorithm that sequentially checks each element in a list until the target value is found or the list ends, with O(n) time complexity.', 'Linear Search Algorithm', 7, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('bba978cc-2698-4a61-8482-5c4d41408e1f', e'![Introduction-to-Hashing](https://media.geeksforgeeks.org/wp-content/uploads/20240807120551/Introduction-to-Hashing.webp)

# Hash Table Data Structure Overview
It is one of the most widely used data structure after arrays.

It mainly supports search, insert and delete in O(1) time on average which is more efficient than other popular data structures like arrays, Linked List and [Self Balancing BST](https://www.geeksforgeeks.org/self-balancing-binary-search-trees/).

We use hashing for dictionaries, frequency counting, maintaining data for quick access by key, etc.

Real World Applications include Database Indexing, Cryptography, Caches, Symbol Table and Dictionaries.

There are mainly two forms of hash typically implemented in programming languages.

****Hash Set**** : Collection of unique keys (Implemented as [Set in Python](https://www.geeksforgeeks.org/sets-in-python/), [Set in JavaScrtipt](https://www.geeksforgeeks.org/sets-in-javascript/), [unordered\\_set in C++](https://www.geeksforgeeks.org/unordered_set-in-cpp-stl/) and [HashSet in Java](https://www.geeksforgeeks.org/hashset-in-java/).

****Hash Map**** : Collection of key value pairs with keys being unique (Implemented as [dictionary in Python,](https://www.geeksforgeeks.org/python-dictionary/) [Map in JavaScript](https://www.geeksforgeeks.org/javascript-map/), [unordered\\_map in C++](https://www.geeksforgeeks.org/unordered_map-in-cpp-stl/) and [HashMap in Java](https://www.geeksforgeeks.org/java-util-hashmap-in-java-with-examples/))

  

## Situations Where Hash is not Used

  

Need to maintain sorted data along with search, insert and delete. We use a self balancing BST in these cases.

When Strings are keys and we need operations like prefix search along with search, insert and delete. We use Trie in these cases.

When we need operations like floor and ceiling along with search, insert and/or delete. We use Self Balancing BST in these cases.

  

## Components of Hashing
There are majorly three components of hashing:

1. ****Key:**** A Key can be anything string or integer which is fed as input in the hash function the technique that determines an index or location for storage of an item in a data structure.

2. ****Hash Function:**** Receives the input key and returns the index of an element in an array called a hash table. The index is known as the hash index .

3. ****Hash Table:**** Hash table is typically an array of lists. It stores values corresponding to the keys. Hash stores the data in an associative manner in an array where each data value has its own unique index.

  

![Components-of-Hashing](https://media.geeksforgeeks.org/wp-content/uploads/20240508162701/Components-of-Hashing.webp)

  

# How does Hashing work?
Suppose we have a set of strings {“ab”, “cd”, “efg”} and we would like to store it in a table.

- ****Step 1:**** We know that hash functions (which is some mathematical formula) are used to calculate the hash value which acts as the index of the data structure where the value will be stored.

- ****Step 2:**** So, let’s assign

	- “a” = 1,

	- “b”=2, .. etc, to all alphabetical characters.

- ****Step 3:**** Therefore, the numerical value by summation of all characters of the string:
	- “ab” = 1 + 2 = 3,
	- “cd” = 3 + 4 = 7 ,
	- “efg” = 5 + 6 + 7 = 18
- ****Step 4:**** Now, assume that we have a table of size 7 to store these strings. The hash function that is used here is the sum of the characters in ****key mod Table size**** . We can compute the location of the string in the array by taking the ****sum(string) mod 7**** .
- ****Step 5:**** So we will then store
	- “ab” in 3 mod 7 = 3,
	- “cd” in 7 mod 7 = 0, and
	- “efg” in 18 mod 7 = 4.

  

![Mapping-Key-with-indices-of-Array](https://media.geeksforgeeks.org/wp-content/uploads/20240514124555/Mapping-Key-with-indices-of-Array.webp)

  

The above technique enables us to calculate the location of a given string by using a simple hash function and rapidly find the value that is stored in that location. Therefore the idea of hashing seems like a great way to store (key, value) pairs of the data in a table.

  

# What is a Hash function?

  

A [hash function](https://www.geeksforgeeks.org/hash-functions-and-list-types-of-hash-functions/) creates a mapping from an input key to an index in hash table, this is done through the use of mathematical formulas known as hash functions. For example: Consider phone numbers as keys and a hash table of size 100. A simple example hash function can be to consider the last two digits of phone numbers so that we have valid array indexes as output. A good hash function should have the following properties:

  

1. Efficient

2. Should uniformly distribute the keys to each index of hash table.

3. Should minimize collisions (This and the below are mainly derived from the above 2nd point)

4. Should have a low load factor (number of items in the table divided by the size of the table).

  

# What is Collision in Hashing?

  

When two or more keys have the same hash value, a ****collision**** happens. If we consider the above example, the hash function we used is the sum of the letters, but if we examined the hash function closely then the problem can be easily visualised that for different strings same hash value is being generated by the hash function.

  

For example: {“ab”, “ba”} both have the same hash value, and string {“cd”,”be”} also generate the same hash value, etc. This is known as ****collision**** and it creates problem in searching, insertion, deletion, and updating of value.

  

![collision-in-hashing](https://media.geeksforgeeks.org/wp-content/uploads/20241223161945846651/collision-in-hashing.webp)


The probability of a hash collision depends on the size of the algorithm, the distribution of hash values and the efficiency of Hash function. To handle this collision, we use [****Collision Resolution Techniques****](https://www.geeksforgeeks.org/collision-resolution-techniques/).

  

# What is meant by Load Factor in Hashing?

  

The [load factor](https://www.geeksforgeeks.org/load-factor-and-rehashing) of the hash table can be defined as the number of items the hash table contains divided by the size of the hash table. Load factor is the decisive parameter that is used when we want to rehash the previous hash function or want to add more elements to the existing hash table.

  

It helps us in determining the efficiency of the hash function i.e. it tells whether the hash function which we are using is distributing the keys uniformly or not in the hash table.

  

> Load Factor = Total elements in hash table/ Size of hash table

  

# What is Rehashing?

  

As the name suggests, [rehashing](https://www.geeksforgeeks.org/load-factor-and-rehashing/?ref=lbp#:~:text=Rehashing%3A,and%20low%20complexity.) means hashing again. Basically, when the load factor increases to more than its predefined value (the default value of the load factor is 0.75), the complexity increases. So to overcome this, the size of the array is increased (doubled) and all the values are hashed again and stored in the new double-sized array to maintain a low load factor and low complexity.

  

# How to Create Your Own Hash Table?
- [You Own Hash Table with Chaining](https://www.geeksforgeeks.org/c-program-hashing-chaining/)
- [Your Own Hash Table with Linear Probing in Open Addressing](https://www.geeksforgeeks.org/implementing-hash-table-open-addressing-linear-probing-cpp/)
- [Your Own Hash Table with Quadratic Probing in Open Addressing](https://www.geeksforgeeks.org/quadratic-probing-in-hashing/)', 'Hashing refers to the process of generating a small sized output (that can be used as index in a table) from an input of typically large and variable size. ', 'Introduction to Hashing', 19, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('079b30d0-e7d5-4d83-9a3d-fdb634fc16ae', e'# Overview Hashing 
**Hash functions** are a fundamental concept in computer science and play a crucial role in various applications such as data storage, retrieval, and cryptography. A hash function creates a mapping from an input key to an index in hash table. Below are few examples.
- **Phone numbers as input keys** : Consider a hash table of size 100. A simple example hash function is to consider the last two digits of phone numbers so that we have valid hash table indexes as output. This is mainly taking remainder when input phone number is divided by 100. Please note that taking first two digits of a phone number would not be a good idea for a hash function as there would be many phone number having same first two digits.
- **Lowercase English Strings as Keys** : Consider a hash table of size 100. A simple way to hash the strings would be add their codes (1 for a, 2 for b, … 26 for z) and take remainder of the sum when divided by 100. This hash function may not be a good idea as strings “ad” and “bc” would have the same hash value. A better idea would be to do weighted sum of characters and then find remainder. Please refer an [example string hashing function](https://www.geeksforgeeks.org/string-hashing-using-polynomial-rolling-hash-function/) for details.

  

## Key Properties of Hash Functions
- **Deterministic**: A hash function must consistently produce the same output for the same input.

- **Fixed Output Size**: The output of a hash function should have a fixed size, regardless of the size of the input.

- **Efficiency**: The hash function should be able to process input quickly.

- **Uniformity**: The hash function should distribute the hash values uniformly across the output space to avoid clustering.

- **Pre-image Resistance**: It should be computationally infeasible to reverse the hash function, i.e., to find the original input given a hash value.

- **Collision Resistance**: It should be difficult to find two different inputs that produce the same hash value.

- **Avalanche Effect**: A small change in the input should produce a significantly different hash value.

  

# Applications of Hash Functions
- **Hash Tables**: The most common use of hash functions in DSA is in hash tables, which provide an efficient way to store and retrieve data.

- **Data Integrity**: Hash functions are used to ensure the integrity of data by generating checksums.

- **Cryptography**: In cryptographic applications, hash functions are used to create secure hash algorithms like SHA-256.

- **Data Structures**: Hash functions are utilized in various data structures such as Bloom filters and hash sets.
# Types of Hash Functions
There are many hash functions that use numeric or alphanumeric keys. This article focuses on discussing different hash functions:
1. Division Method.

2. Multiplication Method

3. Mid-Square Method

4. Folding Method

5. Cryptographic Hash Functions

6. Universal Hashing

7. Perfect Hashing

Let’s begin discussing these methods in detail.

  

## 1. Division Method

  

The division method involves dividing the key by a prime number and using the remainder as the hash value.

  

> __h__(__k__)=__k__ mod __m__
> Where __k__ is the key and __m__ is a prime number.

  

**Advantages**:
- Simple to implement.
- Works well when __m__ is a prime number.

**Disadvantages**:
- Poor distribution if __m__ is not chosen wisely.

  

## 2. Multiplication Method

  

In the multiplication method, a constant __A__ (0 < A < 1) is used to multiply the key. The fractional part of the product is then multiplied by __m__ to get the hash value.

  

> __h__(__k__)=⌊__m__(__kA__mod1)⌋
> Where ⌊ ⌋ denotes the floor function.

**Advantages**:
- Less sensitive to the choice of __m__.

  

**Disadvantages**:
- More complex than the division method.

  

## 3. Mid-Square Method

  

In the mid-square method, the key is squared, and the middle digits of the result are taken as the hash value.

  

**Steps**:
1. Square the key.

2. Extract the middle digits of the squared value.

**Advantages**:
- Produces a good distribution of hash values.

**Disadvantages**:
- May require more computational effort.
## 4. Folding Method
The folding method involves dividing the key into equal parts, summing the parts, and then taking the modulo with respect to __m__.
**Steps**:
1. Divide the key into parts.
2. Sum the parts.
3. Take the modulo __m__ of the sum.

**Advantages**:
- Simple and easy to implement.

**Disadvantages**:
- Depends on the choice of partitioning scheme.
## 5. Cryptographic Hash Functions
Cryptographic hash functions are designed to be secure and are used in cryptography. Examples include MD5, SHA-1, and SHA-256.

**Characteristics**:
- Pre-image resistance.
- Second pre-image resistance.
- Collision resistance.

**Advantages**:
- High security.

**Disadvantages**:
- Computationally intensive.

  

## 6. Universal Hashing
Universal hashing uses a family of hash functions to minimize the chance of collision for any given set of inputs.
> __h__(__k__)=((__a__⋅__k__+__b__)mod __p__)mod __m__ 
>
> Where __a__ and __b__ are randomly chosen constants, __p__ is a prime number greater than __m__, and __k__ is the key.

**Advantages**:
- Reduces the probability of collisions.

**Disadvantages**:
- Requires more computation and storage.
## 7. Perfect Hashing
Perfect hashing aims to create a collision-free hash function for a static set of keys. It guarantees that no two keys will hash to the same value.
**Types**:
- Minimal Perfect Hashing: Ensures that the range of the hash function is equal to the number of keys.
- Non-minimal Perfect Hashing: The range may be larger than the number of keys.
**Advantages**:
- No collisions.
**Disadvantages**:
- Complex to construct.
# Conclusion
In conclusion, hash functions are very important tools that help store and find data quickly. Knowing the different types of hash functions and how to use them correctly is key to making software work better and more securely. By choosing the right hash function for the job, developers can greatly improve the efficiency and reliability of their systems.', 'Handle hashing in several cases', 'Hash Functions and Types of Hash functions', 20, null, '8ff4ea92-41f2-4d49-b230-0281874efb2d', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('451c319e-a0a3-48e5-baca-ece2737e6010', e'Representation of Stack Data Structure:
---------------------------------------

Stack follows LIFO (Last In First Out) Principle so the element which
is pushed last is popped first.


![Stack-representation-in-Data-Structures-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180735/Stack-representation-in-Data-Structures-(1).webp)

****Types of Stack:****
-----------------------

* ****Fixed Size Stack**** 
  : As the name suggests, a fixed size stack has a fixed size and cannot
  grow or shrink dynamically. If the stack is full and an attempt is
  made to add an element to it, an overflow error occurs. If the stack
  is empty and an attempt is made to remove an element from it, an
  underflow error occurs.
* ****Dynamic Size Stack**** 
  : A dynamic size stack can grow or shrink dynamically. When the stack
  is full, it automatically increases its size to accommodate the new
  element, and when the stack is empty, it decreases its size. This type
  of stack is implemented using a linked list, as it allows for easy
  resizing of the stack.

Basic Operations on Stack:
--------------------------

In order to make manipulations in a stack, there are certain operations
provided to us.


* ****push()****  to insert an element into the stack
* ****pop()****  to remove an element from the stack
* ****top()****  Returns the top element of the stack.
* ****isEmpty()****  returns true if stack is empty else false.
* ****isFull()****  returns true if the stack is full else false.

To implement stack, we need to maintain reference to the top
item.

### ****Push Operation on Stack****

Adds an item to the stack. If the stack is full, then it is said to be
an  ****Overflow condition.**** 

 ****Algorithm for Push Operation:**** 

* Before pushing the element to the stack, we check if the stack is  ****full****  .
* If the stack is full  ****(top == capacity-1)****  , then  ****Stack Overflows****  and we cannot insert the element to the stack.
* Otherwise, we increment the value of top by 1  ****(top = top + 1)****  and the new value is inserted at  ****top position****  .
* The elements can be pushed into the stack till we reach the  ****capacity****  of the stack.

![Push-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180844/Push-Operation-in-Stack-(1).webp)
### ****Pop Operation in Stack****

Removes an item from the stack. The items are popped in the reversed
order in which they are pushed. If the stack is empty, then it is said
to be an  ****Underflow condition.**** 

****Algorithm for Pop Operation:**** 

* Before popping the element from the stack, we check if the stack is  ****empty****  .
* If the stack is empty (top == -1), then  ****Stack Underflows****  and we cannot remove any element from the stack.
* Otherwise, we store the value at top, decrement the value of top by 1  ****(top = top – 1)****  and return the stored top value.

![Pop-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606180943/Pop-Operation-in-Stack-(1).webp)
### ****Top or Peek Operation on Stack****

Returns the top element of the stack. 

****Algorithm for Top Operation:**** 

* Before returning the top element from the stack, we check if the
  stack is empty.
* If the stack is empty (top == -1), we simply print “Stack is empty”.
* Otherwise, we return the element stored at  ****index = top****  .

![Top-or-Peek-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181023/Top-or-Peek-Operation-in-Stack-(1).webp)
### ****isEmpty Operation in Stack Data Structure:****

Returns true if the stack is empty, else false. 

****Algorithm for isEmpty Operation****: 

* Check for the value of  ****top****  in stack.
* If  ****(top == -1)****, then the stack is  ****empty****  so return  ****true****  .
* Otherwise, the stack is not empty so return  ****false****  .

![isEmpty-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181101/isEmpty-Operation-in-Stack-(1).webp)
### isFull ****Operation in Stack**** ****Data Structure****:

Returns true if the stack is full, else false. 

****Algorithm for isFull Operation:**** 

* Check for the value of  ****top****  in stack.
* If  ****(top == capacity-1),****  then the stack is  ****full****  so return  ****true****.
* Otherwise, the stack is not full so return  ****false****.

![isFull-Operation-in-Stack-(1)](https://media.geeksforgeeks.org/wp-content/uploads/20240606181147/isFull-Operation-in-Stack-(1).webp)

Implementation of Stack
-----------------------


The basic operations that can be performed on a stack include push, pop,
and peek. There are two ways to implement a stack –


* [****Implementation of Stack using Array****](https://www.geeksforgeeks.org/implement-stack-using-array/)
* [****Implementation of Stack using Linked List****](https://www.geeksforgeeks.org/implement-a-stack-using-singly-linked-list/)

****Complexity Analysis of Operations on Stack Data Structure:****
------------------------------------------------------------------

| ****Operations**** | ****Time Complexity**** | ****Space Complexity**** |
| --- | --- | --- |
| ****push()**** | O(1) | O(1) |
| ****pop()**** | O(1) | O(1) |
| top() or  ****pee****k() | O(1) | O(1) |
| isEmpty() | O(1) | O(1) |
| isFull() | O(1) | O(1) |', e'Stack is a linear data structure that follows LIFO (Last In First Out) Principle, the last element inserted is the first to be popped out. It means
both insertion and deletion operations happen at one end only.', 'What is Stack Data Structure? A Complete Tutorial', 1, null, '95713603-63d1-4b75-8a89-1acdc0977459', false);
INSERT INTO public.lessons (lesson_id, content, description, lesson_name, lesson_order, problem_id, course_id, is_quiz_visible) VALUES ('cf945f38-3396-48d8-815b-81e37df21182', e'****Stack Operations:****
-------------------------

* [****push()****](https://www.geeksforgeeks.org/stack-push-and-pop-in-c-stl/)****:****
  Insert a new element into the stack i.e just insert a new element at
  the beginning of the linked list.
* [****pop()****](https://www.geeksforgeeks.org/stack-push-and-pop-in-c-stl/)****:****
  Return the top element of the Stack i.e simply delete the first
  element from the linked list.
* [****peek()****](https://www.geeksforgeeks.org/stack-peek-method-in-java/)****:**** Return the top element.
* ****display():**** Print all elements in Stack.

Push Operation:
---------------

> * Initialise a node
> * Update the value of that node by data i.e. ****node->data = data****
> * Now link this node to the top of the linked list
> * And update top pointer to the current node

Pop Operation:
--------------

> * First Check whether there is any node present in the linked list or
>   not, if not then return
> * Otherwise make pointer let say ****temp**** to the top node and move forward the top node by 1 step
> * Now free this temp node

Peek Operation:
---------------

> * Check if there is any node present or not, if not then
>   return.
> * Otherwise return the value of top node of the linked list

Display Operation:
------------------

> * Take a ****temp**** node and initialize it with top pointer
> * Now start traversing temp till it encounters NULL
> * Simultaneously print the value of the temp node

 

Below is the implementation of the above operations 

C++
````
// C++ program to implement a stack using singly linked list
#include <bits/stdc++.h>
using namespace std;

// Class representing a node in the linked list
class Node {
public:
    int data;
    Node* next;
    Node(int new_data) {
        this->data = new_data;
        this->next = nullptr;
    }
};

// Class to implement stack using a singly linked list
class Stack {

    // head of the linked list
    Node* head;

public:
    // Constructor to initialize the stack
    Stack() { this->head = nullptr; }

    // Function to check if the stack is empty
    bool isEmpty() {
      
        // If head is nullptr, the stack is empty
        return head == nullptr;
    }

    // Function to push an element onto the stack
    void push(int new_data) {
      
        // Create a new node with given data
        Node* new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (!new_node) {
            cout << "\\nStack Overflow";
        }

        // Link the new node to the current top node
        new_node->next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    void pop() {

        // Check for stack underflow
        if (this->isEmpty()) {
            cout << "\\nStack Underflow" << endl;
        }
        else {
            // Assign the current top to a temporary
            // variable
            Node* temp = head;

            // Update the top to the next node
            head = head->next;

            // Deallocate the memory of the old top node
            delete temp;
        }
    }

    // Function to return the top element of the stack
    int peek() {

        // If stack is not empty, return the top element
        if (!isEmpty())
            return head->data;
        else {
            cout << "\\nStack is empty";
            return INT_MIN;
        }
    }
};

// Driver program to test the stack implementation
int main() {
    // Creating a stack
    Stack st;

    // Push elements onto the stack
    st.push(11);
    st.push(22);
    st.push(33);
    st.push(44);

    // Print top element of the stack
    cout << "Top element is " << st.peek() << endl;

    // removing two elemements from the top
      cout << "Removing two elements..." << endl;
    st.pop();
    st.pop();

    // Print top element of the stack
    cout << "Top element is " << st.peek() << endl;

    return 0;
}

````

C
````
// C program to implement a stack using singly linked list
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>

// Struct representing a node in the linked list
typedef struct Node {
    int data;
    struct Node* next;
} Node;
Node* createNode(int new_data) {
    Node* new_node = (Node*)malloc(sizeof(Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Struct to implement stack using a singly linked list
typedef struct Stack {
    Node* head;
} Stack;

// Constructor to initialize the stack
void initializeStack(Stack* stack) { stack->head = NULL; }

// Function to check if the stack is empty
int isEmpty(Stack* stack) {
  
    // If head is NULL, the stack is empty
    return stack->head == NULL;
}

// Function to push an element onto the stack
void push(Stack* stack, int new_data) {
  
    // Create a new node with given data
    Node* new_node = createNode(new_data);

    // Check if memory allocation for the new node failed
    if (!new_node) {
        printf("\\nStack Overflow");
        return;
    }

    // Link the new node to the current top node
    new_node->next = stack->head;

    // Update the top to the new node
    stack->head = new_node;
}

// Function to remove the top element from the stack
void pop(Stack* stack) {
  
    // Check for stack underflow
    if (isEmpty(stack)) {
        printf("\\nStack Underflow\\n");
        return;
    }
    else {
      
        // Assign the current top to a temporary variable
        Node* temp = stack->head;

        // Update the top to the next node
        stack->head = stack->head->next;

        // Deallocate the memory of the old top node
        free(temp);
    }
}

// Function to return the top element of the stack
int peek(Stack* stack) {
  
    // If stack is not empty, return the top element
    if (!isEmpty(stack))
        return stack->head->data;
    else {
        printf("\\nStack is empty");
        return INT_MIN;
    }
}

// Driver program to test the stack implementation
int main() {
  
    // Creating a stack
    Stack stack;
    initializeStack(&stack);

    // Push elements onto the stack
    push(&stack, 11);
    push(&stack, 22);
    push(&stack, 33);
    push(&stack, 44);

    // Print top element of the stack
    printf("Top element is %d\\n", peek(&stack));

  
      // removing two elemements from the top
      printf("Removing two elements...\\n");
    pop(&stack);
    pop(&stack);

    // Print top element of the stack
    printf("Top element is %d\\n", peek(&stack));

    return 0;
}

````

Java
````
// Java program to implement a stack using singly linked
// list

// Class representing a node in the linked list
class Node {
    int data;
    Node next;
    Node(int new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // Head of the linked list
    Node head;

    // Constructor to initialize the stack
    Stack() { this.head = null; }

    // Function to check if the stack is empty
    boolean isEmpty() {
      
        // If head is null, the stack is empty
        return head == null;
    }

    // Function to push an element onto the stack
    void push(int new_data) {
      
        // Create a new node with given data
        Node new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (new_node == null) {
            System.out.println("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    void pop() {
      
        // Check for stack underflow
        if (isEmpty()) {
            System.out.println("\\nStack Underflow");
            return;
        }
        else {
          
            // Assign the current top to a temporary
            // variable
            Node temp = head;

            // Update the top to the next node
            head = head.next;

            // Deallocate the memory of the old top node
            temp = null;
        }
    }

    // Function to return the top element of the stack
    int peek() {
      
        // If stack is not empty, return the top element
        if (!isEmpty())
            return head.data;
        else {
            System.out.println("\\nStack is empty");
            return Integer.MIN_VALUE;
        }
    }
}

// Driver code
public class Main {
    public static void main(String[] args)
    {
        // Creating a stack
        Stack st = new Stack();

        // Push elements onto the stack
        st.push(11);
        st.push(22);
        st.push(33);
        st.push(44);

        // Print top element of the stack
        System.out.println("Top element is " + st.peek());

        // removing two elemements from the top
          System.out.println("Removing two elements...");
        st.pop();
        st.pop();

        // Print top element of the stack
        System.out.println("Top element is " + st.peek());
    }
}

````

Python
````
# Java program to implement a stack using singly linked
# list

# Class representing a node in the linked list
class Node:
    def __init__(self, new_data):
        self.data = new_data
        self.next = None

# Class to implement stack using a singly linked list
class Stack:
    def __init__(self):

        # head of the linked list
        self.head = None

    # Function to check if the stack is empty
    def is_empty(self):

        # If head is None, the stack is empty
        return self.head is None

    # Function to push an element onto the stack
    def push(self, new_data):

        # Create a new node with given data
        new_node = Node(new_data)

        # Check if memory allocation for the new node failed
        if not new_node:
            print("\\nStack Overflow")
            return

        # Link the new node to the current top node
        new_node.next = self.head

        # Update the top to the new node
        self.head = new_node

    # Function to remove the top element from the stack
    def pop(self):

        # Check for stack underflow
        if self.is_empty():
            print("\\nStack Underflow")
        else:

            # Assign the current top to a temporary variable
            temp = self.head

            # Update the top to the next node
            self.head = self.head.next

            # Deallocate the memory of the old top node
            del temp

    # Function to return the top element of the stack
    def peek(self):

        # If stack is not empty, return the top element
        if not self.is_empty():
            return self.head.data
        else:
            print("\\nStack is empty")
            return float(\'-inf\')


# Creating a stack
st = Stack()

# Push elements onto the stack
st.push(11)
st.push(22)
st.push(33)
st.push(44)

# Print top element of the stack
print("Top element is", st.peek())

# removing two elemements from the top
print("Removing two elements...");
st.pop()
st.pop()

# Print top element of the stack
print("Top element is", st.peek())

````

C#
````
// C# program to implement a stack using singly linked list
using System;

// Class representing a node in the linked list
class Node {
    public int data;
    public Node next;
    public Node(int new_data)
    {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // head of the linked list
    private Node head;

    // Constructor to initialize the stack
    public Stack() { this.head = null; }

    // Function to check if the stack is empty
    public bool isEmpty()
    {

        // If head is null, the stack is empty
        return head == null;
    }

    // Function to push an element onto the stack
    public void push(int new_data)
    {

        // Create a new node with given data
        Node new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (new_node == null) {
            Console.WriteLine("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = head;

        // Update the top to the new node
        head = new_node;
    }

    // Function to remove the top element from the stack
    public void pop()
    {

        // Check for stack underflow
        if (this.isEmpty()) {
            Console.WriteLine("\\nStack Underflow");
        }
        else {

            // Update the top to the next node
            head = head.next;
            /* No need to manually free the memory of the
             * old head in C# */
        }
    }

    // Function to return the top element of the stack
    public int peek()
    {

        // If stack is not empty, return the top element
        if (!isEmpty())
            return head.data;
        else {
            Console.WriteLine("\\nStack is empty");
            return int.MinValue;
        }
    }
}

// Driver program to test the stack implementation
class GfG {
    static void Main(string[] args)
    {

        // Creating a stack
        Stack st = new Stack();

        // Push elements onto the stack
        st.push(11);
        st.push(22);
        st.push(33);
        st.push(44);

        // Print top element of the stack
        Console.WriteLine("Top element is " + st.peek());

        // removing two elemements from the top
          Console.WriteLine("Removing two elements...");
        st.pop();
        st.pop();

        // Print top element of the stack
        Console.WriteLine("Top element is " + st.peek());
    }
}

````

JavaScript
````
// Javascript program to implement a stack using singly
// linked list

// Class representing a node in the linked list
class Node {
    constructor(new_data) {
        this.data = new_data;
        this.next = null;
    }
}

// Class to implement stack using a singly linked list
class Stack {

    // Constructor to initialize the stack
    constructor() { this.head = null; }

    // Function to check if the stack is empty
    isEmpty() {
    
        // If head is null, the stack is empty
        return this.head === null;
    }

    // Function to push an element onto the stack
    push(new_data) {
    
        // Create a new node with given data
        const new_node = new Node(new_data);

        // Check if memory allocation for the new node
        // failed
        if (!new_node) {
            console.log("\\nStack Overflow");
            return;
        }

        // Link the new node to the current top node
        new_node.next = this.head;

        // Update the top to the new node
        this.head = new_node;
    }

    // Function to remove the top element from the stack
    pop() {
    
        // Check for stack underflow
        if (this.isEmpty()) {
            console.log("\\nStack Underflow");
        }
        else {
        
            // Assign the current top to a temporary
            // variable
            let temp = this.head;

            // Update the top to the next node
            this.head = this.head.next;

            // Deallocate the memory of the old top node
            temp = null;
        }
    }

    // Function to return the top element of the stack
    peek() {
    
        // If stack is not empty, return the top element
        if (!this.isEmpty())
            return this.head.data;
        else {
            console.log("\\nStack is empty");
            return Number.MIN_VALUE;
        }
    }
}

// Driver program to test the stack implementation
const st = new Stack();

// Push elements onto the stack
st.push(11);
st.push(22);
st.push(33);
st.push(44);

// Print top element of the stack
console.log("Top element is " + st.peek());

// removing two elemements from the top
console.log("Removing two elements...");
st.pop();
st.pop();

// Print top element of the stack
console.log("Top element is " + st.peek());

````

  
**Output**
```

Top element is 44
Top element is 22

```

****Time Complexity:****
O(1), for all push(), pop(), and peek(), as we are not performing any
kind of traversal over the list. We perform all the operations through
the current pointer only.  
****Auxiliary Space:**** O(N), where N is the size of the stack


In this implementation, we define a Node class that represents a node
in the linked list, and a Stack class that uses this node class to
implement the stack. The head attribute of the Stack class points to the
top of the stack (i.e., the first node in the linked list).

To push an item onto the stack, we create a new node with the given
item and set its next pointer to the current head of the stack. We then
set the head of the stack to the new node, effectively making it the new
top of the stack.

To pop an item from the stack, we simply remove the first node from the
linked list by setting the head of the stack to the next node in the
list (i.e., the node pointed to by the next pointer of the current
head). We return the data stored in the original head node, which is the
item that was removed from the top of the stack.

### Benefits of implementing a stack using a singly linked list include:

****Dynamic memory allocation****: The size of the stack can be increased or decreased dynamically by
adding or removing nodes from the linked list, without the need to
allocate a fixed amount of memory for the stack upfront.

****Efficient memory usage:**** Since nodes in a singly linked list only have a next pointer and not a
prev pointer, they use less memory than nodes in a doubly linked
list.

****Easy implementation****: Implementing a stack using a singly linked list is straightforward
and can be done using just a few lines of code.

****Versatile****: Singly linked lists can be used to implement other data structures
such as queues, linked lists, and trees.

In summary, implementing a stack using a singly linked list is a simple
and efficient way to create a dynamic stack data structure in
Python.

### Real time examples of stack:

Stacks are used in various real-world scenarios where a last-in,
first-out (LIFO) data structure is required. Here are some examples of
real-time applications of stacks:

****Function call stack****: When a function is called in a program, the return address and all
the function parameters are pushed onto the function call stack. The
stack allows the function to execute and return to the caller function
in the reverse order in which they were called.

****Undo/Redo operations:****
In many applications, such as text editors, image editors, or web
browsers, the undo and redo functionalities are implemented using a
stack. Every time an action is performed, it is pushed onto the stack.
When the user wants to undo the last action, the top element of the
stack is popped and the action is reversed.

****Browser history:**** Web browsers use stacks to keep track of the pages visited by the user.
Every time a new page is visited, its URL is pushed onto the stack. When
the user clicks the “Back” button, the last visited URL is popped from
the stack and the user is directed to the previous page.

****Expression evaluation****: Stacks are used in compilers and interpreters to evaluate
expressions. When an expression is parsed, it is converted into postfix
notation and pushed onto a stack. The postfix expression is then
evaluated using the stack.

****Call stack in recursion:****
When a recursive function is called, its call is pushed onto the stack.
The function executes and calls itself, and each subsequent call is
pushed onto the stack. When the recursion ends, the stack is popped, and
the program returns to the previous function call.

In summary, stacks are widely used in many applications where LIFO
functionality is required, such as function calls, undo/redo operations,
browser history, expression evaluation, and recursive function
calls.
', 'To implement a stack using the singly linked list concept, all the singly linked list operations should be performed based on Stack operations LIFO(last in first out) and with the help of that knowledge, we are going to implement a stack using a singly linked list.', 'Implement a stack using singly linked list', 3, null, '95713603-63d1-4b75-8a89-1acdc0977459', false);


INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('52aae031-0311-4a7d-b6ba-939bd82fbbff', '', 'Heap Data Structure Guide', 3, 4, null);
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('8f893dfd-b897-4bd5-9c29-097703871710', '', 'Introduction to DSA', 3, 4, 'b8165176-c256-44f6-bc1a-a32a3626fad5');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('19759307-a805-4bfd-b1a3-648921705a71', '', 'Matrix Data Structure Guide', 3, 4, 'aaf04cd6-13a7-415f-ac21-67a4c001f409');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('73a96fec-0145-4ffd-b7c0-ee6d6ff34aef', '', 'Array', 3, 4, 'bdde6e1b-edc4-4731-a95b-bd1a61a42a7d');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('e73a74e2-29d5-4617-aa46-84c970dbba55', '', 'Linked List Data Structure Guide', 3, 4, '237c88d5-987b-4fc0-8bd1-d27a07cd1aa9');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('fa41a74d-5590-49a6-84f7-ad1ceed83eaf', '', 'The Logic Building Problems', 3, 4, 'e9c94003-0430-44e0-ac55-fda3101baf00');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('853e7ebc-48f7-4f47-aa0f-7cd103b4e503', '', 'Linked List', 3, 4, 'fe47d547-098c-4d93-a52b-09f5533ea97c');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('93e4dba5-5b14-488f-a3ad-45c90459826b', '', 'Queue', 6, 10, 'dfada5ab-a189-4507-8c06-78c269c52440');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('1d759fa1-82b5-4b3e-b147-7979353fbc6a', '', 'Stack', 7, 10, '039efe3e-47d0-410e-b3db-a9e64d9bedd7');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('33f989fd-1f9d-4516-a491-081b973dfa14', '', 'Matrix Data Structure Guide', 3, 4, '44efdcdf-0629-48f9-a271-496cf8c1294f');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('718717e6-158d-46a7-b140-dc7c1c904da5', '', 'Matrix Data Structure Guide', 3, 4, '06a8e89e-01d3-4218-a5c7-b50229b9d379');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('6257fec1-a5d3-4256-bd73-08355513b8ba', '', 'Matrix Data Structure Guide', 3, 4, '93d49a12-3653-4378-b419-b70cd092bbb8');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('4d63d886-7c37-4a36-9caa-5f34a0de764f', '', 'Matrix Data Structure Guide', 3, 4, '5bdeaf80-2a0a-4799-b094-bc29df554f7b');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('14143585-a879-41c9-bfa2-3d6852db6ed9', '', 'Matrix Data Structure Guide', 2, 3, '06284d7e-1a52-4006-a7f2-65ef4c1b2931');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('1e751a05-0b4c-438d-98a5-e277b6f651b6', '', 'Matrix Data Structure Guide', 2, 3, '29efa51f-d459-47a6-a735-6424352e6031');
INSERT INTO public.exercises (exercise_id, description, exercise_name, passing_questions, questions_per_exercise, lesson_id) VALUES ('75682f09-e8d4-49eb-b64c-bd91a3079028', '', 'Matrix Data Structure Guide', 3, 4, '26690fd3-6c33-4660-ab78-a775fce63ff4');


INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('707fc477-b79b-4065-b220-a79199e534ca', '2', '2024-12-23 16:05:38.507629 +00:00', 'Which of the following operations is not efficient in an array?', 'S', 'active', null, '73a96fec-0145-4ffd-b7c0-ee6d6ff34aef');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('a6330516-d682-4807-90c0-5893c31a2a77', '2', '2024-12-23 16:05:44.210787 +00:00', 'What is the space complexity of an array with n elements?', 'S', 'active', null, '73a96fec-0145-4ffd-b7c0-ee6d6ff34aef');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('dfa51df3-225e-42c9-82b4-7ffd179ced23', '2', '2024-12-23 14:19:14.661456 +00:00', 'How are elements stored in an array?', 'S', 'active', null, '73a96fec-0145-4ffd-b7c0-ee6d6ff34aef');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('f2d6151a-0fba-4117-934f-9f0496ea456d', '1', '2024-12-23 16:05:33.703857 +00:00', 'What is the time complexity of accessing an element in an array?', 'S', 'active', null, '73a96fec-0145-4ffd-b7c0-ee6d6ff34aef');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b', '2', '2024-12-23 16:10:37.787124 +00:00', 'What is a matrix?', 'S', 'active', null, '19759307-a805-4bfd-b1a3-648921705a71');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('7192dff8-d333-42a7-86ed-43f14f041587', '2', '2024-12-23 16:05:58.506602 +00:00', 'What is the space complexity of a linked list with n elements?', 'S', 'active', null, '853e7ebc-48f7-4f47-aa0f-7cd103b4e503');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('c4bf4382-3d91-4f88-84ff-6e73b3c58a59', '1', '2024-12-23 16:05:50.300063 +00:00', 'In a singly linked list, what information does each node contain?', 'S', 'active', null, '853e7ebc-48f7-4f47-aa0f-7cd103b4e503');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('e00b2dbc-bf57-46fd-ba89-0d58ff3e751f', '1', '2024-12-23 16:05:50.300063 +00:00', 'What is the time complexity of inserting an element at the beginning of a linked list?', 'S', 'active', null, '853e7ebc-48f7-4f47-aa0f-7cd103b4e503');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('e43c4cb2-0cdd-43c9-b608-99f705d3a897', '2', '2024-12-23 16:05:58.506602 +00:00', 'Which of the following operations is more efficient in a linked list compared to an array?', 'S', 'active', null, '853e7ebc-48f7-4f47-aa0f-7cd103b4e503');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('50b51410-e800-4ef0-8433-06aa3575b95d', '2', '2024-12-23 16:05:58.506602 +00:00', 'Which method is used to add an element to a queue?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('5d0938d2-2457-4491-a759-3b32818c164d', '2', '2024-12-23 16:05:58.506602 +00:00', 'Which method is used to remove an element from a queue?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('962c9fc6-db27-4ed1-8a05-eae5e2dab1e0', '1', '2024-12-23 16:06:05.315234 +00:00', 'What is the time complexity of enqueue operation in a queue?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27', '2', '2024-12-23 16:05:58.506602 +00:00', 'Which principle does a queue operate on?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('bdeb7a18-1e34-49d2-8f04-9fcf91561bd0', '1', '2024-12-23 16:06:05.315234 +00:00', 'Which method is used to remove an element from a stack?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('d4c17fd9-83bc-4b1e-bfd7-114cfd755ce5', '1', '2024-12-23 16:06:05.315234 +00:00', 'Which principle does a stack operate on?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('e6d03d99-6e22-4fb0-97c8-2d18131b8555', '1', '2024-12-23 16:06:22.484900 +00:00', 'What is the time complexity of push operation in a stack?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('f95e89ba-00d1-4e45-b566-a43aa34202f3', '1', '2024-12-23 16:06:14.614514 +00:00', 'Which method is used to add an element to a stack?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('1352cb96-7ad9-4a91-af36-102cb37966fd', '1', '2024-12-23 16:10:21.272876 +00:00', 'Which of the following is a common approach to solve logical problems?', 'S', 'active', null, 'fa41a74d-5590-49a6-84f7-ad1ceed83eaf');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('46f75789-7fc5-44bd-a19a-de98668d4393', '2', '2024-12-23 16:08:21.577441 +00:00', 'What is the most important step when solving logical problems?', 'S', 'active', null, 'fa41a74d-5590-49a6-84f7-ad1ceed83eaf');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('99e0a84b-3a47-415d-b2a0-9335394d9ad3', '2', '2024-12-23 16:10:27.576521 +00:00', 'What is the key to solving complex logical problems?', 'S', 'active', null, 'fa41a74d-5590-49a6-84f7-ad1ceed83eaf');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('a5fb678a-0546-40f4-b17c-7e95a12fd6fd', '3', '2024-12-23 16:06:22.484900 +00:00', 'Which of the following problems is commonly used to test logical thinking?', 'S', 'active', null, 'fa41a74d-5590-49a6-84f7-ad1ceed83eaf');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('43dcf436-65e4-472d-9ece-17234c1bde58', '2', '2024-12-23 16:10:33.042012 +00:00', 'Why is learning DSA important in programming?', 'S', 'active', null, '8f893dfd-b897-4bd5-9c29-097703871710');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('4661f08e-36f8-4599-9ec2-a18e6e837316', '2', '2024-12-23 16:10:37.787124 +00:00', 'What is the primary goal of studying DSA?', 'S', 'active', null, '8f893dfd-b897-4bd5-9c29-097703871710');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('d7cfdfe2-3a50-4c99-85fa-ce0dc633498f', '1', '2024-12-23 16:10:27.576521 +00:00', 'What does DSA stand for?', 'S', 'active', null, '8f893dfd-b897-4bd5-9c29-097703871710');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('e423c8a6-60f2-4e45-b71f-08ca35678003', '2', '2024-12-23 16:10:33.042012 +00:00', 'Which of the following is a fundamental concept in DSA?', 'S', 'active', null, '8f893dfd-b897-4bd5-9c29-097703871710');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('0a8f8813-b742-46e6-9f1a-e4499f6ccadb', '3', '2024-12-23 16:10:45.125857 +00:00', 'What is the time complexity of multiplying two matrices?', 'S', 'active', null, '19759307-a805-4bfd-b1a3-648921705a71');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('1a50cda2-bf99-467d-a835-394783c20787', '4', '2024-12-23 16:10:45.125857 +00:00', 'Which of the following operations is not efficient on a matrix?', 'S', 'active', null, '19759307-a805-4bfd-b1a3-648921705a71');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('8d26a566-aa07-414e-ace1-a7b21bb7074c', '3', '2024-12-23 16:10:45.125857 +00:00', 'What is the space complexity of a matrix with n rows and m columns?', 'S', 'active', null, '19759307-a805-4bfd-b1a3-648921705a71');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('626da05f-e658-4fe0-b7e9-9deba29e4d9e', '4', '2024-12-23 16:10:51.325304 +00:00', 'Which of the following operations is more efficient in a doubly linked list compared to a singly linked list?', 'S', 'active', null, 'e73a74e2-29d5-4617-aa46-84c970dbba55');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('7d7f8f96-947c-4bdd-9a44-dc13ac5804a6', '2', '2024-12-23 16:10:45.125857 +00:00', 'What is the time complexity of traversing a linked list?', 'S', 'active', null, 'e73a74e2-29d5-4617-aa46-84c970dbba55');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('e801c3ac-7931-4a9e-8ef9-c36093c14894', '2', '2024-12-23 16:10:51.325304 +00:00', 'What is the space complexity of a doubly linked list with n elements?', 'S', 'active', null, 'e73a74e2-29d5-4617-aa46-84c970dbba55');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('f4b27993-6b3b-4c08-9028-bf4dc40504bd', '3', '2024-12-23 16:10:45.125857 +00:00', 'In a doubly linked list, what information does each node contain?', 'S', 'active', null, 'e73a74e2-29d5-4617-aa46-84c970dbba55');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('1f837751-5482-4cc6-abaf-9f1b484ab0c9', '2', '2024-12-23 16:10:51.325304 +00:00', 'What is the space complexity of a heap with n elements?', 'S', 'active', null, '52aae031-0311-4a7d-b6ba-939bd82fbbff');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('4481dc50-aadc-41e8-b380-43eb9a3980ce', '2', '2024-12-23 16:10:51.325304 +00:00', 'What property must a heap satisfy?', 'S', 'active', null, '52aae031-0311-4a7d-b6ba-939bd82fbbff');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('4854185c-c851-4865-b287-200036252a7f', '3', '2024-12-23 16:10:51.325304 +00:00', 'What is the time complexity of inserting an element into a heap?', 'S', 'active', null, '52aae031-0311-4a7d-b6ba-939bd82fbbff');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('ba2381e4-26d3-4324-a620-ee7c330f048b', '3', '2024-12-23 16:10:51.325304 +00:00', 'Which of the following operations is not efficient on a heap?', 'S', 'active', null, '52aae031-0311-4a7d-b6ba-939bd82fbbff');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('20453226-4074-4f81-a5d7-832f55181149', '2', '2025-01-16 12:49:41.834480 +00:00', 'What is the key principle of a Queue?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('76d412d0-9dbd-40ce-9fc5-da9b057e5c08', '3', '2025-01-16 12:49:41.834480 +00:00', 'Which operation removes an item from the front of the Queue?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('501b8db5-5608-412d-a0a2-a44572085c80', '1', '2025-01-16 12:49:41.834480 +00:00', 'Which of the following is an example of a Queue?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('973a3348-e394-4d3f-a597-35158aa51c74', '1', '2025-01-16 12:49:41.834480 +00:00', 'What is the time complexity of enqueue and dequeue operations in a Queue?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('1c708886-b0db-4910-b14a-97c860599c31', '1', '2025-01-16 12:49:41.834480 +00:00', 'What does FIFO stand for?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('1470e07c-d79d-452d-ac5b-b131cccc2dae', '4', '2025-01-16 12:49:41.834480 +00:00', 'Which data structure is ideal for implementing task scheduling?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('4de9f1b5-4908-44c1-be16-0bd72e917a55', '3', '2025-01-16 12:49:41.834480 +00:00', 'Which type of Queue allows insertion at both ends?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('41178b65-991e-478c-9f3b-873efbf30b56', '4', '2025-01-16 12:49:41.834480 +00:00', 'In which scenario is a Queue most commonly used?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('44c275b0-f360-4676-8664-010bc0565861', '4', '2025-01-16 12:49:41.834480 +00:00', 'Which of the following is NOT a type of Queue?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('04b149c8-95ec-454c-9e6f-6d215d7c5d01', '3', '2025-01-16 12:49:41.834480 +00:00', 'What happens when you try to dequeue from an empty Queue?', 'S', 'active', null, '93e4dba5-5b14-488f-a3ad-45c90459826b');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('25ff1ed8-1171-4361-b5b1-df695e19c44c', '3', '2025-01-16 12:58:46.979356 +00:00', 'Which of the following is an example of a Stack?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('35eb528d-f31b-4d02-8f35-083fb12d4b9c', '4', '2025-01-16 12:58:46.979356 +00:00', 'Which operation inserts an element into a stack?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('684fb820-a370-4d34-954f-ddaa11b4f0b4', '3', '2025-01-16 12:58:46.979356 +00:00', 'Which operation removes the top element from a stack?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('d04af04d-8330-4b16-be86-313bb1df0cac', '3', '2025-01-16 12:58:46.979356 +00:00', 'What is the time complexity of a stack push operation?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('2114e6b6-1510-4b2f-b379-ed01f9e2b2f3', '4', '2025-01-16 12:58:46.979356 +00:00', 'Which data structure works on Last In First Out (LIFO)?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('7e482eb8-a094-48b3-97a6-6c253045b3e0', '1', '2025-01-16 12:58:46.979356 +00:00', 'Which of these is an application of stack?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('c39095ad-0a08-4a7a-9f05-a4c6a319f170', '2', '2025-01-16 12:58:46.979356 +00:00', 'In a stack, what does the peek operation do?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd', '2', '2025-01-16 12:58:46.979356 +00:00', 'What happens when a stack is full and a push operation is attempted?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('5ada76a4-9e1c-4f93-8e26-653430a2eb10', '1', '2025-01-16 12:58:46.979356 +00:00', 'What is the initial condition of a stack?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('f0a148ac-4c4e-4306-8957-d9de760351e8', '2', '2025-01-16 12:58:46.979356 +00:00', 'Which data structure can be used for undo operations in text editors?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('72ce8429-4c6f-46ff-9029-6fc69150ce4a', '1', '2025-01-16 12:58:46.979356 +00:00', 'What is the space complexity of a stack?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('720aea7e-824a-46cd-acae-627157c68c16', '4', '2025-01-16 12:58:46.979356 +00:00', 'Which operation is not possible in a stack?', 'S', 'active', null, '1d759fa1-82b5-4b3e-b147-7979353fbc6a');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('26a22ae7-efeb-42ec-8dd3-cdabb86369ea', '2', '2025-04-29 10:00:55.693845 +00:00', 'What is a matrix?', 'S', null, '2025-04-29 10:00:55.693845 +00:00', '33f989fd-1f9d-4516-a491-081b973dfa14');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('037f4fcf-035b-444b-8e84-6b8a7c617055', '2', '2025-04-29 19:11:15.539316 +00:00', 'What is a matrix?', 'S', null, '2025-04-29 19:11:15.539316 +00:00', '718717e6-158d-46a7-b140-dc7c1c904da5');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('f4066057-789b-497e-9dd1-2c815122b26f', '2', '2025-04-29 19:30:59.793514 +00:00', 'What is a matrix?', 'S', null, '2025-04-29 19:30:59.860071 +00:00', '6257fec1-a5d3-4256-bd73-08355513b8ba');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('b910bc20-8933-4322-8d63-e6f91e07d19b', '2', '2025-04-29 19:39:39.642350 +00:00', 'What is a matrix?', 'S', null, '2025-04-29 19:39:39.642350 +00:00', '4d63d886-7c37-4a36-9caa-5f34a0de764f');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('d1078f6e-89ff-43c2-b06b-13ed892fe238', '2', '2025-04-29 20:02:53.101510 +00:00', 'What is a matrix?', 'S', null, '2025-04-29 20:02:53.101510 +00:00', '14143585-a879-41c9-bfa2-3d6852db6ed9');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('c3f96ab8-de5c-4fe1-ba98-0c320e98321b', '2', '2025-04-29 20:07:30.974404 +00:00', 'What is a matrix?', 'S', null, '2025-04-29 20:07:30.974404 +00:00', '1e751a05-0b4c-438d-98a5-e277b6f651b6');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('44193b8d-442c-4bd0-8346-1c699f777033', '2', '2025-04-29 22:18:53.949887 +00:00', 'What is a matrix?', 'S', null, '2025-04-29 22:18:53.949887 +00:00', '75682f09-e8d4-49eb-b64c-bd91a3079028');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('aedab96c-86ef-4cae-8be1-1db2a58a01c9', '3', '2025-04-29 22:18:53.966291 +00:00', 'What is the time complexity of multiplying two matrices?', 'S', null, '2025-04-29 22:18:53.966291 +00:00', '75682f09-e8d4-49eb-b64c-bd91a3079028');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('e1598e4d-6f3b-4fe7-9b2c-aed1ef73ef06', '4', '2025-04-29 22:18:53.973655 +00:00', 'Which of the following operations is not efficient on a matrix?', 'S', null, '2025-04-29 22:18:53.973655 +00:00', '75682f09-e8d4-49eb-b64c-bd91a3079028');
INSERT INTO public.questions (question_id, correct_answer, created_at, question_content, question_type, status, updated_at, exercise_id) VALUES ('7a245f70-ab9e-458c-a802-f6b5696b2ab6', '3', '2025-04-29 22:18:53.981719 +00:00', 'What is the space complexity of a matrix with n rows and m columns?', 'S', null, '2025-04-29 22:18:53.981719 +00:00', '75682f09-e8d4-49eb-b64c-bd91a3079028');


WITH ordered_questions AS (
  SELECT
    question_id,
    ROW_NUMBER() OVER (PARTITION BY exercise_id ORDER BY question_id) AS new_order
  FROM questions
)
UPDATE questions q
SET question_order = o.new_order
FROM ordered_questions o
WHERE q.question_id = o.question_id;

INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'In arbitrary order', 'dfa51df3-225e-42c9-82b4-7ffd179ced23');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'In contiguous memory locations', 'dfa51df3-225e-42c9-82b4-7ffd179ced23');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'In reverse order', 'dfa51df3-225e-42c9-82b4-7ffd179ced23');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'In random order', 'dfa51df3-225e-42c9-82b4-7ffd179ced23');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', 'f2d6151a-0fba-4117-934f-9f0496ea456d');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'f2d6151a-0fba-4117-934f-9f0496ea456d');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', 'f2d6151a-0fba-4117-934f-9f0496ea456d');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', 'f2d6151a-0fba-4117-934f-9f0496ea456d');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Deleting an element from the end', '707fc477-b79b-4065-b220-a79199e534ca');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Accessing an element by index', '707fc477-b79b-4065-b220-a79199e534ca');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Searching for an element', '707fc477-b79b-4065-b220-a79199e534ca');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Inserting an element at the beginning', '707fc477-b79b-4065-b220-a79199e534ca');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', 'a6330516-d682-4807-90c0-5893c31a2a77');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', 'a6330516-d682-4807-90c0-5893c31a2a77');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'a6330516-d682-4807-90c0-5893c31a2a77');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', 'a6330516-d682-4807-90c0-5893c31a2a77');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Data and a pointer to the next node', 'c4bf4382-3d91-4f88-84ff-6e73b3c58a59');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Only a pointer', 'c4bf4382-3d91-4f88-84ff-6e73b3c58a59');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Only data', 'c4bf4382-3d91-4f88-84ff-6e73b3c58a59');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Data and a pointer to the previous node', 'c4bf4382-3d91-4f88-84ff-6e73b3c58a59');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'e00b2dbc-bf57-46fd-ba89-0d58ff3e751f');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', 'e00b2dbc-bf57-46fd-ba89-0d58ff3e751f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', 'e00b2dbc-bf57-46fd-ba89-0d58ff3e751f');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', 'e00b2dbc-bf57-46fd-ba89-0d58ff3e751f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Searching for an element', 'e43c4cb2-0cdd-43c9-b608-99f705d3a897');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Accessing an element by index', 'e43c4cb2-0cdd-43c9-b608-99f705d3a897');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Deleting an element from the end', 'e43c4cb2-0cdd-43c9-b608-99f705d3a897');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Inserting an element at the beginning', 'e43c4cb2-0cdd-43c9-b608-99f705d3a897');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', '7192dff8-d333-42a7-86ed-43f14f041587');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '7192dff8-d333-42a7-86ed-43f14f041587');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '7192dff8-d333-42a7-86ed-43f14f041587');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '7192dff8-d333-42a7-86ed-43f14f041587');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'FILO (First In Last Out)', 'ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'LILO (Last In Last Out)', 'ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'FIFO (First In First Out)', 'ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'LIFO (Last In First Out)', 'ccf2ad8e-c660-4cac-a3ba-1a7a6ce93e27');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'enqueue()', '50b51410-e800-4ef0-8433-06aa3575b95d');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'add()', '50b51410-e800-4ef0-8433-06aa3575b95d');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'insert()', '50b51410-e800-4ef0-8433-06aa3575b95d');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'push()', '50b51410-e800-4ef0-8433-06aa3575b95d');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'remove()', '5d0938d2-2457-4491-a759-3b32818c164d');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'delete()', '5d0938d2-2457-4491-a759-3b32818c164d');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'dequeue()', '5d0938d2-2457-4491-a759-3b32818c164d');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'pop()', '5d0938d2-2457-4491-a759-3b32818c164d');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '962c9fc6-db27-4ed1-8a05-eae5e2dab1e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '962c9fc6-db27-4ed1-8a05-eae5e2dab1e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', '962c9fc6-db27-4ed1-8a05-eae5e2dab1e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '962c9fc6-db27-4ed1-8a05-eae5e2dab1e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'FIFO (First In First Out)', 'd4c17fd9-83bc-4b1e-bfd7-114cfd755ce5');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'LILO (Last In Last Out)', 'd4c17fd9-83bc-4b1e-bfd7-114cfd755ce5');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'LIFO (Last In First Out)', 'd4c17fd9-83bc-4b1e-bfd7-114cfd755ce5');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'FILO (First In Last Out)', 'd4c17fd9-83bc-4b1e-bfd7-114cfd755ce5');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'delete()', 'bdeb7a18-1e34-49d2-8f04-9fcf91561bd0');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'remove()', 'bdeb7a18-1e34-49d2-8f04-9fcf91561bd0');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'pop()', 'bdeb7a18-1e34-49d2-8f04-9fcf91561bd0');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'dequeue()', 'bdeb7a18-1e34-49d2-8f04-9fcf91561bd0');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'add()', 'f95e89ba-00d1-4e45-b566-a43aa34202f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'push()', 'f95e89ba-00d1-4e45-b566-a43aa34202f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'enqueue()', 'f95e89ba-00d1-4e45-b566-a43aa34202f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'insert()', 'f95e89ba-00d1-4e45-b566-a43aa34202f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', 'e6d03d99-6e22-4fb0-97c8-2d18131b8555');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', 'e6d03d99-6e22-4fb0-97c8-2d18131b8555');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', 'e6d03d99-6e22-4fb0-97c8-2d18131b8555');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'e6d03d99-6e22-4fb0-97c8-2d18131b8555');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Counting prime numbers', 'a5fb678a-0546-40f4-b17c-7e95a12fd6fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Binary search', 'a5fb678a-0546-40f4-b17c-7e95a12fd6fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Traveling salesman problem', 'a5fb678a-0546-40f4-b17c-7e95a12fd6fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Quick sort', 'a5fb678a-0546-40f4-b17c-7e95a12fd6fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Writing code quickly', '46f75789-7fc5-44bd-a19a-de98668d4393');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Understanding the problem and designing the algorithm', '46f75789-7fc5-44bd-a19a-de98668d4393');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Using existing libraries', '46f75789-7fc5-44bd-a19a-de98668d4393');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Optimizing the code', '46f75789-7fc5-44bd-a19a-de98668d4393');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Random guessing', '1352cb96-7ad9-4a91-af36-102cb37966fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Divide and conquer', '1352cb96-7ad9-4a91-af36-102cb37966fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Ignoring the problem', '1352cb96-7ad9-4a91-af36-102cb37966fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Using brute force', '1352cb96-7ad9-4a91-af36-102cb37966fd');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Using complex data structures', '99e0a84b-3a47-415d-b2a0-9335394d9ad3');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Writing long code', '99e0a84b-3a47-415d-b2a0-9335394d9ad3');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Breaking down the problem into smaller parts', '99e0a84b-3a47-415d-b2a0-9335394d9ad3');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Memorizing solution', '99e0a84b-3a47-415d-b2a0-9335394d9ad3');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Digital Structure and Algorithm', 'd7cfdfe2-3a50-4c99-85fa-ce0dc633498f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Data Storage and Access', 'd7cfdfe2-3a50-4c99-85fa-ce0dc633498f');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Data System and Analysis', 'd7cfdfe2-3a50-4c99-85fa-ce0dc633498f');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Data Structure and Algorithm', 'd7cfdfe2-3a50-4c99-85fa-ce0dc633498f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'To increase debugging skills', '43dcf436-65e4-472d-9ece-17234c1bde58');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'To optimize algorithms and program performance', '43dcf436-65e4-472d-9ece-17234c1bde58');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'To increase the use of libraries', '43dcf436-65e4-472d-9ece-17234c1bde58');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'To increase coding speed', '43dcf436-65e4-472d-9ece-17234c1bde58');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Scripting', 'e423c8a6-60f2-4e45-b71f-08ca35678003');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Data abstraction', 'e423c8a6-60f2-4e45-b71f-08ca35678003');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Functional programming', 'e423c8a6-60f2-4e45-b71f-08ca35678003');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Object-oriented programming', 'e423c8a6-60f2-4e45-b71f-08ca35678003');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'To write more lines of code', '4661f08e-36f8-4599-9ec2-a18e6e837316');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'To learn new programming languages', '4661f08e-36f8-4599-9ec2-a18e6e837316');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'To understand how to organize and manipulate data efficiently', '4661f08e-36f8-4599-9ec2-a18e6e837316');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'To create graphical user interfaces', '4661f08e-36f8-4599-9ec2-a18e6e837316');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'A binary tree', '8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'A one-dimensional array', '8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'A two-dimensional array', '8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'A linked list', '8973b0dd-ca0e-43fa-9f42-5fc16c4d6c7b');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(n)', '0a8f8813-b742-46e6-9f1a-e4499f6ccadb');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(log n)', '0a8f8813-b742-46e6-9f1a-e4499f6ccadb');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(n^3)', '0a8f8813-b742-46e6-9f1a-e4499f6ccadb');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n^2)', '0a8f8813-b742-46e6-9f1a-e4499f6ccadb');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Inserting an element in the middle', '1a50cda2-bf99-467d-a835-394783c20787');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Accessing an element by index', '1a50cda2-bf99-467d-a835-394783c20787');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Adding two matrices', '1a50cda2-bf99-467d-a835-394783c20787');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Transposing a matrix', '1a50cda2-bf99-467d-a835-394783c20787');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '8d26a566-aa07-414e-ace1-a7b21bb7074c');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '8d26a566-aa07-414e-ace1-a7b21bb7074c');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(n*m)', '8d26a566-aa07-414e-ace1-a7b21bb7074c');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '8d26a566-aa07-414e-ace1-a7b21bb7074c');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Only data', 'f4b27993-6b3b-4c08-9028-bf4dc40504bd');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Data and pointers to both the previous and next nodes', 'f4b27993-6b3b-4c08-9028-bf4dc40504bd');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Data and a pointer to the previous node', 'f4b27993-6b3b-4c08-9028-bf4dc40504bd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Data and a pointer to the next node', 'f4b27993-6b3b-4c08-9028-bf4dc40504bd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '7d7f8f96-947c-4bdd-9a44-dc13ac5804a6');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '7d7f8f96-947c-4bdd-9a44-dc13ac5804a6');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '7d7f8f96-947c-4bdd-9a44-dc13ac5804a6');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', '7d7f8f96-947c-4bdd-9a44-dc13ac5804a6');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Traversing the list in reverse order', '626da05f-e658-4fe0-b7e9-9deba29e4d9e');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Inserting an element at the beginning', '626da05f-e658-4fe0-b7e9-9deba29e4d9e');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Deleting an element from the end', '626da05f-e658-4fe0-b7e9-9deba29e4d9e');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Accessing an element by index', '626da05f-e658-4fe0-b7e9-9deba29e4d9e');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', 'e801c3ac-7931-4a9e-8ef9-c36093c14894');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'e801c3ac-7931-4a9e-8ef9-c36093c14894');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', 'e801c3ac-7931-4a9e-8ef9-c36093c14894');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', 'e801c3ac-7931-4a9e-8ef9-c36093c14894');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Recursive property', '4481dc50-aadc-41e8-b380-43eb9a3980ce');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Balanced tree property', '4481dc50-aadc-41e8-b380-43eb9a3980ce');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Determinant property', '4481dc50-aadc-41e8-b380-43eb9a3980ce');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Complete binary tree property', '4481dc50-aadc-41e8-b380-43eb9a3980ce');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '4854185c-c851-4865-b287-200036252a7f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '4854185c-c851-4865-b287-200036252a7f');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', '4854185c-c851-4865-b287-200036252a7f');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '4854185c-c851-4865-b287-200036252a7f');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Deleting the root element', 'ba2381e4-26d3-4324-a620-ee7c330f048b');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Accessing the root element', 'ba2381e4-26d3-4324-a620-ee7c330f048b');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Searching for an element', 'ba2381e4-26d3-4324-a620-ee7c330f048b');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Inserting an element', 'ba2381e4-26d3-4324-a620-ee7c330f048b');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '1f837751-5482-4cc6-abaf-9f1b484ab0c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '1f837751-5482-4cc6-abaf-9f1b484ab0c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '1f837751-5482-4cc6-abaf-9f1b484ab0c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(log n)', '1f837751-5482-4cc6-abaf-9f1b484ab0c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Random Access', '20453226-4074-4f81-a5d7-832f55181149');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'FIFO', '20453226-4074-4f81-a5d7-832f55181149');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'None of the above', '20453226-4074-4f81-a5d7-832f55181149');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'LIFO', '20453226-4074-4f81-a5d7-832f55181149');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'insert', '76d412d0-9dbd-40ce-9fc5-da9b057e5c08');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'pop', '76d412d0-9dbd-40ce-9fc5-da9b057e5c08');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'dequeue', '76d412d0-9dbd-40ce-9fc5-da9b057e5c08');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'enqueue', '76d412d0-9dbd-40ce-9fc5-da9b057e5c08');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Call Center System', '501b8db5-5608-412d-a0a2-a44572085c80');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Tree', '501b8db5-5608-412d-a0a2-a44572085c80');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Stack', '501b8db5-5608-412d-a0a2-a44572085c80');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Binary Search Tree', '501b8db5-5608-412d-a0a2-a44572085c80');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '973a3348-e394-4d3f-a597-35158aa51c74');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n^2)', '973a3348-e394-4d3f-a597-35158aa51c74');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(n)', '973a3348-e394-4d3f-a597-35158aa51c74');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(log n)', '973a3348-e394-4d3f-a597-35158aa51c74');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'First In First Out', '1c708886-b0db-4910-b14a-97c860599c31');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'None of the above', '1c708886-b0db-4910-b14a-97c860599c31');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Last In First Out', '1c708886-b0db-4910-b14a-97c860599c31');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'File Input File Output', '1c708886-b0db-4910-b14a-97c860599c31');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Queue', '1470e07c-d79d-452d-ac5b-b131cccc2dae');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Binary Tree', '1470e07c-d79d-452d-ac5b-b131cccc2dae');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Hash Table', '1470e07c-d79d-452d-ac5b-b131cccc2dae');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Stack', '1470e07c-d79d-452d-ac5b-b131cccc2dae');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Stack', '4de9f1b5-4908-44c1-be16-0bd72e917a55');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Priority Queue', '4de9f1b5-4908-44c1-be16-0bd72e917a55');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Deque', '4de9f1b5-4908-44c1-be16-0bd72e917a55');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Circular Queue', '4de9f1b5-4908-44c1-be16-0bd72e917a55');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Breadth-First Search', '41178b65-991e-478c-9f3b-873efbf30b56');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Undo operations in editors', '41178b65-991e-478c-9f3b-873efbf30b56');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Evaluating expressions', '41178b65-991e-478c-9f3b-873efbf30b56');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Task scheduling', '41178b65-991e-478c-9f3b-873efbf30b56');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Circular Queue', '44c275b0-f360-4676-8664-010bc0565861');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Priority Queue', '44c275b0-f360-4676-8664-010bc0565861');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Deque', '44c275b0-f360-4676-8664-010bc0565861');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Binary Search Queue', '44c275b0-f360-4676-8664-010bc0565861');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Adds a default value', '04b149c8-95ec-454c-9e6f-6d215d7c5d01');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Dequeues another element', '04b149c8-95ec-454c-9e6f-6d215d7c5d01');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Throws an exception or error', '04b149c8-95ec-454c-9e6f-6d215d7c5d01');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Ignores the operation', '04b149c8-95ec-454c-9e6f-6d215d7c5d01');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Queue', '25ff1ed8-1171-4361-b5b1-df695e19c44c');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Binary Search Tree', '25ff1ed8-1171-4361-b5b1-df695e19c44c');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Browser back button', '25ff1ed8-1171-4361-b5b1-df695e19c44c');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Tree', '25ff1ed8-1171-4361-b5b1-df695e19c44c');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Pop', '35eb528d-f31b-4d02-8f35-083fb12d4b9c');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Enqueue', '35eb528d-f31b-4d02-8f35-083fb12d4b9c');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Peek', '35eb528d-f31b-4d02-8f35-083fb12d4b9c');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Push', '35eb528d-f31b-4d02-8f35-083fb12d4b9c');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Dequeue', '684fb820-a370-4d34-954f-ddaa11b4f0b4');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Push', '684fb820-a370-4d34-954f-ddaa11b4f0b4');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Pop', '684fb820-a370-4d34-954f-ddaa11b4f0b4');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Peek', '684fb820-a370-4d34-954f-ddaa11b4f0b4');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(n^2)', 'd04af04d-8330-4b16-be86-313bb1df0cac');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', 'd04af04d-8330-4b16-be86-313bb1df0cac');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(1)', 'd04af04d-8330-4b16-be86-313bb1df0cac');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(log n)', 'd04af04d-8330-4b16-be86-313bb1df0cac');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Array', '2114e6b6-1510-4b2f-b379-ed01f9e2b2f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Queue', '2114e6b6-1510-4b2f-b379-ed01f9e2b2f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Tree', '2114e6b6-1510-4b2f-b379-ed01f9e2b2f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Stack', '2114e6b6-1510-4b2f-b379-ed01f9e2b2f3');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Recursion', '7e482eb8-a094-48b3-97a6-6c253045b3e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Breadth First Search', '7e482eb8-a094-48b3-97a6-6c253045b3e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Sorting', '7e482eb8-a094-48b3-97a6-6c253045b3e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Graph traversal', '7e482eb8-a094-48b3-97a6-6c253045b3e0');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Inserts an element at the top', 'c39095ad-0a08-4a7a-9f05-a4c6a319f170');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Returns the top element without removing it', 'c39095ad-0a08-4a7a-9f05-a4c6a319f170');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Checks if the stack is full', 'c39095ad-0a08-4a7a-9f05-a4c6a319f170');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Removes the top element', 'c39095ad-0a08-4a7a-9f05-a4c6a319f170');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'The stack is resized', '9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Stack underflow occurs', '9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Stack overflow occurs', '9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'The element is added', '9dcaa8cb-d5d9-4f3f-a181-0ee9bf670dfd');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'The stack is empty', '5ada76a4-9e1c-4f93-8e26-653430a2eb10');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'The stack is full', '5ada76a4-9e1c-4f93-8e26-653430a2eb10');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'The stack is half full', '5ada76a4-9e1c-4f93-8e26-653430a2eb10');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'The stack has one element', '5ada76a4-9e1c-4f93-8e26-653430a2eb10');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Tree', 'f0a148ac-4c4e-4306-8957-d9de760351e8');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Stack', 'f0a148ac-4c4e-4306-8957-d9de760351e8');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Queue', 'f0a148ac-4c4e-4306-8957-d9de760351e8');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Array', 'f0a148ac-4c4e-4306-8957-d9de760351e8');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(n)', '72ce8429-4c6f-46ff-9029-6fc69150ce4a');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(log n)', '72ce8429-4c6f-46ff-9029-6fc69150ce4a');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(n^2)', '72ce8429-4c6f-46ff-9029-6fc69150ce4a');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(1)', '72ce8429-4c6f-46ff-9029-6fc69150ce4a');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Peek', '720aea7e-824a-46cd-acae-627157c68c16');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Pop', '720aea7e-824a-46cd-acae-627157c68c16');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Push', '720aea7e-824a-46cd-acae-627157c68c16');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Traversal', '720aea7e-824a-46cd-acae-627157c68c16');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'A binary tree', '26a22ae7-efeb-42ec-8dd3-cdabb86369ea');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'A one-dimensional array', '26a22ae7-efeb-42ec-8dd3-cdabb86369ea');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'A two-dimensional array', '26a22ae7-efeb-42ec-8dd3-cdabb86369ea');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'A linked list', '26a22ae7-efeb-42ec-8dd3-cdabb86369ea');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'A binary tree', '037f4fcf-035b-444b-8e84-6b8a7c617055');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'A one-dimensional array', '037f4fcf-035b-444b-8e84-6b8a7c617055');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'A two-dimensional array', '037f4fcf-035b-444b-8e84-6b8a7c617055');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'A linked list', '037f4fcf-035b-444b-8e84-6b8a7c617055');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'A binary tree', 'f4066057-789b-497e-9dd1-2c815122b26f');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'A one-dimensional array', 'f4066057-789b-497e-9dd1-2c815122b26f');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'A two-dimensional array', 'f4066057-789b-497e-9dd1-2c815122b26f');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'A linked list', 'f4066057-789b-497e-9dd1-2c815122b26f');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'A binary tree', 'b910bc20-8933-4322-8d63-e6f91e07d19b');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'A one-dimensional array', 'b910bc20-8933-4322-8d63-e6f91e07d19b');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'A two-dimensional array', 'b910bc20-8933-4322-8d63-e6f91e07d19b');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'A linked list', 'b910bc20-8933-4322-8d63-e6f91e07d19b');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'A binary tree', 'd1078f6e-89ff-43c2-b06b-13ed892fe238');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'A one-dimensional array', 'd1078f6e-89ff-43c2-b06b-13ed892fe238');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'A two-dimensional array', 'd1078f6e-89ff-43c2-b06b-13ed892fe238');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'A linked list', 'd1078f6e-89ff-43c2-b06b-13ed892fe238');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'A binary tree', 'c3f96ab8-de5c-4fe1-ba98-0c320e98321b');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'A one-dimensional array', 'c3f96ab8-de5c-4fe1-ba98-0c320e98321b');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'A two-dimensional array', 'c3f96ab8-de5c-4fe1-ba98-0c320e98321b');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'A linked list', 'c3f96ab8-de5c-4fe1-ba98-0c320e98321b');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'A binary tree', '44193b8d-442c-4bd0-8346-1c699f777033');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'A one-dimensional array', '44193b8d-442c-4bd0-8346-1c699f777033');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'A two-dimensional array', '44193b8d-442c-4bd0-8346-1c699f777033');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'A linked list', '44193b8d-442c-4bd0-8346-1c699f777033');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(n)', 'aedab96c-86ef-4cae-8be1-1db2a58a01c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(log n)', 'aedab96c-86ef-4cae-8be1-1db2a58a01c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(n^3)', 'aedab96c-86ef-4cae-8be1-1db2a58a01c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n^2)', 'aedab96c-86ef-4cae-8be1-1db2a58a01c9');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'Inserting an element in the middle', 'e1598e4d-6f3b-4fe7-9b2c-aed1ef73ef06');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'Accessing an element by index', 'e1598e4d-6f3b-4fe7-9b2c-aed1ef73ef06');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'Adding two matrices', 'e1598e4d-6f3b-4fe7-9b2c-aed1ef73ef06');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'Transposing a matrix', 'e1598e4d-6f3b-4fe7-9b2c-aed1ef73ef06');
INSERT INTO public.options (option_order, content, question_id) VALUES (1, 'O(1)', '7a245f70-ab9e-458c-a802-f6b5696b2ab6');
INSERT INTO public.options (option_order, content, question_id) VALUES (4, 'O(n^2)', '7a245f70-ab9e-458c-a802-f6b5696b2ab6');
INSERT INTO public.options (option_order, content, question_id) VALUES (3, 'O(n*m)', '7a245f70-ab9e-458c-a802-f6b5696b2ab6');
INSERT INTO public.options (option_order, content, question_id) VALUES (2, 'O(n)', '7a245f70-ab9e-458c-a802-f6b5696b2ab6');


-- problems
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('7328995b-6079-4bd9-8be0-7c9152d5a73b', 0.00, 0.00, e'You are given two integer arrays `nums1` and `nums2`, **sorted in non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.

**Merge** `nums1` and `nums2` into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be _stored_ inside the array `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.

#### Example 1:

```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
```

#### Example 2:

```
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
```

#### Example 3:

```
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
```', 'easy', 'Merge sorted array', 2, false, true, e'Problem Name: Merge Sorted Array
Function Name: mergeSortedArray
Input Structure:
Input Field: list<int> num1
Input Field: int m
Input Field: list<int> num2
Input Field: int n
Output Structure:
Output Field: list<int> result', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('c3756efe-d408-4e99-844e-a55021fb7c02', 0.00, 0.00, e'Given a string `s` containing just the characters \'(\', \')\', \'{\', \'}\', \'[\', and \']\', determine if the input string is valid.

       An input string is valid if:
       1. Open brackets must be closed by the same type of brackets.
       2. Open brackets must be closed in the correct order.

       #### Example 1:

       ```
       Input: s = "()"
       Output: true
       ```

       #### Example 2:

       ```
       Input: s = "()[]{}"
       Output: true
       ```

       #### Example 3:

       ```
       Input: s = "(]"
       Output: false
       ```

       #### Example 4:

       ```
       Input: s = "([)]"
       Output: false
       ```

       #### Example 5:

       ```
       Input: s = "{[]}"
       Output: true
       ```

       #### Constraints:
       - 1 <= s.length <= 10^4
       - `s` consists of parentheses only: \'(\', \')\', \'{\', \'}\', \'[\', and \']\'.', 'easy', 'Valid Parentheses', 3, true, false, e'Function Name: isValid
       Input Structure:
       Input Field: string s
       Output Structure:
       Output Field: boolean result', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('82978535-a8da-46e1-a39a-31a232e3fffc', 0.00, 0.00, e'Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with `O(log n)` runtime complexity.

#### Example 1:

```
Input: nums = [1,3,5,6], target = 5
Output: 2
```

#### Example 2:

```
Input: nums = [1,3,5,6], target = 2
Output: 1
```

#### Example 3:

```
Input: nums = [1,3,5,6], target = 7
Output: 4
```', 'easy', 'Search Insert Position', 2, false, true, e'Problem Name: Search Insert Position
Function Name: searchInsertPosition
Input Structure:
Input Field: list<int> nums
Input Field: int target
Output Structure:
Output Field: int result
', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('591b3457-2157-4d61-b03d-d53f8666342c', 0.00, 0.00, e'Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

#### Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
```

#### Example 2:

```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

#### Example 3:

```
Input: nums = [3,3], target = 6
Output: [0,1]
```', 'easy', 'Two sum', 2, false, true, e'Function Name: twoSum
Input Structure:
Input Field: list<int> nums
Input Field: int target
Output Structure:
Output Field: list<int> result', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('feb01aba-eefe-4220-9242-729f52935cd7', 0.00, 0.00, e'You are given a string `s` consisting of lowercase English letters, an integer `t` representing the number of **transformations** to perform, and an array `nums` of size 26. In one **transformation**, every character in `s` is replaced according to the following rules:

-   Replace `s[i]` with the **next** `nums[s[i] - \'a\']` consecutive characters in the alphabet. For example, if `s[i] = \'a\'` and `nums[0] = 3`, the character `\'a\'` transforms into the next 3 consecutive characters ahead of it, which results in `"bcd"`.
-   The transformation **wraps** around the alphabet if it exceeds `\'z\'`. For example, if `s[i] = \'y\'` and `nums[24] = 3`, the character `\'y\'` transforms into the next 3 consecutive characters ahead of it, which results in `"zab"`.

Return the length of the resulting string after **exactly** `t` transformations.

Since the answer may be very large, return it **modulo** `10<sup>9</sup> + 7`.

**Example 1:**

**Input:** s = "abcyy", t = 2, nums = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2]

**Output:** 7

**Explanation:**

-   **First Transformation (t = 1):**
    
    -   `\'a\'` becomes `\'b\'` as `nums[0] == 1`
    -   `\'b\'` becomes `\'c\'` as `nums[1] == 1`
    -   `\'c\'` becomes `\'d\'` as `nums[2] == 1`
    -   `\'y\'` becomes `\'z\'` as `nums[24] == 1`
    -   `\'y\'` becomes `\'z\'` as `nums[24] == 1`
    -   String after the first transformation: `"bcdzz"`
-   **Second Transformation (t = 2):**
    
    -   `\'b\'` becomes `\'c\'` as `nums[1] == 1`
    -   `\'c\'` becomes `\'d\'` as `nums[2] == 1`
    -   `\'d\'` becomes `\'e\'` as `nums[3] == 1`
    -   `\'z\'` becomes `\'ab\'` as `nums[25] == 2`
    -   `\'z\'` becomes `\'ab\'` as `nums[25] == 2`
    -   String after the second transformation: `"cdeabab"`
-   **Final Length of the string:** The string is `"cdeabab"`, which has 7 characters.
    

**Example 2:**

**Input:** s = "azbk", t = 1, nums = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]

**Output:** 8

**Explanation:**

-   **First Transformation (t = 1):**
    
    -   `\'a\'` becomes `\'bc\'` as `nums[0] == 2`
    -   `\'z\'` becomes `\'ab\'` as `nums[25] == 2`
    -   `\'b\'` becomes `\'cd\'` as `nums[1] == 2`
    -   `\'k\'` becomes `\'lm\'` as `nums[10] == 2`
    -   String after the first transformation: `"bcabcdlm"`
-   **Final Length of the string:** The string is `"bcabcdlm"`, which has 8 characters.
    

**Constraints:**

-   `1 <= s.length <= 10<sup>5</sup>`
-   `s` consists only of lowercase English letters.
-   `1 <= t <= 10<sup>9</sup>`
-   `nums.length == 26`
-   `1 <= nums[i] <= 25`', 'hard', e'Total Characters in String After Transformations II
', 8, true, true, e'Problem Name: Total Characters in String After Transformations II
Function Name: lengthAfterTransformations
Input Structure:
Input Field: string s
Input Field: int t
Input Field: list<int> nums
Output Structure:
Output Field: int result', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('73c532f9-4d55-4737-ae19-3006e02864cc', 0.00, 0.00, e'You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the i<sup>th</sup> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`\'s.

Increment the large integer by one and return the resulting array of digits.

#### Example 1:

```
Input: digits = [1,2,3]
Output: [1,2,4]
```

#### Example 2:

```
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
```

#### Example 3:

```
Input: digits = [9]
Output: [1,0]
```', 'easy', 'Plus one', 2, false, true, e'Problem Name: Plus One
Function Name: plusOne
Input Structure:
Input Field: list<int> digits
Output Structure:
Output Field: list<int> result', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('e608ebb7-07ef-4a2f-8081-92e5993e6118', 0.00, 0.00, e'Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

#### Example 1:

```
Input: nums = [2,2,1]
Output: 1
```

#### Example 2:

```
Input: nums = [4,1,2,1,2]
Output: 4
```

#### Example 3:

```
Input: nums = [1]
Output: 1
```', 'easy', 'Single Number', 2, false, true, e'Problem Name: Single Number
Function Name: singleNumber
Input Structure:
Input Field: list<int> nums
Output Structure:
Output Field: int result', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('5c078d66-5e74-402b-8216-04ac197477a9', 0.00, 0.00, e'A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.

-   For example, for `arr = [1,2,3]`, the following are all the permutations of `arr`: `[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]`.

The **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the **next permutation** of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).

-   For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.
-   Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.
-   While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.

Given an array of integers `nums`, *find the next permutation of* `nums`.

The replacement must be **[in place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only constant extra memory.

**Example 1:**


Input: nums = [1,2,3]
Output: [1,3,2]


**Example 2:**


Input: nums = [3,2,1]
Output: [1,2,3]


**Example 3:**


Input: nums = [1,1,5]
Output: [1,5,1]


**Constraints:**

-   `1 <= nums.length <= 100`
-   `0 <= nums[i] <= 100`', 'medium', 'Next Permutation', 5, true, true, e'Problem Name: Next Permutation
Function Name: nextPermutation
Input Structure:
Input Field: list<int> num
Output Structure:
Output Field: list<int> result', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('992e6551-1c96-4362-b9f9-7cb08afca28d', 0.00, 0.00, e'Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**


Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.


**Example 2:**

Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.


**Example 3:**

Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
', 'medium', '3Sum', 5, false, false, e'Problem Name: 3Sum
Function Name: threeSum
Input Structure:
Input Field: list<int> num
Output Structure:
Output Field: list<list<int>> result', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('f3248456-acbf-46ae-9888-8bd0fad9cd91', 0.00, 0.00, e'The **next greater element** of some element `x` in an array is the **first greater** element that is **to the right** of `x` in the same array.

You are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.

For each `0 <= i < nums1.length`, find the index `j` such that `nums1[i] == nums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`. If there is no next greater element, then the answer for this query is `-1`.

Return *an array* `ans` *of length* `nums1.length` *such that* `ans[i]` *is the **next greater element** as described above.*

**Example 1:**

**Input:** `nums1 = [4,1,2], nums2 = [1,3,4,2]`

 **Output:** `[-1,3,-1]` 

**Explanation:** The next greater element for each value of nums1 is as follows: 
- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. 
- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3. 
- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.

**Example 2:**

**Input:** `nums1 = [2,4], nums2 = [1,2,3,4] `

**Output:** `[3,-1]` 

**Explanation:** The next greater element for each value of nums1 is as follows: 
- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3. 
- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.

**Constraints:**

-   1 <= nums1.length <= nums2.length <= 1000
-   0 <= nums1[i], nums2[i] <= 10$^4$
-   All integers in `nums1` and `nums2` are **unique**.
-   All the integers of `nums1` also appear in `nums2`.', 'easy', 'Next Greater Element I', 3, true, true, e'Problem Name: Next Greater Element I
Function Name: nextGreaterElement
Input Structure:
Input Field: list<int> nums1
Input Field: list<int> nums2
Output Structure:
Output Field: list<int> result', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');
INSERT INTO public.problems (problem_id, acceptance_rate, average_rating, description, problem_level, problem_name, score, is_available, is_published, problem_structure, author_id, current_creation_step, is_completed_creation, created_at, current_creation_step_description) VALUES ('a1964481-4927-4946-bd13-cee87f00a952', 0.00, 0.00, e'Suppose LeetCode will start its **IPO** soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the **IPO**. Since it has limited resources, it can only finish at most `k` distinct projects before the **IPO**. Help LeetCode design the best way to maximize its total capital after finishing at most `k` distinct projects.

You are given `n` projects where the `i<sup>th</sup>` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.

Initially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.

Pick a list of **at most** `k` distinct projects from given projects to **maximize your final capital**, and return *the final maximized capital*.

The answer is guaranteed to fit in a 32-bit signed integer.

**Example 1:**

**Input:** k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]

**Output:** 4

**Explanation:** Since your initial capital is 0, you can only start the project indexed 0.
After finishing it you will obtain profit 1 and your capital becomes 1.
With capital 1, you can either start the project indexed 1 or the project indexed 2.
Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.
Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.


**Example 2:**

**Input:** k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]

**Output:** 6', 'hard', 'IPO', 8, true, true, e'Problem Name: IPO
Function Name: findMaximizedCapital
Input Structure:
Input Field: int k
Input Field: int w
Input Field: list<int> profits
Input Field: list<int> capital
Output Structure:
Output Field: int result', '4d0c8d27-4509-402b-cf6f-58686cd47319', 6, true, null, 'Final Step');



-- test_cases
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('eb1f21cf-b8fa-41cc-aea8-7224a85998c6', e'7
1 3 5 0 0 0 0
3
4
2 4 6 7
4', '1 2 3 4 5 6 7', null, 2, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('607a6878-899a-4f10-a3ff-106e36f6db7b', e'6
4 5 6 0 0 0
3
3
1 2 3
3', '1 2 3 4 5 6', null, 3, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('7d1d2398-47fd-480a-a662-b8bb892656a4', e'6
1 2 3 0 0 0
3
3
2 5 6
3', '1 2 2 3 5 6', null, 5, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('0ccce6f3-b6f1-4184-b13d-0aec69dfc148', e'1
9', '1 0', null, 1, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('00222cc2-be0a-4b78-8e49-8a7572418dad', e'4
4 3 2 1', '4 3 2 2', null, 2, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('6fbb0344-0bc8-4df2-a64d-785fb373a9a7', e'3
9 9 9', '1 0 0 0', null, 3, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('8a85700f-ffb4-438b-8183-8f3aa1999c24', e'39
7 2 8 5 0 9 1 2 9 5 3 6 6 7 3 2 8 4 3 7 9 5 7 7 4 7 4 9 4 7 0 1 1 1 7 4 0 0 6', '7 2 8 5 0 9 1 2 9 5 3 6 6 7 3 2 8 4 3 7 9 5 7 7 4 7 4 9 4 7 0 1 1 1 7 4 0 0 7', null, 4, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('d725244d-31f7-4ddc-b494-dc54cab67964', e'3
1 2 3', '1 2 4', null, 5, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('4a9c10f0-eb2a-4b19-8e19-9edf117e76d8', e'4
1 0 0 0', '1 0 0 1', null, 6, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('21a234fc-adc3-4012-9802-63ab716fb8c4', e'4
1 3 5 6
5', '2', null, 1, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('4703bfe2-5040-49f7-b728-bdea2b6c97e4', e'4
1 3 5 6
7', '4', null, 2, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('e8698f62-9051-49e0-8610-56c27a7dcb96', e'4
1 3 5 6
4', '2', null, 3, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('da031658-0ac7-4aae-99e5-6c01e2862b29', e'4
1 3 5 6
0', '0', null, 4, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('2becdcf8-1773-4d3a-b759-63fea450106c', e'4
1 3 5 6
2', '1', null, 5, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('93cfd193-1620-4e60-8c84-983041d205f0', e'3
0 1 0', '1', null, 1, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('fad6d724-b8ce-4b6b-a1fb-f5a1e8b7e003', e'1
1', '1', null, 2, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('f8e22dda-b2cf-473e-b10f-ca1069fd5630', e'5
4 1 2 1 2', '4', null, 3, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('4343cfa0-4508-4157-b986-23e04fc60069', e'5
3 3 7 8 8', '7', null, 4, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('e15bef99-a6dd-46a1-bbb0-af5ed9d06e09', e'3
2 2 1', '1', null, 5, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('abf531db-e157-49e9-8310-beb37cffe58a', e'2
3 3
6', '0 1', null, 1, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('78dd79f1-3691-42da-9fcf-37e7c96c439f', e'4
1 0 0 7
8', '0 3', null, 2, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('5aedba91-125d-4cdc-99f3-43fc3d431bad', e'3
3 2 4
6', '1 2', null, 3, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('d915b2ea-eb2a-450b-aa28-e506bf55a856', e'4
2 7 11 15
9', '0 1', null, 4, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('ddd22af2-0e71-4768-ad6c-b7307395c108', e'4
4 6 10 2
12', '1 2', null, 5, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('54cf7c62-34fe-4a9a-b249-5a33954da0e1', e'abcyy
2
26
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2', '7', null, 1, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('69d9cd9f-2360-4afb-b6ae-0c1daa6c89b4', e'azbk
1
26
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2', '8', null, 2, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('96cce528-4619-44c2-91c2-77c343336ca1', e'x
16
26
6 6 8 1 9 9 10 3 9 4 8 5 2 8 10 2 6 8 2 3 3 7 2 6 4 2', '417796858', null, 3, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('99edde29-95e8-49c1-91f8-9101017ec82e', e'yyatb
16
26
6 6 8 1 9 9 1 3 9 4 8 5 2 8 5 2 6 8 2 3 3 7 2 2 1 2', '685264743', null, 4, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('19cb11c9-80a7-4213-9818-0027895df28c', e'prhjvhgcthxxtxhjh
9
26
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2', '8704', null, 5, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('2a780b15-8e6c-4ce1-bcca-09cd93ec9be4', e'3
1 2 3', '1 3 2', null, 1, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('eae3123e-c834-4779-be4a-954495b2dbad', e'3
3 2 1', '1 2 3', null, 2, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('e24ec0a8-cc08-41f9-8fee-354744d2dc3d', e'3
1 1 5', '1 5 1', null, 3, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('c6a4be62-1c13-4314-a57b-284c0f0d9b3d', e'3
6 7 7', '7 6 7', null, 4, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('9526e520-d2fd-45be-aa15-c17b58f2bca8', e'3
0 3 4', '0 4 3', null, 5, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('3023b13d-5542-49e3-9bc1-2a268d9b7958', e'3
0 2 7', '0 7 2', null, 6, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('42018af1-6259-4030-a798-4d7b10614cd0', e'3
9 7 2', '2 7 9', null, 7, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('74280ed8-db86-4b49-b747-87ea08c701ea', e'3
4 1 2
4
1 3 4 2', '-1 3 -1', null, 1, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('8fd1fddd-c3f7-4f1b-a8ff-5afdaa728841', e'2
2 4
4
1 2 3 4', '3 -1', null, 2, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('15172638-0f5b-4206-a979-9b75c425653e', e'3
1 0 2
4
1 0 2 7', '2 2 7', null, 3, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('9a27902a-596a-4e37-b7f6-65ebb4d38d5f', e'3
1 0 6
5
1 6 0 7 3', '6 7 7', null, 4, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('b01d8dc4-2dcd-40f5-92c5-a07011c33837', e'2
0
3
1 2 3
3
0 1 1', '4', null, 1, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('f50d5d2d-6c69-49f1-84d6-beadf5f27b03', e'3
0
3
1 2 3
3
0 1 2', '6', null, 2, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('98bcd4f0-eeb4-4176-a9f5-541bc9b4e071', e'5
0
3
1 2 3
3
0 1 1', '6', null, 3, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('c9415e88-e3f7-4dff-ad58-59518bd6a103', e'10
0
3
1 2 3
3
0 1 2', '6', null, 4, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('beba8151-d2e7-4cdc-851b-053aec059352', e'11
0
3
1 2 3
3
0 1 2', '6', null, 5, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('d363f914-f3d8-4b53-a770-2c31e0c74ea2', e'13
0
3
1 2 3
3
0 1 2', '6', null, 6, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('ce9ce4a1-e19e-4cd3-91cf-bdb9047b50b3', e'1
0
3
1 2 3
3
0 1 2', '1', null, 7, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('2484336b-c5d5-4b95-9cb4-09c2a245cd34', e'2
0
3
2 3 8
3
3 1 2', '0', null, 8, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('630888c6-b2e6-4e6e-b8e1-ea19cc79a008', e'6
-1 0 1 2 -1 -4', e'[-1, -1, 2]
[-1, 0, 1]', null, 1, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('ee4de00e-cd8f-4ce3-9901-3ce98f40ae67', e'3
0 1 1', null, null, 2, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('d79abe99-f3f1-4dd9-8452-4ca78c4459c0', e'3
0 0 0', '[0, 0, 0]', null, 3, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('af2e10d1-479e-48a5-b2f8-15ead574cece', e'11
0 1 2 5 1 1 0 2 5 7 1', null, null, 4, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('d9bd9994-38a7-4882-8d43-661c82190209', e'18
4 5 6 -1 0 1 2 -1 -4 0 0 0 2 2 2 2 2 2', e'[-4, -1, 5]
[-4, 0, 4]
[-4, 2, 2]
[-1, -1, 2]
[-1, 0, 1]
[0, 0, 0]', null, 5, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('23f35de8-7a82-4688-9253-6b5330894296', e'1
1
1
0

0', '1', null, 1, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.test_cases (testcase_id, input, output, user_id, testcase_order, problem_id) VALUES ('285e81b0-b13c-4a30-b861-228edd8fa05a', e'1
0
0
1
1
1', '1', null, 4, '7328995b-6079-4bd9-8be0-7c9152d5a73b');



-- Solutions
INSERT INTO public.solutions (author_id, content, problem_id) VALUES ('4d0c8d27-4509-402b-cf6f-58686cd47319', e'# Approach: Matrix Multiplication + Matrix Exponentiation By Squaring

#### Intuition

We use $f(i,c)$ to represent the number of occurrences of the character c in the string after i transformations. For convenience, we let the value range of c be [0,26), corresponding to the 26 characters from a to z in sequence.

Initially, all $f(0,c)$ values are equal to the number of occurrences of c in the given string s. When we iterate from $f(i−1,⋯)$ to $f(i,⋯)$, we use the recurrence:

$$ f(i,c)=∑_{c′=0}^{25}[f(i−1,c′)×T(c,c′)]$$

Here, the value of $T(c,c′)$ is either 0 or 1. If c′ is included in the substitution set of c during a single transformation, the value is 1; otherwise, it is 0. The values of $T(c,c′)$ can be obtained from the given array ***nums***.

The time complexity of directly using the recurrence is high, so optimization is necessary. Notice that $T(c,c′)$ is independent of i; it remains fixed in each round of iteration. Therefore, if we express $f(i,c)$ and $f(i−1,c′)$ as *n×1* column vectors, and $T(c,c′)$ as an *n×n* matrix, the recurrence becomes a matrix multiplication:




![](https://res.cloudinary.com/diyn1vkim/image/upload/v1749642042/mwhnh7gpxwqazafiwtyo.png)



So, after t iterations:

$$ \\mathbf{f}_t = \\mathbf{T}^t \\cdot \\mathbf{f}_0 $$

Thus, we can first compute the t-th power of the matrix corresponding to T(c,c′), and then multiply it by the initial column vector f(0,⋯) to obtain all values f(t,⋯). The sum of these values gives the final answer.

The exponentiation of the transformation matrix can be efficiently performed using [matrix exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring), which we will not elaborate on here.

# Implementation

```cpp
static constexpr int L = 26;
static constexpr int mod = 1000000007;

struct Mat {
Mat() { memset(a, 0, sizeof(a)); }
Mat(const Mat& that) {
  for (int i = 0; i < L; ++i) {
    for (int j = 0; j < L; ++j) {
      a[i][j] = that.a[i][j];
    }
  }
}
Mat& operator=(const Mat& that) {
  if (this != &that) {
    for (int i = 0; i < L; ++i) {
      for (int j = 0; j < L; ++j) {
        a[i][j] = that.a[i][j];
      }
    }
  }
  return *this;
}

int a[L][L];
};

Mat operator*(const Mat& u, const Mat& v) {
  Mat w;
  for (int i = 0; i < L; ++i) {
    for (int j = 0; j < L; ++j) {
      for (int k = 0; k < L; ++k) {
        w.a[i][j] =
          (w.a[i][j] + (long long)u.a[i][k] * v.a[k][j]) % mod;
      }
    }
  }
  return w;
}

// identity matrix
Mat I() {
  Mat w;
  for (int i = 0; i < L; ++i) {
    w.a[i][i] = 1;
  }
  return w;
}

// matrix exponentiation by squaring
Mat quickmul(const Mat& x, int y) {
  Mat ans = I(), cur = x;
  while (y) {
    if (y & 1) {
      ans = ans * cur;
    }
    cur = cur * cur;
    y >>= 1;
  }
  return ans;
}

int lengthAfterTransformations(string s, int t, vector<int>& nums) {
  Mat T;
  for (int i = 0; i < 26; ++i) {
    for (int j = 1; j <= nums[i]; ++j) {
      T.a[(i + j) % 26][i] = 1;
    }
  }
  Mat res = quickmul(T, t);
  int ans = 0;
  vector<int> f(26);
  for (char ch : s) {
    ++f[ch - \'a\'];
  }
  for (int i = 0; i < 26; ++i) {
    for (int j = 0; j < 26; ++j) {
      ans = (ans + (long long)res.a[i][j] * f[j]) % mod;
    }
  }
  return ans;
}
};
```
```python
MOD = 10**9 + 7
L = 26


class Mat:
  def __init__(self, copy_from: "Mat" = None) -> None:
    self.a: List[List[int]] = [[0] * L for _ in range(L)]
    if copy_from:
      for i in range(L):
        for j in range(L):
          self.a[i][j] = copy_from.a[i][j]

    def __mul__(self, other: "Mat") -> "Mat":
      result = Mat()
      for i in range(L):
        for j in range(L):
          for k in range(L):
            result.a[i][j] = (
              result.a[i][j] + self.a[i][k] * other.a[k][j]
            ) % MOD
        return result


# identity matrix
def I() -> Mat:
  m = Mat()
  for i in range(L):
    m.a[i][i] = 1
    return m


# matrix exponentiation by squaring
def quickmul(x: Mat, y: int) -> Mat:
  ans = I()
  cur = x
  while y:
    if y & 1:
      ans = ans * cur
      cur = cur * cur
    y >>= 1
    return ans


def lengthAfterTransformations(self, s: str, t: int, nums: List[int]) -> int:
  T = Mat()
  for i in range(26):
    for j in range(1, nums[i] + 1):
      T.a[(i + j) % 26][i] = 1

      res = quickmul(T, t)

    f = [0] * 26
  for ch in s:
    f[ord(ch) - ord("a")] += 1

    ans = 0
    for i in range(26):
      for j in range(26):
        ans = (ans + res.a[i][j] * f[j]) % MOD

        return ans
```
```javascript
class Mat {
    constructor(copyFrom = null) {
        this.a = Array.from({ length: 26 }, () => new Array(26).fill(0n));
        if (copyFrom) {
            for (let i = 0; i < 26; i++) {
                for (let j = 0; j < 26; j++) {
                    this.a[i][j] = copyFrom.a[i][j];
                }
            }
        }
    }

    mul(other) {
        const MOD = BigInt(1e9 + 7);
        const result = new Mat();
        for (let i = 0; i < 26; i++) {
            for (let j = 0; j < 26; j++) {
                for (let k = 0; k < 26; k++) {
                    result.a[i][j] =
                        (result.a[i][j] + this.a[i][k] * other.a[k][j]) % MOD;
                }
            }
        }
        return result;
    }
}

/* identity matrix */
function I() {
    const m = new Mat();
    for (let i = 0; i < 26; i++) {
        m.a[i][i] = 1n;
    }
    return m;
}

/* matrix exponentiation by squaring */
function quickmul(x, y) {
    let ans = I();
    let cur = new Mat(x);
    while (y > 0n) {
        if (y & (1n != 0n)) {
            ans = ans.mul(cur);
        }
        cur = cur.mul(cur);
        y >>= 1;
    }
    return ans;
}

var lengthAfterTransformations = function (s, t, nums) {
    const MOD = BigInt(1e9 + 7);
    const T = new Mat();
    for (let i = 0; i < 26; i++) {
        for (let j = 1; j <= nums[i]; j++) {
            T.a[(i + j) % 26][i] = 1n;
        }
    }

    const res = quickmul(T, t);
    const f = new Array(26).fill(0n);
    for (const ch of s) {
        f[ch.charCodeAt(0) - "a".charCodeAt(0)]++;
    }

    let ans = 0n;
    for (let i = 0; i < 26; i++) {
        for (let j = 0; j < 26; j++) {
            ans = (ans + res.a[i][j] * f[j]) % MOD;
        }
    }
    return Number(ans);
};
```

#### Complexity Analysis

Let n be the length of the string s, and let $∣Σ∣$ denote the size of the character set, which is 26 in this case.

-   Time complexity: $O(n+logt×∣Σ∣^3)$.
    
    We first traverse the string to count the occurrences of each character. Then, we apply matrix exponentiation by squaring to compute repeated matrix multiplication.
    
-   Space complexity: $O(∣Σ∣^2).$
    
    This is the space required to store the transformation matrix.', 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.solutions (author_id, content, problem_id) VALUES ('4d0c8d27-4509-402b-cf6f-58686cd47319', e'# Solution Article  

## Approach 1: Brute Force  
### Algorithm  
The brute force approach is simple: loop through each element `x` and find if there is another value that equals `target - x`.  

### Implementation  
``` C++
vector<int> twoSum(vector<int> &nums, int target) {
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i + 1; j < nums.size(); j++) {
            if (nums[j] == target - nums[i]) {
                return {i, j};
            }
        }
    }
        // Return an empty vector if no solution is found
    return {};
}
```  
```C
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    for (int i = 0; i < numsSize; i++) {
        for (int j = i + 1; j < numsSize; j++) {
            if (nums[j] == target - nums[i]) {
                int* result = malloc(sizeof(int) * 2);
                result[0] = i;
                result[1] = j;
                *returnSize = 2;
                return result;
            }
        }
    }
    // Return an empty array if no solution is found
    *returnSize = 0;
    return malloc(sizeof(int) * 0);
}
```
```C#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        for (int i = 0; i < nums.Length; i++) {
            for (int j = i + 1; j < nums.Length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        // Return an empty array if no solution is found
        return new int[] {};
    }
}
```
```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        // If no valid pair is found, return an empty array instead of null
        return new int[] {};
    }
}
```
```JavaScript
function twoSum(nums, target) {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[j] === target - nums[i]) {
                return [i, j];
            }
        }
    }
    // Return an empty array if no solution is found
    return [];
};
```
```Python
def twoSum(nums: list[int], target: int) -> list[int]:
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[j] == target - nums[i]:
                return [i, j]
    # Return an empty list if no solution is found
    return []
```
```TypeScript
function twoSum(nums: number[], target: number): number[] {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[j] === target - nums[i]) {
                return [i, j];
            }
        }
    }
    // Return an empty array if no solution is found
    return [];
}
```

### Complexity Analysis  
- **Time complexity**: O(n²)  
  - For each element, we try to find its complement by looping through the rest of the array, which takes O(n) time. Therefore, the overall time complexity is O(n²).  
- **Space complexity**: O(1)  
  - The space required does not depend on the size of the input array, so only constant space is used.  

---

## Approach 2: Two-pass Hash Table  
### Intuition  
To improve our runtime complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to get its index.  

Using a **hash table** can reduce the lookup time from O(n) to O(1) by trading space for speed. A hash table is well suited for this purpose because it supports fast lookup in near constant time. (Note that if a collision occurs, lookup could degenerate to O(n) time. However, with a well-chosen hash function, lookup remains amortized O(1) time.)  

### Algorithm  
A simple implementation involves two iterations:  
1. In the first iteration, add each element\'s value as a key and its index as a value to the hash table.  
2. In the second iteration, check if each element\'s complement (`target - nums[i]`) exists in the hash table. If it does exist, return the current element\'s index and its complement\'s index. **Note:** The complement must not be `nums[i]` itself!  

### Implementation  
``` C++
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        unordered_map<int, int> hash;
        for (int i = 0; i < nums.size(); i++) {
            hash[nums[i]] = i;
        }
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (hash.find(complement) != hash.end() && hash[complement] != i) {
                return {i, hash[complement]};
            }
        }
        // If no valid pair is found, return an empty vector
        return {};
    }
};
```  
```C
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    struct hashTable {
        int key;
        int value;
        UT_hash_handle hh;
    } *hashTable = NULL, *item, *tmpItem;

    for (int i = 0; i < numsSize; i++) {
        HASH_FIND_INT(hashTable, &nums[i], item);
        if (item) {
            int* result = malloc(sizeof(int) * 2);
            result[0] = item->value;
            result[1] = i;
            *returnSize = 2;
            HASH_ITER(hh, hashTable, item, tmpItem) {
                HASH_DEL(hashTable, item);
                free(item);
            }
            return result;
        }
        item = malloc(sizeof(struct hashTable));
        item->key = target - nums[i];
        item->value = i;
        HASH_ADD_INT(hashTable, key, item);
    }
    HASH_ITER(hh, hashTable, item, tmpItem) {
        HASH_DEL(hashTable, item);
        free(item);
    }
    *returnSize = 0;
    // If no valid pair is found, return an empty array
    return malloc(sizeof(int) * 0);
}
```
```C#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int, int> map = new Dictionary<int, int>();
        for (int i = 0; i < nums.Length; i++) {
            map[nums[i]] = i;
        }

        for (int i = 0; i < nums.Length; i++) {
            int complement = target - nums[i];
            if (map.ContainsKey(complement) && map[complement] != i) {
                return new int[] { i, map[complement] };
            }
        }

        // If no valid pair is found, return an empty array
        return new int[] {};
    }
}
```
```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement) && map.get(complement) != i) {
                return new int[] { i, map.get(complement) };
            }
        }
        // In case there is no solution, return an empty array
        return new int[] {};
    }
}
```
```JavaScript
var twoSum = function (nums, target) {
    const map = new Map();
    for (let i = 0; i < nums.length; i++) {
        map.set(nums[i], i);
    }
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement) && map.get(complement) !== i) {
            return [i, map.get(complement)];
        }
    }
    // If no valid pair is found, return an empty array
    return [];
};
```
```Python3
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for i in range(len(nums)):
            hashmap[nums[i]] = i
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in hashmap and hashmap[complement] != i:
                return [i, hashmap[complement]]
        # If no valid pair is found, return an empty list
        return []
```
```TypeScript
function twoSum(nums: number[], target: number): number[] {
    const map: Map<number, number> = new Map();
    for (let i = 0; i < nums.length; i++) {
        map.set(nums[i], i);
    }
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement) && map.get(complement) !== i) {
            return [i, map.get(complement)];
        }
    }
    // If no valid pair is found, return an empty array
    return [];
}
```



### Complexity Analysis  
- **Time complexity**: O(n)  
  - We traverse the list containing `n` elements exactly twice. Since the hash table reduces the lookup time to O(1), the overall time complexity is O(n).  
- **Space complexity**: O(n)  
  - The extra space required depends on the number of items stored in the hash table, which stores exactly `n` elements.  

---

## Approach 3: One-pass Hash Table  
### Algorithm  
It turns out we can do it in one pass! While iterating and inserting elements into the hash table, we also look back to check if the current element\'s complement already exists in the hash table. If it exists, we have found a solution and return the indices immediately.  

### Implementation  
``` C++
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        unordered_map<int, int> hash;
        for (int i = 0; i < nums.size(); ++i) {
            int complement = target - nums[i];
            if (hash.find(complement) != hash.end()) {
                return {hash[complement], i};
            }
            hash[nums[i]] = i;
        }
        // Return an empty vector if no solution is found
        return {};
    }
};
```  
```C
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    struct hashTable {
        int key;
        int value;
        UT_hash_handle hh;
    } *hashTable = NULL, *item;

    for (int i = 0; i < numsSize; i++) {
        int complement = target - nums[i];
        HASH_FIND_INT(hashTable, &complement, item);
        if (item) {
            int* result = malloc(sizeof(int) * 2);
            result[0] = item->value;
            result[1] = i;
            *returnSize = 2;
            HASH_CLEAR(hh, hashTable);  // Free the hash table
            return result;
        }
        item = malloc(sizeof(struct hashTable));
        item->key = nums[i];
        item->value = i;
        HASH_ADD_INT(hashTable, key, item);
    }
    *returnSize = 0;
    HASH_CLEAR(hh, hashTable);  // Free the hash table
    // Return an empty array if no solution is found
    return malloc(0);  // Allocate 0 bytes
}
```
```C#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int, int> map = new Dictionary<int, int>();
        for (int i = 0; i < nums.Length; i++) {
            int complement = target - nums[i];
            if (map.ContainsKey(complement)) {
                return new int[] { map[complement], i };
            }
            map[nums[i]] = i;
        }
        // Return an empty array if no solution is found
        return new int[] {};
    }
}
```
```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        // Return an empty array if no solution is found
        return new int[] {};
    }
}
```
```JavaScript
var twoSum = function (nums, target) {
    const map = new Map();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement)) {
            return [map.get(complement), i];
        }
        map.set(nums[i], i);
    }
    // Return an empty array if no solution is found
    return [];
};
```
```Python3
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in hashmap:
                return [i, hashmap[complement]]
            hashmap[nums[i]] = i
        # Return an empty list if no solution is found
        return []
```
```TypeScript
function twoSum(nums: number[], target: number): number[] {
    const map: Map<number, number> = new Map();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement)) {
            return [map.get(complement), i];
        }
        map.set(nums[i], i);
    }
    // Return an empty array if no solution is found
    return [];
}
```


### Complexity Analysis  
- **Time complexity**: O(n)  
  - We traverse the list containing `n` elements only once. Each lookup in the hash table costs only O(1) time.  
- **Space complexity**: O(n)  
  - The extra space required depends on the number of items stored in the hash table, which stores at most `n` elements.  
```  ', '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.solutions (author_id, content, problem_id) VALUES ('4d0c8d27-4509-402b-cf6f-58686cd47319', e'# Approach 1: Brute Force

**Algorithm**

In this approach, we find out every possible permutation of list formed by the elements of the given array and find out the permutation which is  
just larger than the given one. But this one will be a very naive approach, since it requires us to find out every possible permutation  
which will take really long time and the implementation is complex.  
Thus, this approach is not acceptable at all. Hence, we move on directly to the correct approach.

**Complexity Analysis**

-   Time complexity : O(n!). Total possible permutations is n!.
-   Space complexity : O(n). Since an array will be used to store the permutations.  
    

# Approach 2: Single Pass Approach

**Algorithm**

First, we observe that for any given sequence that is in descending order, no next larger permutation is possible.  
For example, no next permutation is possible for the following array:

```
[9, 5, 4, 3, 1]
```

We need to find the first pair of two successive numbers a[i] and a[i−1], from the right, which satisfy  
a[i]>a[i−1]. Now, no rearrangements to the right of a[i−1] can create a larger permutation since that subarray consists of numbers in descending order.  
Thus, we need to rearrange the numbers to the right of a[i−1] including itself.

Now, what kind of rearrangement will produce the next larger number? We want to create the permutation just larger than the current one. Therefore, we need to replace the number a[i−1] with the number which is just larger than itself among the numbers lying to its right section, say a[j].

![ Next Permutation ](https://leetcode.com/media/original_images/31_nums_graph.png)

We swap the numbers a[i−1] and a[j]. We now have the correct number at index i−1. But still the current permutation isn\'t the permutation  
that we are looking for. We need the smallest permutation that can be formed by using the numbers only to the right of a[i−1]. Therefore, we need to place those  
numbers in ascending order to get their smallest permutation.

But, recall that while scanning the numbers from the right, we simply kept decrementing the index  
until we found the pair a[i] and a[i−1] where, a[i]>a[i−1]. Thus, all numbers to the right of a[i−1] were already sorted in descending order.  
Furthermore, swapping a[i−1] and a[j] didn\'t change that order.  
Therefore, we simply need to reverse the numbers following a[i−1] to get the next smallest lexicographic permutation.

The following animation will make things clearer:

![Next Permutation](https://leetcode.com/media/original_images/31_Next_Permutation.gif)


```cpp

    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.size() - 1;
            while (nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums.begin() + i + 1, nums.end());
    }

private:
    void swap(vector<int>& nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```
```c
void swap(int* nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
void reverse(int* nums, int start, int numsSize) {
    int i = start, j = numsSize - 1;
    while (i < j) {
        swap(nums, i, j);
        i++;
        j--;
    }
}
void nextPermutation(int* nums, int numsSize) {
    int i = numsSize - 2;
    while (i >= 0 && nums[i + 1] <= nums[i]) {
        i--;
    }
    if (i >= 0) {
        int j = numsSize - 1;
        while (nums[j] <= nums[i]) {
            j--;
        }
        swap(nums, i, j);
    }
    reverse(nums, i + 1, numsSize);
}
```
```java
public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    private void reverse(int[] nums, int start) {
        int i = start, j = nums.length - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```
```Go 
func nextPermutation(nums []int) {
    i := len(nums) - 2
    for i >= 0 && nums[i+1] <= nums[i] {
        i--
    }
    if i >= 0 {
        j := len(nums) - 1
        for nums[j] <= nums[i] {
            j--
        }
        swap(nums, i, j)
    }
    reverse(nums, i+1)
}

func reverse(nums []int, start int) {
    i, j := start, len(nums)-1
    for i < j {
        swap(nums, i, j)
        i++
        j--
    }
}

func swap(nums []int, i int, j int) {
    temp := nums[i]
    nums[i] = nums[j]
    nums[j] = temp
}
```
```Python
def nextPermutation(nums):
	"""
	:type nums: List[int]
	:rtype: void Do not return anything, modify nums in-place instead.
	"""
	i = len(nums) - 2
	while i >= 0 and nums[i + 1] <= nums[i]:
	    i -= 1
	if i >= 0:
	    j = len(nums) - 1
	    while nums[j] <= nums[i]:
	        j -= 1
	    self.swap(nums, i, j)
	self.reverse(nums, i + 1)

	def reverse(self, nums, start):
	i, j = start, len(nums) - 1
	while i < j:
	    self.swap(nums, i, j)
	    i += 1
	    j -= 1

	def swap(self, nums, i, j):
	temp = nums[i]
	nums[i] = nums[j]
	nums[j] = temp
```
```csharp
public class Solution {
    public void NextPermutation(int[] nums) {
        int i = nums.Length - 2;
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }

        if (i >= 0) {
            int j = nums.Length - 1;
            while (nums[j] <= nums[i]) {
                j--;
            }

            Swap(nums, i, j);
        }

        Reverse(nums, i + 1);
    }

    private void Reverse(int[] nums, int start) {
        int i = start, j = nums.Length - 1;
        while (i < j) {
            Swap(nums, i, j);
            i++;
            j--;
        }
    }

    private void Swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
```javascript
function nextPermutation (nums) {
    let i = nums.length - 2;
    while (i >= 0 && nums[i + 1] <= nums[i]) {
        i--;
    }
    if (i >= 0) {
        let j = nums.length - 1;
        while (nums[j] <= nums[i]) {
            j--;
        }
        swap(nums, i, j);
    }
    reverse(nums, i + 1);
    function reverse(nums, start) {
        let i = start,
            j = nums.length - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }
    function swap(nums, i, j) {
        let temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
};
```



**Complexity Analysis**

Let n be the size of the `nums` array.

-   Time complexity: O(n)
    
    The first `while` loop runs at most n iterations, decrementing the variable `i` as it searches for the first decreasing element from the right. In the worst case, it checks all elements, so it takes O(n) time.
    
    The second `while` loop also runs at most n iterations, decrementing the variable `j` as it searches for the smallest element larger than `nums[i]`. Similarly, it can take O(n) time.
    
    The `reverse` function is called on a portion of the array, from index `i + 1` to the end. In the worst case, this can cover the entire array, leading to a time complexity of O(n).
    
    The `swap` function runs in constant time, O(1), since it only exchanges two elements.
    
    Therefore, the overall time complexity is O(n).
    
-   Space complexity: O(1)
    
    The function operates in-place on the `nums` array, meaning no extra space is used for storing additional data.
    
    Only a few constant space variables (`i`, `j`, and `temp`) are used.
    
    The built-in `swap` and `reverse` functions do not require additional space beyond what is already present in the input array.
    
    Hence, the space complexity is O(1).', '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.solutions (author_id, content, problem_id) VALUES ('4d0c8d27-4509-402b-cf6f-58686cd47319', e'# Approach

To merge the arrays in-place, we can solve this problem efficiently by merging from **right to left**, starting at the end of `nums1` and `nums2` (this prevents overwriting elements that haven’t been processed yet).  

**Optimal Solution:**  
1. Use three pointers:  
   - `p1`: Last valid element in `nums1` (`m - 1`)  
   - `p2`: Last element in `nums2` (`n - 1`)  
   - `p`: Points to the last position in `nums1` (`m + n - 1`)  
2. Compare the elements from `nums1[p1]` and `nums2[p2]`, and place the larger element at `nums1[p]`, then decrement `p`, `p1`, or `p2` accordingly.  
3. If there are any remaining elements in `nums2`, copy them to the beginning of `nums1`.  

---
# Solutions code


```python
def mergeSortedArray(nums1, m, nums2, n):
    p1, p2, p = m - 1, n - 1, m + n - 1
    
    while p1 >= 0 and p2 >= 0:
        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
    
    # If there are remaining elements in nums2
    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1
    return nums1
```
```cpp

vector<int> mergeSortedArray(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int p1 = m - 1, p2 = n - 1, p = m + n - 1;
    
    while (p1 >= 0 && p2 >= 0) {
        if (nums1[p1] > nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }
    
    // Copy remaining elements from nums2
    while (p2 >= 0) {
        nums1[p--] = nums2[p2--];
    }
    return nums1;
}


```
```javascript
function mergeSortedArray(nums1, m, nums2, n) {
    let p1 = m - 1, p2 = n - 1, p = m + n - 1;

    while (p1 >= 0 && p2 >= 0) {
        if (nums1[p1] > nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }

    // Copy remaining elements from nums2 (if any)
    while (p2 >= 0) {
        nums1[p--] = nums2[p2--];
    }
    return nums1;
}

```
```typescript
function mergeSortedArray(nums1: number[], m: number, nums2: number[], n: number): number[] {
    let p1 = m - 1, p2 = n - 1, p = m + n - 1;

    while (p1 >= 0 && p2 >= 0) {
        if (nums1[p1] > nums2[p2]) {
            nums1[p--] = nums1[p1--];
        } else {
            nums1[p--] = nums2[p2--];
        }
    }

    // Copy remaining elements from nums2 (if any)
    while (p2 >= 0) {
        nums1[p--] = nums2[p2--];
    }
    return nums1;
}


```

---

# Complexity
- **Time:** `O(m + n)` since we iterate through all the elements of `nums1` and `nums2`.  
- **Space:** `O(1)` (in-place modification of `nums1`).  

This is an optimal solution that efficiently merges the arrays in sorted order.', '7328995b-6079-4bd9-8be0-7c9152d5a73b');


-- Programming language
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (50, 'C (GCC 9.2.0)', 'C');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (54, 'C++ (GCC 9.2.0)', 'C++');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (51, 'C# (Mono 6.6.0.161)', 'C#');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (63, 'JavaScript (Node.js 12.14.0)', 'JavaScript');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (71, 'Python (3.8.1)', 'Python');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (74, 'TypeScript (3.7.4)', 'TypeScript');
INSERT INTO public.programming_language (programming_language_id, long_name, short_name) VALUES (91, 'Java (JDK 17.0.6)', 'Java');


INSERT INTO public.problem_category (category_id, problem_id) VALUES (1, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (1, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (1, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (1, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (5, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (6, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (2, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (6, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (2, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (6, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.problem_category (category_id, problem_id) VALUES (2, '591b3457-2157-4d61-b03d-d53f8666342c');

INSERT INTO public.problem_comments(
    comment_id, content, created_at, last_modified_at, user_uid, user_uuid,
    parent_comment_id, problem_id, replied_comment_id, number_of_likes, is_modified
) VALUES
('3177f55e-8fca-459c-96d4-90e51dae4588', 'i run now 7',
 '2025-02-21 16:43:00.683279+07', '2025-02-22 15:13:23.367305+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 NULL, '7328995b-6079-4bd9-8be0-7c9152d5a73b', NULL, 0, NULL),

('0dc0dfa1-cca9-42b4-bfad-f9379fdd139e', 'i run now 5',
 '2025-02-22 16:13:31.790966+07', '2025-02-22 16:13:58.301744+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 NULL, '7328995b-6079-4bd9-8be0-7c9152d5a73b', NULL, 0, NULL),

('1db65ea6-4237-4219-86ad-1f8bcee67e29', 'i run now 8',
 '2025-02-21 16:46:37.991912+07', '2025-02-22 13:07:38.136802+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 '3177f55e-8fca-459c-96d4-90e51dae4588', '7328995b-6079-4bd9-8be0-7c9152d5a73b',
 '3177f55e-8fca-459c-96d4-90e51dae4588', 0, NULL),

('9be6a2bc-e4b1-4b56-ac5d-77c06ac1b6df', 'i run now 3',
 '2025-02-21 22:02:03.547642+07', '2025-02-21 22:02:03.547642+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 NULL, '7328995b-6079-4bd9-8be0-7c9152d5a73b', NULL, 0, NULL),

('5ddd3184-4713-419c-8611-9cfd5e984c96', 'i run now 4',
 '2025-02-21 16:45:50.394167+07', '2025-02-22 17:56:49.763188+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 '3177f55e-8fca-459c-96d4-90e51dae4588', '7328995b-6079-4bd9-8be0-7c9152d5a73b',
 '3177f55e-8fca-459c-96d4-90e51dae4588', 0, NULL),

('c3265443-b55a-4f3b-b9b5-f00886ae409a', 'i run now 2',
 '2025-02-21 16:46:08.087696+07', '2025-02-22 18:11:22.526227+07',
 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a',
 '3177f55e-8fca-459c-96d4-90e51dae4588', '7328995b-6079-4bd9-8be0-7c9152d5a73b',
 '5ddd3184-4713-419c-8611-9cfd5e984c96', 0, NULL);



-- boilerplate

INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'void* isValid(char* s, int size_result) {
    // Implementation goes here
    return result;
}
', 50, 'c3756efe-d408-4e99-844e-a55021fb7c02');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
unknown isValid(std::string s) {
    // Implementation goes here
    return result;
}
', 54, 'c3756efe-d408-4e99-844e-a55021fb7c02');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public object isValid(string s) {
    // Implementation goes here
    return default;
}
', 51, 'c3756efe-d408-4e99-844e-a55021fb7c02');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function isValid(s) {
    // Implementation goes here
    return null;
}
', 63, 'c3756efe-d408-4e99-844e-a55021fb7c02');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def isValid(s):

    # Implementation goes here
    return None
', 71, 'c3756efe-d408-4e99-844e-a55021fb7c02');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function isValid(s: string): any {
    // Implementation goes here
    return null;
}
', 74, 'c3756efe-d408-4e99-844e-a55021fb7c02');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static Object isValid(String s) {

    // Implementation goes here
    return null;
}
', 91, 'c3756efe-d408-4e99-844e-a55021fb7c02');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'int* mergeSortedArray(int* num1, int m, int* num2, int n, int size_num1, int size_num2, int size_result) {
    // Implementation goes here
    return result;
}
', 50, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
std::vector<int> mergeSortedArray(std::vector<int> num1, int m, std::vector<int> num2, int n) {
    // Implementation goes here
    return result;
}
', 54, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public List<int> mergeSortedArray(List<int> num1, int m, List<int> num2, int n) {
    // Implementation goes here
    return default;
}
', 51, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function mergeSortedArray(num1, m, num2, n) {
    // Implementation goes here
    return null;
}
', 63, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def mergeSortedArray(num1, m, num2, n):

    # Implementation goes here
    return None
', 71, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function mergeSortedArray(num1: number[], m: number, num2: number[], n: number): number[] {
    // Implementation goes here
    return null;
}
', 74, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static List<int> mergeSortedArray(List<int> num1, int m, List<int> num2, int n) {

    // Implementation goes here
    return null;
}
', 91, '7328995b-6079-4bd9-8be0-7c9152d5a73b');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'int searchInsertPosition(int* nums, int target, int size_nums, int size_result) {
    // Implementation goes here
    return result;
}
', 50, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
int searchInsertPosition(std::vector<int> nums, int target) {
    // Implementation goes here
    return result;
}
', 54, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public int searchInsertPosition(List<int> nums, int target) {
    // Implementation goes here
    return default;
}
', 51, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function searchInsertPosition(nums, target) {
    // Implementation goes here
    return null;
}
', 63, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def searchInsertPosition(nums, target):

    # Implementation goes here
    return None
', 71, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function searchInsertPosition(nums: number[], target: number): number {
    // Implementation goes here
    return null;
}
', 74, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static int searchInsertPosition(List<int> nums, int target) {

    // Implementation goes here
    return null;
}
', 91, '82978535-a8da-46e1-a39a-31a232e3fffc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'int* twoSum(int* nums, int target, int size_nums, int size_result) {
    // Implementation goes here
    return result;
}
', 50, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
std::vector<int> twoSum(std::vector<int> nums, int target) {
    // Implementation goes here
    return result;
}
', 54, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public List<int> twoSum(List<int> nums, int target) {
    // Implementation goes here
    return default;
}
', 51, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function twoSum(nums, target) {
    // Implementation goes here
    return null;
}
', 63, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def twoSum(nums, target):

    # Implementation goes here
    return None
', 71, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function twoSum(nums: number[], target: number): number[] {
    // Implementation goes here
    return null;
}
', 74, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static List<int> twoSum(List<int> nums, int target) {

    // Implementation goes here
    return null;
}
', 91, '591b3457-2157-4d61-b03d-d53f8666342c');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'int lengthAfterTransformations(char* s, int t, int* nums, int size_nums, int size_result) {
    // Implementation goes here
    return result;
}
', 50, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
int lengthAfterTransformations(std::string s, int t, std::vector<int> nums) {
    // Implementation goes here
    return result;
}
', 54, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public int lengthAfterTransformations(string s, int t, List<int> nums) {
    // Implementation goes here
    return default;
}
', 51, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function lengthAfterTransformations(s, t, nums) {
    // Implementation goes here
    return null;
}
', 63, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def lengthAfterTransformations(s, t, nums):

    # Implementation goes here
    return None
', 71, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function lengthAfterTransformations(s: string, t: number, nums: number[]): number {
    // Implementation goes here
    return null;
}
', 74, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static int lengthAfterTransformations(String s, int t, List<int> nums) {

    // Implementation goes here
    return null;
}
', 91, 'feb01aba-eefe-4220-9242-729f52935cd7');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'int singleNumber(int* nums, int size_nums, int size_result) {
    // Implementation goes here
    return result;
}
', 50, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
int singleNumber(std::vector<int> nums) {
    // Implementation goes here
    return result;
}
', 54, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public int singleNumber(List<int> nums) {
    // Implementation goes here
    return default;
}
', 51, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function singleNumber(nums) {
    // Implementation goes here
    return null;
}
', 63, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def singleNumber(nums):

    # Implementation goes here
    return None
', 71, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function singleNumber(nums: number[]): number {
    // Implementation goes here
    return null;
}
', 74, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static int singleNumber(List<int> nums) {

    // Implementation goes here
    return null;
}
', 91, 'e608ebb7-07ef-4a2f-8081-92e5993e6118');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'int* plusOne(int* digits, int size_digits, int size_result) {
    // Implementation goes here
    return result;
}
', 50, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
std::vector<int> plusOne(std::vector<int> digits) {
    // Implementation goes here
    return result;
}
', 54, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public List<int> plusOne(List<int> digits) {
    // Implementation goes here
    return default;
}
', 51, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function plusOne(digits) {
    // Implementation goes here
    return null;
}
', 63, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def plusOne(digits):

    # Implementation goes here
    return None
', 71, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function plusOne(digits: number[]): number[] {
    // Implementation goes here
    return null;
}
', 74, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static List<int> plusOne(List<int> digits) {

    // Implementation goes here
    return null;
}
', 91, '73c532f9-4d55-4737-ae19-3006e02864cc');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'int* nextPermutation(int* num, int size_num, int size_result) {
    // Implementation goes here
    return result;
}
', 50, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
std::vector<int> nextPermutation(std::vector<int> num) {
    // Implementation goes here
    return result;
}
', 54, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public List<int> nextPermutation(List<int> num) {
    // Implementation goes here
    return default;
}
', 51, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function nextPermutation(num) {
    // Implementation goes here
    return null;
}
', 63, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def nextPermutation(num):

    # Implementation goes here
    return None
', 71, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function nextPermutation(num: number[]): number[] {
    // Implementation goes here
    return null;
}
', 74, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static List<int> nextPermutation(List<int> num) {

    // Implementation goes here
    return null;
}
', 91, '5c078d66-5e74-402b-8216-04ac197477a9');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'void* threeSum(int* num, int size_num, int size_result) {
    // Implementation goes here
    return result;
}
', 50, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
std::vector<std::vector<int>> threeSum(std::vector<int> num) {
    // Implementation goes here
    return result;
}
', 54, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public List<List<int>> threeSum(List<int> num) {
    // Implementation goes here
    return default;
}
', 51, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function threeSum(num) {
    // Implementation goes here
    return null;
}
', 63, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def threeSum(num):

    # Implementation goes here
    return None
', 71, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function threeSum(num: number[]): number {
    // Implementation goes here
    return null;
}
', 74, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static List<List<int>> threeSum(List<int> num) {

    // Implementation goes here
    return null;
}
', 91, '992e6551-1c96-4362-b9f9-7cb08afca28d');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'int* nextGreaterElement(int* nums1, int* nums2, int size_nums1, int size_nums2, int size_result) {
    // Implementation goes here
    return result;
}
', 50, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
std::vector<int> nextGreaterElement(std::vector<int> nums1, std::vector<int> nums2) {
    // Implementation goes here
    return result;
}
', 54, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public List<int> nextGreaterElement(List<int> nums1, List<int> nums2) {
    // Implementation goes here
    return default;
}
', 51, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function nextGreaterElement(nums1, nums2) {
    // Implementation goes here
    return null;
}
', 63, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def nextGreaterElement(nums1, nums2):

    # Implementation goes here
    return None
', 71, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function nextGreaterElement(nums1: number[], nums2: number[]): number[] {
    // Implementation goes here
    return null;
}
', 74, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static List<int> nextGreaterElement(List<int> nums1, List<int> nums2) {

    // Implementation goes here
    return null;
}
', 91, 'f3248456-acbf-46ae-9888-8bd0fad9cd91');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'int findMaximizedCapital(int k, int w, int* profits, int* capital, int size_profits, int size_capital, int size_result) {
    // Implementation goes here
    return result;
}
', 50, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'#include <iostream>
#include <vector>
#include <string>
int findMaximizedCapital(int k, int w, std::vector<int> profits, std::vector<int> capital) {
    // Implementation goes here
    return result;
}
', 54, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public int findMaximizedCapital(int k, int w, List<int> profits, List<int> capital) {
    // Implementation goes here
    return default;
}
', 51, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function findMaximizedCapital(k, w, profits, capital) {
    // Implementation goes here
    return null;
}
', 63, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'import sys
def findMaximizedCapital(k, w, profits, capital):

    # Implementation goes here
    return None
', 71, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'function findMaximizedCapital(k: number, w: number, profits: number[], capital: number[]): number {
    // Implementation goes here
    return null;
}
', 74, 'a1964481-4927-4946-bd13-cee87f00a952');
INSERT INTO public.default_code (code, language_id, problem_id) VALUES (e'public static int findMaximizedCapital(int k, int w, List<int> profits, List<int> capital) {

    // Implementation goes here
    return null;
}
', 91, 'a1964481-4927-4946-bd13-cee87f00a952');





-- Tạo bảng audit log
CREATE TABLE audit_logs (
    id SERIAL PRIMARY KEY,
    table_name VARCHAR(100) NOT NULL,
    record_id uuid NOT NULL,
    action VARCHAR(20) NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE'
    user_id VARCHAR(100) NOT NULL,
	user_role varchar(100) NOT NULL,
    changed_at TIMESTAMP NOT NULL DEFAULT NOW(),
    old_data JSONB,
    new_data JSONB
);

-- Hàm trigger
CREATE OR REPLACE FUNCTION audit_courses_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
    current_user_id TEXT;
	current_user_role TEXT;
BEGIN
    current_user_id := current_setting('audit.user_id', true);
	current_user_role := current_setting('audit.user_role', true);

    IF (current_user_id IS NULL) THEN
		current_user_id := 'AMBIGOUS_USER';
		current_user_role := 'AMBIGOUS_ROLE';
	END IF;

	IF (current_user_role = 'user' and TG_OP = 'UPDATE') THEN
		RETURN NEW;
	END IF;

    IF (TG_OP = 'DELETE') THEN
        INSERT INTO audit_logs (table_name, record_id, action, user_id, user_role, old_data)
        VALUES (TG_TABLE_NAME, OLD.course_id, 'DELETE', current_user_id, current_user_role, to_jsonb(OLD));
        RETURN OLD;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO audit_logs (table_name, record_id, action, user_id, user_role, old_data, new_data)
        VALUES (TG_TABLE_NAME, NEW.course_id, 'UPDATE', current_user_id, current_user_role, to_jsonb(OLD), to_jsonb(NEW));
        RETURN NEW;
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO audit_logs (table_name, record_id, action, user_id, user_role, new_data)
        VALUES (TG_TABLE_NAME, NEW.course_id, 'INSERT', current_user_id, current_user_role, to_jsonb(NEW));
        RETURN NEW;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Áp dụng trigger cho bảng courses
CREATE TRIGGER courses_audit_trigger
AFTER INSERT OR UPDATE OR DELETE ON courses
FOR EACH ROW EXECUTE FUNCTION audit_courses_trigger_function();

CREATE TRIGGER lessons_audit_trigger
AFTER INSERT OR UPDATE OR DELETE ON lessons
FOR EACH ROW EXECUTE FUNCTION audit_courses_trigger_function();


-- Hàm trigger
CREATE OR REPLACE FUNCTION audit_problems_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
    current_user_id TEXT;
	current_user_role TEXT;
BEGIN
    current_user_id := current_setting('audit.user_id', true);
	current_user_role := current_setting('audit.user_role', true);



    IF (current_user_id IS NULL) THEN
		current_user_id := 'AMBIGOUS_USER';
		current_user_role := 'AMBIGOUS_ROLE';
	END IF;

	IF (current_user_role = 'user' and TG_OP = 'UPDATE') THEN
		RETURN NEW;
	END IF;

    IF (TG_OP = 'DELETE') THEN
        INSERT INTO audit_logs (table_name, record_id, action, user_id, user_role, old_data)
        VALUES (TG_TABLE_NAME, OLD.problem_id, 'DELETE', current_user_id, current_user_role, to_jsonb(OLD));
        RETURN OLD;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO audit_logs (table_name, record_id, action, user_id, user_role, old_data, new_data)
        VALUES (TG_TABLE_NAME, NEW.problem_id, 'UPDATE', current_user_id, current_user_role, to_jsonb(OLD), to_jsonb(NEW));
        RETURN NEW;
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO audit_logs (table_name, record_id, action, user_id, user_role, new_data)
        VALUES (TG_TABLE_NAME, NEW.problem_id, 'INSERT', current_user_id, current_user_role, to_jsonb(NEW));
        RETURN NEW;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- DROP TRIGGER problems_audit_trigger ON PROBLEMS
CREATE TRIGGER problems_audit_trigger
AFTER INSERT OR UPDATE OR DELETE ON problems
FOR EACH ROW EXECUTE FUNCTION audit_problems_trigger_function();

-- CREATE TRIGGER test_cases_audit_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON test_cases
-- FOR EACH ROW EXECUTE FUNCTION audit_problems_trigger_function();
--
-- CREATE TRIGGER solutions_audit_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON solutions
-- FOR EACH ROW EXECUTE FUNCTION audit_problems_trigger_function();



CREATE OR REPLACE FUNCTION create_problem_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
	IF (NEW.current_creation_step < 6) THEN
		RETURN NEW;
	END IF;

	IF (NEW.current_creation_step = OLD.current_creation_step) THEN
		RETURN NEW;
	END IF;

	IF (NEW.current_creation_step = 6) THEN
		IF NEW.problem_structure IS NULL THEN
			RAISE EXCEPTION 'VALIDATE DATA: %', 'problem_structure MUST NOT BE NULL';
		END IF;
	END IF;

	IF (NOT OLD.is_completed_creation AND NEW.is_completed_creation) THEN
		IF NEW.problem_structure IS NULL THEN
			RAISE EXCEPTION 'VALIDATE DATA: %', 'problem_structure MUST NOT BE NULL';
		END IF;
	END IF;

	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_problem_step
AFTER UPDATE ON problems
FOR EACH ROW EXECUTE FUNCTION create_problem_trigger_function();








INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2508324a-2466-4bc9-bafb-e7afcab15321', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2025-06-04 15:59:26.669000 +00:00', '2026-06-04 15:59:26.669000 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ac3d203c-026d-459f-b19d-c09b3bc9c3c5', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2025-05-08 18:46:02.918728 +00:00', '2025-06-07 18:45:55.501443 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('bde8d447-0c68-4a59-93ec-5a7b19d5e27a', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2023-12-19 16:40:01.209813 +00:00', '2024-12-18 16:40:00.633442 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b08662bd-3679-4293-bd7f-e9b2822fb071', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2024-11-20 01:22:37.664539 +00:00', '2024-12-20 01:22:36.937752 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('02be5367-e0f2-44f3-8440-fd0b0237d929', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2023-11-11 22:45:48.373217 +00:00', '2023-12-11 22:45:41.834947 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ad7fb94b-7f87-4f78-8d3b-ec8c5836209b', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2025-01-19 17:34:27.308430 +00:00', '2025-02-18 17:34:17.608336 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ef63b599-41be-4a4b-b8a2-6e29bb8652d8', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2022-11-21 01:20:37.226700 +00:00', '2023-11-21 01:20:29.051105 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3b99090f-4ae0-4ac3-9563-2185952b9f7f', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2025-01-24 17:18:17.620034 +00:00', '2026-01-24 17:18:16.502081 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f77ef026-ddb4-4e36-bca9-16878995682c', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2022-03-25 05:23:51.929706 +00:00', '2022-04-24 05:23:42.565752 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('d4140fcc-6944-45fa-9795-2373f44ea6bc', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2023-02-24 18:02:36.602601 +00:00', '2023-03-26 18:02:28.345449 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('974c8926-1b48-4e08-ac17-3de35a0f3a37', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2023-11-27 12:23:12.317544 +00:00', '2024-11-26 12:23:06.366011 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('df43e6b3-f869-4efb-a767-b06f8ddad006', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2023-10-16 02:24:37.225828 +00:00', '2024-10-15 02:24:32.248360 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7c0f4122-6aec-46e4-8bf6-c739ca80ea28', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2022-05-26 10:59:12.755295 +00:00', '2022-06-25 10:59:07.500830 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e04a0f09-0015-40ca-be7b-11c958e7cb35', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2025-04-29 22:00:34.854417 +00:00', '2026-04-29 22:00:34.669836 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('18c874d6-1ae3-4013-a158-a362cb37ac2a', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2022-06-24 11:53:43.479362 +00:00', '2023-06-24 11:53:35.858584 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c5c395a8-6663-426b-bf22-3eb198a4dbfb', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2024-09-05 05:53:24.384590 +00:00', '2025-09-05 05:53:24.214609 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e37c714c-0c04-496f-9429-dffd6474f237', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2024-01-12 03:19:40.867902 +00:00', '2025-01-11 03:19:34.410381 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5a612126-da56-4b39-9f35-9ab8211c1396', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2023-11-06 10:35:55.665546 +00:00', '2023-12-06 10:35:53.362164 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f60ba290-ea93-485c-8805-457978ceb1dc', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2024-12-24 23:13:42.696644 +00:00', '2025-12-24 23:13:35.270783 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('cebd6e8d-16d0-418d-92e0-3c9825509dd1', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2023-04-01 19:17:17.508588 +00:00', '2023-05-01 19:17:13.294263 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c23eba06-2e75-4c3f-b164-796f0f1e7ef5', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2025-04-30 09:42:28.990128 +00:00', '2025-05-30 09:42:27.230699 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('23da0c64-522b-42a4-82e5-1cd204e87763', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2022-02-01 07:40:22.471091 +00:00', '2023-02-01 07:40:14.896306 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('51f47c1c-cc9c-4bb5-8164-708d14b86803', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2022-01-13 03:52:33.110521 +00:00', '2023-01-13 03:52:30.295989 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b253d00f-afa7-4c5d-8bc1-4575fa012454', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2022-11-06 14:02:13.844785 +00:00', '2022-12-06 14:02:10.263067 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a7b28af8-27cb-4f48-93e5-d268140092b1', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2024-04-06 18:39:39.748622 +00:00', '2025-04-06 18:39:35.928923 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('98098dd4-a3d3-4351-b582-ece2a76ca7c7', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2024-03-02 01:05:45.616959 +00:00', '2024-04-01 01:05:44.885316 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8cac56b2-bd29-44b5-ad71-69fe8d27a793', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2024-11-07 23:00:52.058104 +00:00', '2025-11-07 23:00:42.966913 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b123937a-773d-4022-a0e7-9215bfbb3d1f', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2024-08-25 18:48:01.936266 +00:00', '2024-09-24 18:47:56.235980 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('cefdf80b-d97a-441b-bb95-d638e0fd94cb', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2023-05-30 12:06:38.144877 +00:00', '2024-05-29 12:06:35.948559 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c82cb064-510a-401e-be55-5c39eec18c49', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2023-10-18 14:07:52.293578 +00:00', '2024-10-17 14:07:52.097196 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7c5231b7-9a07-4417-9d3a-f5867c02ffe6', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2024-05-03 14:28:11.264916 +00:00', '2024-06-02 14:28:06.136309 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('cca0ab32-79a2-4fc8-827a-a018e6d0e282', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2025-01-18 23:25:48.819502 +00:00', '2025-02-17 23:25:43.576376 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2d7320f5-33b0-4ebb-9751-34d4eb03959a', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2023-05-13 18:32:33.860402 +00:00', '2024-05-12 18:32:33.609091 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('007cf383-7933-4735-8a33-5dfff20af854', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2023-05-14 21:07:47.124054 +00:00', '2024-05-13 21:07:44.371281 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7ccb2485-a679-4f53-be1e-c8f56b3e316e', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2023-03-08 20:01:24.185022 +00:00', '2023-04-07 20:01:19.343493 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('58bb4f62-b69c-4493-a101-96d0935d58ff', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2023-10-05 14:27:48.139937 +00:00', '2023-11-04 14:27:46.659658 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('347d0248-daac-4bdf-bcef-bfbb8931fb8d', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2021-07-16 22:49:27.144497 +00:00', '2022-07-16 22:49:18.661285 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3c3a6d5b-39fe-4f4b-8f99-83951003ad58', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2021-10-19 23:09:36.869200 +00:00', '2022-10-19 23:09:33.620392 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2284a352-f058-42c9-862a-1e0b9df266ef', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2025-03-07 23:14:25.782412 +00:00', '2026-03-07 23:14:25.509587 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('9e4d4b06-0921-428d-8e8c-23fbe29f1f7e', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2022-11-10 02:45:48.126327 +00:00', '2023-11-10 02:45:44.261321 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('217cdbe6-8821-41d9-b0e2-ab4519f35fdf', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2023-11-30 10:32:54.684665 +00:00', '2024-11-29 10:32:52.894346 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5888d4c4-d550-422f-824a-b3f9e6cff614', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2025-01-06 22:36:56.761142 +00:00', '2025-02-05 22:36:48.821669 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('382ac517-e011-4d2f-bfc3-55dc9ee53b5c', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2023-08-21 20:42:13.641123 +00:00', '2023-09-20 20:42:04.178716 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0f0b89d3-c22a-41aa-be3a-250961296e2c', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2020-06-09 11:02:16.866590 +00:00', '2021-06-09 11:02:13.447448 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e268ea5a-198e-4a5a-b3b9-ffd05e2bbe68', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2022-03-22 03:06:42.052153 +00:00', '2023-03-22 03:06:33.021403 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b3e2f5be-ff98-42ed-9b2b-d2c70aa7149e', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2023-11-18 22:27:09.784174 +00:00', '2024-11-17 22:27:05.598615 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('db092ea1-f45a-41e2-9cfd-31fb1cd5b6ec', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2024-04-02 10:55:27.037421 +00:00', '2024-05-02 10:55:22.174013 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1a73aa79-efd8-4c97-b0e1-6e607f0984d3', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2022-12-02 13:34:21.067871 +00:00', '2023-01-01 13:34:13.002221 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('aaeee951-d7ab-4115-93a8-fc70d228ed09', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2022-01-30 12:38:52.713803 +00:00', '2022-03-01 12:38:48.805993 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7ba2d762-67e8-4aec-8dd6-b249443703ef', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2023-08-13 13:45:56.165428 +00:00', '2023-09-12 13:45:49.602043 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('979a41b2-b01b-4f97-80cf-3b6db70cbfe6', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2023-04-10 19:07:57.972845 +00:00', '2023-05-10 19:07:54.886473 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('61f1df1b-3b26-4e87-aca2-a764d9db111b', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2023-03-23 01:40:26.539614 +00:00', '2023-04-22 01:40:21.505054 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('225e14ca-5565-45b4-8777-4a2d24ac5439', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2018-09-08 07:19:05.815745 +00:00', '2019-09-08 07:18:55.878488 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('02929696-d64c-49ea-b0bd-eba61e02e091', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2022-02-15 09:04:20.126477 +00:00', '2023-02-15 09:04:12.202792 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7558cb49-6d27-45b3-a903-91aa787bfbe7', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2025-03-01 07:01:52.330983 +00:00', '2025-03-31 07:01:44.254141 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('4f69b079-cb7b-4cc7-8976-eabcab8ca49e', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2021-09-17 01:29:28.865657 +00:00', '2021-10-17 01:29:26.320165 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0e243efb-3a6a-4d57-99c9-3febf79937b5', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2022-05-17 22:51:03.586217 +00:00', '2022-06-16 22:51:00.347993 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('acd62b95-959d-4b02-93cb-b19569e40316', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2023-03-05 20:25:26.646741 +00:00', '2023-04-04 20:25:21.149054 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('4f0468ff-efe0-4b14-8569-199a13ba6e51', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2024-06-07 07:34:28.506293 +00:00', '2024-07-07 07:34:22.697908 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('68e386e2-38c8-40df-bf67-9b2acda75552', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2020-07-09 16:53:01.795729 +00:00', '2021-07-09 16:52:54.794020 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c9b17867-12b6-4b66-b85d-fe7fdb5385e1', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2023-12-06 04:26:38.263813 +00:00', '2024-01-05 04:26:35.290272 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ff84f6ee-1498-4e17-b8f2-18c2c9bb1b92', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2023-10-08 04:16:41.716612 +00:00', '2023-11-07 04:16:35.961262 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7fdddbbc-8ebb-4f8a-950a-76834377e95d', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2023-01-16 12:18:28.970633 +00:00', '2023-02-15 12:18:22.717273 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('fd281b47-a71a-4f4b-ac9b-f58be4624f36', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2023-10-03 21:27:30.622718 +00:00', '2023-11-02 21:27:23.276582 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('49d6cba4-d2e8-41fe-b0bd-7a44569d6eca', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2024-02-16 04:27:01.282341 +00:00', '2025-02-15 04:26:58.586550 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('03537af8-dca4-4028-a0b4-be6dba0f3dfb', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2022-04-27 13:25:10.653170 +00:00', '2023-04-27 13:25:03.053713 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('585d08f7-2da0-49ff-8fbe-dd7fc730b073', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2022-09-15 23:04:23.843773 +00:00', '2022-10-15 23:04:14.210228 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b1972d00-5a7c-4d8d-9dbc-7d9771026b43', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2022-02-01 23:27:53.058768 +00:00', '2022-03-03 23:27:49.277692 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ca4fd193-519f-49f3-9e0e-024d22a06b41', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2019-05-06 09:10:26.191277 +00:00', '2020-05-05 09:10:16.791052 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0663abfa-961e-41b5-9da0-1540e0554e23', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2022-09-28 00:48:06.811806 +00:00', '2023-09-28 00:48:00.596729 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('d269fe47-4329-48eb-b4db-51596edf6663', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2022-04-25 00:02:43.878361 +00:00', '2023-04-25 00:02:36.341539 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('cddc10af-6c18-4999-942c-d1f67872c2da', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2022-08-19 11:34:39.802150 +00:00', '2022-09-18 11:34:34.932560 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ce80e6e0-924b-4df9-bfab-685add35616f', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2023-04-06 13:03:29.598875 +00:00', '2023-05-06 13:03:24.171214 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5ef995ca-e197-4060-bc94-ccd5580731e2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2021-07-26 00:09:47.802241 +00:00', '2021-08-25 00:09:46.846498 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1f98e6ee-369b-493e-88a4-d571178ee207', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2024-12-07 12:35:57.944635 +00:00', '2025-01-06 12:35:57.738458 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1638dbd8-32e9-47c3-b161-524889bc97cf', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2023-04-05 10:59:31.705395 +00:00', '2023-05-05 10:59:30.586577 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('752eabcc-f98d-412b-8c3f-752c8e3e0b8a', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2022-03-04 04:06:08.926307 +00:00', '2022-04-03 04:05:59.872457 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f48b40cb-9b62-4516-b3a5-763fc06e43e3', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2025-05-23 05:12:50.093663 +00:00', '2026-05-23 05:12:44.076373 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('73bdbc85-b920-4da6-bf04-769b71c55e7a', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2020-04-30 23:04:10.916824 +00:00', '2021-04-30 23:04:03.339911 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('925833d3-7de3-4b68-b373-d86f6cb709a2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2020-04-04 19:09:34.132743 +00:00', '2021-04-04 19:09:27.561996 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5df3f764-6a6a-4a63-b6d9-91052dd575ac', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2023-06-25 17:49:54.292114 +00:00', '2023-07-25 17:49:46.099663 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7e4d59ab-6d0e-4a57-97c9-4298613d9e2a', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2025-02-03 07:35:28.496041 +00:00', '2025-03-05 07:35:27.974266 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('55cad6ee-c3c0-490b-83a5-a064beb32eda', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2021-12-30 01:50:59.226437 +00:00', '2022-01-29 01:50:59.078135 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('11df7442-c4fa-4fa1-acc1-6e4ab337a4d7', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2023-11-12 19:25:28.080593 +00:00', '2024-11-11 19:25:18.571276 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7a05efaa-3e51-43ac-822f-44525979cfe8', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2024-11-22 06:34:17.055478 +00:00', '2025-11-22 06:34:12.387630 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c983e5bd-2e45-49d9-96d0-d96129a74fe1', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2021-02-15 10:14:12.159420 +00:00', '2022-02-15 10:14:04.411537 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7a95c666-1e42-432d-808c-112eab3bdfb2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2018-07-26 18:30:45.959336 +00:00', '2019-07-26 18:30:39.327793 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5f13f61e-d685-4fc5-bb78-ddd1d433bb5a', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2022-06-10 23:51:39.307634 +00:00', '2023-06-10 23:51:34.071126 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('89a95fd4-613c-4ad8-bdb1-6cffbc41b3ac', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2022-09-15 08:06:54.165353 +00:00', '2023-09-15 08:06:51.532451 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5fc2e207-65e9-4d16-bc31-1d4910e9fd9f', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2022-07-04 09:37:07.486746 +00:00', '2022-08-03 09:37:04.561407 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8bdf420d-ca9b-4044-b255-a4169b9f02be', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2022-01-02 10:01:24.757351 +00:00', '2022-02-01 10:01:22.169451 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1e48fe15-1355-4624-871a-483c45ef5fa9', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2025-03-09 08:43:28.987922 +00:00', '2026-03-09 08:43:25.498152 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5c53155c-3024-483d-ae1a-bf2ec2e601cf', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2023-02-13 10:43:52.421555 +00:00', '2023-03-15 10:43:50.450459 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2b70abda-101e-4b85-b2b1-e7270a004c24', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2020-06-28 10:52:17.836632 +00:00', '2021-06-28 10:52:08.617793 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('4009932a-8a78-4d88-954d-101ccb542195', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2022-01-28 21:19:22.722708 +00:00', '2022-02-27 21:19:21.047916 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1474da91-ffb8-44cc-a068-c89122fdd6e2', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2023-09-23 20:29:10.911298 +00:00', '2024-09-22 20:29:07.842594 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8dc15335-74eb-43a8-96aa-52882ce16765', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2023-08-18 12:11:08.112984 +00:00', '2023-09-17 12:11:02.971853 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('01016226-fa43-45e4-86fd-67245c212be7', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2024-10-28 03:39:05.597931 +00:00', '2024-11-27 03:38:58.054485 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f6ecdf0b-d738-4f2a-b275-013a6e43ab5e', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2018-01-06 04:15:55.154223 +00:00', '2019-01-06 04:15:49.081299 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c2d281bf-1433-4add-a68a-918d242a7ac9', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2022-01-16 10:31:38.907424 +00:00', '2022-02-15 10:31:32.840117 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5e863605-a5f8-4a8f-b41f-22ca63c0b9d0', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2023-09-10 15:31:30.222450 +00:00', '2023-10-10 15:31:29.582734 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5b59ca24-838a-4783-b0b4-5eb8438001c9', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2022-05-05 19:58:05.007836 +00:00', '2022-06-04 19:57:55.921194 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0072030b-a06d-49da-8840-7a5ac6985951', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2021-05-05 21:42:58.799629 +00:00', '2022-05-05 21:42:58.012615 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2489c505-9685-4b7f-bd8d-0c080a8154a2', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2021-11-26 19:43:01.548079 +00:00', '2022-11-26 19:42:58.435186 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c8cfae06-5f56-401c-8799-c0b4bee4a1e3', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2020-12-28 18:37:50.510869 +00:00', '2021-12-28 18:37:43.798183 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b3d554e3-9038-4fc9-b511-dc85608e34d2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2016-05-03 19:10:18.757147 +00:00', '2017-05-03 19:10:10.888910 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('093c7ab1-0088-4e8f-9d22-91aa1fc4d8aa', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2024-06-18 03:04:07.107167 +00:00', '2025-06-18 03:04:04.963305 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ecfd51e2-27f4-4e56-90b1-382ef9516c7e', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2022-03-27 15:22:41.352713 +00:00', '2022-04-26 15:22:34.224784 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3d3220bc-382f-492a-8490-796e7b8ae91c', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2021-12-05 01:01:23.536539 +00:00', '2022-01-04 01:01:22.852821 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('edacda70-9dbb-4a5e-82f7-a9a08bd9fc77', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2017-01-15 06:28:59.201815 +00:00', '2018-01-15 06:28:49.941677 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('9f2d35bc-29e2-4bc8-aa93-3fd7585752d5', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2022-07-20 01:27:16.657657 +00:00', '2022-08-19 01:27:10.526231 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('52e7f9ea-2bd0-46ab-90b1-b8e3aa0d62c1', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2023-08-12 06:25:21.726827 +00:00', '2023-09-11 06:25:15.150502 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('23978ebc-ba19-4223-be61-65bb9413f678', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2021-10-06 04:38:46.883587 +00:00', '2021-11-05 04:38:46.879228 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('fd2b342c-1b40-4fb7-b35d-b6519b9b018e', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2021-06-07 09:01:21.839486 +00:00', '2021-07-07 09:01:15.684010 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ad7e98ff-ee1a-4c22-b61e-02d8c6daa4af', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2020-04-06 07:22:18.187439 +00:00', '2021-04-06 07:22:14.103288 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0130ddad-b9c4-473c-9d6b-971f5d04071c', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2019-10-20 18:05:10.670383 +00:00', '2020-10-19 18:05:07.682851 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e7c29a43-95fe-4bf7-b0de-20cc5c5b5011', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2023-07-14 23:23:30.160353 +00:00', '2023-08-13 23:23:29.704937 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f78ce997-95b2-4d68-9fdb-ec023ff77a07', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2022-01-11 04:56:42.112131 +00:00', '2022-02-10 04:56:40.006670 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0540c79b-bdcf-4a3c-941a-2e85c2be3e20', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2025-03-13 08:18:52.059890 +00:00', '2026-03-13 08:18:49.689980 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2db0ef52-8b93-4760-8eba-4dbf12bb0740', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2021-05-06 03:21:11.991115 +00:00', '2021-06-05 03:21:08.461064 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('dfc0c732-ed3a-4c5e-aba6-eb8e4eedfedf', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2015-12-05 08:49:22.487355 +00:00', '2016-12-04 08:49:18.268313 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('9b5e3a52-aaa8-4e97-a1b7-ef753f299bd6', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2020-09-21 17:37:57.010493 +00:00', '2021-09-21 17:37:56.879394 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('aa9ba243-b21b-4325-9eb5-b150e6084c17', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2023-01-23 09:40:20.169181 +00:00', '2023-02-22 09:40:19.997013 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('24e58827-b09c-4b38-8968-0737089b933a', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2022-03-22 17:24:59.044427 +00:00', '2022-04-21 17:24:53.831570 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('24400360-c59e-4b99-9b81-adaf3d2102fb', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2024-06-28 09:30:14.816175 +00:00', '2024-07-28 09:30:08.085022 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('cea53ed6-3416-4481-890b-4c90b29afd99', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2022-06-17 14:33:21.557105 +00:00', '2022-07-17 14:33:14.764400 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('68344614-9e14-47e9-9997-78308653c4e4', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2023-06-20 01:38:11.213759 +00:00', '2023-07-20 01:38:10.758405 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('742505ca-2c58-4dea-9daa-400246f618cf', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2021-03-27 15:18:46.176003 +00:00', '2021-04-26 15:18:40.159556 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c318323d-4cfa-49aa-8166-25fe324e265a', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2022-04-23 19:21:19.457382 +00:00', '2022-05-23 19:21:17.276101 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('72a00bb6-ecff-4a81-afd4-e2965834a5d5', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2023-10-09 13:58:31.539052 +00:00', '2023-11-08 13:58:23.273830 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2ec082a3-f184-446f-94d9-e2c9376e81ff', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2021-06-13 18:50:40.524160 +00:00', '2021-07-13 18:50:38.582606 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('634a5437-00af-427c-add2-e574f33436c6', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2019-12-16 12:23:38.190792 +00:00', '2020-12-15 12:23:37.567665 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a73b4bdf-a6dc-4971-9b10-1fd0630fe4d6', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2022-02-05 03:22:43.253456 +00:00', '2023-02-05 03:22:40.516975 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b1123680-a224-4c51-acf0-f4ae201398a5', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2023-11-23 15:23:53.171981 +00:00', '2024-11-22 15:23:51.023478 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('963472bf-7500-4f77-9b9b-ec08dacca90c', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2018-12-26 06:44:47.446481 +00:00', '2019-12-26 06:44:41.357851 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('38ae5a08-f8a6-4a33-a4a0-965adea4c96c', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2019-10-15 05:13:05.357213 +00:00', '2020-10-14 05:13:04.472032 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('bbb3cc67-2b55-47c0-b276-a417e91dcd3b', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2020-12-16 07:12:42.835573 +00:00', '2021-12-16 07:12:37.480690 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('86c6062a-fbd7-4ec2-a6a9-2e5d99ef409a', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2023-08-29 07:20:32.978866 +00:00', '2023-09-28 07:20:23.383746 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('aa74ab01-8c04-405d-ab44-c269187c1584', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2021-03-24 12:28:59.826785 +00:00', '2021-04-23 12:28:58.978241 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a4df172a-129a-4844-8dba-46561b04230e', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2022-11-24 02:07:16.842283 +00:00', '2022-12-24 02:07:12.917591 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b514a26a-ec5e-46a4-b2eb-7d896c154c30', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2023-06-18 23:00:57.950018 +00:00', '2023-07-18 23:00:56.983331 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('05995f19-6c68-478a-8277-becc4a65db0a', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2018-01-12 18:26:16.316953 +00:00', '2019-01-12 18:26:10.708228 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('10dd9eec-4afc-4c77-96e0-1164a68e2425', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2019-03-28 02:23:40.709198 +00:00', '2020-03-27 02:23:31.019508 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('102bf980-c84f-47f8-a552-2b36f4f968bf', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2024-01-05 09:08:23.486763 +00:00', '2024-02-04 09:08:17.625882 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('6e83e099-801a-4575-a158-2a4c9501c1c5', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2019-03-07 02:32:38.108532 +00:00', '2020-03-06 02:32:29.646080 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('003b409b-f23d-44c0-b028-651efef12744', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2023-07-24 18:38:27.327123 +00:00', '2023-08-23 18:38:21.708229 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('d9f9cd9f-4b14-4eab-912f-881fe22a6102', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2023-06-18 15:51:04.685396 +00:00', '2023-07-18 15:50:56.460121 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('266fb15f-f035-4e73-ba7c-121fc4bee226', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2020-10-01 07:09:04.141821 +00:00', '2021-10-01 07:08:54.387034 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0e8ec39b-bf27-4e9b-9ceb-6ad172320bcf', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2019-08-14 06:30:34.229681 +00:00', '2020-08-13 06:30:32.847110 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7bebbd42-9f2f-4b9b-8eb9-fb5d765bd3aa', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2023-07-11 02:52:42.335453 +00:00', '2023-08-10 02:52:34.872386 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2fbc6475-e564-4d5d-a920-13cc2e1e41f6', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2017-10-28 13:12:22.168653 +00:00', '2018-10-28 13:12:14.466092 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7d0d9446-0498-488e-86e9-585438866861', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2019-01-25 05:42:01.655850 +00:00', '2020-01-25 05:41:57.494541 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('982efff0-bed4-4648-8789-9c7c1ad89788', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2022-03-10 06:05:20.989354 +00:00', '2022-04-09 06:05:19.038914 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5ea628ac-5b77-4988-ae51-716368a096b7', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2023-05-03 07:18:58.208198 +00:00', '2023-06-02 07:18:52.809638 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0566bd9f-b5dc-4de3-aa48-d2ddb3c5de12', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2017-02-07 05:56:24.393067 +00:00', '2018-02-07 05:56:23.776978 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c99004ef-fd75-47a7-81a0-8ef1bfed1ad3', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2020-09-07 01:40:41.329174 +00:00', '2021-09-07 01:40:39.145544 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a86b4f6e-5e6c-4a1f-a55b-d80bf66e12ad', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2022-05-11 00:22:02.792753 +00:00', '2022-06-10 00:21:58.649137 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ff77b15e-e86e-414a-8d2b-6c22365ebeb4', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2023-02-15 23:31:16.972750 +00:00', '2024-02-15 23:31:15.336596 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('4abb5e01-b416-487c-bc48-72277dd7f2b5', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2018-01-27 06:11:08.362799 +00:00', '2019-01-27 06:11:04.933361 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('726b7f60-5567-45af-b949-b3902ade390d', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2019-08-30 05:17:42.398628 +00:00', '2020-08-29 05:17:41.746114 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ccea8ffe-c847-447d-b5b5-28d6216e5bcc', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2025-03-28 13:08:36.679719 +00:00', '2025-04-27 13:08:35.200003 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0b3e3fd3-7819-42e8-a921-160cbe720a5b', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2022-01-11 17:17:38.114775 +00:00', '2022-02-10 17:17:37.134619 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f2334928-136b-45f7-964e-4fa8e67b6523', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2022-08-10 10:34:35.227944 +00:00', '2022-09-09 10:34:34.143020 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8a88d872-cf06-434e-a83f-7513014c76db', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2017-03-15 03:57:55.838160 +00:00', '2018-03-15 03:57:50.768692 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0588e250-aba5-48ca-a4c7-74b9f49f4293', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2018-01-13 13:57:01.341374 +00:00', '2019-01-13 13:56:53.377558 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('4859aa13-b94c-4201-95b2-fe76d8617817', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2019-06-21 09:09:49.552936 +00:00', '2019-07-21 09:09:49.471083 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7573bb5f-b910-494e-a5df-387d75fa69fd', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2024-09-23 11:21:06.400639 +00:00', '2024-10-23 11:21:03.690984 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1c52dfdd-93f8-494c-a0c3-1aa30050e61c', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2023-05-16 15:24:20.774971 +00:00', '2023-06-15 15:24:18.378721 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('874748aa-f855-468e-8556-cffb93008a35', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2017-11-22 06:39:08.917281 +00:00', '2018-11-22 06:39:02.660370 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5653d2ca-8c3d-49c3-9790-e4ca42ff993b', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2024-07-13 00:07:58.122726 +00:00', '2024-08-12 00:07:52.510331 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('34ed4ad7-c6f1-4e9b-a8d6-61f3876bec1b', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2023-05-15 22:52:13.312526 +00:00', '2023-06-14 22:52:12.660445 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('897ab98f-0f11-4a74-8f43-c4b1e35ad786', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2018-01-13 17:03:23.428459 +00:00', '2019-01-13 17:03:14.480566 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3adae69e-276b-4c8d-972c-2a9cbe86ec17', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2024-10-15 02:29:02.049307 +00:00', '2024-11-14 02:28:59.244203 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ce4d2ea2-7546-4f8d-925e-a6010cd08953', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2020-11-13 08:22:02.695550 +00:00', '2020-12-13 08:22:00.090637 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('05fdc2c8-618d-4ae0-808d-c3024bac8084', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2021-11-19 18:08:51.922687 +00:00', '2021-12-19 18:08:45.728024 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('122c25b6-a08c-4a6f-b7c2-5c41f253d914', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2023-10-04 15:37:09.072238 +00:00', '2023-11-03 15:36:59.115429 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('4998f313-468a-4098-89b5-1286d8fa04a9', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2023-02-19 15:29:38.292790 +00:00', '2023-03-21 15:29:36.447922 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('562538ea-a87a-4741-b1ce-ac12ac7823ba', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2016-10-28 20:59:36.118006 +00:00', '2017-10-28 20:59:31.450391 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('d0ed3e42-b77e-4b6c-8653-0c6490baae23', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2023-09-30 07:02:09.363099 +00:00', '2023-10-30 07:02:06.823679 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('d57c5b5c-906d-487b-9cbd-be90c52c6fba', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2021-08-13 13:19:20.348852 +00:00', '2021-09-12 13:19:17.907115 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('6fb68fe1-2481-4924-84aa-c9c211ee26a9', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2022-06-12 01:59:17.890582 +00:00', '2022-07-12 01:59:09.454870 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1f3647f5-b854-47fa-a2d8-6a02dc0cc64e', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2021-02-10 19:37:40.905744 +00:00', '2022-02-10 19:37:39.485903 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e262ac24-644c-4e56-9ea7-e2fb9705fdc8', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2023-10-03 20:45:39.701713 +00:00', '2023-11-02 20:45:33.882616 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('834b36d5-24df-4df7-b094-b84d74fad44b', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2018-03-01 15:45:26.973224 +00:00', '2019-03-01 15:45:25.790937 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b24ac7f7-1723-4063-ac3b-2973efcc607b', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2014-04-10 02:29:12.956556 +00:00', '2015-04-10 02:29:09.502086 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('12752dcd-8faa-4bd0-923b-fdb7850e0961', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2021-10-20 16:30:27.114887 +00:00', '2022-10-20 16:30:25.360034 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8dc48962-aa49-4929-af2a-853af31e793d', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2021-12-19 06:53:19.622459 +00:00', '2022-01-18 06:53:10.869470 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('9d4aa75e-ee50-4c2f-9fd0-94e991e5d96f', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2022-03-05 16:02:39.016085 +00:00', '2022-04-04 16:02:31.213914 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5b9ef4c1-469a-44c6-8a8b-9f8b79ba60d8', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2018-06-02 03:09:46.907491 +00:00', '2019-06-02 03:09:45.637439 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0fac4383-6a2a-487b-ba11-0c2af098d905', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2016-06-21 12:13:07.399584 +00:00', '2017-06-21 12:13:05.806139 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('58cfada8-0e8e-4d65-914a-139ae2eecb0c', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2023-08-26 23:49:55.307794 +00:00', '2023-09-25 23:49:50.625046 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('6a580811-6450-4020-b123-3ed475a4b4a2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2023-03-24 20:18:33.910592 +00:00', '2023-04-23 20:18:31.222003 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3776a7d5-4808-47bf-98d3-5267df33accf', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2016-12-17 08:43:35.531260 +00:00', '2017-12-17 08:43:26.869649 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('81b108d3-4b9a-4f80-a433-fea3c89d417a', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2016-07-30 05:10:30.344473 +00:00', '2017-07-30 05:10:21.171338 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3bdc06c8-9388-4952-9d7f-36da5c193ca6', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2024-01-21 11:05:45.760324 +00:00', '2024-02-20 11:05:38.353474 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('99c12d6f-18bb-4101-9e6b-a6824a2cd593', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2017-04-01 05:45:43.252539 +00:00', '2018-04-01 05:45:42.261285 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7f133609-1eb1-488a-8d86-a5be9bd2fd16', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2025-04-23 08:13:50.349526 +00:00', '2026-04-23 08:13:48.033555 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('499deea7-1062-4910-a035-4db1b2d6d1f8', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2014-08-03 22:20:43.672723 +00:00', '2015-08-03 22:20:40.701782 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8e5772dd-8d9a-449a-bde4-be98343e36ff', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2024-12-23 10:14:58.952118 +00:00', '2025-01-22 10:14:51.698469 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('91236253-4e17-4a86-9553-a1dc5e5b862a', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2016-06-11 00:20:23.958459 +00:00', '2017-06-11 00:20:14.463828 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('95a0e835-b9e5-4e07-a7ec-261539841ffe', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2023-07-16 18:40:10.157082 +00:00', '2023-08-15 18:40:05.629254 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1ffb72e0-52e3-4232-ace1-60de14c5396a', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2022-08-20 06:22:16.228686 +00:00', '2022-09-19 06:22:13.614502 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('73617945-9be0-48bd-ab39-e9f12f2fc126', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2013-03-22 15:19:15.325476 +00:00', '2014-03-22 15:19:06.018442 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('9e380f3a-0f0e-4961-8140-da42efba27ad', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2022-07-11 13:55:53.277414 +00:00', '2023-07-11 13:55:49.458681 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('30b10a1e-d61e-4bdd-996b-b90bc3dffcd3', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2021-12-18 22:19:51.401240 +00:00', '2022-01-17 22:19:46.606857 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e65be18d-ad86-4c85-ab71-da88914ae324', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2015-11-25 20:04:19.028078 +00:00', '2016-11-24 20:04:15.339561 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('53702b32-4e40-402d-b63d-d8738086cd38', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2021-09-23 06:49:39.723654 +00:00', '2021-10-23 06:49:36.693000 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0163400b-dcb7-4c93-91d5-80478587ad6c', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2023-11-06 15:59:56.274418 +00:00', '2023-12-06 15:59:49.610637 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('6bcd4c14-66c6-4303-a923-f379eff7aa79', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2022-12-31 10:09:32.322181 +00:00', '2023-01-30 10:09:28.900030 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8df1bedf-8a0d-415f-b04b-9bdb68379fcf', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2025-02-27 18:54:14.137160 +00:00', '2025-03-29 18:54:12.581778 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3af24eb7-1ced-4949-adef-24fbdfcd2576', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2020-10-27 21:17:29.874141 +00:00', '2021-10-27 21:17:28.305500 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('96f7dd95-812b-4376-a736-bbab8793fc8c', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2014-11-07 16:04:09.195706 +00:00', '2015-11-07 16:04:00.530571 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f1a979b6-a2c9-4886-8d01-1fdcbbe89b68', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2023-08-29 14:11:44.396591 +00:00', '2023-09-28 14:11:40.512874 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('deb6678b-ac95-4965-81c7-7a8a86ca1d97', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2021-01-03 10:40:39.677595 +00:00', '2022-01-03 10:40:35.182578 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('9e7cfb99-c06b-4494-aea4-bf55e3a2b723', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2019-08-21 15:06:53.337192 +00:00', '2020-08-20 15:06:48.674668 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('dddfe078-573c-4338-9ae9-d53d76060a2f', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2019-05-07 04:00:20.272892 +00:00', '2019-06-06 04:00:11.509247 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('45fe1eb3-c1f6-4e45-9a90-7367f1901e84', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2021-12-24 16:20:33.179156 +00:00', '2022-01-23 16:20:25.937208 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b3d65186-83d2-45ab-899c-280b2a3339c3', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2019-07-19 07:54:41.923360 +00:00', '2019-08-18 07:54:39.791774 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('16115d61-494f-4203-b576-fb0098245729', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2015-08-18 05:43:05.914462 +00:00', '2016-08-17 05:43:05.092404 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('20ba2297-8825-483a-b744-94631a6b9803', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2014-05-26 02:26:29.354429 +00:00', '2015-05-26 02:26:27.413946 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('dc68db36-badc-4aba-9cb3-ee4a57a9499b', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2021-02-05 21:25:55.170733 +00:00', '2021-03-07 21:25:48.838249 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b1de8b6c-12e7-4c84-9866-84092c815a27', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2025-01-23 05:46:28.502680 +00:00', '2025-02-22 05:46:27.691705 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e14d170d-05a9-41b7-8baa-359941d7cab9', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2021-11-14 18:36:47.362761 +00:00', '2021-12-14 18:36:44.678425 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c425266e-f502-4922-96a5-41be299f2f9a', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2019-06-01 22:13:59.818593 +00:00', '2020-05-31 22:13:50.321313 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f2fc10f8-6e0b-4918-86aa-f77153e8612d', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2013-07-17 02:59:39.520502 +00:00', '2014-07-17 02:59:32.835513 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2033a723-d220-4d6d-a9ec-6f5bc74b6541', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2023-08-20 11:13:42.612000 +00:00', '2023-09-19 11:13:36.519922 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7b740328-0722-4ab3-970e-3631c8aa9b10', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2019-06-24 08:48:03.285903 +00:00', '2020-06-23 08:47:54.787870 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('9bffd80d-7783-4ac3-b54a-e93b884372ff', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2022-05-30 00:50:53.911737 +00:00', '2022-06-29 00:50:53.801264 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('233fb535-2921-4d38-81ed-61e396041d20', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2017-11-19 09:14:08.112767 +00:00', '2018-11-19 09:13:59.063435 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c4850867-e50b-4ea3-ba5d-d0bccc3543f4', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2022-02-18 09:32:07.737403 +00:00', '2022-03-20 09:32:05.298729 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('53f141b9-ad72-4fd0-b651-de5755104cbe', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2012-02-27 01:26:30.434837 +00:00', '2013-02-26 01:26:21.906157 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a7a005f3-4fea-4eb8-a73b-02f561aea062', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2022-06-08 07:00:48.962711 +00:00', '2022-07-08 07:00:48.265182 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('4e2f7649-c3d5-49d6-8b25-aaf26d3011c3', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2023-07-04 09:38:02.471744 +00:00', '2023-08-03 09:37:58.992149 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('439bde64-f18b-48ce-97d3-eff3f794ebd2', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2020-12-21 16:17:53.046598 +00:00', '2021-01-20 16:17:49.030222 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8a05d40d-87d1-4165-8bd0-557be788e162', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2022-04-28 15:26:59.275085 +00:00', '2022-05-28 15:26:58.723582 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('759cd4ed-39cf-4cb9-a424-9a5b7789de62', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2017-02-04 06:31:23.700433 +00:00', '2018-02-04 06:31:20.344293 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('18ea4ab1-27d2-4333-b4c5-5f018f966765', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2023-12-19 07:09:01.589680 +00:00', '2024-01-18 07:08:51.759939 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e52018df-3e5c-4324-bfa7-b3ca0c8759c4', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2023-04-03 06:12:41.313780 +00:00', '2023-05-03 06:12:37.713798 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7b06f85e-c110-4311-a44c-26e8bfd8fc96', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2021-01-03 08:52:30.543194 +00:00', '2021-02-02 08:52:23.854346 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('103660b4-1f15-4778-9292-aed2204c4515', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2015-03-31 07:19:43.492721 +00:00', '2016-03-30 07:19:38.600457 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('d9aa000c-8123-46b7-bfc7-74d54eb61250', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2021-08-13 04:40:33.072609 +00:00', '2021-09-12 04:40:26.939511 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0c83ace7-ec04-4de6-83ef-d45949a3c6b8', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2023-02-07 04:59:56.971253 +00:00', '2023-03-09 04:59:50.070130 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('27c456d0-4292-46eb-baad-4db1a43c26d0', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2011-09-08 10:31:16.242383 +00:00', '2012-09-07 10:31:12.348449 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3e1a6265-b942-4750-9e72-af86d3d67aaa', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2019-08-27 00:36:59.259118 +00:00', '2019-09-26 00:36:51.658565 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a5d718de-e651-41e4-b26e-96a1d8547c71', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2023-06-11 00:39:24.811214 +00:00', '2023-07-11 00:39:15.765780 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8621e496-f747-4006-950b-1bc238d97dcf', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2020-08-13 06:27:36.093145 +00:00', '2021-08-13 06:27:32.739479 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8479bdbb-53e1-4f97-9de8-3eaf35b676b7', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2018-10-27 18:21:58.191256 +00:00', '2019-10-27 18:21:57.572422 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('efd0bbd9-97b0-40ee-aaec-a2b904554d2f', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2015-03-05 04:32:13.320250 +00:00', '2016-03-04 04:32:06.934361 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7d1583ba-d837-4474-88cf-8efb4c070175', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2014-06-23 15:24:43.422738 +00:00', '2015-06-23 15:24:36.996004 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('6628ce2d-bebe-49ed-a508-37f58cabe449', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2010-08-20 23:28:26.501971 +00:00', '2011-08-20 23:28:26.481865 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('132b20ca-dee7-4dce-a3e6-368add04c270', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2021-11-12 03:34:23.306722 +00:00', '2021-12-12 03:34:13.806271 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('14a48304-5592-4c1d-9963-b5ec86b12cf9', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2021-09-28 23:10:30.975797 +00:00', '2021-10-28 23:10:23.577036 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a0affa2d-8fcc-4a8b-8c9d-4dcd55974c7b', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2017-02-23 02:27:29.333993 +00:00', '2018-02-23 02:27:22.727569 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('cf59ae97-8ea4-4a40-a06d-bd2f122dd786', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2023-05-15 21:38:34.061995 +00:00', '2023-06-14 21:38:30.599477 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c018153c-a8be-4a1f-9e18-ff2866d69908', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2022-07-24 20:15:16.757154 +00:00', '2022-08-23 20:15:10.996075 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('85f12d6f-5b46-4395-adb4-0d1b4816fcba', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2017-10-14 16:56:25.851205 +00:00', '2018-10-14 16:56:18.896692 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7bc536f2-9c96-43d3-9f1e-4f34764c812b', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2022-11-30 18:38:12.169724 +00:00', '2022-12-30 18:38:07.941501 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('d10584a3-27b4-4b75-b495-012742b6ebc1', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2009-07-15 23:55:29.687099 +00:00', '2010-07-15 23:55:21.048875 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('53f28a3a-ed8f-43ef-b350-c797e2ccb5fa', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2022-05-06 21:39:35.638805 +00:00', '2022-06-05 21:39:32.611195 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b20e5731-db6c-4575-bee3-5bfa77066767', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2021-06-27 03:16:53.108055 +00:00', '2021-07-27 03:16:46.619978 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('93fdb7c3-c9ed-4f61-85ae-f81036d8d3f8', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2020-10-22 22:19:01.113523 +00:00', '2020-11-21 22:18:56.869945 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3be0a888-570a-4bb2-97ea-8744a71189c7', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2023-05-15 04:02:16.646650 +00:00', '2023-06-14 04:02:15.127311 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('27a03930-be9b-44a9-9851-cb0308f40700', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2020-11-18 00:18:24.564767 +00:00', '2020-12-18 00:18:20.488513 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('974caefc-7318-4953-8eea-b73a85a96dfa', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2022-10-02 13:35:28.309206 +00:00', '2022-11-01 13:35:20.365184 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('853ba5b1-6a34-4386-b379-0bad6b41adb3', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2016-10-22 01:24:52.762076 +00:00', '2017-10-22 01:24:48.518035 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('826f822a-c66d-4614-ab66-aba542286646', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2020-09-16 13:36:57.581763 +00:00', '2020-10-16 13:36:53.129994 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2fed12c9-3fd1-48df-9417-c61be81ee122', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2019-07-18 20:20:08.686127 +00:00', '2019-08-17 20:20:04.060357 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('19d81128-e243-47a5-b374-4bed4a3c384a', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2015-04-24 15:17:19.536807 +00:00', '2016-04-23 15:17:15.151692 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1b4b8671-61f9-47a7-903d-df3072bcabc5', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2012-09-06 16:25:58.972656 +00:00', '2013-09-06 16:25:50.570546 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('9c2bd2b4-b105-405c-b398-1683e1892cff', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2022-07-20 06:03:40.655989 +00:00', '2022-08-19 06:03:34.378907 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c1f2326b-ba7b-4dca-868a-82f68f96ea70', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2015-07-12 15:06:36.275714 +00:00', '2016-07-11 15:06:31.549509 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7a283265-38c5-4ee7-886f-c5affc8e99c7', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2022-01-29 15:43:09.613394 +00:00', '2022-02-28 15:43:08.160817 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5eadf577-cbb4-48be-87e1-3a431775a5ee', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2021-11-15 02:41:38.719269 +00:00', '2021-12-15 02:41:33.525016 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e98edb27-009b-4118-9601-0ee10efcf693', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2019-07-03 04:51:42.076627 +00:00', '2020-07-02 04:51:36.855128 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c0721077-1503-49bf-aafc-dfc1763df5bb', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2013-02-13 23:45:50.534805 +00:00', '2014-02-13 23:45:40.950077 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('dbfe5b1f-c4c2-4078-8ea2-8ce791a325f0', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2016-02-06 22:55:19.293584 +00:00', '2017-02-05 22:55:12.093462 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7ee54fa4-8a58-4129-b644-1c071291c371', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2013-06-07 09:42:06.100089 +00:00', '2014-06-07 09:42:03.199408 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('109f4e5d-11bf-4a86-ad1f-86386f4cce19', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2022-03-22 08:44:56.551166 +00:00', '2022-04-21 08:44:50.562383 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ff5994e3-188b-4ae0-82e3-0425c5b79388', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2013-05-20 05:35:38.258646 +00:00', '2014-05-20 05:35:33.705485 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('77bfe807-5949-4203-b481-515184c8c496', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2014-01-14 15:47:10.562717 +00:00', '2015-01-14 15:47:10.427154 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('d9e932e6-bdc3-44e5-9fdb-381934727f94', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2021-05-21 21:18:32.092223 +00:00', '2021-06-20 21:18:25.150088 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('4e6922ef-376b-4667-b4be-202b428b6acc', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2023-03-18 10:55:17.300338 +00:00', '2023-04-17 10:55:12.788609 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('40757a91-9a99-4526-9bd3-c83eafde0e52', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2024-01-26 16:40:14.820312 +00:00', '2024-02-25 16:40:09.648798 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8b808016-bb83-4d1d-b933-7963c87d8b4d', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2017-06-24 04:32:02.684445 +00:00', '2018-06-24 04:31:53.405197 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('bd94b571-52f8-4824-aa6e-9ce8a40765c3', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2008-02-19 02:19:52.954616 +00:00', '2009-02-18 02:19:43.468592 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('291b33d3-6021-41e0-a7e6-2dc473fc7d06', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2020-05-02 12:38:13.805493 +00:00', '2020-06-01 12:38:05.556547 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e1948717-86c6-4ef4-bc36-3d611271d2e6', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2012-01-01 11:02:07.941343 +00:00', '2012-12-31 11:02:00.628673 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0b183d5e-26cf-4214-bea5-062e9fe628d4', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2015-06-30 01:51:13.210206 +00:00', '2016-06-29 01:51:09.527798 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('990eb8c1-ee18-418c-8bce-7708739cc85a', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2024-05-18 22:46:35.724777 +00:00', '2024-06-17 22:46:31.635480 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('9a6a4589-0832-4b22-8daa-4b5530d70054', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2014-03-14 02:17:10.478012 +00:00', '2015-03-14 02:17:04.238175 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('781e6a82-bf01-4181-9b5f-1def5292f961', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2021-08-16 14:11:46.641536 +00:00', '2021-09-15 14:11:38.433864 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a50f305c-d382-43a3-a1fd-6de05a8d8f8d', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2012-11-22 17:25:34.850012 +00:00', '2013-11-22 17:25:30.460714 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('16d2ef32-bdb2-44e7-902c-50d89374cb3c', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2014-11-30 18:14:01.737671 +00:00', '2015-11-30 18:13:53.332293 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('888c19d5-d8c4-4200-9f40-7628629c1a0e', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2012-03-27 19:53:04.547363 +00:00', '2013-03-27 19:53:04.254122 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('84a172d7-3e56-491f-8be3-b0d7ea09797e', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2020-10-12 08:04:24.561788 +00:00', '2020-11-11 08:04:14.927845 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b85c11b8-74a6-4dba-a479-6053035d38ce', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2021-07-08 13:28:50.256071 +00:00', '2021-08-07 13:28:45.930409 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('54a3893f-2735-47dd-a7ac-694820ea0cd8', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2024-12-04 04:17:32.129431 +00:00', '2025-01-03 04:17:27.507825 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('771ecddd-6a3c-4329-87ab-becd269e3f14', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2024-08-16 10:47:18.424545 +00:00', '2024-09-15 10:47:13.589356 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('dc12afe6-3c8b-4315-abb7-728b6a61b90e', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2021-12-22 20:03:46.674698 +00:00', '2022-01-21 20:03:44.757315 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('61c9947b-50ee-46d6-96af-7ab4ee156f7c', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2018-04-26 02:22:20.318662 +00:00', '2018-05-26 02:22:12.605259 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3b8f5f1a-c906-4a8b-8609-73e90d92fdf0', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2021-09-22 09:00:58.775302 +00:00', '2021-10-22 09:00:53.287210 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e4601154-6e84-4aa3-b86e-cac16fd7d52e', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2021-10-22 04:38:50.839702 +00:00', '2021-11-21 04:38:47.389505 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e9880157-5a9a-4a34-89d7-02d8179b0558', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '2021-09-21 22:11:31.153728 +00:00', '2021-10-21 22:11:24.686378 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5f12c5a3-8203-4f4d-9ab1-5543c3f188ee', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2010-10-14 13:28:29.626850 +00:00', '2011-10-14 13:28:20.907882 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('6a58e17c-5244-476c-8596-915549c4f1ee', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2010-12-19 06:14:49.660847 +00:00', '2011-12-19 06:14:48.931284 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('92d1afc2-f060-49c9-b32e-f673ae0c670b', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2012-06-09 07:18:11.897258 +00:00', '2013-06-09 07:18:04.353559 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f6171b67-a380-4d27-bffc-7ae6422ae5a5', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2023-12-20 05:35:51.879952 +00:00', '2024-01-19 05:35:43.423224 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('bd697226-f5ca-4b8e-8b47-6e6aae36df06', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2020-08-03 13:39:01.263113 +00:00', '2020-09-02 13:38:52.983570 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f1e6d74b-d5fd-40a0-b1a8-130ed77e3a1c', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2024-11-21 14:03:42.929117 +00:00', '2024-12-21 14:03:42.312435 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('d49a6b32-98d6-43a9-af88-1f0845f9a532', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2022-02-18 02:03:15.500025 +00:00', '2022-03-20 02:03:11.721833 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('15700dca-eb39-4dac-9c7a-c2a6be0ef86a', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2011-06-29 10:58:08.575221 +00:00', '2012-06-28 10:58:05.815348 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1d40e99c-e0ca-4712-9e60-4d16b817f138', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2011-04-25 05:58:19.833209 +00:00', '2012-04-24 05:58:13.653976 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ec1eb721-4d17-4633-89e7-7bbbd7ddceb1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2009-06-09 03:40:29.042542 +00:00', '2010-06-09 03:40:19.575332 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0e2af8ed-c475-41b6-a2ec-245338a5aeca', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2016-05-03 19:02:41.715547 +00:00', '2017-05-03 19:02:34.480347 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('18986914-d8a6-405e-ac43-4374b1c9f989', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2021-11-20 02:52:11.000938 +00:00', '2021-12-20 02:52:02.477341 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('c7bb5bb5-7d42-4348-9499-94b95c101cfd', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2025-03-07 06:06:09.916101 +00:00', '2026-03-07 06:06:04.328203 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('8ecaa874-66ee-46f2-9044-41d691e32e9d', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2021-09-03 11:42:55.907955 +00:00', '2021-10-03 11:42:46.878714 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('bb775236-186e-41cd-b67d-c0a511ba57ad', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2010-04-25 03:35:47.163963 +00:00', '2011-04-25 03:35:39.111758 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f3749171-8ed2-4405-a5bc-7f81af51007b', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2023-11-07 22:46:30.781219 +00:00', '2023-12-07 22:46:26.918651 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('fb0b34cc-fa1b-4cb5-b94c-3a4075c9a738', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2020-08-30 23:13:41.411730 +00:00', '2020-09-29 23:13:32.034021 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e064b4f8-ea9e-42fc-90a6-438edcf8a49f', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2008-03-28 22:59:45.999908 +00:00', '2009-03-28 22:59:39.215961 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f097af7e-3e4c-4453-9c50-05b2864cac65', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2020-08-21 00:58:41.621314 +00:00', '2020-09-20 00:58:37.318193 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1d935809-57a3-4614-9e1b-ab6da5e484c7', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2019-06-16 07:41:51.302245 +00:00', '2019-07-16 07:41:49.380902 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('b0070ca0-e812-4a87-9cf8-bf8b1f584be3', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2020-11-11 09:15:41.861208 +00:00', '2020-12-11 09:15:37.377253 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a50e341b-c1f0-4d35-863b-ddb243f6c843', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2024-08-02 18:57:47.356693 +00:00', '2024-09-01 18:57:38.637578 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('6d939dca-517a-46cc-b1cc-026f85f49244', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2020-07-03 00:04:18.211746 +00:00', '2020-08-02 00:04:16.477332 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3270438d-da2d-4b36-8ffd-6c016634f5f9', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2016-08-04 18:29:50.493361 +00:00', '2017-08-04 18:29:43.138404 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ee2dae4b-2f32-4a81-b4fc-839babd5b33e', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2010-01-20 06:29:06.670833 +00:00', '2011-01-20 06:29:05.545882 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ee653061-d690-4637-968f-439e96edbf80', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2009-01-31 09:17:38.081595 +00:00', '2010-01-31 09:17:34.586321 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('edd9d17a-ecac-4037-9b67-ba30fc8acbf1', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2015-04-18 22:51:21.657422 +00:00', '2016-04-17 22:51:16.098326 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('fa45a510-fcdd-4571-895b-d79c265fbfb3', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2010-08-10 02:39:25.239166 +00:00', '2011-08-10 02:39:21.419015 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('7b49203b-7e6d-4da7-be09-386c7723313b', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2009-02-28 09:46:21.261417 +00:00', '2010-02-28 09:46:15.568769 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('6dccba82-62e2-473f-a43d-89555d779c42', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2009-07-20 00:26:57.733563 +00:00', '2010-07-20 00:26:56.314980 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3f67c0e1-eb07-484d-bc4d-1dc9a0e49c96', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2024-04-18 21:16:15.085776 +00:00', '2024-05-18 21:16:07.562438 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('866d62e1-52db-4720-8fdd-866cd781a893', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2025-05-15 09:01:43.976830 +00:00', '2026-05-15 09:01:37.698328 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f7c16443-962d-4fc4-b49a-087c4807eea4', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2019-07-07 04:48:17.007285 +00:00', '2019-08-06 04:48:10.380418 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0f6bf56d-889c-46ca-80bc-9f0b338a742f', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2007-05-04 13:52:18.221900 +00:00', '2008-05-03 13:52:10.474648 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('37a1cc31-f974-4e9c-9fec-62c59fa3ec2e', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2006-08-02 07:58:09.003445 +00:00', '2007-08-02 07:58:07.030549 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('86fb6ccf-6a5e-4d33-87c5-2bf0f0d8d58e', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2018-04-17 15:07:16.704467 +00:00', '2019-04-17 15:07:11.166129 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('133001a0-6b3a-4578-a6e5-d0be25330fa8', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2025-03-07 08:47:36.764710 +00:00', '2026-03-07 08:47:32.789335 +00:00', 'PREMIUM_PLAN', 'Active', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('77e1a6df-4f11-4a6a-b837-880e4e068bef', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2019-08-30 09:32:03.263371 +00:00', '2019-09-29 09:32:02.989347 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('81ebca92-0e9f-4711-ad13-2dd9626ead10', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2019-05-18 16:30:12.565408 +00:00', '2019-06-17 16:30:05.039579 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('81c5af20-f33d-484a-915e-63dff4d4035b', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2013-05-09 16:42:54.472266 +00:00', '2014-05-09 16:42:46.227208 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('6eff7c00-3874-4c34-9ca0-967d10f23ae5', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2006-09-27 21:18:30.139222 +00:00', '2007-09-27 21:18:23.360505 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a06ff255-2461-4b52-bbb4-6b016dff3fce', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2020-05-06 03:44:18.329566 +00:00', '2020-06-05 03:44:13.291207 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('edb1cec9-f458-4cd9-8995-1075c8c6e9cf', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2024-03-06 04:54:07.430527 +00:00', '2024-04-05 04:53:57.960676 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('59eee284-2e07-427c-94c4-b3e8546b9f93', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2007-07-24 21:19:04.916175 +00:00', '2008-07-23 21:19:04.774699 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('59e2a541-dd6e-4ae9-bf19-18c0375fa543', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '2021-08-16 08:24:50.694987 +00:00', '2021-09-15 08:24:42.555432 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('ab98ff20-32e3-4215-aa54-a06aa33a04c5', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2019-04-01 18:46:04.606668 +00:00', '2019-05-01 18:46:04.082901 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f679a431-d21c-43a8-8677-67e5316c3559', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2020-03-22 02:01:27.677096 +00:00', '2020-04-21 02:01:24.906338 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('f9bb0bbf-00c7-483a-bb54-4b3e0d35e7a4', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2020-11-14 22:53:02.919470 +00:00', '2020-12-14 22:52:59.370913 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('9f88570e-a141-45c7-8c15-dc5cd37ab08e', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2016-11-23 21:21:12.013653 +00:00', '2017-11-23 21:21:10.931150 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('a447811b-a936-447a-82c3-8b928ce29a85', '59208f4f-d6ae-0792-0317-f36822578f81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '2020-06-10 06:31:54.319606 +00:00', '2020-07-10 06:31:47.119128 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('01a1b186-df51-46eb-9c51-174808543bb1', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2006-02-20 21:07:44.776893 +00:00', '2007-02-20 21:07:38.325233 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('47457bd5-1745-4bf0-9f32-49d5c94d29ce', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2011-04-05 16:34:04.688459 +00:00', '2012-04-04 16:33:57.487481 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('5ac75d56-f26c-4ed7-9c41-96bc3ffa1c3c', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2014-08-05 09:08:11.503554 +00:00', '2015-08-05 09:08:05.677755 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('989505a1-60c0-493f-b71c-68b6fe2e839e', '1974945b-162f-c609-9934-c330126caf14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2019-04-26 16:59:02.118639 +00:00', '2019-05-26 16:58:55.765646 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('d2fb481e-ba95-46ce-8005-e7c0d3df58d9', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '2009-01-07 05:02:41.951803 +00:00', '2010-01-07 05:02:33.964289 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('0ccb6146-589f-4589-852a-c6525541970b', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2020-02-05 22:06:05.266627 +00:00', '2020-03-06 22:05:57.774360 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1b369d96-fdf6-45cf-a43e-5fce83fa67d6', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '2020-09-27 01:06:26.808826 +00:00', '2020-10-27 01:06:21.305586 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('228d9e45-6531-4e84-81eb-c357dce529fa', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2021-07-20 13:46:26.156200 +00:00', '2021-08-19 13:46:16.948421 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3bdb3bd8-a9c3-4a81-8d8a-44dcf8e19ef7', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2015-01-27 13:18:18.056833 +00:00', '2016-01-27 13:18:15.099219 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('67a3b563-34e3-4f0b-acc9-026692f7ad1f', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2004-03-14 21:06:13.184307 +00:00', '2005-03-14 21:06:03.651909 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('2c33308d-c2ac-481d-a67e-a409c717dc72', '573a0d23-196a-6b35-cf9c-6e168c18596a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2021-10-14 09:29:28.379832 +00:00', '2021-11-13 09:29:26.199083 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('90132a16-618b-4f14-a485-fa3e925f4f9b', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '2021-04-10 12:26:05.452867 +00:00', '2021-05-10 12:26:04.143595 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('52645d6d-7765-4001-b3cf-36f711c285bb', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2021-05-09 20:35:00.097198 +00:00', '2021-06-08 20:34:52.545085 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('95b71b28-961f-4fe3-8901-3cc12bd6e1ce', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2023-09-26 18:13:40.702733 +00:00', '2023-10-26 18:13:32.485982 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('4a043bb7-5926-458f-9e61-469a62d7a062', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', 'Dg12bGtwJHarGR8am1f9jleense2', '2013-04-05 08:05:26.818634 +00:00', '2014-04-05 08:05:21.948123 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('e6e0602d-e5fd-495c-8cc4-6d216795a46f', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '2015-04-24 17:33:01.533489 +00:00', '2016-04-23 17:33:00.256763 +00:00', 'PREMIUM_PLAN', 'Expired', 365);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('1e55e07d-cd98-4aaa-a78d-c26133fb38f9', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '2017-01-31 16:32:03.075549 +00:00', '2017-03-02 16:32:02.462559 +00:00', 'PREMIUM_PLAN', 'Expired', 30);
INSERT INTO public.vnpay_payment_premium_package (payment_premium_package_id, user_uuid, user_uid, start_date, end_date, package_type, status, duration) VALUES ('3a71c4bd-18b8-4b34-9a9f-0111e7bdc479', 'aef57c4e-4011-1938-0086-86b46a63617c', 'nCirq4T53BPtub8VnU5VQas14B12', '2002-12-21 07:45:50.906824 +00:00', '2003-12-21 07:45:44.988424 +00:00', 'PREMIUM_PLAN', 'Expired', 365);




INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('88c34955-0874-45f8-90ed-54b6bc4e1497', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 50000, 'VND', 50000, 'VNBANK', '30545620', '2025-06-04 15:47:18.934637 +00:00', '2025-06-04 15:48:14.764000 +00:00', 'VNP15000054', '15000054', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('36d46f5a-151c-49dd-846c-8010b69db08e', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 50000, 'VND', 50000, 'VNBANK', '42229513', '2025-06-04 15:54:46.661687 +00:00', '2025-06-04 15:55:31.282000 +00:00', 'VNP15000069', '15000069', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('140db242-ba8b-42e1-850b-628d5202711f', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '17035800', '2025-06-04 15:57:26.260543 +00:00', '2025-06-04 15:58:02.004000 +00:00', 'VNP15000077', '15000077', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0cb6f248-410a-460f-a9a5-639ce330ff04', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '98395109', '2025-06-04 15:58:51.544029 +00:00', '2025-06-04 15:59:26.669000 +00:00', 'VNP15000083', '15000083', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2508324a-2466-4bc9-bafb-e7afcab15321');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3621742e-a546-4f8e-8d13-9be28d16b0ea', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 100000, 'VND', 100000, 'VNBANK', '116456', '2025-02-25 12:10:54.780347 +00:00', '2025-02-25 12:10:55.436939 +00:00', 'VNBANK116456', '116456', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('49da7006-e632-4246-b641-d14b3e0a9099', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 300000, 'VND', 300000, 'VNBANK', '776476', '2025-04-30 20:42:03.276527 +00:00', '2025-04-30 20:42:11.264175 +00:00', 'VNBANK776476', '776476', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f5b986f4-19d2-4d4e-9c70-ea4e1c2a2c14', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 100000, 'VND', 100000, 'VNBANK', '888433', '2025-04-06 00:33:37.519659 +00:00', '2025-04-06 00:33:45.448915 +00:00', 'VNBANK888433', '888433', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f828567b-4d9e-4fde-9e45-5fe8f168205b', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 100000, 'VND', 100000, 'VNBANK', '629696', '2025-04-28 03:47:49.281950 +00:00', '2025-04-28 03:47:57.888290 +00:00', 'VNBANK629696', '629696', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a043bc04-1173-494f-9f8a-2ba9844fbba0', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '457698', '2025-03-30 22:55:25.851458 +00:00', '2025-03-30 22:55:27.509025 +00:00', 'VNBANK457698', '457698', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a748a5b2-a42f-409c-9207-04a9e8a594ad', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 50000, 'VND', 50000, 'VNBANK', '713263', '2025-01-20 16:16:39.313251 +00:00', '2025-01-20 16:16:45.245985 +00:00', 'VNBANK713263', '713263', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('25e08245-28fb-4f72-ada7-d0c85de13fec', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 100000, 'VND', 100000, 'VNBANK', '72810', '2025-04-01 20:49:12.716005 +00:00', '2025-04-01 20:49:18.569110 +00:00', 'VNBANK72810', '72810', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fdf63243-288f-4271-9b06-4c3975e1f0d3', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 200000, 'VND', 200000, 'VNBANK', '491951', '2025-02-23 01:21:30.003702 +00:00', '2025-02-23 01:21:32.360567 +00:00', 'VNBANK491951', '491951', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b393dcd8-4cfa-424e-a3aa-cab5f94e98d9', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 100000, 'VND', 100000, 'VNBANK', '985510', '2025-01-25 05:14:13.094912 +00:00', '2025-01-25 05:14:15.831371 +00:00', 'VNBANK985510', '985510', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('cd663b03-2049-4f33-8205-fffe7e4ab4f0', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 100000, 'VND', 100000, 'VNBANK', '545564', '2025-02-23 23:19:15.497161 +00:00', '2025-02-23 23:19:19.217925 +00:00', 'VNBANK545564', '545564', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('27d2e10f-c04e-4cb4-beb2-3cbd99d804ff', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 400000, 'VND', 400000, 'VNBANK', '7862', '2025-05-16 13:51:42.144436 +00:00', '2025-05-16 13:51:49.485994 +00:00', 'VNBANK7862', '7862', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('087a0916-2c4e-4ea2-849d-72cb4bdbb8c6', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 50000, 'VND', 50000, 'VNBANK', '480666', '2025-02-22 07:55:02.031194 +00:00', '2025-02-22 07:55:09.981948 +00:00', 'VNBANK480666', '480666', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fe09b0cd-8c05-4cc4-871d-7927fda099f1', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 400000, 'VND', 400000, 'VNBANK', '18787', '2025-02-05 14:50:34.564141 +00:00', '2025-02-05 14:50:41.786955 +00:00', 'VNBANK18787', '18787', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a1c4e8a4-277c-4a7b-8893-aac49033ae4f', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 100000, 'VND', 100000, 'VNBANK', '738657', '2025-04-06 20:41:56.615762 +00:00', '2025-04-06 20:42:06.500274 +00:00', 'VNBANK738657', '738657', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('709825ec-687b-4019-84c6-6e17d35648dd', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 300000, 'VND', 300000, 'VNBANK', '783302', '2025-05-15 06:21:49.888837 +00:00', '2025-05-15 06:21:50.131595 +00:00', 'VNBANK783302', '783302', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('678140e4-3193-497e-8057-4773974e3411', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 50000, 'VND', 50000, 'VNBANK', '277668', '2025-06-04 14:21:45.597734 +00:00', '2025-06-04 14:21:45.701117 +00:00', 'VNBANK277668', '277668', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ff1ddeff-c482-45a4-b5c6-17169e826011', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 200000, 'VND', 200000, 'VNBANK', '580793', '2025-02-27 01:50:17.831649 +00:00', '2025-02-27 01:50:18.496482 +00:00', 'VNBANK580793', '580793', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2a8ad71c-67f1-4606-bf8e-f2580d89caa3', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 300000, 'VND', 300000, 'VNBANK', '868974', '2025-04-10 03:04:52.521915 +00:00', '2025-04-10 03:04:54.489029 +00:00', 'VNBANK868974', '868974', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('94358d15-386b-440b-802c-c9a9a4c29272', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '636509', '2025-03-14 15:45:43.544204 +00:00', '2025-03-14 15:45:50.815599 +00:00', 'VNBANK636509', '636509', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('10405bf0-f61f-44a0-ae7e-c6fec5e6b1fd', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 100000, 'VND', 100000, 'VNBANK', '72321', '2025-02-06 19:10:03.196639 +00:00', '2025-02-06 19:10:12.150408 +00:00', 'VNBANK72321', '72321', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5ff6d4df-cd63-48e6-89a9-1bb953177508', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 400000, 'VND', 400000, 'VNBANK', '395928', '2025-05-15 03:26:26.636427 +00:00', '2025-05-15 03:26:30.080395 +00:00', 'VNBANK395928', '395928', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4e459d6b-e45b-42b4-aaca-b6321fb39d64', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 50000, 'VND', 50000, 'VNBANK', '378771', '2025-01-30 05:07:38.675932 +00:00', '2025-01-30 05:07:47.378930 +00:00', 'VNBANK378771', '378771', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('6dda542c-3edc-4955-a501-114e3c88068c', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 500000, 'VND', 500000, 'VNBANK', '376970', '2025-01-05 14:18:48.511185 +00:00', '2025-01-05 14:18:51.980854 +00:00', 'VNBANK376970', '376970', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7308b39c-2d0b-4418-a427-cf1ae950208a', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '739090', '2025-05-17 03:38:37.664664 +00:00', '2025-05-17 03:38:39.208555 +00:00', 'VNBANK739090', '739090', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f0316b1b-0f95-4589-bbc6-afd1aa98bd81', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 50000, 'VND', 50000, 'VNBANK', '574678', '2025-02-01 17:39:25.817758 +00:00', '2025-02-01 17:39:26.924194 +00:00', 'VNBANK574678', '574678', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ffdf6e79-dbe1-4a83-8171-f73e712eac1b', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 100000, 'VND', 100000, 'VNBANK', '538490', '2025-05-13 17:18:43.300714 +00:00', '2025-05-13 17:18:43.593024 +00:00', 'VNBANK538490', '538490', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('927a3862-e211-409a-b5a1-c37dd0298c5a', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 100000, 'VND', 100000, 'VNBANK', '357266', '2025-01-05 20:04:31.456383 +00:00', '2025-01-05 20:04:37.596990 +00:00', 'VNBANK357266', '357266', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fd176f42-6c32-4609-bbb7-bbd673a95f11', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 100000, 'VND', 100000, 'VNBANK', '422615', '2025-04-11 11:38:34.736001 +00:00', '2025-04-11 11:38:40.054092 +00:00', 'VNBANK422615', '422615', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('212070e2-f5f1-482e-bf19-f8eb53ff3c7f', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 100000, 'VND', 100000, 'VNBANK', '739917', '2025-04-21 13:08:19.031930 +00:00', '2025-04-21 13:08:26.779746 +00:00', 'VNBANK739917', '739917', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9c928b5c-5da6-453c-89b9-768096a233ff', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 100000, 'VND', 100000, 'VNBANK', '25372', '2025-04-10 06:01:47.735588 +00:00', '2025-04-10 06:01:51.573957 +00:00', 'VNBANK25372', '25372', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d98fd52a-2cb1-4aa7-8396-627790a3f921', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '191584', '2025-03-29 07:32:14.999709 +00:00', '2025-03-29 07:32:23.390144 +00:00', 'VNBANK191584', '191584', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('34f19f08-b96e-4e54-b182-c3d0b719fc0b', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '20512', '2025-05-10 18:39:21.877015 +00:00', '2025-05-10 18:39:31.117332 +00:00', 'VNBANK20512', '20512', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('54ca9005-dea8-4e4a-a73f-2c3a0d05696f', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 200000, 'VND', 200000, 'VNBANK', '582994', '2025-05-04 17:59:37.148253 +00:00', '2025-05-04 17:59:43.657952 +00:00', 'VNBANK582994', '582994', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e774b9c0-42aa-431a-b595-217f29606071', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 100000, 'VND', 100000, 'VNBANK', '235245', '2025-02-04 05:49:29.351997 +00:00', '2025-02-04 05:49:34.732043 +00:00', 'VNBANK235245', '235245', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f50deaa0-d39a-459f-b77a-36f58210146e', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 50000, 'VND', 50000, 'VNBANK', '574245', '2025-01-28 12:41:08.430338 +00:00', '2025-01-28 12:41:14.623366 +00:00', 'VNBANK574245', '574245', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3e79694e-3f5e-4d4d-877f-8fed581b32da', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '279338', '2025-01-04 15:57:52.854785 +00:00', '2025-01-04 15:57:53.642972 +00:00', 'VNBANK279338', '279338', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f935506e-2ac5-440f-b9a0-b410ddbebf1f', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '259851', '2025-05-17 01:41:56.308108 +00:00', '2025-05-17 01:41:59.490624 +00:00', 'VNBANK259851', '259851', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e105cf80-5fc7-4161-b37e-0d993e7d49fc', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 50000, 'VND', 50000, 'VNBANK', '754360', '2025-05-31 13:55:01.843015 +00:00', '2025-05-31 13:55:10.502504 +00:00', 'VNBANK754360', '754360', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('11c35445-e36c-4ed3-8e87-2635a45852dd', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 50000, 'VND', 50000, 'VNBANK', '139352', '2025-02-25 00:23:12.655526 +00:00', '2025-02-25 00:23:18.331615 +00:00', 'VNBANK139352', '139352', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9d66e490-f03d-44b2-9372-140d3d9a6657', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '154336', '2025-06-01 15:30:31.665630 +00:00', '2025-06-01 15:30:34.210969 +00:00', 'VNBANK154336', '154336', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('66d3280c-0959-4134-a2fc-344f0e385b68', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 100000, 'VND', 100000, 'VNBANK', '51421', '2025-02-12 04:06:57.343829 +00:00', '2025-02-12 04:07:04.172382 +00:00', 'VNBANK51421', '51421', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1ab4e2cd-6607-468c-84bf-a7e200302065', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 100000, 'VND', 100000, 'VNBANK', '983165', '2025-04-19 20:54:43.812179 +00:00', '2025-04-19 20:54:45.008625 +00:00', 'VNBANK983165', '983165', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('19f4c330-7646-4000-8cf9-ab906f0448a9', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '88360', '2025-04-20 16:25:26.940273 +00:00', '2025-04-20 16:25:29.269500 +00:00', 'VNBANK88360', '88360', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ceaf1618-92cf-4d15-9d51-da2b002724d1', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 100000, 'VND', 100000, 'VNBANK', '245113', '2025-05-16 04:47:15.644228 +00:00', '2025-05-16 04:47:25.160403 +00:00', 'VNBANK245113', '245113', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('462ec5ec-c535-4d96-a1a8-993fa17f217f', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 100000, 'VND', 100000, 'VNBANK', '484501', '2025-05-13 07:15:28.792994 +00:00', '2025-05-13 07:15:36.369344 +00:00', 'VNBANK484501', '484501', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('cc862a1c-0bdd-4ea6-ab43-a6a6a3d319d6', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 100000, 'VND', 100000, 'VNBANK', '215055', '2025-04-05 11:25:21.836278 +00:00', '2025-04-05 11:25:27.527277 +00:00', 'VNBANK215055', '215055', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f6d69956-b9fe-42f7-87db-14324f3dbe9f', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '554706', '2025-02-12 13:17:46.879087 +00:00', '2025-02-12 13:17:56.095316 +00:00', 'VNBANK554706', '554706', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7f4b95e0-42ec-4e88-9654-b977447ba0dd', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 50000, 'VND', 50000, 'VNBANK', '730106', '2025-02-28 20:27:36.754320 +00:00', '2025-02-28 20:27:42.179861 +00:00', 'VNBANK730106', '730106', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fea57cd8-b043-41dc-b65f-bbd3303c3f61', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 400000, 'VND', 400000, 'VNBANK', '906257', '2025-03-24 20:09:20.252472 +00:00', '2025-03-24 20:09:28.309739 +00:00', 'VNBANK906257', '906257', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5cbd09a4-c44d-4e0a-b338-6b8c4e27e4e8', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 100000, 'VND', 100000, 'VNBANK', '33035', '2025-05-24 04:00:28.496951 +00:00', '2025-05-24 04:00:31.986463 +00:00', 'VNBANK33035', '33035', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('003b0ca0-152d-4e68-beb4-76bfaadb833a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 50000, 'VND', 50000, 'VNBANK', '365805', '2025-02-03 01:40:39.931365 +00:00', '2025-02-03 01:40:40.063788 +00:00', 'VNBANK365805', '365805', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('738aaa0c-a606-4a74-a86e-a1b9622d7d36', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 100000, 'VND', 100000, 'VNBANK', '635026', '2025-04-16 02:16:40.250258 +00:00', '2025-04-16 02:16:44.628683 +00:00', 'VNBANK635026', '635026', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('56715fd9-c387-43d0-95fa-1ff7a152cca8', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 300000, 'VND', 300000, 'VNBANK', '984913', '2025-01-10 21:34:47.997348 +00:00', '2025-01-10 21:34:52.226237 +00:00', 'VNBANK984913', '984913', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a8d842d3-d119-4aea-82c1-ca7859acc98e', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '120192', '2025-01-03 20:46:18.004901 +00:00', '2025-01-03 20:46:20.585948 +00:00', 'VNBANK120192', '120192', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('dc659b80-eddc-4ecd-b151-d4c330ada469', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 50000, 'VND', 50000, 'VNBANK', '472068', '2025-03-07 07:32:48.621852 +00:00', '2025-03-07 07:32:56.067110 +00:00', 'VNBANK472068', '472068', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('daa89011-ea8f-463f-8538-300ed4b7cb63', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 100000, 'VND', 100000, 'VNBANK', '650954', '2025-04-14 05:52:50.978331 +00:00', '2025-04-14 05:52:53.412119 +00:00', 'VNBANK650954', '650954', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('993810eb-0b00-4b1b-a699-d0e13c9be1d2', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 50000, 'VND', 50000, 'VNBANK', '314374', '2025-02-02 01:01:10.213805 +00:00', '2025-02-02 01:01:19.955982 +00:00', 'VNBANK314374', '314374', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('6b7031c8-c6bc-4175-9ec9-fe3a36f760e8', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 400000, 'VND', 400000, 'VNBANK', '345033', '2025-01-25 14:26:24.887921 +00:00', '2025-01-25 14:26:30.721147 +00:00', 'VNBANK345033', '345033', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8c2833eb-2169-4767-b869-b5a2468f8d04', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 100000, 'VND', 100000, 'VNBANK', '397631', '2025-05-13 20:16:20.930074 +00:00', '2025-05-13 20:16:24.670571 +00:00', 'VNBANK397631', '397631', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a0fead72-57b5-4753-acdc-58fbaf94aba3', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 50000, 'VND', 50000, 'VNBANK', '397929', '2025-05-02 16:49:39.375395 +00:00', '2025-05-02 16:49:48.261266 +00:00', 'VNBANK397929', '397929', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('856a901b-a375-4bc6-ae52-f5574307c1ca', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 200000, 'VND', 200000, 'VNBANK', '169776', '2025-05-30 10:02:16.958685 +00:00', '2025-05-30 10:02:24.728836 +00:00', 'VNBANK169776', '169776', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ce036758-358f-407d-8743-46c094946155', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 100000, 'VND', 100000, 'VNBANK', '285002', '2025-04-23 05:46:24.417265 +00:00', '2025-04-23 05:46:32.873816 +00:00', 'VNBANK285002', '285002', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9c81f693-b9be-48d8-8074-fbcb93af5b14', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 50000, 'VND', 50000, 'VNBANK', '941678', '2025-02-23 23:12:28.410790 +00:00', '2025-02-23 23:12:36.645240 +00:00', 'VNBANK941678', '941678', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('57bb786b-56d1-4163-9998-a06a7c9e8b2e', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 100000, 'VND', 100000, 'VNBANK', '335466', '2025-02-08 21:29:33.500811 +00:00', '2025-02-08 21:29:39.220752 +00:00', 'VNBANK335466', '335466', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3499ba37-42d9-4c7c-9692-e6075075d63c', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 100000, 'VND', 100000, 'VNBANK', '601898', '2025-05-15 03:36:05.769521 +00:00', '2025-05-15 03:36:12.156264 +00:00', 'VNBANK601898', '601898', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5cfd01fa-fe50-4e9f-a1ba-465fae50541c', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 100000, 'VND', 100000, 'VNBANK', '632252', '2025-04-26 10:30:07.251005 +00:00', '2025-04-26 10:30:07.642830 +00:00', 'VNBANK632252', '632252', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('857efadc-e1ee-44bc-b209-cfb512b9479b', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 50000, 'VND', 50000, 'VNBANK', '301177', '2025-03-29 11:04:49.157762 +00:00', '2025-03-29 11:04:49.879492 +00:00', 'VNBANK301177', '301177', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('df283d6d-da51-44f3-957c-a790ce3f6b3e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 50000, 'VND', 50000, 'VNBANK', '944255', '2025-04-16 08:02:19.588412 +00:00', '2025-04-16 08:02:22.416820 +00:00', 'VNBANK944255', '944255', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e954a102-37e5-495d-970b-73aef3494bc5', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 500000, 'VND', 500000, 'VNBANK', '256893', '2025-03-05 20:57:39.080162 +00:00', '2025-03-05 20:57:40.647719 +00:00', 'VNBANK256893', '256893', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('85eaef81-841b-4d65-ae6d-302e555e0090', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 400000, 'VND', 400000, 'VNBANK', '603695', '2025-01-30 14:57:42.969249 +00:00', '2025-01-30 14:57:45.919998 +00:00', 'VNBANK603695', '603695', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e9ac197d-2b26-4af0-9855-40107c0ef09b', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '89205', '2025-02-01 01:17:22.839877 +00:00', '2025-02-01 01:17:27.354609 +00:00', 'VNBANK89205', '89205', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f9369f64-f641-4c4a-92c9-60e8aab44c2b', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 100000, 'VND', 100000, 'VNBANK', '166644', '2025-03-30 05:47:26.979635 +00:00', '2025-03-30 05:47:28.427761 +00:00', 'VNBANK166644', '166644', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4329d10d-1612-4866-a914-63129fd7bfd6', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 100000, 'VND', 100000, 'VNBANK', '701939', '2025-02-09 03:13:48.191280 +00:00', '2025-02-09 03:13:52.667275 +00:00', 'VNBANK701939', '701939', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('361a5be2-726b-4ca6-9dd5-cc33f8172b21', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 300000, 'VND', 300000, 'VNBANK', '959275', '2025-04-22 06:38:17.126952 +00:00', '2025-04-22 06:38:25.392957 +00:00', 'VNBANK959275', '959275', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ca6a5d57-b328-4a31-a8a0-0721f8052e92', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 100000, 'VND', 100000, 'VNBANK', '296707', '2025-04-01 18:01:37.459810 +00:00', '2025-04-01 18:01:44.329910 +00:00', 'VNBANK296707', '296707', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9d973527-5e81-41d5-8d82-a5ffde47e9d0', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 50000, 'VND', 50000, 'VNBANK', '131177', '2025-03-30 05:29:53.016123 +00:00', '2025-03-30 05:29:55.058047 +00:00', 'VNBANK131177', '131177', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d7787a7a-8ef5-4f90-a1d8-e5cb349b2cd2', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 400000, 'VND', 400000, 'VNBANK', '17599', '2025-02-15 02:51:18.196776 +00:00', '2025-02-15 02:51:28.109203 +00:00', 'VNBANK17599', '17599', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4c818dd4-d2c1-48e0-993a-7c85bc956353', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 100000, 'VND', 100000, 'VNBANK', '353933', '2025-04-19 19:28:22.592680 +00:00', '2025-04-19 19:28:24.183747 +00:00', 'VNBANK353933', '353933', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1bf47cf7-8d5c-410c-b638-b8c80bb6b342', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 500000, 'VND', 500000, 'VNBANK', '579164', '2025-01-13 07:01:42.524609 +00:00', '2025-01-13 07:01:47.791489 +00:00', 'VNBANK579164', '579164', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ec275f1c-6490-4fee-a163-63c141e07d4a', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 200000, 'VND', 200000, 'VNBANK', '73820', '2025-01-04 11:24:38.071482 +00:00', '2025-01-04 11:24:39.965793 +00:00', 'VNBANK73820', '73820', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b1ce830f-229a-44d4-89f6-cac218cd81b9', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 400000, 'VND', 400000, 'VNBANK', '928436', '2025-02-17 08:31:14.776555 +00:00', '2025-02-17 08:31:24.183613 +00:00', 'VNBANK928436', '928436', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('37c048b2-b8f1-4d1c-8353-7a4a7cbf0868', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 100000, 'VND', 100000, 'VNBANK', '667691', '2025-05-01 07:22:04.020114 +00:00', '2025-05-01 07:22:11.969314 +00:00', 'VNBANK667691', '667691', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('95812534-5197-4511-92f6-fd393526f0e6', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 100000, 'VND', 100000, 'VNBANK', '668494', '2025-05-01 22:50:07.054031 +00:00', '2025-05-01 22:50:13.889207 +00:00', 'VNBANK668494', '668494', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4c390189-7b50-40ed-83ab-94742dacf58e', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 100000, 'VND', 100000, 'VNBANK', '156425', '2025-05-03 20:43:38.041969 +00:00', '2025-05-03 20:43:46.620421 +00:00', 'VNBANK156425', '156425', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3b88866c-4667-4c60-b597-384714ad5b82', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 200000, 'VND', 200000, 'VNBANK', '25694', '2025-04-14 08:24:48.636307 +00:00', '2025-04-14 08:24:54.996518 +00:00', 'VNBANK25694', '25694', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ef3ff4c0-1b6d-41d7-8bcf-422aa7e3c73b', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 400000, 'VND', 400000, 'VNBANK', '551962', '2025-04-09 02:30:06.269520 +00:00', '2025-04-09 02:30:06.927858 +00:00', 'VNBANK551962', '551962', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1ac7449a-a11c-46a4-af8a-1f496db2e91b', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 300000, 'VND', 300000, 'VNBANK', '923398', '2025-01-29 23:48:09.307963 +00:00', '2025-01-29 23:48:12.842476 +00:00', 'VNBANK923398', '923398', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4d650ffa-bc11-4e9f-8d2e-d668d46f2abb', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '198634', '2025-03-04 14:24:57.034043 +00:00', '2025-03-04 14:25:06.264619 +00:00', 'VNBANK198634', '198634', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('25d5af66-cb01-49b7-a699-28f4243cb94b', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 500000, 'VND', 500000, 'VNBANK', '13500', '2025-01-29 11:52:10.142495 +00:00', '2025-01-29 11:52:13.703218 +00:00', 'VNBANK13500', '13500', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('24ff2140-7765-4781-9846-7128376d9bc9', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 100000, 'VND', 100000, 'VNBANK', '242826', '2025-02-16 00:50:38.650410 +00:00', '2025-02-16 00:50:41.948800 +00:00', 'VNBANK242826', '242826', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f21f51cc-6d63-4393-91b1-abc732e237ee', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 300000, 'VND', 300000, 'VNBANK', '959670', '2025-04-22 01:46:18.888367 +00:00', '2025-04-22 01:46:28.315466 +00:00', 'VNBANK959670', '959670', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5f5b2d13-a6f4-402a-b2f1-6de9060e42d4', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '236077', '2025-02-17 10:41:37.143046 +00:00', '2025-02-17 10:41:46.655233 +00:00', 'VNBANK236077', '236077', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('321fff9b-6231-4c67-a589-b73b79609ef9', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 300000, 'VND', 300000, 'VNBANK', '654027', '2025-05-23 02:23:55.492353 +00:00', '2025-05-23 02:24:00.045433 +00:00', 'VNBANK654027', '654027', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f7147bf1-49f7-41ed-b3e0-676eecef2ff5', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '743802', '2025-04-29 07:02:20.941794 +00:00', '2025-04-29 07:02:22.091148 +00:00', 'VNBANK743802', '743802', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a34a1e23-4ba0-4009-bcf8-5e088e2a3e0b', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 200000, 'VND', 200000, 'VNBANK', '773241', '2025-02-14 01:15:45.328097 +00:00', '2025-02-14 01:15:48.448891 +00:00', 'VNBANK773241', '773241', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bbe3e7e2-9625-4ac9-8fc9-d0c9714d7981', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 100000, 'VND', 100000, 'VNBANK', '575348', '2025-04-29 09:43:35.044375 +00:00', '2025-04-29 09:43:42.213049 +00:00', 'VNBANK575348', '575348', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('75858aae-ae7c-47f5-8599-8a9d460d3dc5', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 50000, 'VND', 50000, 'VNBANK', '641005', '2025-03-09 00:26:38.992422 +00:00', '2025-03-09 00:26:42.926912 +00:00', 'VNBANK641005', '641005', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b06717a2-0460-433a-9e8a-dce70e1efa37', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 50000, 'VND', 50000, 'VNBANK', '961804', '2025-02-07 20:43:10.863357 +00:00', '2025-02-07 20:43:13.859874 +00:00', 'VNBANK961804', '961804', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ce0efd30-5010-4af5-a0fb-a36f4e7c19f9', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9553533', '2025-01-05 20:20:36.924050 +00:00', '2025-01-05 20:20:44.662588 +00:00', 'VNBANK9553533', '9553533', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9e6efafa-e975-4561-a042-c682be0d8e56', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9641488', '2025-05-06 14:46:59.012671 +00:00', '2025-05-06 14:47:06.549879 +00:00', 'VNBANK9641488', '9641488', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2e86bc41-8fef-493e-81e3-6ac390916e1d', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 300000, 'VND', 300000, 'VNBANK', '9602026', '2025-03-09 03:29:10.553488 +00:00', '2025-03-09 03:29:13.254654 +00:00', 'VNBANK9602026', '9602026', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('512be2da-24d0-4727-a707-69c9a93a2dd7', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9765207', '2025-05-08 12:53:50.550044 +00:00', '2025-05-08 12:53:59.724617 +00:00', 'VNBANK9765207', '9765207', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4114563b-620d-4fb7-8472-8f93ce4f0330', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9455014', '2025-05-07 16:10:27.345265 +00:00', '2025-05-07 16:10:35.021242 +00:00', 'VNBANK9455014', '9455014', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d9eeacd5-638b-48b6-9e7c-a2bf9e3b628a', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9055050', '2025-01-27 14:56:50.120781 +00:00', '2025-01-27 14:56:54.099759 +00:00', 'VNBANK9055050', '9055050', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5d036e74-0528-4248-aebe-b9cd96102193', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9346942', '2025-03-11 10:01:01.033887 +00:00', '2025-03-11 10:01:09.487252 +00:00', 'VNBANK9346942', '9346942', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('51761e72-cd2e-4a2f-a6e1-a88d2087289a', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9525486', '2025-02-25 00:48:41.514856 +00:00', '2025-02-25 00:48:50.209939 +00:00', 'VNBANK9525486', '9525486', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8227f389-79e0-469f-a52b-96e7d331c1ae', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 200000, 'VND', 200000, 'VNBANK', '9576145', '2025-03-14 01:11:26.115602 +00:00', '2025-03-14 01:11:35.053684 +00:00', 'VNBANK9576145', '9576145', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('65c8b269-70c1-42fb-a8f9-de6f495eb7e7', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9398028', '2025-02-13 08:45:44.311164 +00:00', '2025-02-13 08:45:52.724048 +00:00', 'VNBANK9398028', '9398028', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fb3b2d24-5141-4287-a705-47f49438a4dd', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9168897', '2025-04-09 05:31:36.767175 +00:00', '2025-04-09 05:31:41.748788 +00:00', 'VNBANK9168897', '9168897', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9bb39520-cc76-492c-879f-638229c627e5', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9230583', '2025-02-17 17:13:47.365993 +00:00', '2025-02-17 17:13:55.157595 +00:00', 'VNBANK9230583', '9230583', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('10c82477-5c83-4d60-9529-074ff41ffc78', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 200000, 'VND', 200000, 'VNBANK', '9258816', '2025-03-08 21:06:02.681362 +00:00', '2025-03-08 21:06:05.921315 +00:00', 'VNBANK9258816', '9258816', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7d70f009-7a2a-4e19-9150-8057230aa926', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9949940', '2025-04-08 06:59:19.754078 +00:00', '2025-04-08 06:59:23.920810 +00:00', 'VNBANK9949940', '9949940', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('27bab176-3c8b-461b-b19b-a973e780e062', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9145753', '2025-03-28 09:23:07.474643 +00:00', '2025-03-28 09:23:09.884731 +00:00', 'VNBANK9145753', '9145753', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('39787f1a-bd76-43da-b487-2b5fce12f449', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9985081', '2025-06-02 05:32:26.849781 +00:00', '2025-06-02 05:32:33.395252 +00:00', 'VNBANK9985081', '9985081', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3f1cd93d-9aba-4c99-bd74-1dd1b06b2ee3', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9407214', '2025-03-10 21:54:32.018070 +00:00', '2025-03-10 21:54:37.702424 +00:00', 'VNBANK9407214', '9407214', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ba3224c1-10e5-4800-bdce-4335283ff27e', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 400000, 'VND', 400000, 'VNBANK', '9806868', '2025-05-18 23:00:28.368721 +00:00', '2025-05-18 23:00:33.643685 +00:00', 'VNBANK9806868', '9806868', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9ad41dcd-bf42-4bb9-8dbf-248054863517', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9128107', '2025-01-12 09:38:51.235067 +00:00', '2025-01-12 09:38:53.183005 +00:00', 'VNBANK9128107', '9128107', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9533b2b2-60a6-48d8-be08-ab562e2dce3c', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9563948', '2025-01-17 11:04:35.534908 +00:00', '2025-01-17 11:04:42.978298 +00:00', 'VNBANK9563948', '9563948', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bb584674-469c-4573-98a6-7968da68b38b', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9737006', '2025-02-20 11:26:19.270856 +00:00', '2025-02-20 11:26:26.595269 +00:00', 'VNBANK9737006', '9737006', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('73393459-44ac-4409-8e4a-5ba5d6cd74e1', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9093263', '2025-05-26 07:27:21.469330 +00:00', '2025-05-26 07:27:22.639438 +00:00', 'VNBANK9093263', '9093263', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('625c07b8-291e-4f71-9a8d-ed596618013e', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 200000, 'VND', 200000, 'VNBANK', '9215061', '2025-05-20 09:47:30.015254 +00:00', '2025-05-20 09:47:39.728353 +00:00', 'VNBANK9215061', '9215061', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d6debefd-4587-45e6-b192-117b3da60aff', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9839636', '2025-03-24 08:48:31.891480 +00:00', '2025-03-24 08:48:32.218993 +00:00', 'VNBANK9839636', '9839636', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('284e2dd9-2597-4b14-9dc1-20d7de2d05f4', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9000013', '2025-05-03 05:21:56.742694 +00:00', '2025-05-03 05:22:01.936132 +00:00', 'VNBANK9000013', '9000013', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ef14e552-8243-484c-a7c0-900a541b128e', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9246663', '2025-05-19 16:28:03.374129 +00:00', '2025-05-19 16:28:04.660717 +00:00', 'VNBANK9246663', '9246663', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2a3a2d4b-9b81-4120-af01-cca3601885ca', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9453935', '2025-01-29 20:59:42.398919 +00:00', '2025-01-29 20:59:45.414168 +00:00', 'VNBANK9453935', '9453935', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f2a85fd1-1ebb-4512-b741-827dc906f52b', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9852775', '2025-04-27 16:14:35.892708 +00:00', '2025-04-27 16:14:38.286825 +00:00', 'VNBANK9852775', '9852775', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b5912506-8f4f-423f-a5a8-aeb2d087166c', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 300000, 'VND', 300000, 'VNBANK', '9895926', '2025-02-08 18:11:15.305248 +00:00', '2025-02-08 18:11:24.698124 +00:00', 'VNBANK9895926', '9895926', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('27b2279d-33c7-4c1f-ac9a-c2816fb3e53a', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9966373', '2025-02-27 16:32:56.019937 +00:00', '2025-02-27 16:33:01.169216 +00:00', 'VNBANK9966373', '9966373', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1731e8ee-6cc4-466a-b4b0-8beb1189e340', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 300000, 'VND', 300000, 'VNBANK', '9495222', '2025-01-27 09:59:46.743360 +00:00', '2025-01-27 09:59:51.435218 +00:00', 'VNBANK9495222', '9495222', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bcd2ac6f-0089-46ab-a638-474354ae729e', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9486851', '2025-06-04 12:53:26.046291 +00:00', '2025-06-04 12:53:34.314830 +00:00', 'VNBANK9486851', '9486851', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2b998d71-21f3-48f9-981c-23d4d303be38', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9191236', '2025-03-19 12:08:24.110333 +00:00', '2025-03-19 12:08:30.545858 +00:00', 'VNBANK9191236', '9191236', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('57969f94-90ec-4346-9d5d-430e61e2bdba', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9997727', '2025-05-28 23:43:44.202991 +00:00', '2025-05-28 23:43:46.933649 +00:00', 'VNBANK9997727', '9997727', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5dd60519-137f-4ae7-9bc2-f27ed55b844f', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9722005', '2025-01-26 12:38:39.913333 +00:00', '2025-01-26 12:38:46.037428 +00:00', 'VNBANK9722005', '9722005', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('063e1fa5-7e6c-42f8-bf1d-e3ce90ca8245', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9648152', '2025-05-12 20:38:24.422304 +00:00', '2025-05-12 20:38:26.483978 +00:00', 'VNBANK9648152', '9648152', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9ce0df69-62f5-46e5-b654-bcf12c91b73b', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9200596', '2025-01-25 14:40:01.695122 +00:00', '2025-01-25 14:40:10.384032 +00:00', 'VNBANK9200596', '9200596', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3ceadef9-90f5-408b-a8cd-43a359b5cc4e', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9525306', '2025-04-10 18:38:22.686885 +00:00', '2025-04-10 18:38:29.494510 +00:00', 'VNBANK9525306', '9525306', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5f78d2b5-dc56-4989-acc0-e5e7d3771ad1', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9598846', '2025-02-08 03:34:35.526276 +00:00', '2025-02-08 03:34:39.802342 +00:00', 'VNBANK9598846', '9598846', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('33c3a54a-db14-45d1-8fb4-2628dbc415bb', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9465278', '2025-05-11 18:55:07.723942 +00:00', '2025-05-11 18:55:08.400312 +00:00', 'VNBANK9465278', '9465278', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a550ba00-c20f-4c9e-b02e-eb550c763140', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 200000, 'VND', 200000, 'VNBANK', '9364770', '2025-01-05 14:50:43.300217 +00:00', '2025-01-05 14:50:47.228084 +00:00', 'VNBANK9364770', '9364770', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('07b2e5f4-5623-4ab4-bae6-db5b3f8e986d', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9764998', '2025-02-21 00:40:15.181553 +00:00', '2025-02-21 00:40:17.388679 +00:00', 'VNBANK9764998', '9764998', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('12fc377e-15e0-4c03-a2c0-2fa22c113d46', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9790787', '2025-03-11 17:26:41.293839 +00:00', '2025-03-11 17:26:44.408735 +00:00', 'VNBANK9790787', '9790787', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5f5b0d69-8f6d-4166-af4a-d18eae83f4f9', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9257834', '2025-06-04 11:27:11.316075 +00:00', '2025-06-04 11:27:12.168160 +00:00', 'VNBANK9257834', '9257834', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('dba418c6-7a68-46b0-beb3-b28dcc3747a1', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9853006', '2025-06-02 15:03:34.187281 +00:00', '2025-06-02 15:03:41.652444 +00:00', 'VNBANK9853006', '9853006', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0689d380-e7c4-46c2-ae80-08eaf06657bd', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9401027', '2025-03-16 09:58:47.012330 +00:00', '2025-03-16 09:58:55.573422 +00:00', 'VNBANK9401027', '9401027', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f6009a30-77bf-48db-bcad-893c73228de5', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 300000, 'VND', 300000, 'VNBANK', '9375867', '2025-04-08 11:25:50.338571 +00:00', '2025-04-08 11:25:57.308097 +00:00', 'VNBANK9375867', '9375867', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f5048145-be59-43e1-b29b-0ad786f70b07', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9074609', '2025-03-05 05:26:06.735089 +00:00', '2025-03-05 05:26:16.251222 +00:00', 'VNBANK9074609', '9074609', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('15ce5065-21a4-4d60-be32-31ad568fd734', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9372919', '2025-05-26 23:46:46.190367 +00:00', '2025-05-26 23:46:49.638729 +00:00', 'VNBANK9372919', '9372919', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b28bc8ca-1c49-44e2-b4fb-3f3f1d91824b', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 400000, 'VND', 400000, 'VNBANK', '9517058', '2025-04-17 08:49:51.830787 +00:00', '2025-04-17 08:49:53.604782 +00:00', 'VNBANK9517058', '9517058', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('328f5f74-761a-44e3-a1da-eeccc8e1303c', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9535191', '2025-03-18 11:21:07.023097 +00:00', '2025-03-18 11:21:12.279117 +00:00', 'VNBANK9535191', '9535191', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bf54b452-0a9e-4c9a-82fc-4503c477b503', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9589287', '2025-02-04 06:16:00.375397 +00:00', '2025-02-04 06:16:08.572390 +00:00', 'VNBANK9589287', '9589287', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fc127fe9-326e-495f-9559-fcdf90922f7f', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 400000, 'VND', 400000, 'VNBANK', '9930023', '2025-01-16 23:25:32.364608 +00:00', '2025-01-16 23:25:41.683068 +00:00', 'VNBANK9930023', '9930023', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d53e0366-ca04-4e8c-aca1-d33ba439dfb9', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9679173', '2025-03-15 13:10:15.791574 +00:00', '2025-03-15 13:10:24.245204 +00:00', 'VNBANK9679173', '9679173', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('17923856-698f-4b75-b92c-2dde5b524d4b', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 300000, 'VND', 300000, 'VNBANK', '9885204', '2025-05-28 12:52:56.839296 +00:00', '2025-05-28 12:53:01.248702 +00:00', 'VNBANK9885204', '9885204', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('97cbb271-dd0f-4f1a-81fd-690704e4a665', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9555854', '2025-04-20 04:18:32.199077 +00:00', '2025-04-20 04:18:39.922066 +00:00', 'VNBANK9555854', '9555854', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('09e5707d-ff3e-4c7f-84dc-18b777543551', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9886218', '2025-04-19 19:49:28.435690 +00:00', '2025-04-19 19:49:35.593735 +00:00', 'VNBANK9886218', '9886218', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4a48c3a0-ca87-4afd-a21e-6fb2c6f77d18', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 300000, 'VND', 300000, 'VNBANK', '9580725', '2025-04-22 10:13:47.766163 +00:00', '2025-04-22 10:13:54.320289 +00:00', 'VNBANK9580725', '9580725', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8765fd16-b051-4c75-b5de-18106b72647d', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9051975', '2025-05-18 23:46:50.517996 +00:00', '2025-05-18 23:46:57.291445 +00:00', 'VNBANK9051975', '9051975', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('030a68ad-83af-414e-b206-e94e95b868f0', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 400000, 'VND', 400000, 'VNBANK', '9917006', '2025-04-22 22:55:51.370928 +00:00', '2025-04-22 22:55:58.590103 +00:00', 'VNBANK9917006', '9917006', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c70f06d4-33e7-485e-a478-e672957c5ace', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 200000, 'VND', 200000, 'VNBANK', '9990511', '2025-06-03 02:49:56.174887 +00:00', '2025-06-03 02:50:04.685874 +00:00', 'VNBANK9990511', '9990511', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c3850334-6169-456a-b270-dffa6fd61abf', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9322412', '2025-01-13 12:13:51.235536 +00:00', '2025-01-13 12:13:56.925860 +00:00', 'VNBANK9322412', '9322412', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5156ef57-a4a9-4eab-aa50-dd57bf078ace', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 400000, 'VND', 400000, 'VNBANK', '9552633', '2025-04-14 20:00:35.696364 +00:00', '2025-04-14 20:00:42.799075 +00:00', 'VNBANK9552633', '9552633', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5cdccb72-3cfb-4813-874f-a25f45edb446', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9446788', '2025-01-01 21:52:29.288517 +00:00', '2025-01-01 21:52:37.137420 +00:00', 'VNBANK9446788', '9446788', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('dda1b4d5-2db4-4b24-8780-da31866b89d6', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9395281', '2025-05-08 19:07:37.310825 +00:00', '2025-05-08 19:07:40.437361 +00:00', 'VNBANK9395281', '9395281', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bdcce407-534b-4676-8f67-a887e73e90de', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9243079', '2025-05-15 15:17:52.722665 +00:00', '2025-05-15 15:17:57.204033 +00:00', 'VNBANK9243079', '9243079', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f5301abb-82f9-4efe-b8e9-d9beb5bcbd99', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9818857', '2025-03-06 03:44:15.520294 +00:00', '2025-03-06 03:44:15.796616 +00:00', 'VNBANK9818857', '9818857', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('94b2d82d-518f-4095-969a-4bc53494f912', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9181923', '2025-04-11 12:58:24.297729 +00:00', '2025-04-11 12:58:31.381642 +00:00', 'VNBANK9181923', '9181923', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('89c862c2-d6fc-45ef-a6ad-9a6969dc05d4', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9235395', '2025-01-25 12:31:52.113883 +00:00', '2025-01-25 12:32:01.656640 +00:00', 'VNBANK9235395', '9235395', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('28e9cd80-bc71-4980-8e7d-c2c7c02149e1', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9682020', '2025-01-20 05:03:39.925244 +00:00', '2025-01-20 05:03:44.047920 +00:00', 'VNBANK9682020', '9682020', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2ce907b2-3a92-43df-b04d-195853a097c6', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9498917', '2025-02-28 09:33:14.991223 +00:00', '2025-02-28 09:33:20.843282 +00:00', 'VNBANK9498917', '9498917', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5940f356-1f06-4334-9e1c-7d2fc2162b35', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9395808', '2025-01-14 13:27:13.423979 +00:00', '2025-01-14 13:27:17.623077 +00:00', 'VNBANK9395808', '9395808', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7f423ed1-2ea4-45a9-bed0-206b3922b09a', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9134091', '2025-03-14 19:58:14.760021 +00:00', '2025-03-14 19:58:16.741545 +00:00', 'VNBANK9134091', '9134091', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3042f7cc-70f5-4bc0-a136-65755984bb1a', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9511886', '2025-02-24 05:35:23.079419 +00:00', '2025-02-24 05:35:26.309641 +00:00', 'VNBANK9511886', '9511886', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8e2c26af-40f0-4f91-ad72-d9db988a6372', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 200000, 'VND', 200000, 'VNBANK', '9250056', '2025-02-26 06:30:41.349107 +00:00', '2025-02-26 06:30:43.899975 +00:00', 'VNBANK9250056', '9250056', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b04c8058-9bf5-4b21-81db-f4281f43ee92', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9030519', '2025-05-30 13:34:02.089370 +00:00', '2025-05-30 13:34:11.339705 +00:00', 'VNBANK9030519', '9030519', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a9576346-9e42-4b35-bbb4-9d64602a58cd', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9093925', '2025-01-15 19:01:37.017910 +00:00', '2025-01-15 19:01:39.314381 +00:00', 'VNBANK9093925', '9093925', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1fce8743-7777-400c-b1c2-1d6762850647', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9250742', '2025-01-25 21:33:52.317344 +00:00', '2025-01-25 21:34:01.205452 +00:00', 'VNBANK9250742', '9250742', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4768712b-85e2-46ca-855e-9fdd43f663b5', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9101368', '2025-04-14 15:35:15.231137 +00:00', '2025-04-14 15:35:15.989816 +00:00', 'VNBANK9101368', '9101368', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1373409f-3eb3-46fe-bd9f-de907835e468', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9315287', '2025-02-18 19:37:46.079403 +00:00', '2025-02-18 19:37:54.317935 +00:00', 'VNBANK9315287', '9315287', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4ab437b9-2e0c-4fe9-86c2-5647e3f7d520', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9334826', '2025-05-05 23:48:38.053152 +00:00', '2025-05-05 23:48:41.590036 +00:00', 'VNBANK9334826', '9334826', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('099b3206-2f52-4bfc-955f-c6bbb0f9b253', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9797828', '2025-01-02 03:33:29.745222 +00:00', '2025-01-02 03:33:29.862687 +00:00', 'VNBANK9797828', '9797828', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4836b683-bf6c-4f7f-a65f-fa9bb8ed4498', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 200000, 'VND', 200000, 'VNBANK', '9371821', '2025-05-09 03:33:25.073110 +00:00', '2025-05-09 03:33:34.101515 +00:00', 'VNBANK9371821', '9371821', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7a749eea-f800-4006-b8c9-6758413ecee5', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9004019', '2025-02-08 09:20:53.411889 +00:00', '2025-02-08 09:21:01.226268 +00:00', 'VNBANK9004019', '9004019', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('40a96c35-75e7-4a96-bc41-91e4f5e6d48b', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 200000, 'VND', 200000, 'VNBANK', '9557155', '2025-04-16 23:19:08.903902 +00:00', '2025-04-16 23:19:17.567194 +00:00', 'VNBANK9557155', '9557155', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('419e91a2-1935-4d9c-8609-f4f1f371c5a8', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9009002', '2025-05-21 14:13:38.473460 +00:00', '2025-05-21 14:13:44.618066 +00:00', 'VNBANK9009002', '9009002', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b34a032f-a174-43ff-9944-0c1613e4cb8e', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9371995', '2025-01-27 17:54:39.893675 +00:00', '2025-01-27 17:54:47.695763 +00:00', 'VNBANK9371995', '9371995', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('70de39c3-75d5-4fb5-ad63-4a7a6f0edc85', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9986081', '2025-05-13 10:17:45.259601 +00:00', '2025-05-13 10:17:51.984423 +00:00', 'VNBANK9986081', '9986081', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1cc20c79-1e8e-44f9-b334-ac96e1902ce3', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9646316', '2025-02-04 12:59:51.829611 +00:00', '2025-02-04 12:59:52.057508 +00:00', 'VNBANK9646316', '9646316', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('23c86950-bec5-4818-ac2f-d31330799c05', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9152073', '2025-03-04 17:03:33.590745 +00:00', '2025-03-04 17:03:39.306890 +00:00', 'VNBANK9152073', '9152073', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ec6bfdd7-99a7-4aee-a398-e561334ab931', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9560568', '2025-02-11 05:14:01.859945 +00:00', '2025-02-11 05:14:10.061544 +00:00', 'VNBANK9560568', '9560568', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a36e7826-dc1c-495b-81cf-dddd19612c63', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9819245', '2025-02-17 21:52:15.231627 +00:00', '2025-02-17 21:52:20.444209 +00:00', 'VNBANK9819245', '9819245', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3fd185a0-554e-49d5-a7ec-a50f5e26fa82', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9246913', '2025-01-02 12:43:23.620962 +00:00', '2025-01-02 12:43:25.556350 +00:00', 'VNBANK9246913', '9246913', 'Thanh toan cho khoa hoc: TAOCP 2', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('17ba34a6-bb50-4062-b4eb-a30fe0f80db9', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9515739', '2025-04-22 17:42:56.505651 +00:00', '2025-04-22 17:43:03.420990 +00:00', 'VNBANK9515739', '9515739', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('db2d639d-1392-4b64-9aa4-656b0155c14f', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9738968', '2025-01-13 00:38:49.870405 +00:00', '2025-01-13 00:38:52.081592 +00:00', 'VNBANK9738968', '9738968', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0f234b7e-cd29-4b32-b21e-695bb742df00', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9400895', '2025-03-12 05:19:14.166868 +00:00', '2025-03-12 05:19:22.872979 +00:00', 'VNBANK9400895', '9400895', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bc89db32-7f76-4120-82c7-cdf16a64c895', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9283587', '2025-01-07 22:36:57.651430 +00:00', '2025-01-07 22:36:59.618748 +00:00', 'VNBANK9283587', '9283587', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a0d0fabd-82f5-4e5a-9426-1bc7ae296d1c', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 300000, 'VND', 300000, 'VNBANK', '9420191', '2025-05-04 14:33:06.957164 +00:00', '2025-05-04 14:33:09.070720 +00:00', 'VNBANK9420191', '9420191', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b9cca4a0-23e5-4fae-abd6-8e92a6d21698', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9422275', '2025-04-26 17:46:53.305231 +00:00', '2025-04-26 17:47:02.678671 +00:00', 'VNBANK9422275', '9422275', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('95dd954f-c132-46b2-a709-f41c51cce97d', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9311673', '2025-04-22 23:05:14.471318 +00:00', '2025-04-22 23:05:17.285524 +00:00', 'VNBANK9311673', '9311673', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fc8133ee-5e98-4607-bd94-e35e0d3e0ee4', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9268749', '2025-02-23 22:26:45.397741 +00:00', '2025-02-23 22:26:46.292112 +00:00', 'VNBANK9268749', '9268749', 'Thanh toan cho khoa hoc: DSA Masterclass', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2bc92b9c-3b90-4b45-8be4-b6bdfc3c3d4f', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9981315', '2025-03-09 05:27:23.451419 +00:00', '2025-03-09 05:27:30.985012 +00:00', 'VNBANK9981315', '9981315', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3b06a6b7-bad6-4369-845d-fd71c9c9bc10', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 400000, 'VND', 400000, 'VNBANK', '9912773', '2025-05-01 20:31:29.123041 +00:00', '2025-05-01 20:31:36.285386 +00:00', 'VNBANK9912773', '9912773', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9c9f11f6-808f-4d72-a27a-8d9a7e6680ae', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9322191', '2025-01-07 06:55:07.241803 +00:00', '2025-01-07 06:55:11.354173 +00:00', 'VNBANK9322191', '9322191', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('35249462-ac28-43f8-bc9a-d4d83d01c391', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9309247', '2025-03-22 08:47:41.741261 +00:00', '2025-03-22 08:47:48.689293 +00:00', 'VNBANK9309247', '9309247', 'Thanh toan cho khoa hoc: Introduction to DSA II: Recursion & Algorithmic Thinking', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('efa94235-3247-4708-87fb-9230fc2ab931', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 300000, 'VND', 300000, 'VNBANK', '9386987', '2025-05-16 12:37:53.514460 +00:00', '2025-05-16 12:37:57.889582 +00:00', 'VNBANK9386987', '9386987', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('aadce037-9438-4d4c-9683-68c7c9f6e631', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9727486', '2025-04-26 19:55:45.382124 +00:00', '2025-04-26 19:55:47.630543 +00:00', 'VNBANK9727486', '9727486', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ae32711a-7d7a-4cd7-ba37-01a98ae34db4', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9309239', '2025-03-26 14:53:22.575931 +00:00', '2025-03-26 14:53:27.982639 +00:00', 'VNBANK9309239', '9309239', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('577b7524-03cb-43c2-b8c4-e2723e243e54', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9161325', '2025-05-22 02:08:00.253681 +00:00', '2025-05-22 02:08:10.071976 +00:00', 'VNBANK9161325', '9161325', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('45c2fd5c-1448-4d69-b9c1-893b678f7286', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 200000, 'VND', 200000, 'VNBANK', '9816498', '2025-01-29 20:26:58.347854 +00:00', '2025-01-29 20:27:03.639006 +00:00', 'VNBANK9816498', '9816498', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a417b631-74fa-4f16-93a5-53f6165f1b1e', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9204810', '2025-03-28 15:28:26.869856 +00:00', '2025-03-28 15:28:30.566283 +00:00', 'VNBANK9204810', '9204810', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fdd21a41-948a-432d-8ca9-5c249b5e6fb7', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9990240', '2025-05-30 05:20:27.185624 +00:00', '2025-05-30 05:20:31.765273 +00:00', 'VNBANK9990240', '9990240', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f68f71e2-036c-4a54-9a39-d9255f1de64c', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9903971', '2025-05-05 10:30:48.860827 +00:00', '2025-05-05 10:30:54.438257 +00:00', 'VNBANK9903971', '9903971', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('05c7c91d-43ee-4a11-8896-1e39df529986', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9795485', '2025-03-10 06:45:07.654648 +00:00', '2025-03-10 06:45:14.238246 +00:00', 'VNBANK9795485', '9795485', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b96493c1-f185-4fbf-8219-87cfd2fe2927', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 400000, 'VND', 400000, 'VNBANK', '9919307', '2025-02-16 15:05:34.459618 +00:00', '2025-02-16 15:05:36.859730 +00:00', 'VNBANK9919307', '9919307', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('67d0b02e-76e4-41e1-a6fe-3a284bdc0586', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9581297', '2025-05-06 21:45:00.234426 +00:00', '2025-05-06 21:45:08.866271 +00:00', 'VNBANK9581297', '9581297', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('413f0ac1-7cb9-4b87-8b5c-0fd9f205e98b', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9022449', '2025-05-05 23:00:16.515801 +00:00', '2025-05-05 23:00:18.112617 +00:00', 'VNBANK9022449', '9022449', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('829b988d-7843-4ea9-8975-3dd18d015070', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 300000, 'VND', 300000, 'VNBANK', '9928560', '2025-04-13 04:31:36.959097 +00:00', '2025-04-13 04:31:43.859748 +00:00', 'VNBANK9928560', '9928560', 'Thanh toan cho khoa hoc: TAOCP 4', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1ffcfc41-41a9-4ce7-bd76-cac061ebf71e', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9547033', '2025-02-08 23:38:05.168649 +00:00', '2025-02-08 23:38:10.643421 +00:00', 'VNBANK9547033', '9547033', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('70cad1d1-afa7-41a7-b8b5-5ff1b7fb46d8', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9233463', '2025-04-10 22:16:30.792610 +00:00', '2025-04-10 22:16:38.500877 +00:00', 'VNBANK9233463', '9233463', 'Thanh toan cho khoa hoc: Guide on Graph Algorithms', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5b41b4a3-7da1-402e-8e00-386fa69864da', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9477681', '2025-04-30 21:02:08.884470 +00:00', '2025-04-30 21:02:12.164336 +00:00', 'VNBANK9477681', '9477681', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b2119bc7-6b34-495b-b368-ea7d52360955', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9385927', '2025-04-25 19:34:25.651615 +00:00', '2025-04-25 19:34:30.036048 +00:00', 'VNBANK9385927', '9385927', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b3837ba9-3ffb-439f-b189-d622b609b6cb', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9349112', '2025-04-20 18:28:05.368965 +00:00', '2025-04-20 18:28:06.899189 +00:00', 'VNBANK9349112', '9349112', 'Thanh toan cho khoa hoc: Dynamic Programming Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('04281eaf-472a-443c-a9e1-2f5e93dc3d6d', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9073525', '2025-01-13 15:16:19.944923 +00:00', '2025-01-13 15:16:26.311713 +00:00', 'VNBANK9073525', '9073525', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ce6d3ecf-383a-4ff3-ad56-842f9f11bc56', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9759370', '2025-02-16 05:30:56.604113 +00:00', '2025-02-16 05:31:02.214739 +00:00', 'VNBANK9759370', '9759370', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('86f52c72-f34a-48da-96b2-fa01f1d2490d', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 200000, 'VND', 200000, 'VNBANK', '9153816', '2025-04-18 09:20:25.399773 +00:00', '2025-04-18 09:20:28.800782 +00:00', 'VNBANK9153816', '9153816', 'Thanh toan cho khoa hoc: TAOCP 3', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bf4774ab-0401-4596-b131-050ac7c0f6a5', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 500000, 'VND', 500000, 'VNBANK', '9978860', '2025-05-23 12:32:24.022110 +00:00', '2025-05-23 12:32:28.984432 +00:00', 'VNBANK9978860', '9978860', 'Thanh toan cho khoa hoc: TAOCP 6', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('721be235-d816-4953-a6ea-c8398137a4da', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9132413', '2025-04-27 20:12:50.989758 +00:00', '2025-04-27 20:12:55.761437 +00:00', 'VNBANK9132413', '9132413', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('98cd279e-a7d7-4232-807c-ff760da3cbd2', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9831667', '2025-02-28 01:24:30.145599 +00:00', '2025-02-28 01:24:34.452367 +00:00', 'VNBANK9831667', '9831667', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a62d7134-84d1-4e2d-ad79-64d3cfc3ffe5', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9714340', '2025-01-29 07:57:01.670106 +00:00', '2025-01-29 07:57:06.423380 +00:00', 'VNBANK9714340', '9714340', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d999d402-d420-45e1-90ff-a46ea90cedc0', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 1000000, 'VND', 1000000, 'VNBANK', '9221073', '2025-04-20 16:58:47.971630 +00:00', '2025-04-20 16:58:53.889233 +00:00', 'VNBANK9221073', '9221073', 'Thanh toan cho khoa hoc: TAOCP 7', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('278d694e-c54c-45ec-a29b-a1da84fbbefe', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9253291', '2025-02-26 23:53:53.593651 +00:00', '2025-02-26 23:53:55.817244 +00:00', 'VNBANK9253291', '9253291', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('263bd7a7-9b7e-4c16-b652-79fc9b847d14', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9680342', '2025-03-09 14:13:44.168935 +00:00', '2025-03-09 14:13:44.321094 +00:00', 'VNBANK9680342', '9680342', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('61aee4d3-75aa-4248-8e58-44b8700343aa', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9045944', '2025-06-01 05:26:03.610578 +00:00', '2025-06-01 05:26:11.194554 +00:00', 'VNBANK9045944', '9045944', 'Thanh toan cho khoa hoc: TAOCP 1', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d834b152-20ab-47e9-bf0a-a5c7706443a7', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9301398', '2025-02-08 09:45:45.911341 +00:00', '2025-02-08 09:45:55.111449 +00:00', 'VNBANK9301398', '9301398', 'Thanh toan cho khoa hoc: Matrix Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9aa4aadc-2be2-46fa-b0e6-e15f6439b9d2', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 50000, 'VND', 50000, 'VNBANK', '9633138', '2025-04-17 22:16:49.652228 +00:00', '2025-04-17 22:16:49.692570 +00:00', 'VNBANK9633138', '9633138', 'Thanh toan cho khoa hoc: Linked List Data Structure Guide', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4117cc89-1e4c-4d48-b0f7-01f1af388089', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 100000, 'VND', 100000, 'VNBANK', '9692282', '2025-02-25 23:20:57.994247 +00:00', '2025-02-25 23:20:59.726391 +00:00', 'VNBANK9692282', '9692282', 'Thanh toan cho khoa hoc: The Logic Building Problems', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e5ba8e99-da40-484b-b01c-37e5fd57a592', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 400000, 'VND', 400000, 'VNBANK', '9959679', '2025-04-30 05:43:15.860256 +00:00', '2025-04-30 05:43:25.804515 +00:00', 'VNBANK9959679', '9959679', 'Thanh toan cho khoa hoc: TAOCP 5', 'Course', null);
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5030b802-5922-49b5-932c-cfc1741ef961', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '576176', '2023-12-19 16:40:00.633442 +00:00', '2023-12-19 16:40:01.209813 +00:00', 'VNBANK576176', '576176', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'bde8d447-0c68-4a59-93ec-5a7b19d5e27a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('cbc3b20f-c1c1-467b-bf89-f322101667d6', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '112141', '2024-11-20 01:22:36.937752 +00:00', '2024-11-20 01:22:37.664539 +00:00', 'VNBANK112141', '112141', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b08662bd-3679-4293-bd7f-e9b2822fb071');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9956e2b1-7b69-44e2-8c81-4cd391d2a9f9', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '645512', '2023-11-11 22:45:41.834947 +00:00', '2023-11-11 22:45:48.373217 +00:00', 'VNBANK645512', '645512', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '02be5367-e0f2-44f3-8440-fd0b0237d929');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c9636132-811c-43f4-a1c0-9f98c573e5db', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 499000, 'VND', 499000, 'VNBANK', '32872', '2025-01-19 17:34:17.608336 +00:00', '2025-01-19 17:34:27.308430 +00:00', 'VNBANK32872', '32872', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ad7fb94b-7f87-4f78-8d3b-ec8c5836209b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c4466cc2-1ee0-41ff-a6f3-95cb62783864', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '533466', '2022-11-21 01:20:29.051105 +00:00', '2022-11-21 01:20:37.226700 +00:00', 'VNBANK533466', '533466', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ef63b599-41be-4a4b-b8a2-6e29bb8652d8');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bb2a3a24-8579-4b32-ae73-a8d98d061da7', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '380369', '2025-01-24 17:18:16.502081 +00:00', '2025-01-24 17:18:17.620034 +00:00', 'VNBANK380369', '380369', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3b99090f-4ae0-4ac3-9563-2185952b9f7f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('79cf4cde-8e6a-4c48-ac2c-55416b99a1e4', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '653292', '2022-03-25 05:23:42.565752 +00:00', '2022-03-25 05:23:51.929706 +00:00', 'VNBANK653292', '653292', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f77ef026-ddb4-4e36-bca9-16878995682c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f541183c-ad83-43f3-8afb-de30d8ae78b3', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '138737', '2023-02-24 18:02:28.345449 +00:00', '2023-02-24 18:02:36.602601 +00:00', 'VNBANK138737', '138737', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'd4140fcc-6944-45fa-9795-2373f44ea6bc');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e83f3014-79b2-4881-ac0c-67c141052c48', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '582375', '2023-11-27 12:23:06.366011 +00:00', '2023-11-27 12:23:12.317544 +00:00', 'VNBANK582375', '582375', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '974c8926-1b48-4e08-ac17-3de35a0f3a37');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('844faa54-2c66-47ed-aa3b-b3c8fe35bc8e', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '95891', '2023-10-16 02:24:32.248360 +00:00', '2023-10-16 02:24:37.225828 +00:00', 'VNBANK95891', '95891', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'df43e6b3-f869-4efb-a767-b06f8ddad006');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2d7984ae-1e3b-4df1-b750-1aed003fdec8', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 499000, 'VND', 499000, 'VNBANK', '756654', '2022-05-26 10:59:07.500830 +00:00', '2022-05-26 10:59:12.755295 +00:00', 'VNBANK756654', '756654', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7c0f4122-6aec-46e4-8bf6-c739ca80ea28');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2f26fdeb-b683-4dc2-9e7e-7b7a3f1bd06a', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '480998', '2025-04-29 22:00:34.669836 +00:00', '2025-04-29 22:00:34.854417 +00:00', 'VNBANK480998', '480998', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e04a0f09-0015-40ca-be7b-11c958e7cb35');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e2624e89-8ebc-42b1-9436-723958f28bd8', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '870602', '2022-06-24 11:53:35.858584 +00:00', '2022-06-24 11:53:43.479362 +00:00', 'VNBANK870602', '870602', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '18c874d6-1ae3-4013-a158-a362cb37ac2a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f8a6b4e0-e055-40ea-b191-af2abcb7e26c', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '556876', '2024-09-05 05:53:24.214609 +00:00', '2024-09-05 05:53:24.384590 +00:00', 'VNBANK556876', '556876', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c5c395a8-6663-426b-bf22-3eb198a4dbfb');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('daead872-8aeb-48cd-a931-664449186aa0', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '62876', '2024-01-12 03:19:34.410381 +00:00', '2024-01-12 03:19:40.867902 +00:00', 'VNBANK62876', '62876', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e37c714c-0c04-496f-9429-dffd6474f237');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('84960e94-ff4c-45aa-9505-67a9eaea9fcd', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '347557', '2023-11-06 10:35:53.362164 +00:00', '2023-11-06 10:35:55.665546 +00:00', 'VNBANK347557', '347557', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5a612126-da56-4b39-9f35-9ab8211c1396');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('716ea740-4275-4595-9ae9-ed78e73bdae4', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '131534', '2024-12-24 23:13:35.270783 +00:00', '2024-12-24 23:13:42.696644 +00:00', 'VNBANK131534', '131534', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f60ba290-ea93-485c-8805-457978ceb1dc');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8dd40219-b61e-4c99-9cc9-fd9af6bade29', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 499000, 'VND', 499000, 'VNBANK', '634066', '2023-04-01 19:17:13.294263 +00:00', '2023-04-01 19:17:17.508588 +00:00', 'VNBANK634066', '634066', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'cebd6e8d-16d0-418d-92e0-3c9825509dd1');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('87b8b8c6-545e-44e1-ab35-30440a3ad966', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '497401', '2025-04-30 09:42:27.230699 +00:00', '2025-04-30 09:42:28.990128 +00:00', 'VNBANK497401', '497401', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c23eba06-2e75-4c3f-b164-796f0f1e7ef5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3e3dcbe9-9caa-46e2-96c3-014831ac1a01', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '233979', '2022-02-01 07:40:14.896306 +00:00', '2022-02-01 07:40:22.471091 +00:00', 'VNBANK233979', '233979', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '23da0c64-522b-42a4-82e5-1cd204e87763');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ee284de4-aa56-40f2-95c7-6b794f965a6d', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '299818', '2022-01-13 03:52:30.295989 +00:00', '2022-01-13 03:52:33.110521 +00:00', 'VNBANK299818', '299818', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '51f47c1c-cc9c-4bb5-8164-708d14b86803');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3af4d793-53c0-4e65-9294-881a913be4f9', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '682257', '2022-11-06 14:02:10.263067 +00:00', '2022-11-06 14:02:13.844785 +00:00', 'VNBANK682257', '682257', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b253d00f-afa7-4c5d-8bc1-4575fa012454');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ee87dabc-f17c-4e5e-bb2a-93e4baf067bf', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '871635', '2024-04-06 18:39:35.928923 +00:00', '2024-04-06 18:39:39.748622 +00:00', 'VNBANK871635', '871635', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a7b28af8-27cb-4f48-93e5-d268140092b1');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('033f9e2f-4f2c-463e-b50b-3f49f40dd5dd', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 499000, 'VND', 499000, 'VNBANK', '404377', '2024-03-02 01:05:44.885316 +00:00', '2024-03-02 01:05:45.616959 +00:00', 'VNBANK404377', '404377', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '98098dd4-a3d3-4351-b582-ece2a76ca7c7');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b36a1b90-3f58-4a73-9828-26cda09c6984', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '881788', '2024-11-07 23:00:42.966913 +00:00', '2024-11-07 23:00:52.058104 +00:00', 'VNBANK881788', '881788', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8cac56b2-bd29-44b5-ad71-69fe8d27a793');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e13e4dc8-7d15-4ca9-b1a4-c3d117b96e27', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '239571', '2024-08-25 18:47:56.235980 +00:00', '2024-08-25 18:48:01.936266 +00:00', 'VNBANK239571', '239571', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b123937a-773d-4022-a0e7-9215bfbb3d1f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('db4c8467-6e60-4bb3-bfa3-09d8242a9253', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '496617', '2023-05-30 12:06:35.948559 +00:00', '2023-05-30 12:06:38.144877 +00:00', 'VNBANK496617', '496617', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'cefdf80b-d97a-441b-bb95-d638e0fd94cb');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c7371c28-4453-483a-8647-8b0e9778086a', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '187663', '2023-10-18 14:07:52.097196 +00:00', '2023-10-18 14:07:52.293578 +00:00', 'VNBANK187663', '187663', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c82cb064-510a-401e-be55-5c39eec18c49');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5abbda34-54e3-407b-ad4b-b4f59dd98f7b', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 499000, 'VND', 499000, 'VNBANK', '731931', '2024-05-03 14:28:06.136309 +00:00', '2024-05-03 14:28:11.264916 +00:00', 'VNBANK731931', '731931', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7c5231b7-9a07-4417-9d3a-f5867c02ffe6');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('84878a74-b97e-4c98-aee8-eab4869ac19d', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '333926', '2025-01-18 23:25:43.576376 +00:00', '2025-01-18 23:25:48.819502 +00:00', 'VNBANK333926', '333926', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'cca0ab32-79a2-4fc8-827a-a018e6d0e282');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('6f32721e-b4b3-40d6-b4a5-f8a90ac4f32a', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '754423', '2023-05-13 18:32:33.609091 +00:00', '2023-05-13 18:32:33.860402 +00:00', 'VNBANK754423', '754423', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2d7320f5-33b0-4ebb-9751-34d4eb03959a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8e2ea2a0-97c8-405b-8241-0c585f136c35', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '295982', '2023-05-14 21:07:44.371281 +00:00', '2023-05-14 21:07:47.124054 +00:00', 'VNBANK295982', '295982', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '007cf383-7933-4735-8a33-5dfff20af854');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ee920226-15c0-4f03-b610-d788b5850a9d', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '515418', '2023-03-08 20:01:19.343493 +00:00', '2023-03-08 20:01:24.185022 +00:00', 'VNBANK515418', '515418', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7ccb2485-a679-4f53-be1e-c8f56b3e316e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0fa8de04-0148-482d-97df-a308ddc77bfd', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '271405', '2023-10-05 14:27:46.659658 +00:00', '2023-10-05 14:27:48.139937 +00:00', 'VNBANK271405', '271405', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '58bb4f62-b69c-4493-a101-96d0935d58ff');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d82fd258-27ef-4aa5-a108-bea8ea1a0777', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '278091', '2021-07-16 22:49:18.661285 +00:00', '2021-07-16 22:49:27.144497 +00:00', 'VNBANK278091', '278091', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '347d0248-daac-4bdf-bcef-bfbb8931fb8d');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9acc189d-c72f-440c-8ebb-b0af233edf70', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '722026', '2021-10-19 23:09:33.620392 +00:00', '2021-10-19 23:09:36.869200 +00:00', 'VNBANK722026', '722026', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3c3a6d5b-39fe-4f4b-8f99-83951003ad58');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('df094fa9-5a3c-450f-a502-7387730d1108', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '60537', '2025-03-07 23:14:25.509587 +00:00', '2025-03-07 23:14:25.782412 +00:00', 'VNBANK60537', '60537', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2284a352-f058-42c9-862a-1e0b9df266ef');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('58378a23-003a-4a5c-b201-f58e9bf3d640', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '677183', '2022-11-10 02:45:44.261321 +00:00', '2022-11-10 02:45:48.126327 +00:00', 'VNBANK677183', '677183', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '9e4d4b06-0921-428d-8e8c-23fbe29f1f7e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4f9dc0f1-e704-408a-acc1-e73c3739dc07', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '885525', '2023-11-30 10:32:52.894346 +00:00', '2023-11-30 10:32:54.684665 +00:00', 'VNBANK885525', '885525', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '217cdbe6-8821-41d9-b0e2-ab4519f35fdf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9e40a49e-5894-4d51-9342-30c4c0efe7d8', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 499000, 'VND', 499000, 'VNBANK', '792468', '2025-01-06 22:36:48.821669 +00:00', '2025-01-06 22:36:56.761142 +00:00', 'VNBANK792468', '792468', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5888d4c4-d550-422f-824a-b3f9e6cff614');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('cb06857d-d7ba-440e-9923-bedbc36048dd', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 499000, 'VND', 499000, 'VNBANK', '329733', '2023-08-21 20:42:04.178716 +00:00', '2023-08-21 20:42:13.641123 +00:00', 'VNBANK329733', '329733', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '382ac517-e011-4d2f-bfc3-55dc9ee53b5c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('127978e7-6a20-4318-953a-d821bca65b11', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '189650', '2020-06-09 11:02:13.447448 +00:00', '2020-06-09 11:02:16.866590 +00:00', 'VNBANK189650', '189650', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0f0b89d3-c22a-41aa-be3a-250961296e2c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('eefb78a9-e280-4dbc-a4f7-2f0e278c2ac1', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '295670', '2022-03-22 03:06:33.021403 +00:00', '2022-03-22 03:06:42.052153 +00:00', 'VNBANK295670', '295670', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e268ea5a-198e-4a5a-b3b9-ffd05e2bbe68');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('95e220e2-bb97-44a3-9c13-92fabf1c0adb', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '82551', '2023-11-18 22:27:05.598615 +00:00', '2023-11-18 22:27:09.784174 +00:00', 'VNBANK82551', '82551', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b3e2f5be-ff98-42ed-9b2b-d2c70aa7149e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('296bbe88-d29a-4ca5-846f-266edda6239a', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '239978', '2024-04-02 10:55:22.174013 +00:00', '2024-04-02 10:55:27.037421 +00:00', 'VNBANK239978', '239978', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'db092ea1-f45a-41e2-9cfd-31fb1cd5b6ec');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b575aa4b-3bc6-4c05-974c-68205fa3e6cb', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '723371', '2022-12-02 13:34:13.002221 +00:00', '2022-12-02 13:34:21.067871 +00:00', 'VNBANK723371', '723371', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1a73aa79-efd8-4c97-b0e1-6e607f0984d3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('55367e1c-c994-43b8-bc70-626b90f4d421', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '328055', '2022-01-30 12:38:48.805993 +00:00', '2022-01-30 12:38:52.713803 +00:00', 'VNBANK328055', '328055', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'aaeee951-d7ab-4115-93a8-fc70d228ed09');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a17564b0-b01f-460e-a89d-e7647a8686ba', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '448506', '2023-08-13 13:45:49.602043 +00:00', '2023-08-13 13:45:56.165428 +00:00', 'VNBANK448506', '448506', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7ba2d762-67e8-4aec-8dd6-b249443703ef');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fa766ced-4b3b-4282-aff5-a4aa58adf332', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '263482', '2023-04-10 19:07:54.886473 +00:00', '2023-04-10 19:07:57.972845 +00:00', 'VNBANK263482', '263482', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '979a41b2-b01b-4f97-80cf-3b6db70cbfe6');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1fe49b45-fe43-4d21-9b4e-38c086d95978', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 499000, 'VND', 499000, 'VNBANK', '156683', '2023-03-23 01:40:21.505054 +00:00', '2023-03-23 01:40:26.539614 +00:00', 'VNBANK156683', '156683', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '61f1df1b-3b26-4e87-aca2-a764d9db111b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e56948ca-1e14-4ac3-aa88-90c87fb8cef4', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '859465', '2018-09-08 07:18:55.878488 +00:00', '2018-09-08 07:19:05.815745 +00:00', 'VNBANK859465', '859465', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '225e14ca-5565-45b4-8777-4a2d24ac5439');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c66b7ba6-021c-49b8-bbd8-069b485c3354', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '914952', '2022-02-15 09:04:12.202792 +00:00', '2022-02-15 09:04:20.126477 +00:00', 'VNBANK914952', '914952', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '02929696-d64c-49ea-b0bd-eba61e02e091');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c1a7227e-2788-4e25-82fd-77f3d88162ea', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 499000, 'VND', 499000, 'VNBANK', '887728', '2025-03-01 07:01:44.254141 +00:00', '2025-03-01 07:01:52.330983 +00:00', 'VNBANK887728', '887728', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7558cb49-6d27-45b3-a903-91aa787bfbe7');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1f6c8aba-6b3c-4c86-bc2e-0ce02bd15528', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '364996', '2021-09-17 01:29:26.320165 +00:00', '2021-09-17 01:29:28.865657 +00:00', 'VNBANK364996', '364996', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '4f69b079-cb7b-4cc7-8976-eabcab8ca49e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ddfdae94-c9b9-48a7-b6a8-a7d6a4245210', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 499000, 'VND', 499000, 'VNBANK', '540312', '2022-05-17 22:51:00.347993 +00:00', '2022-05-17 22:51:03.586217 +00:00', 'VNBANK540312', '540312', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0e243efb-3a6a-4d57-99c9-3febf79937b5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('46da8090-0ba9-441f-9e37-a9d02146a875', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '805952', '2023-03-05 20:25:21.149054 +00:00', '2023-03-05 20:25:26.646741 +00:00', 'VNBANK805952', '805952', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'acd62b95-959d-4b02-93cb-b19569e40316');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('926f7153-57e1-4b9f-8306-9a62ddffaf6d', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '608128', '2024-06-07 07:34:22.697908 +00:00', '2024-06-07 07:34:28.506293 +00:00', 'VNBANK608128', '608128', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '4f0468ff-efe0-4b14-8569-199a13ba6e51');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c3e72691-c6a7-4828-8684-905f4ccf6b23', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '370804', '2020-07-09 16:52:54.794020 +00:00', '2020-07-09 16:53:01.795729 +00:00', 'VNBANK370804', '370804', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '68e386e2-38c8-40df-bf67-9b2acda75552');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fc0b2c6a-f0c2-4cf1-ad99-8724824b5e53', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '315863', '2023-12-06 04:26:35.290272 +00:00', '2023-12-06 04:26:38.263813 +00:00', 'VNBANK315863', '315863', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c9b17867-12b6-4b66-b85d-fe7fdb5385e1');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8e69fb04-4a95-499a-a0d1-e18f32bb5dd4', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 499000, 'VND', 499000, 'VNBANK', '469037', '2023-10-08 04:16:35.961262 +00:00', '2023-10-08 04:16:41.716612 +00:00', 'VNBANK469037', '469037', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ff84f6ee-1498-4e17-b8f2-18c2c9bb1b92');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9d072413-f173-47c5-a1a2-e956b480486a', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '578746', '2023-01-16 12:18:22.717273 +00:00', '2023-01-16 12:18:28.970633 +00:00', 'VNBANK578746', '578746', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7fdddbbc-8ebb-4f8a-950a-76834377e95d');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3dda4f11-2b29-4595-9893-063c4742c6ee', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '548269', '2023-10-03 21:27:23.276582 +00:00', '2023-10-03 21:27:30.622718 +00:00', 'VNBANK548269', '548269', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'fd281b47-a71a-4f4b-ac9b-f58be4624f36');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b854bffb-76f8-4db2-bef6-1458851617b4', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '600642', '2024-02-16 04:26:58.586550 +00:00', '2024-02-16 04:27:01.282341 +00:00', 'VNBANK600642', '600642', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '49d6cba4-d2e8-41fe-b0bd-7a44569d6eca');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c683fe47-6cf8-41ff-be4c-7801c21e90ae', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '489552', '2022-04-27 13:25:03.053713 +00:00', '2022-04-27 13:25:10.653170 +00:00', 'VNBANK489552', '489552', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '03537af8-dca4-4028-a0b4-be6dba0f3dfb');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('54d239e2-ea4c-4abe-a16d-42b7b336f522', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 499000, 'VND', 499000, 'VNBANK', '192247', '2022-09-15 23:04:14.210228 +00:00', '2022-09-15 23:04:23.843773 +00:00', 'VNBANK192247', '192247', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '585d08f7-2da0-49ff-8fbe-dd7fc730b073');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b2e07c4d-925a-4755-9a93-06b028ca537e', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 499000, 'VND', 499000, 'VNBANK', '133932', '2022-02-01 23:27:49.277692 +00:00', '2022-02-01 23:27:53.058768 +00:00', 'VNBANK133932', '133932', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b1972d00-5a7c-4d8d-9dbc-7d9771026b43');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('00b83dc7-801c-40a9-aec6-c43ed68447c0', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '241267', '2019-05-06 09:10:16.791052 +00:00', '2019-05-06 09:10:26.191277 +00:00', 'VNBANK241267', '241267', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ca4fd193-519f-49f3-9e0e-024d22a06b41');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8c2162eb-3ab0-4795-bf0c-4cb89db41528', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '825046', '2022-09-28 00:48:00.596729 +00:00', '2022-09-28 00:48:06.811806 +00:00', 'VNBANK825046', '825046', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0663abfa-961e-41b5-9da0-1540e0554e23');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a9d2d88d-0b3b-4c71-87a0-90d70e8a9eef', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '677140', '2022-04-25 00:02:36.341539 +00:00', '2022-04-25 00:02:43.878361 +00:00', 'VNBANK677140', '677140', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'd269fe47-4329-48eb-b4db-51596edf6663');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e70d409f-b9a4-4899-9cee-bc2506e06e72', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '772758', '2022-08-19 11:34:34.932560 +00:00', '2022-08-19 11:34:39.802150 +00:00', 'VNBANK772758', '772758', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'cddc10af-6c18-4999-942c-d1f67872c2da');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('365ffdfd-ef68-4f15-b860-558e39f366c7', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '569938', '2023-04-06 13:03:24.171214 +00:00', '2023-04-06 13:03:29.598875 +00:00', 'VNBANK569938', '569938', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ce80e6e0-924b-4df9-bfab-685add35616f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('566b306c-4eca-4d52-a01b-5bafb92ca956', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '278065', '2021-07-26 00:09:46.846498 +00:00', '2021-07-26 00:09:47.802241 +00:00', 'VNBANK278065', '278065', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5ef995ca-e197-4060-bc94-ccd5580731e2');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('551fda0d-879e-4640-a811-8cb5ad3b6d3e', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 499000, 'VND', 499000, 'VNBANK', '634605', '2024-12-07 12:35:57.738458 +00:00', '2024-12-07 12:35:57.944635 +00:00', 'VNBANK634605', '634605', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1f98e6ee-369b-493e-88a4-d571178ee207');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b1ea9942-18a8-403a-a835-77200ae27721', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 499000, 'VND', 499000, 'VNBANK', '662575', '2023-04-05 10:59:30.586577 +00:00', '2023-04-05 10:59:31.705395 +00:00', 'VNBANK662575', '662575', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1638dbd8-32e9-47c3-b161-524889bc97cf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ddb41b64-e24f-42e5-82fe-9e3e1192c272', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '981850', '2022-03-04 04:05:59.872457 +00:00', '2022-03-04 04:06:08.926307 +00:00', 'VNBANK981850', '981850', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '752eabcc-f98d-412b-8c3f-752c8e3e0b8a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5e68af80-c0bc-4adf-911a-3225400ead28', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '83959', '2025-05-23 05:12:44.076373 +00:00', '2025-05-23 05:12:50.093663 +00:00', 'VNBANK83959', '83959', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f48b40cb-9b62-4516-b3a5-763fc06e43e3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c1e3cb2c-cc7f-400f-a1cc-ef989d5c328c', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '245966', '2020-04-30 23:04:03.339911 +00:00', '2020-04-30 23:04:10.916824 +00:00', 'VNBANK245966', '245966', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '73bdbc85-b920-4da6-bf04-769b71c55e7a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ece5ca56-8cac-411f-b0d2-45f82e32ac16', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '848904', '2020-04-04 19:09:27.561996 +00:00', '2020-04-04 19:09:34.132743 +00:00', 'VNBANK848904', '848904', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '925833d3-7de3-4b68-b373-d86f6cb709a2');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3550d52e-6a4c-421d-9be5-c6ac0b9480e7', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 499000, 'VND', 499000, 'VNBANK', '788343', '2023-06-25 17:49:46.099663 +00:00', '2023-06-25 17:49:54.292114 +00:00', 'VNBANK788343', '788343', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5df3f764-6a6a-4a63-b6d9-91052dd575ac');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('72b233bc-88d2-4371-b3d7-ab2869f7872e', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '477363', '2025-02-03 07:35:27.974266 +00:00', '2025-02-03 07:35:28.496041 +00:00', 'VNBANK477363', '477363', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7e4d59ab-6d0e-4a57-97c9-4298613d9e2a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('18f1613b-8692-407b-b239-bc2c29410c37', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '605545', '2021-12-30 01:50:59.078135 +00:00', '2021-12-30 01:50:59.226437 +00:00', 'VNBANK605545', '605545', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '55cad6ee-c3c0-490b-83a5-a064beb32eda');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4e7d24da-f3fa-4753-825b-110ca69d770b', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '832395', '2023-11-12 19:25:18.571276 +00:00', '2023-11-12 19:25:28.080593 +00:00', 'VNBANK832395', '832395', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '11df7442-c4fa-4fa1-acc1-6e4ab337a4d7');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ea00f3e1-b59e-40e2-8234-c5e400e1ce11', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '426049', '2024-11-22 06:34:12.387630 +00:00', '2024-11-22 06:34:17.055478 +00:00', 'VNBANK426049', '426049', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7a05efaa-3e51-43ac-822f-44525979cfe8');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('92d52903-d654-468b-9b44-c140cd71e47a', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '637019', '2021-02-15 10:14:04.411537 +00:00', '2021-02-15 10:14:12.159420 +00:00', 'VNBANK637019', '637019', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c983e5bd-2e45-49d9-96d0-d96129a74fe1');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f3583cf9-b72f-4b53-96e0-ae5cc3ef18c2', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '778330', '2018-07-26 18:30:39.327793 +00:00', '2018-07-26 18:30:45.959336 +00:00', 'VNBANK778330', '778330', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7a95c666-1e42-432d-808c-112eab3bdfb2');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a546022b-7575-4fdf-a463-b6e68fdb5bc7', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '989487', '2022-06-10 23:51:34.071126 +00:00', '2022-06-10 23:51:39.307634 +00:00', 'VNBANK989487', '989487', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5f13f61e-d685-4fc5-bb78-ddd1d433bb5a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('10f7c019-3d44-48ef-90d8-7cc15e3d888f', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '9367', '2022-09-15 08:06:51.532451 +00:00', '2022-09-15 08:06:54.165353 +00:00', 'VNBANK9367', '9367', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '89a95fd4-613c-4ad8-bdb1-6cffbc41b3ac');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a6012817-ca9a-436c-8f09-ace0e61d61b5', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '936667', '2022-07-04 09:37:04.561407 +00:00', '2022-07-04 09:37:07.486746 +00:00', 'VNBANK936667', '936667', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5fc2e207-65e9-4d16-bc31-1d4910e9fd9f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f19a1d0e-a10d-4206-b72e-d3d38c075006', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 499000, 'VND', 499000, 'VNBANK', '879847', '2022-01-02 10:01:22.169451 +00:00', '2022-01-02 10:01:24.757351 +00:00', 'VNBANK879847', '879847', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8bdf420d-ca9b-4044-b255-a4169b9f02be');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d5a147cc-1904-4fa2-aa97-c32db7fa40a9', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '50431', '2025-03-09 08:43:25.498152 +00:00', '2025-03-09 08:43:28.987922 +00:00', 'VNBANK50431', '50431', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1e48fe15-1355-4624-871a-483c45ef5fa9');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f922b52b-3c74-4ec8-a4c3-a80b7e307dd2', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 499000, 'VND', 499000, 'VNBANK', '341196', '2023-02-13 10:43:50.450459 +00:00', '2023-02-13 10:43:52.421555 +00:00', 'VNBANK341196', '341196', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5c53155c-3024-483d-ae1a-bf2ec2e601cf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bed541b0-f861-4daf-81ef-8b9034498973', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '603131', '2020-06-28 10:52:08.617793 +00:00', '2020-06-28 10:52:17.836632 +00:00', 'VNBANK603131', '603131', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2b70abda-101e-4b85-b2b1-e7270a004c24');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('02b2d1e6-705f-4bbe-b242-e0be17838f91', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 499000, 'VND', 499000, 'VNBANK', '213098', '2022-01-28 21:19:21.047916 +00:00', '2022-01-28 21:19:22.722708 +00:00', 'VNBANK213098', '213098', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '4009932a-8a78-4d88-954d-101ccb542195');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('17361e0f-7158-4a3a-a21d-25307291042d', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '192067', '2023-09-23 20:29:07.842594 +00:00', '2023-09-23 20:29:10.911298 +00:00', 'VNBANK192067', '192067', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1474da91-ffb8-44cc-a068-c89122fdd6e2');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('feb96c19-6700-4f9c-a463-25320293618a', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '197747', '2023-08-18 12:11:02.971853 +00:00', '2023-08-18 12:11:08.112984 +00:00', 'VNBANK197747', '197747', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8dc15335-74eb-43a8-96aa-52882ce16765');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('92496a22-f982-4d94-ae84-0aba556be038', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '111102', '2024-10-28 03:38:58.054485 +00:00', '2024-10-28 03:39:05.597931 +00:00', 'VNBANK111102', '111102', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '01016226-fa43-45e4-86fd-67245c212be7');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c155ca56-e25e-4f44-a7ca-54dfe7c0bf53', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '717615', '2018-01-06 04:15:49.081299 +00:00', '2018-01-06 04:15:55.154223 +00:00', 'VNBANK717615', '717615', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f6ecdf0b-d738-4f2a-b275-013a6e43ab5e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('cb6ac311-f44d-4342-87e8-bd5ff59a927f', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '590033', '2022-01-16 10:31:32.840117 +00:00', '2022-01-16 10:31:38.907424 +00:00', 'VNBANK590033', '590033', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c2d281bf-1433-4add-a68a-918d242a7ac9');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4a5180e2-1511-4c40-a4fe-72e23a01d5b7', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '99025', '2023-09-10 15:31:29.582734 +00:00', '2023-09-10 15:31:30.222450 +00:00', 'VNBANK99025', '99025', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5e863605-a5f8-4a8f-b41f-22ca63c0b9d0');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ffee5f9c-39a6-4ce3-9c04-6df1f25562aa', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '343956', '2022-05-05 19:57:55.921194 +00:00', '2022-05-05 19:58:05.007836 +00:00', 'VNBANK343956', '343956', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5b59ca24-838a-4783-b0b4-5eb8438001c9');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ed02ded4-502c-4e3a-bdf6-5c75a4ef9068', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '75035', '2021-05-05 21:42:58.012615 +00:00', '2021-05-05 21:42:58.799629 +00:00', 'VNBANK75035', '75035', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0072030b-a06d-49da-8840-7a5ac6985951');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('00a8c615-4037-48f8-bd60-aa6a2c2176cd', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '495888', '2021-11-26 19:42:58.435186 +00:00', '2021-11-26 19:43:01.548079 +00:00', 'VNBANK495888', '495888', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2489c505-9685-4b7f-bd8d-0c080a8154a2');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4af672c7-f9fe-44f6-a1d2-05bc70c3ce14', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '254352', '2020-12-28 18:37:43.798183 +00:00', '2020-12-28 18:37:50.510869 +00:00', 'VNBANK254352', '254352', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c8cfae06-5f56-401c-8799-c0b4bee4a1e3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bd801c29-1ab2-42a4-b1cb-db35b25f73ed', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '982432', '2016-05-03 19:10:10.888910 +00:00', '2016-05-03 19:10:18.757147 +00:00', 'VNBANK982432', '982432', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b3d554e3-9038-4fc9-b511-dc85608e34d2');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0b6767b1-63b5-422c-aa1b-d231623c0fda', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '144897', '2024-06-18 03:04:04.963305 +00:00', '2024-06-18 03:04:07.107167 +00:00', 'VNBANK144897', '144897', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '093c7ab1-0088-4e8f-9d22-91aa1fc4d8aa');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('aeca2a7a-0633-4f34-9566-f3071c4c60cf', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '766231', '2022-03-27 15:22:34.224784 +00:00', '2022-03-27 15:22:41.352713 +00:00', 'VNBANK766231', '766231', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ecfd51e2-27f4-4e56-90b1-382ef9516c7e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('6446edba-1f8c-43c4-bbb6-9900da74730b', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 499000, 'VND', 499000, 'VNBANK', '940936', '2021-12-05 01:01:22.852821 +00:00', '2021-12-05 01:01:23.536539 +00:00', 'VNBANK940936', '940936', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3d3220bc-382f-492a-8490-796e7b8ae91c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('78e0cddd-6460-467b-8a3b-5c6f722f1cfd', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '226114', '2017-01-15 06:28:49.941677 +00:00', '2017-01-15 06:28:59.201815 +00:00', 'VNBANK226114', '226114', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'edacda70-9dbb-4a5e-82f7-a9a08bd9fc77');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('71286de3-6ed6-4583-8959-4514baf1f4ff', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '161181', '2022-07-20 01:27:10.526231 +00:00', '2022-07-20 01:27:16.657657 +00:00', 'VNBANK161181', '161181', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '9f2d35bc-29e2-4bc8-aa93-3fd7585752d5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('77613c26-5c8e-4e7b-8739-ff5f89b34eb3', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '954556', '2023-08-12 06:25:15.150502 +00:00', '2023-08-12 06:25:21.726827 +00:00', 'VNBANK954556', '954556', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '52e7f9ea-2bd0-46ab-90b1-b8e3aa0d62c1');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b4fddf79-f711-4097-8b6b-666701ecc52b', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '42314', '2021-10-06 04:38:46.879228 +00:00', '2021-10-06 04:38:46.883587 +00:00', 'VNBANK42314', '42314', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '23978ebc-ba19-4223-be61-65bb9413f678');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('72677fe1-8334-4df1-a6ad-b04de0eb6df8', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '875960', '2021-06-07 09:01:15.684010 +00:00', '2021-06-07 09:01:21.839486 +00:00', 'VNBANK875960', '875960', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'fd2b342c-1b40-4fb7-b35d-b6519b9b018e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c6480a39-92b4-487d-bc2c-49d50bbe8a67', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '453655', '2020-04-06 07:22:14.103288 +00:00', '2020-04-06 07:22:18.187439 +00:00', 'VNBANK453655', '453655', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ad7e98ff-ee1a-4c22-b61e-02d8c6daa4af');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4ed68de1-647c-4d94-9d3c-d4ca9db7a365', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '265411', '2019-10-20 18:05:07.682851 +00:00', '2019-10-20 18:05:10.670383 +00:00', 'VNBANK265411', '265411', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0130ddad-b9c4-473c-9d6b-971f5d04071c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9db5d47e-d87f-45f1-8399-32a612c72786', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '89516', '2023-07-14 23:23:29.704937 +00:00', '2023-07-14 23:23:30.160353 +00:00', 'VNBANK89516', '89516', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e7c29a43-95fe-4bf7-b0de-20cc5c5b5011');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('da35835d-01fa-46fa-a233-350b624b8f23', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 499000, 'VND', 499000, 'VNBANK', '107874', '2022-01-11 04:56:40.006670 +00:00', '2022-01-11 04:56:42.112131 +00:00', 'VNBANK107874', '107874', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f78ce997-95b2-4d68-9fdb-ec023ff77a07');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c9b65583-fc44-4525-9c23-552cc4a62434', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '750473', '2025-03-13 08:18:49.689980 +00:00', '2025-03-13 08:18:52.059890 +00:00', 'VNBANK750473', '750473', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0540c79b-bdcf-4a3c-941a-2e85c2be3e20');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f0dca201-08a8-4b92-9124-9f7601207249', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '301813', '2021-05-06 03:21:08.461064 +00:00', '2021-05-06 03:21:11.991115 +00:00', 'VNBANK301813', '301813', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2db0ef52-8b93-4760-8eba-4dbf12bb0740');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a58cf2a7-2d79-41e5-b860-a36957c3a66a', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '543798', '2015-12-05 08:49:18.268313 +00:00', '2015-12-05 08:49:22.487355 +00:00', 'VNBANK543798', '543798', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'dfc0c732-ed3a-4c5e-aba6-eb8e4eedfedf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4332ef4b-8a74-431c-bff8-52316b91bf26', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '896900', '2020-09-21 17:37:56.879394 +00:00', '2020-09-21 17:37:57.010493 +00:00', 'VNBANK896900', '896900', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '9b5e3a52-aaa8-4e97-a1b7-ef753f299bd6');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e0680b36-35df-4715-bfb8-cdf9c5d9f046', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '598253', '2023-01-23 09:40:19.997013 +00:00', '2023-01-23 09:40:20.169181 +00:00', 'VNBANK598253', '598253', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'aa9ba243-b21b-4325-9eb5-b150e6084c17');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1078085c-8c06-4aa7-b86d-cf47764fc2f8', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 499000, 'VND', 499000, 'VNBANK', '207890', '2022-03-22 17:24:53.831570 +00:00', '2022-03-22 17:24:59.044427 +00:00', 'VNBANK207890', '207890', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '24e58827-b09c-4b38-8968-0737089b933a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f51bd111-1431-49d8-85a6-f7db2df42665', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '54757', '2024-06-28 09:30:08.085022 +00:00', '2024-06-28 09:30:14.816175 +00:00', 'VNBANK54757', '54757', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '24400360-c59e-4b99-9b81-adaf3d2102fb');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('96aec315-dfa8-4abd-b7a7-551e677a1d04', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '804133', '2022-06-17 14:33:14.764400 +00:00', '2022-06-17 14:33:21.557105 +00:00', 'VNBANK804133', '804133', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'cea53ed6-3416-4481-890b-4c90b29afd99');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('40f016cd-62d5-47c5-8455-81708699015e', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '107682', '2023-06-20 01:38:10.758405 +00:00', '2023-06-20 01:38:11.213759 +00:00', 'VNBANK107682', '107682', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '68344614-9e14-47e9-9997-78308653c4e4');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('521e9f8b-621b-4a86-8436-8b913915fe55', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 499000, 'VND', 499000, 'VNBANK', '952390', '2021-03-27 15:18:40.159556 +00:00', '2021-03-27 15:18:46.176003 +00:00', 'VNBANK952390', '952390', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '742505ca-2c58-4dea-9daa-400246f618cf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('848c04b0-485a-4712-b34b-097049beeaf0', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '398802', '2022-04-23 19:21:17.276101 +00:00', '2022-04-23 19:21:19.457382 +00:00', 'VNBANK398802', '398802', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c318323d-4cfa-49aa-8166-25fe324e265a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a11e4e48-14fb-4bf5-8f23-81c94bcf04ed', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '328001', '2023-10-09 13:58:23.273830 +00:00', '2023-10-09 13:58:31.539052 +00:00', 'VNBANK328001', '328001', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '72a00bb6-ecff-4a81-afd4-e2965834a5d5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('23abbc8c-52be-4ce4-b940-7c4abe417392', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 499000, 'VND', 499000, 'VNBANK', '4355', '2021-06-13 18:50:38.582606 +00:00', '2021-06-13 18:50:40.524160 +00:00', 'VNBANK4355', '4355', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2ec082a3-f184-446f-94d9-e2c9376e81ff');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('54caba9a-dd18-41d2-ba2b-16c274842abb', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '706716', '2019-12-16 12:23:37.567665 +00:00', '2019-12-16 12:23:38.190792 +00:00', 'VNBANK706716', '706716', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '634a5437-00af-427c-add2-e574f33436c6');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('20e8c797-9a6d-4596-b8c1-4df629d1980e', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '864170', '2022-02-05 03:22:40.516975 +00:00', '2022-02-05 03:22:43.253456 +00:00', 'VNBANK864170', '864170', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a73b4bdf-a6dc-4971-9b10-1fd0630fe4d6');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('358a2425-831d-4610-b8c4-5aff382a26d2', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '342774', '2023-11-23 15:23:51.023478 +00:00', '2023-11-23 15:23:53.171981 +00:00', 'VNBANK342774', '342774', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b1123680-a224-4c51-acf0-f4ae201398a5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8b27c487-11fe-4df2-aca9-3b4922bebb20', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '770459', '2018-12-26 06:44:41.357851 +00:00', '2018-12-26 06:44:47.446481 +00:00', 'VNBANK770459', '770459', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '963472bf-7500-4f77-9b9b-ec08dacca90c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ba03064f-85c6-4489-b11e-484400199157', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '929551', '2019-10-15 05:13:04.472032 +00:00', '2019-10-15 05:13:05.357213 +00:00', 'VNBANK929551', '929551', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '38ae5a08-f8a6-4a33-a4a0-965adea4c96c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d20895db-79ba-4225-95c1-ca92712d4609', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '695168', '2020-12-16 07:12:37.480690 +00:00', '2020-12-16 07:12:42.835573 +00:00', 'VNBANK695168', '695168', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'bbb3cc67-2b55-47c0-b276-a417e91dcd3b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('43852237-6c07-4d22-a20b-7180dfd161c5', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '94259', '2023-08-29 07:20:23.383746 +00:00', '2023-08-29 07:20:32.978866 +00:00', 'VNBANK94259', '94259', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '86c6062a-fbd7-4ec2-a6a9-2e5d99ef409a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('94c9d297-d444-41d6-8f7d-6af49034afc2', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '612525', '2021-03-24 12:28:58.978241 +00:00', '2021-03-24 12:28:59.826785 +00:00', 'VNBANK612525', '612525', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'aa74ab01-8c04-405d-ab44-c269187c1584');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d02523b5-09f5-444a-b9d1-64a5d565f873', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '697867', '2022-11-24 02:07:12.917591 +00:00', '2022-11-24 02:07:16.842283 +00:00', 'VNBANK697867', '697867', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a4df172a-129a-4844-8dba-46561b04230e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a47afebc-d14f-42ef-817f-bcfec95183c6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '924460', '2023-06-18 23:00:56.983331 +00:00', '2023-06-18 23:00:57.950018 +00:00', 'VNBANK924460', '924460', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b514a26a-ec5e-46a4-b2eb-7d896c154c30');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('19a56e46-b450-48ae-b591-86e7616c7468', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '13083', '2018-01-12 18:26:10.708228 +00:00', '2018-01-12 18:26:16.316953 +00:00', 'VNBANK13083', '13083', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '05995f19-6c68-478a-8277-becc4a65db0a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1c079f1f-65b5-4650-964a-b38519b6bf85', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '965091', '2019-03-28 02:23:31.019508 +00:00', '2019-03-28 02:23:40.709198 +00:00', 'VNBANK965091', '965091', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '10dd9eec-4afc-4c77-96e0-1164a68e2425');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fdc12878-db85-48ed-be3f-c38afe8e48fd', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '984463', '2024-01-05 09:08:17.625882 +00:00', '2024-01-05 09:08:23.486763 +00:00', 'VNBANK984463', '984463', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '102bf980-c84f-47f8-a552-2b36f4f968bf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a9c5edbf-6f53-463d-b9a3-6fea65892fe7', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '589761', '2019-03-07 02:32:29.646080 +00:00', '2019-03-07 02:32:38.108532 +00:00', 'VNBANK589761', '589761', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '6e83e099-801a-4575-a158-2a4c9501c1c5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3edc09e4-d384-45d8-aa84-75718e26e5d8', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '394342', '2023-07-24 18:38:21.708229 +00:00', '2023-07-24 18:38:27.327123 +00:00', 'VNBANK394342', '394342', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '003b409b-f23d-44c0-b028-651efef12744');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e96e4596-3d48-45db-bde9-53371fb6cb66', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '335899', '2023-06-18 15:50:56.460121 +00:00', '2023-06-18 15:51:04.685396 +00:00', 'VNBANK335899', '335899', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'd9f9cd9f-4b14-4eab-912f-881fe22a6102');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('92d348af-a90a-4e14-93f7-eadbd6e8eb1f', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '846464', '2020-10-01 07:08:54.387034 +00:00', '2020-10-01 07:09:04.141821 +00:00', 'VNBANK846464', '846464', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '266fb15f-f035-4e73-ba7c-121fc4bee226');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c6c146f9-cc0a-44d3-bbd4-770f563f82ff', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '777957', '2019-08-14 06:30:32.847110 +00:00', '2019-08-14 06:30:34.229681 +00:00', 'VNBANK777957', '777957', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0e8ec39b-bf27-4e9b-9ceb-6ad172320bcf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('306f9a53-1974-432d-aec2-6468900b1f56', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '30869', '2023-07-11 02:52:34.872386 +00:00', '2023-07-11 02:52:42.335453 +00:00', 'VNBANK30869', '30869', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7bebbd42-9f2f-4b9b-8eb9-fb5d765bd3aa');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0234638c-ad20-476c-9f3d-f8f8de9964c9', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '430561', '2017-10-28 13:12:14.466092 +00:00', '2017-10-28 13:12:22.168653 +00:00', 'VNBANK430561', '430561', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2fbc6475-e564-4d5d-a920-13cc2e1e41f6');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('27c098a1-dd07-49fc-aa5a-2af1b6a87d94', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '941738', '2019-01-25 05:41:57.494541 +00:00', '2019-01-25 05:42:01.655850 +00:00', 'VNBANK941738', '941738', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7d0d9446-0498-488e-86e9-585438866861');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9d24fe47-e759-49aa-8024-9d16a759f4a9', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '955946', '2022-03-10 06:05:19.038914 +00:00', '2022-03-10 06:05:20.989354 +00:00', 'VNBANK955946', '955946', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '982efff0-bed4-4648-8789-9c7c1ad89788');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('89e8eb5a-becd-4a1e-8845-bc86497c6797', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 499000, 'VND', 499000, 'VNBANK', '611632', '2023-05-03 07:18:52.809638 +00:00', '2023-05-03 07:18:58.208198 +00:00', 'VNBANK611632', '611632', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5ea628ac-5b77-4988-ae51-716368a096b7');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('65b4f740-c75e-4d48-a163-ec6fa321218f', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '772513', '2017-02-07 05:56:23.776978 +00:00', '2017-02-07 05:56:24.393067 +00:00', 'VNBANK772513', '772513', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0566bd9f-b5dc-4de3-aa48-d2ddb3c5de12');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8096e5e8-f99a-41fb-a9fb-550a071079f6', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '552678', '2020-09-07 01:40:39.145544 +00:00', '2020-09-07 01:40:41.329174 +00:00', 'VNBANK552678', '552678', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c99004ef-fd75-47a7-81a0-8ef1bfed1ad3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('64cf3147-1dbc-4b81-9a1b-41fb0f5dbc7f', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '875387', '2022-05-11 00:21:58.649137 +00:00', '2022-05-11 00:22:02.792753 +00:00', 'VNBANK875387', '875387', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a86b4f6e-5e6c-4a1f-a55b-d80bf66e12ad');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c15eaa28-e9e6-49ce-803c-c8e8ff22aced', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '135346', '2023-02-15 23:31:15.336596 +00:00', '2023-02-15 23:31:16.972750 +00:00', 'VNBANK135346', '135346', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ff77b15e-e86e-414a-8d2b-6c22365ebeb4');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1c2f5f4b-dd16-40cc-bcad-5446cbf18f71', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '700409', '2018-01-27 06:11:04.933361 +00:00', '2018-01-27 06:11:08.362799 +00:00', 'VNBANK700409', '700409', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '4abb5e01-b416-487c-bc48-72277dd7f2b5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('06bd401c-3b09-41a7-962b-0875e9ff12b7', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '880931', '2019-08-30 05:17:41.746114 +00:00', '2019-08-30 05:17:42.398628 +00:00', 'VNBANK880931', '880931', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '726b7f60-5567-45af-b949-b3902ade390d');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ccf57377-8685-469c-aed1-a71b0a50f0d7', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '372968', '2025-03-28 13:08:35.200003 +00:00', '2025-03-28 13:08:36.679719 +00:00', 'VNBANK372968', '372968', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ccea8ffe-c847-447d-b5b5-28d6216e5bcc');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8f330f5b-e9bc-4864-bca6-30375e22f0e0', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '559177', '2022-01-11 17:17:37.134619 +00:00', '2022-01-11 17:17:38.114775 +00:00', 'VNBANK559177', '559177', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0b3e3fd3-7819-42e8-a921-160cbe720a5b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7cf649d7-4d03-4332-b424-7b822a258fe6', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 499000, 'VND', 499000, 'VNBANK', '573003', '2022-08-10 10:34:34.143020 +00:00', '2022-08-10 10:34:35.227944 +00:00', 'VNBANK573003', '573003', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f2334928-136b-45f7-964e-4fa8e67b6523');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d1163489-c0cb-4350-a826-d1a9214e9db6', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '134358', '2017-03-15 03:57:50.768692 +00:00', '2017-03-15 03:57:55.838160 +00:00', 'VNBANK134358', '134358', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8a88d872-cf06-434e-a83f-7513014c76db');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e7a47fb5-b0ef-41a1-8bf0-27877f72f04b', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '669562', '2018-01-13 13:56:53.377558 +00:00', '2018-01-13 13:57:01.341374 +00:00', 'VNBANK669562', '669562', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0588e250-aba5-48ca-a4c7-74b9f49f4293');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('31c4fdf2-62af-4dd9-9a7e-fda274677658', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '985980', '2019-06-21 09:09:49.471083 +00:00', '2019-06-21 09:09:49.552936 +00:00', 'VNBANK985980', '985980', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '4859aa13-b94c-4201-95b2-fe76d8617817');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('db4b0f97-8bbf-49c5-a8a1-a22ef6489e9b', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '531305', '2024-09-23 11:21:03.690984 +00:00', '2024-09-23 11:21:06.400639 +00:00', 'VNBANK531305', '531305', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7573bb5f-b910-494e-a5df-387d75fa69fd');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0f7526f9-ea37-4b7b-878d-650d694d9060', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '926178', '2023-05-16 15:24:18.378721 +00:00', '2023-05-16 15:24:20.774971 +00:00', 'VNBANK926178', '926178', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1c52dfdd-93f8-494c-a0c3-1aa30050e61c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('58741383-24cb-4eed-a07c-a96ed395be6a', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '919514', '2017-11-22 06:39:02.660370 +00:00', '2017-11-22 06:39:08.917281 +00:00', 'VNBANK919514', '919514', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '874748aa-f855-468e-8556-cffb93008a35');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8cb56a4d-ce80-4597-a374-ed5c62b0f0f9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 499000, 'VND', 499000, 'VNBANK', '716295', '2024-07-13 00:07:52.510331 +00:00', '2024-07-13 00:07:58.122726 +00:00', 'VNBANK716295', '716295', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5653d2ca-8c3d-49c3-9790-e4ca42ff993b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('db626f57-18d2-4856-b545-4f7ef039c67f', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '784583', '2023-05-15 22:52:12.660445 +00:00', '2023-05-15 22:52:13.312526 +00:00', 'VNBANK784583', '784583', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '34ed4ad7-c6f1-4e9b-a8d6-61f3876bec1b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d84e59f2-8d7e-45e2-bd5b-d86c448b582f', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '992275', '2018-01-13 17:03:14.480566 +00:00', '2018-01-13 17:03:23.428459 +00:00', 'VNBANK992275', '992275', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '897ab98f-0f11-4a74-8f43-c4b1e35ad786');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a00bdbae-bfd4-4362-909f-9d6564243928', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 499000, 'VND', 499000, 'VNBANK', '180816', '2024-10-15 02:28:59.244203 +00:00', '2024-10-15 02:29:02.049307 +00:00', 'VNBANK180816', '180816', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3adae69e-276b-4c8d-972c-2a9cbe86ec17');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1dd36f00-262b-49ea-a732-cfb4b3505dba', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '761715', '2020-11-13 08:22:00.090637 +00:00', '2020-11-13 08:22:02.695550 +00:00', 'VNBANK761715', '761715', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ce4d2ea2-7546-4f8d-925e-a6010cd08953');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d76c02d2-168b-4048-b252-b41b20e82228', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '219805', '2021-11-19 18:08:45.728024 +00:00', '2021-11-19 18:08:51.922687 +00:00', 'VNBANK219805', '219805', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '05fdc2c8-618d-4ae0-808d-c3024bac8084');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c28d1980-6615-4a50-9e47-26aa25cbf78e', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 499000, 'VND', 499000, 'VNBANK', '587128', '2023-10-04 15:36:59.115429 +00:00', '2023-10-04 15:37:09.072238 +00:00', 'VNBANK587128', '587128', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '122c25b6-a08c-4a6f-b7c2-5c41f253d914');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5c4f1d0d-d6bf-4818-aac3-122cb305cb6b', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '696997', '2023-02-19 15:29:36.447922 +00:00', '2023-02-19 15:29:38.292790 +00:00', 'VNBANK696997', '696997', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '4998f313-468a-4098-89b5-1286d8fa04a9');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('afbe3fa1-b0ac-4d92-8885-1dbeff34067c', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '170849', '2016-10-28 20:59:31.450391 +00:00', '2016-10-28 20:59:36.118006 +00:00', 'VNBANK170849', '170849', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '562538ea-a87a-4741-b1ce-ac12ac7823ba');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ba8f57c3-875e-4709-90b7-86dd9adc2039', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '118200', '2023-09-30 07:02:06.823679 +00:00', '2023-09-30 07:02:09.363099 +00:00', 'VNBANK118200', '118200', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'd0ed3e42-b77e-4b6c-8653-0c6490baae23');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d86aa150-1c37-4539-b138-a2c7ec3d10be', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '493109', '2021-08-13 13:19:17.907115 +00:00', '2021-08-13 13:19:20.348852 +00:00', 'VNBANK493109', '493109', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'd57c5b5c-906d-487b-9cbd-be90c52c6fba');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8d5690b4-9fc2-4148-90ad-9eb03dd9f1c9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 499000, 'VND', 499000, 'VNBANK', '337049', '2022-06-12 01:59:09.454870 +00:00', '2022-06-12 01:59:17.890582 +00:00', 'VNBANK337049', '337049', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '6fb68fe1-2481-4924-84aa-c9c211ee26a9');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c21611ec-0e63-4a1f-89a2-071f19b77401', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '99908', '2021-02-10 19:37:39.485903 +00:00', '2021-02-10 19:37:40.905744 +00:00', 'VNBANK99908', '99908', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1f3647f5-b854-47fa-a2d8-6a02dc0cc64e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('cca32099-65ea-4564-be54-010416468948', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '173322', '2023-10-03 20:45:33.882616 +00:00', '2023-10-03 20:45:39.701713 +00:00', 'VNBANK173322', '173322', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e262ac24-644c-4e56-9ea7-e2fb9705fdc8');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0281f60f-fa73-485f-baf5-ba4138a5190c', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '899214', '2018-03-01 15:45:25.790937 +00:00', '2018-03-01 15:45:26.973224 +00:00', 'VNBANK899214', '899214', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '834b36d5-24df-4df7-b094-b84d74fad44b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('12518967-bb90-4a7c-a719-27f7703ab78d', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '768133', '2014-04-10 02:29:09.502086 +00:00', '2014-04-10 02:29:12.956556 +00:00', 'VNBANK768133', '768133', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b24ac7f7-1723-4063-ac3b-2973efcc607b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('873f0485-98ed-41dc-a441-5b062323c80b', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '508967', '2021-10-20 16:30:25.360034 +00:00', '2021-10-20 16:30:27.114887 +00:00', 'VNBANK508967', '508967', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '12752dcd-8faa-4bd0-923b-fdb7850e0961');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fc9fbacd-d141-4b3e-b2d8-ced04923e799', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '474232', '2021-12-19 06:53:10.869470 +00:00', '2021-12-19 06:53:19.622459 +00:00', 'VNBANK474232', '474232', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8dc48962-aa49-4929-af2a-853af31e793d');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('42c9366e-9401-482e-a44b-702b4dddd48c', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '959150', '2022-03-05 16:02:31.213914 +00:00', '2022-03-05 16:02:39.016085 +00:00', 'VNBANK959150', '959150', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '9d4aa75e-ee50-4c2f-9fd0-94e991e5d96f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('efdbf65b-0eef-401d-bc05-64bc993096eb', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '8992', '2018-06-02 03:09:45.637439 +00:00', '2018-06-02 03:09:46.907491 +00:00', 'VNBANK8992', '8992', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5b9ef4c1-469a-44c6-8a8b-9f8b79ba60d8');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('441e3b42-05aa-482f-baa7-e1cf4c2d5322', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '975488', '2016-06-21 12:13:05.806139 +00:00', '2016-06-21 12:13:07.399584 +00:00', 'VNBANK975488', '975488', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0fac4383-6a2a-487b-ba11-0c2af098d905');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ab8cdbd3-ce18-44ac-9297-67dc4742d678', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '345916', '2023-08-26 23:49:50.625046 +00:00', '2023-08-26 23:49:55.307794 +00:00', 'VNBANK345916', '345916', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '58cfada8-0e8e-4d65-914a-139ae2eecb0c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e69217d6-f0c9-40c0-bbcd-6734c56cc0a5', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 499000, 'VND', 499000, 'VNBANK', '512015', '2023-03-24 20:18:31.222003 +00:00', '2023-03-24 20:18:33.910592 +00:00', 'VNBANK512015', '512015', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '6a580811-6450-4020-b123-3ed475a4b4a2');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2b0a43c0-7606-489c-818a-92d444f37c8b', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '147238', '2016-12-17 08:43:26.869649 +00:00', '2016-12-17 08:43:35.531260 +00:00', 'VNBANK147238', '147238', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3776a7d5-4808-47bf-98d3-5267df33accf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('55845540-ec38-4a23-bb8d-f80b4c525741', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '789989', '2016-07-30 05:10:21.171338 +00:00', '2016-07-30 05:10:30.344473 +00:00', 'VNBANK789989', '789989', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '81b108d3-4b9a-4f80-a433-fea3c89d417a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7f5866c2-c380-4a4b-adad-4e41af3dbad2', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 499000, 'VND', 499000, 'VNBANK', '996996', '2024-01-21 11:05:38.353474 +00:00', '2024-01-21 11:05:45.760324 +00:00', 'VNBANK996996', '996996', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3bdc06c8-9388-4952-9d7f-36da5c193ca6');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('51f440d9-5ef2-4512-863c-8cbaa0326f1f', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '602883', '2017-04-01 05:45:42.261285 +00:00', '2017-04-01 05:45:43.252539 +00:00', 'VNBANK602883', '602883', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '99c12d6f-18bb-4101-9e6b-a6824a2cd593');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('51502f3b-0f4e-47b6-9aa7-b3ae1a713549', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '999160', '2025-04-23 08:13:48.033555 +00:00', '2025-04-23 08:13:50.349526 +00:00', 'VNBANK999160', '999160', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7f133609-1eb1-488a-8d86-a5be9bd2fd16');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a7a6eaf4-5f1c-42b6-ba61-74767d59a91a', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '476792', '2014-08-03 22:20:40.701782 +00:00', '2014-08-03 22:20:43.672723 +00:00', 'VNBANK476792', '476792', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '499deea7-1062-4910-a035-4db1b2d6d1f8');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('67e597c6-d170-4248-9284-1e701544eb2b', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '119961', '2024-12-23 10:14:51.698469 +00:00', '2024-12-23 10:14:58.952118 +00:00', 'VNBANK119961', '119961', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8e5772dd-8d9a-449a-bde4-be98343e36ff');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f8124e3f-256c-47b5-91a2-33bc5935f797', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '772271', '2016-06-11 00:20:14.463828 +00:00', '2016-06-11 00:20:23.958459 +00:00', 'VNBANK772271', '772271', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '91236253-4e17-4a86-9553-a1dc5e5b862a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bffa0bd6-defa-467d-8eb1-eb84f7ac7996', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '380220', '2023-07-16 18:40:05.629254 +00:00', '2023-07-16 18:40:10.157082 +00:00', 'VNBANK380220', '380220', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '95a0e835-b9e5-4e07-a7ec-261539841ffe');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('42eb15b5-8f76-4751-b398-5c4cc140cc37', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '208150', '2022-08-20 06:22:13.614502 +00:00', '2022-08-20 06:22:16.228686 +00:00', 'VNBANK208150', '208150', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1ffb72e0-52e3-4232-ace1-60de14c5396a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0e236c05-233d-4bc0-ad6d-4f0aea7dbfca', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '46790', '2013-03-22 15:19:06.018442 +00:00', '2013-03-22 15:19:15.325476 +00:00', 'VNBANK46790', '46790', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '73617945-9be0-48bd-ab39-e9f12f2fc126');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7a4ac20d-f87e-4509-bad6-74f0cc15fe3e', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '145142', '2022-07-11 13:55:49.458681 +00:00', '2022-07-11 13:55:53.277414 +00:00', 'VNBANK145142', '145142', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '9e380f3a-0f0e-4961-8140-da42efba27ad');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e43f84fb-f209-4c9d-bd0d-6c2e3cea91b1', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '670041', '2021-12-18 22:19:46.606857 +00:00', '2021-12-18 22:19:51.401240 +00:00', 'VNBANK670041', '670041', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '30b10a1e-d61e-4bdd-996b-b90bc3dffcd3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b794ddbe-b296-4131-b0bc-c897f4d78905', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '195455', '2015-11-25 20:04:15.339561 +00:00', '2015-11-25 20:04:19.028078 +00:00', 'VNBANK195455', '195455', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e65be18d-ad86-4c85-ab71-da88914ae324');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5491c890-313d-497b-a338-61d673987c3e', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '94681', '2021-09-23 06:49:36.693000 +00:00', '2021-09-23 06:49:39.723654 +00:00', 'VNBANK94681', '94681', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '53702b32-4e40-402d-b63d-d8738086cd38');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b84dc5e1-7d1f-47c5-bb22-3d90c15271a7', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '878169', '2023-11-06 15:59:49.610637 +00:00', '2023-11-06 15:59:56.274418 +00:00', 'VNBANK878169', '878169', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0163400b-dcb7-4c93-91d5-80478587ad6c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e3c13fb1-04b2-4eeb-9daa-e25e34931705', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 499000, 'VND', 499000, 'VNBANK', '532168', '2022-12-31 10:09:28.900030 +00:00', '2022-12-31 10:09:32.322181 +00:00', 'VNBANK532168', '532168', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '6bcd4c14-66c6-4303-a923-f379eff7aa79');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('6118a34a-9c19-4062-8d0f-d788f460329f', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 499000, 'VND', 499000, 'VNBANK', '276489', '2025-02-27 18:54:12.581778 +00:00', '2025-02-27 18:54:14.137160 +00:00', 'VNBANK276489', '276489', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8df1bedf-8a0d-415f-b04b-9bdb68379fcf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e54fde12-bcbf-415b-8b5c-63d608b33c40', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '628995', '2020-10-27 21:17:28.305500 +00:00', '2020-10-27 21:17:29.874141 +00:00', 'VNBANK628995', '628995', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3af24eb7-1ced-4949-adef-24fbdfcd2576');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('92fff132-72e6-407a-88e9-91e79ff4ddea', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '395034', '2014-11-07 16:04:00.530571 +00:00', '2014-11-07 16:04:09.195706 +00:00', 'VNBANK395034', '395034', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '96f7dd95-812b-4376-a736-bbab8793fc8c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4af4d6bb-3463-4047-bc3f-031002531ee6', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 499000, 'VND', 499000, 'VNBANK', '980548', '2023-08-29 14:11:40.512874 +00:00', '2023-08-29 14:11:44.396591 +00:00', 'VNBANK980548', '980548', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f1a979b6-a2c9-4886-8d01-1fdcbbe89b68');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1792c66e-d3f0-4e76-803c-e0d74fbfe145', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '84060', '2021-01-03 10:40:35.182578 +00:00', '2021-01-03 10:40:39.677595 +00:00', 'VNBANK84060', '84060', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'deb6678b-ac95-4965-81c7-7a8a86ca1d97');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('df009cad-7958-4661-8861-30e5d3c3ad74', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '193588', '2019-08-21 15:06:48.674668 +00:00', '2019-08-21 15:06:53.337192 +00:00', 'VNBANK193588', '193588', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '9e7cfb99-c06b-4494-aea4-bf55e3a2b723');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1f24e7b5-a6e9-4a39-90be-2dd07bc07287', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '281225', '2019-05-07 04:00:11.509247 +00:00', '2019-05-07 04:00:20.272892 +00:00', 'VNBANK281225', '281225', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'dddfe078-573c-4338-9ae9-d53d76060a2f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c54b4cf4-28c4-4c29-b305-2c9919837c52', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 499000, 'VND', 499000, 'VNBANK', '322759', '2021-12-24 16:20:25.937208 +00:00', '2021-12-24 16:20:33.179156 +00:00', 'VNBANK322759', '322759', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '45fe1eb3-c1f6-4e45-9a90-7367f1901e84');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('86232e85-a07c-446b-8edd-deaf4663d787', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 499000, 'VND', 499000, 'VNBANK', '327625', '2019-07-19 07:54:39.791774 +00:00', '2019-07-19 07:54:41.923360 +00:00', 'VNBANK327625', '327625', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b3d65186-83d2-45ab-899c-280b2a3339c3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5c1350d4-6483-4aa6-8301-e3baf8944985', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '471029', '2015-08-18 05:43:05.092404 +00:00', '2015-08-18 05:43:05.914462 +00:00', 'VNBANK471029', '471029', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '16115d61-494f-4203-b576-fb0098245729');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('210bc4db-861f-4065-a938-c49b62a06c84', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '852350', '2014-05-26 02:26:27.413946 +00:00', '2014-05-26 02:26:29.354429 +00:00', 'VNBANK852350', '852350', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '20ba2297-8825-483a-b744-94631a6b9803');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8ba66d6d-c1c1-4b9a-a8ec-3f60fa8fcd97', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 499000, 'VND', 499000, 'VNBANK', '608236', '2021-02-05 21:25:48.838249 +00:00', '2021-02-05 21:25:55.170733 +00:00', 'VNBANK608236', '608236', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'dc68db36-badc-4aba-9cb3-ee4a57a9499b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('6923f65c-61f2-4ba7-87b1-d4a8f3d930d8', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 499000, 'VND', 499000, 'VNBANK', '36480', '2025-01-23 05:46:27.691705 +00:00', '2025-01-23 05:46:28.502680 +00:00', 'VNBANK36480', '36480', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b1de8b6c-12e7-4c84-9866-84092c815a27');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('87bd2b2b-010f-43db-bfce-851145fed50a', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '594634', '2021-11-14 18:36:44.678425 +00:00', '2021-11-14 18:36:47.362761 +00:00', 'VNBANK594634', '594634', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e14d170d-05a9-41b7-8baa-359941d7cab9');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('c5b50c23-98e1-4310-a3a3-11a82960c936', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '552918', '2019-06-01 22:13:50.321313 +00:00', '2019-06-01 22:13:59.818593 +00:00', 'VNBANK552918', '552918', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c425266e-f502-4922-96a5-41be299f2f9a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7f34e2a4-7176-4d91-bfab-7b1d05e5d6cd', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '229447', '2013-07-17 02:59:32.835513 +00:00', '2013-07-17 02:59:39.520502 +00:00', 'VNBANK229447', '229447', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f2fc10f8-6e0b-4918-86aa-f77153e8612d');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b01d26e8-3c5f-4bb5-a7f0-b0a05d623231', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 499000, 'VND', 499000, 'VNBANK', '835737', '2023-08-20 11:13:36.519922 +00:00', '2023-08-20 11:13:42.612000 +00:00', 'VNBANK835737', '835737', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2033a723-d220-4d6d-a9ec-6f5bc74b6541');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e288bff4-eba7-4662-acd7-6a78cd7758e6', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '386022', '2019-06-24 08:47:54.787870 +00:00', '2019-06-24 08:48:03.285903 +00:00', 'VNBANK386022', '386022', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7b740328-0722-4ab3-970e-3631c8aa9b10');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1ca87bbd-ad0d-4106-99d8-b66f6309f4f1', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '357301', '2022-05-30 00:50:53.801264 +00:00', '2022-05-30 00:50:53.911737 +00:00', 'VNBANK357301', '357301', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '9bffd80d-7783-4ac3-b54a-e93b884372ff');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('48135390-d931-4ef9-a4db-2fa3a7d42cba', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '308675', '2017-11-19 09:13:59.063435 +00:00', '2017-11-19 09:14:08.112767 +00:00', 'VNBANK308675', '308675', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '233fb535-2921-4d38-81ed-61e396041d20');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2a12b7e6-e7a4-4921-a37a-52e8406c7ad2', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '855367', '2022-02-18 09:32:05.298729 +00:00', '2022-02-18 09:32:07.737403 +00:00', 'VNBANK855367', '855367', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c4850867-e50b-4ea3-ba5d-d0bccc3543f4');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('556f2f59-71c0-47db-ad12-3f97e916d716', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '476302', '2012-02-27 01:26:21.906157 +00:00', '2012-02-27 01:26:30.434837 +00:00', 'VNBANK476302', '476302', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '53f141b9-ad72-4fd0-b651-de5755104cbe');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('af5b8f8c-9c66-49dd-bb7e-f95cff5c52f3', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '500831', '2022-06-08 07:00:48.265182 +00:00', '2022-06-08 07:00:48.962711 +00:00', 'VNBANK500831', '500831', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a7a005f3-4fea-4eb8-a73b-02f561aea062');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('383dbe69-da51-467f-afa7-72ec987e72a4', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 499000, 'VND', 499000, 'VNBANK', '738714', '2023-07-04 09:37:58.992149 +00:00', '2023-07-04 09:38:02.471744 +00:00', 'VNBANK738714', '738714', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '4e2f7649-c3d5-49d6-8b25-aaf26d3011c3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b623a179-8acc-4878-b9af-45ebee8d99cd', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '450833', '2020-12-21 16:17:49.030222 +00:00', '2020-12-21 16:17:53.046598 +00:00', 'VNBANK450833', '450833', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '439bde64-f18b-48ce-97d3-eff3f794ebd2');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('142fb6ce-c6a7-4ff2-83d0-e93b5744c6bd', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '634052', '2022-04-28 15:26:58.723582 +00:00', '2022-04-28 15:26:59.275085 +00:00', 'VNBANK634052', '634052', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8a05d40d-87d1-4165-8bd0-557be788e162');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2db4fbb2-08e4-4b7c-935a-c7bc648d08c1', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '345332', '2017-02-04 06:31:20.344293 +00:00', '2017-02-04 06:31:23.700433 +00:00', 'VNBANK345332', '345332', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '759cd4ed-39cf-4cb9-a424-9a5b7789de62');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('78f105c2-e681-4c14-9650-c94bbcaa2b7f', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 499000, 'VND', 499000, 'VNBANK', '198513', '2023-12-19 07:08:51.759939 +00:00', '2023-12-19 07:09:01.589680 +00:00', 'VNBANK198513', '198513', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '18ea4ab1-27d2-4333-b4c5-5f018f966765');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2ccd6f84-2f87-4e5c-8d27-67ee8484df11', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 499000, 'VND', 499000, 'VNBANK', '90021', '2023-04-03 06:12:37.713798 +00:00', '2023-04-03 06:12:41.313780 +00:00', 'VNBANK90021', '90021', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e52018df-3e5c-4324-bfa7-b3ca0c8759c4');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0e87c07e-b15a-48bd-8862-26d1ed427624', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '671598', '2021-01-03 08:52:23.854346 +00:00', '2021-01-03 08:52:30.543194 +00:00', 'VNBANK671598', '671598', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7b06f85e-c110-4311-a44c-26e8bfd8fc96');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f35d8f0e-ea61-467d-9630-e837bdda708c', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '917715', '2015-03-31 07:19:38.600457 +00:00', '2015-03-31 07:19:43.492721 +00:00', 'VNBANK917715', '917715', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '103660b4-1f15-4778-9292-aed2204c4515');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fb45eef6-e7c0-4e92-96c8-a98c8d4f7d6b', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '138282', '2021-08-13 04:40:26.939511 +00:00', '2021-08-13 04:40:33.072609 +00:00', 'VNBANK138282', '138282', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'd9aa000c-8123-46b7-bfc7-74d54eb61250');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('28463e11-fa73-460b-af40-011a5e3f5e85', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 499000, 'VND', 499000, 'VNBANK', '152433', '2023-02-07 04:59:50.070130 +00:00', '2023-02-07 04:59:56.971253 +00:00', 'VNBANK152433', '152433', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0c83ace7-ec04-4de6-83ef-d45949a3c6b8');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e95ed44b-dd86-4822-b130-3f0bdf4648c8', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '32851', '2011-09-08 10:31:12.348449 +00:00', '2011-09-08 10:31:16.242383 +00:00', 'VNBANK32851', '32851', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '27c456d0-4292-46eb-baad-4db1a43c26d0');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('cf0a9e4a-1842-440c-b34c-c3abf583f6d5', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '104269', '2019-08-27 00:36:51.658565 +00:00', '2019-08-27 00:36:59.259118 +00:00', 'VNBANK104269', '104269', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3e1a6265-b942-4750-9e72-af86d3d67aaa');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2c6cd451-353b-42f9-9617-94f40c4af6bd', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '121697', '2023-06-11 00:39:15.765780 +00:00', '2023-06-11 00:39:24.811214 +00:00', 'VNBANK121697', '121697', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a5d718de-e651-41e4-b26e-96a1d8547c71');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('270c2b2a-a364-46ea-a6b9-a193bb2c628f', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '740032', '2020-08-13 06:27:32.739479 +00:00', '2020-08-13 06:27:36.093145 +00:00', 'VNBANK740032', '740032', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8621e496-f747-4006-950b-1bc238d97dcf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('389bfd99-d33e-403d-a074-7b261766d1c4', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '370825', '2018-10-27 18:21:57.572422 +00:00', '2018-10-27 18:21:58.191256 +00:00', 'VNBANK370825', '370825', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8479bdbb-53e1-4f97-9de8-3eaf35b676b7');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('13623ec6-9e9b-4170-801a-d20eead9c432', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '145397', '2015-03-05 04:32:06.934361 +00:00', '2015-03-05 04:32:13.320250 +00:00', 'VNBANK145397', '145397', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'efd0bbd9-97b0-40ee-aaec-a2b904554d2f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b18d5974-3fd1-4c6b-b55c-a07578ac75ad', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '834029', '2014-06-23 15:24:36.996004 +00:00', '2014-06-23 15:24:43.422738 +00:00', 'VNBANK834029', '834029', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7d1583ba-d837-4474-88cf-8efb4c070175');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('09b18133-2106-4a20-9aed-4a0e3895899a', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '585465', '2010-08-20 23:28:26.481865 +00:00', '2010-08-20 23:28:26.501971 +00:00', 'VNBANK585465', '585465', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '6628ce2d-bebe-49ed-a508-37f58cabe449');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('25c7e636-7aa6-4641-8a0d-71e4b7dedede', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 499000, 'VND', 499000, 'VNBANK', '556854', '2021-11-12 03:34:13.806271 +00:00', '2021-11-12 03:34:23.306722 +00:00', 'VNBANK556854', '556854', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '132b20ca-dee7-4dce-a3e6-368add04c270');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('15f79210-c089-4127-aa47-e3545e199730', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '437805', '2021-09-28 23:10:23.577036 +00:00', '2021-09-28 23:10:30.975797 +00:00', 'VNBANK437805', '437805', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '14a48304-5592-4c1d-9963-b5ec86b12cf9');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('367e72d3-6e42-4931-a1e1-d6396d03a00f', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '108943', '2017-02-23 02:27:22.727569 +00:00', '2017-02-23 02:27:29.333993 +00:00', 'VNBANK108943', '108943', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a0affa2d-8fcc-4a8b-8c9d-4dcd55974c7b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('cefedfe8-5ba0-4e61-a3db-0d0f36b59c9a', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 499000, 'VND', 499000, 'VNBANK', '309577', '2023-05-15 21:38:30.599477 +00:00', '2023-05-15 21:38:34.061995 +00:00', 'VNBANK309577', '309577', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'cf59ae97-8ea4-4a40-a06d-bd2f122dd786');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7e5fd23b-99c6-4c32-8648-03a9dda775da', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 499000, 'VND', 499000, 'VNBANK', '514742', '2022-07-24 20:15:10.996075 +00:00', '2022-07-24 20:15:16.757154 +00:00', 'VNBANK514742', '514742', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c018153c-a8be-4a1f-9e18-ff2866d69908');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1a073f3d-7ee5-4b2c-bcfb-26f793c9202b', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '838664', '2017-10-14 16:56:18.896692 +00:00', '2017-10-14 16:56:25.851205 +00:00', 'VNBANK838664', '838664', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '85f12d6f-5b46-4395-adb4-0d1b4816fcba');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d18b3600-1bb8-42b0-844e-cc69f8c53b27', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '676584', '2022-11-30 18:38:07.941501 +00:00', '2022-11-30 18:38:12.169724 +00:00', 'VNBANK676584', '676584', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7bc536f2-9c96-43d3-9f1e-4f34764c812b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('64b0e126-51d8-43f3-a7b4-2fb7227705ed', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '198576', '2009-07-15 23:55:21.048875 +00:00', '2009-07-15 23:55:29.687099 +00:00', 'VNBANK198576', '198576', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'd10584a3-27b4-4b75-b495-012742b6ebc1');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f89c547f-654a-4e15-b0e2-3f564761f250', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '168379', '2022-05-06 21:39:32.611195 +00:00', '2022-05-06 21:39:35.638805 +00:00', 'VNBANK168379', '168379', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '53f28a3a-ed8f-43ef-b350-c797e2ccb5fa');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a44f3551-1ab6-465d-804a-5f3202615c9d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '176609', '2021-06-27 03:16:46.619978 +00:00', '2021-06-27 03:16:53.108055 +00:00', 'VNBANK176609', '176609', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b20e5731-db6c-4575-bee3-5bfa77066767');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('17fd8011-62e8-45a4-a312-56cb870c8539', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '386571', '2020-10-22 22:18:56.869945 +00:00', '2020-10-22 22:19:01.113523 +00:00', 'VNBANK386571', '386571', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '93fdb7c3-c9ed-4f61-85ae-f81036d8d3f8');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('482f7ae9-f35e-4fae-9a17-a7dae95f01e0', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '178208', '2023-05-15 04:02:15.127311 +00:00', '2023-05-15 04:02:16.646650 +00:00', 'VNBANK178208', '178208', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3be0a888-570a-4bb2-97ea-8744a71189c7');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1980cdce-9a3a-427f-8f5a-34e5ede977a3', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '515382', '2020-11-18 00:18:20.488513 +00:00', '2020-11-18 00:18:24.564767 +00:00', 'VNBANK515382', '515382', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '27a03930-be9b-44a9-9851-cb0308f40700');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('cb869ab5-3c60-41b2-b516-87d7b224af18', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '531245', '2022-10-02 13:35:20.365184 +00:00', '2022-10-02 13:35:28.309206 +00:00', 'VNBANK531245', '531245', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '974caefc-7318-4953-8eea-b73a85a96dfa');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('36814305-00d1-4f39-82ac-046e905c03d8', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '724652', '2016-10-22 01:24:48.518035 +00:00', '2016-10-22 01:24:52.762076 +00:00', 'VNBANK724652', '724652', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '853ba5b1-6a34-4386-b379-0bad6b41adb3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('900923d0-f601-4de6-8def-c237bca8f421', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '726630', '2020-09-16 13:36:53.129994 +00:00', '2020-09-16 13:36:57.581763 +00:00', 'VNBANK726630', '726630', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '826f822a-c66d-4614-ab66-aba542286646');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ab7173a6-d303-48e8-9b1d-a87e319a2a25', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '302091', '2019-07-18 20:20:04.060357 +00:00', '2019-07-18 20:20:08.686127 +00:00', 'VNBANK302091', '302091', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2fed12c9-3fd1-48df-9417-c61be81ee122');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('263e14ab-981f-49cb-9800-70d334ba1c61', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '337019', '2015-04-24 15:17:15.151692 +00:00', '2015-04-24 15:17:19.536807 +00:00', 'VNBANK337019', '337019', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '19d81128-e243-47a5-b374-4bed4a3c384a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fc092dc9-fcd3-462f-8233-0c916e0d369b', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '478108', '2012-09-06 16:25:50.570546 +00:00', '2012-09-06 16:25:58.972656 +00:00', 'VNBANK478108', '478108', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1b4b8671-61f9-47a7-903d-df3072bcabc5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('31e51f82-729e-41c3-b117-dd10a00b6da4', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '218198', '2022-07-20 06:03:34.378907 +00:00', '2022-07-20 06:03:40.655989 +00:00', 'VNBANK218198', '218198', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '9c2bd2b4-b105-405c-b398-1683e1892cff');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('71aa35f4-cb36-4558-8443-0714bae0191a', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '978390', '2015-07-12 15:06:31.549509 +00:00', '2015-07-12 15:06:36.275714 +00:00', 'VNBANK978390', '978390', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c1f2326b-ba7b-4dca-868a-82f68f96ea70');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('71af6e03-c03b-4e8d-8380-cff549dacd6f', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '42568', '2022-01-29 15:43:08.160817 +00:00', '2022-01-29 15:43:09.613394 +00:00', 'VNBANK42568', '42568', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7a283265-38c5-4ee7-886f-c5affc8e99c7');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d4c5df94-5d78-4fa4-80ea-1d9035f04ec5', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 499000, 'VND', 499000, 'VNBANK', '71571', '2021-11-15 02:41:33.525016 +00:00', '2021-11-15 02:41:38.719269 +00:00', 'VNBANK71571', '71571', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5eadf577-cbb4-48be-87e1-3a431775a5ee');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5f9cb5a1-5d8d-4bba-b236-4f4ea14d5a5e', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '410928', '2019-07-03 04:51:36.855128 +00:00', '2019-07-03 04:51:42.076627 +00:00', 'VNBANK410928', '410928', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e98edb27-009b-4118-9601-0ee10efcf693');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d9edc131-8297-4ca5-b4d2-616945380bb1', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '107625', '2013-02-13 23:45:40.950077 +00:00', '2013-02-13 23:45:50.534805 +00:00', 'VNBANK107625', '107625', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c0721077-1503-49bf-aafc-dfc1763df5bb');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('53decbb0-9f13-4a17-8742-a784505e4b5b', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '311970', '2016-02-06 22:55:12.093462 +00:00', '2016-02-06 22:55:19.293584 +00:00', 'VNBANK311970', '311970', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'dbfe5b1f-c4c2-4078-8ea2-8ce791a325f0');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9566d2c9-1833-412d-a822-b6c4f8273e8c', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '721593', '2013-06-07 09:42:03.199408 +00:00', '2013-06-07 09:42:06.100089 +00:00', 'VNBANK721593', '721593', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7ee54fa4-8a58-4129-b644-1c071291c371');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d829a18a-a434-4eae-99e1-58656fc1fb80', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '767152', '2022-03-22 08:44:50.562383 +00:00', '2022-03-22 08:44:56.551166 +00:00', 'VNBANK767152', '767152', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '109f4e5d-11bf-4a86-ad1f-86386f4cce19');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('49ab2c37-d4af-4577-b9a7-b9e11ce2c4e0', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '288631', '2013-05-20 05:35:33.705485 +00:00', '2013-05-20 05:35:38.258646 +00:00', 'VNBANK288631', '288631', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ff5994e3-188b-4ae0-82e3-0425c5b79388');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ddc4d6e6-23b2-43aa-98b3-f02e61fc7975', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '127799', '2014-01-14 15:47:10.427154 +00:00', '2014-01-14 15:47:10.562717 +00:00', 'VNBANK127799', '127799', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '77bfe807-5949-4203-b481-515184c8c496');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e2491b50-626b-4554-9042-691d9a55a6c0', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '412164', '2021-05-21 21:18:25.150088 +00:00', '2021-05-21 21:18:32.092223 +00:00', 'VNBANK412164', '412164', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'd9e932e6-bdc3-44e5-9fdb-381934727f94');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('21ad487d-145d-4ce1-a717-baa606429b0d', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '264659', '2023-03-18 10:55:12.788609 +00:00', '2023-03-18 10:55:17.300338 +00:00', 'VNBANK264659', '264659', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '4e6922ef-376b-4667-b4be-202b428b6acc');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1e8ab8ac-5ab7-432f-b4e8-23c5e48ffd47', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 499000, 'VND', 499000, 'VNBANK', '772175', '2024-01-26 16:40:09.648798 +00:00', '2024-01-26 16:40:14.820312 +00:00', 'VNBANK772175', '772175', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '40757a91-9a99-4526-9bd3-c83eafde0e52');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f0d6be31-f4d0-45f7-ba3a-782f9d3f02f5', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '28622', '2017-06-24 04:31:53.405197 +00:00', '2017-06-24 04:32:02.684445 +00:00', 'VNBANK28622', '28622', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8b808016-bb83-4d1d-b933-7963c87d8b4d');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5385eafa-18a0-437f-973f-83c1d7a8ba19', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '177031', '2008-02-19 02:19:43.468592 +00:00', '2008-02-19 02:19:52.954616 +00:00', 'VNBANK177031', '177031', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'bd94b571-52f8-4824-aa6e-9ce8a40765c3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2e16385b-856a-45b8-9773-094ade87c598', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 499000, 'VND', 499000, 'VNBANK', '208126', '2020-05-02 12:38:05.556547 +00:00', '2020-05-02 12:38:13.805493 +00:00', 'VNBANK208126', '208126', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '291b33d3-6021-41e0-a7e6-2dc473fc7d06');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('7527d734-e311-4733-9e69-1d8ac5519024', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '346176', '2012-01-01 11:02:00.628673 +00:00', '2012-01-01 11:02:07.941343 +00:00', 'VNBANK346176', '346176', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e1948717-86c6-4ef4-bc36-3d611271d2e6');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('099f0717-be23-4eff-ac87-0b03b54dc397', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '503767', '2015-06-30 01:51:09.527798 +00:00', '2015-06-30 01:51:13.210206 +00:00', 'VNBANK503767', '503767', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0b183d5e-26cf-4214-bea5-062e9fe628d4');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9133cc31-12da-42a7-9bbf-99fbfc491902', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '255632', '2024-05-18 22:46:31.635480 +00:00', '2024-05-18 22:46:35.724777 +00:00', 'VNBANK255632', '255632', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '990eb8c1-ee18-418c-8bce-7708739cc85a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('6f24701e-67ac-4af9-9548-d5939c2a3ba6', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '65856', '2014-03-14 02:17:04.238175 +00:00', '2014-03-14 02:17:10.478012 +00:00', 'VNBANK65856', '65856', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '9a6a4589-0832-4b22-8daa-4b5530d70054');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fda65da4-7d3c-4fba-b787-e16e8c2a8fea', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '29463', '2021-08-16 14:11:38.433864 +00:00', '2021-08-16 14:11:46.641536 +00:00', 'VNBANK29463', '29463', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '781e6a82-bf01-4181-9b5f-1def5292f961');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('59be5595-3226-412e-a09a-89a9dbcefdb1', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '390783', '2012-11-22 17:25:30.460714 +00:00', '2012-11-22 17:25:34.850012 +00:00', 'VNBANK390783', '390783', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a50f305c-d382-43a3-a1fd-6de05a8d8f8d');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d92c8fc7-188b-487c-a9d4-6ca2f99446cd', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '100715', '2014-11-30 18:13:53.332293 +00:00', '2014-11-30 18:14:01.737671 +00:00', 'VNBANK100715', '100715', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '16d2ef32-bdb2-44e7-902c-50d89374cb3c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ed093879-486f-4911-94e6-2176a8d5e62c', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '469020', '2012-03-27 19:53:04.254122 +00:00', '2012-03-27 19:53:04.547363 +00:00', 'VNBANK469020', '469020', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '888c19d5-d8c4-4200-9f40-7628629c1a0e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('556981cd-a2ea-4e58-bec2-ce881935f7fb', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '602657', '2020-10-12 08:04:14.927845 +00:00', '2020-10-12 08:04:24.561788 +00:00', 'VNBANK602657', '602657', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '84a172d7-3e56-491f-8be3-b0d7ea09797e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('85e49d2f-6232-4fbf-be95-e5f716ae468c', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '963227', '2021-07-08 13:28:45.930409 +00:00', '2021-07-08 13:28:50.256071 +00:00', 'VNBANK963227', '963227', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b85c11b8-74a6-4dba-a479-6053035d38ce');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2d3d1aae-3e70-46d4-a93d-772cce8e4154', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 499000, 'VND', 499000, 'VNBANK', '972648', '2024-12-04 04:17:27.507825 +00:00', '2024-12-04 04:17:32.129431 +00:00', 'VNBANK972648', '972648', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '54a3893f-2735-47dd-a7ac-694820ea0cd8');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b6189ef4-c392-49e5-9564-d4c6718a4e89', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 499000, 'VND', 499000, 'VNBANK', '427869', '2024-08-16 10:47:13.589356 +00:00', '2024-08-16 10:47:18.424545 +00:00', 'VNBANK427869', '427869', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '771ecddd-6a3c-4329-87ab-becd269e3f14');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('154e8f5e-ec61-40c3-804e-68f67df3e6af', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '935752', '2021-12-22 20:03:44.757315 +00:00', '2021-12-22 20:03:46.674698 +00:00', 'VNBANK935752', '935752', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'dc12afe6-3c8b-4315-abb7-728b6a61b90e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d9b45386-d49f-4b87-b892-980e499442a6', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 499000, 'VND', 499000, 'VNBANK', '478622', '2018-04-26 02:22:12.605259 +00:00', '2018-04-26 02:22:20.318662 +00:00', 'VNBANK478622', '478622', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '61c9947b-50ee-46d6-96af-7ab4ee156f7c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f25873aa-005c-4145-a684-4fc08e60679d', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 499000, 'VND', 499000, 'VNBANK', '722687', '2021-09-22 09:00:53.287210 +00:00', '2021-09-22 09:00:58.775302 +00:00', 'VNBANK722687', '722687', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3b8f5f1a-c906-4a8b-8609-73e90d92fdf0');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0a96d494-ef29-4cac-8cb5-35aebd6eeb6c', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 499000, 'VND', 499000, 'VNBANK', '219316', '2021-10-22 04:38:47.389505 +00:00', '2021-10-22 04:38:50.839702 +00:00', 'VNBANK219316', '219316', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e4601154-6e84-4aa3-b86e-cac16fd7d52e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1f0bf578-1cf7-48b7-a24a-cfba5e52e77f', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'b70339e8-2c3b-1a70-5d18-52ed64ae4dc2', '00', '00', 499000, 'VND', 499000, 'VNBANK', '135884', '2021-09-21 22:11:24.686378 +00:00', '2021-09-21 22:11:31.153728 +00:00', 'VNBANK135884', '135884', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e9880157-5a9a-4a34-89d7-02d8179b0558');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('709a3642-7618-442b-a3fb-19163dc1e564', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '357798', '2010-10-14 13:28:20.907882 +00:00', '2010-10-14 13:28:29.626850 +00:00', 'VNBANK357798', '357798', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5f12c5a3-8203-4f4d-9ab1-5543c3f188ee');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('eda3b43f-071d-4d0f-b673-4f23e0058087', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '110135', '2025-05-08 18:45:55.501443 +00:00', '2025-05-08 18:46:02.918728 +00:00', 'VNBANK110135', '110135', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ac3d203c-026d-459f-b19d-c09b3bc9c3c5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('af08282e-7f86-464e-b19a-da3349cfee77', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '698252', '2010-12-19 06:14:48.931284 +00:00', '2010-12-19 06:14:49.660847 +00:00', 'VNBANK698252', '698252', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '6a58e17c-5244-476c-8596-915549c4f1ee');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f6c44eef-da89-4345-88b5-1d8b86223301', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '443444', '2012-06-09 07:18:04.353559 +00:00', '2012-06-09 07:18:11.897258 +00:00', 'VNBANK443444', '443444', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '92d1afc2-f060-49c9-b32e-f673ae0c670b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0e54ded0-6a89-4ce2-8e9d-d4ab81e65e80', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '306706', '2023-12-20 05:35:43.423224 +00:00', '2023-12-20 05:35:51.879952 +00:00', 'VNBANK306706', '306706', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f6171b67-a380-4d27-bffc-7ae6422ae5a5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2362b400-9d00-4484-b749-7817f30060a6', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '74229', '2020-08-03 13:38:52.983570 +00:00', '2020-08-03 13:39:01.263113 +00:00', 'VNBANK74229', '74229', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'bd697226-f5ca-4b8e-8b47-6e6aae36df06');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a2e37ddc-a381-4fea-8348-e91829a859be', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 499000, 'VND', 499000, 'VNBANK', '518123', '2024-11-21 14:03:42.312435 +00:00', '2024-11-21 14:03:42.929117 +00:00', 'VNBANK518123', '518123', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f1e6d74b-d5fd-40a0-b1a8-130ed77e3a1c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('05849cd0-6dbe-4200-949f-17497d58673e', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '800316', '2022-02-18 02:03:11.721833 +00:00', '2022-02-18 02:03:15.500025 +00:00', 'VNBANK800316', '800316', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'd49a6b32-98d6-43a9-af88-1f0845f9a532');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('31211da7-6462-422e-8edf-47bf077b58c1', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '607174', '2011-06-29 10:58:05.815348 +00:00', '2011-06-29 10:58:08.575221 +00:00', 'VNBANK607174', '607174', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '15700dca-eb39-4dac-9c7a-c2a6be0ef86a');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('4b6310a4-2008-4978-b43d-f1fbfca72bf3', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '967922', '2011-04-25 05:58:13.653976 +00:00', '2011-04-25 05:58:19.833209 +00:00', 'VNBANK967922', '967922', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1d40e99c-e0ca-4712-9e60-4d16b817f138');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('05319274-3104-48df-9959-973e18d95970', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '356333', '2009-06-09 03:40:19.575332 +00:00', '2009-06-09 03:40:29.042542 +00:00', 'VNBANK356333', '356333', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ec1eb721-4d17-4633-89e7-7bbbd7ddceb1');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a9d93ca5-8d53-4839-bd92-2d2b3258e77a', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '646820', '2016-05-03 19:02:34.480347 +00:00', '2016-05-03 19:02:41.715547 +00:00', 'VNBANK646820', '646820', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0e2af8ed-c475-41b6-a2ec-245338a5aeca');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1cf68ab6-8380-481c-a5ec-ea38cb4c13bd', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '479130', '2021-11-20 02:52:02.477341 +00:00', '2021-11-20 02:52:11.000938 +00:00', 'VNBANK479130', '479130', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '18986914-d8a6-405e-ac43-4374b1c9f989');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('fc8c1b50-59c8-4dd0-bfb5-13f8a0cc6c59', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '790724', '2025-03-07 06:06:04.328203 +00:00', '2025-03-07 06:06:09.916101 +00:00', 'VNBANK790724', '790724', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'c7bb5bb5-7d42-4348-9499-94b95c101cfd');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ae207330-5fda-46c7-afc2-dca5a8fecc2a', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 499000, 'VND', 499000, 'VNBANK', '319669', '2021-09-03 11:42:46.878714 +00:00', '2021-09-03 11:42:55.907955 +00:00', 'VNBANK319669', '319669', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '8ecaa874-66ee-46f2-9044-41d691e32e9d');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d8480c4c-12da-4ab2-808b-4970b2c442d9', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '75405', '2010-04-25 03:35:39.111758 +00:00', '2010-04-25 03:35:47.163963 +00:00', 'VNBANK75405', '75405', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'bb775236-186e-41cd-b67d-c0a511ba57ad');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('36683b2c-0ba6-422d-85b2-842954f605f9', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 499000, 'VND', 499000, 'VNBANK', '554343', '2023-11-07 22:46:26.918651 +00:00', '2023-11-07 22:46:30.781219 +00:00', 'VNBANK554343', '554343', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f3749171-8ed2-4405-a5bc-7f81af51007b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e0a366c2-f4a4-40ff-990a-93cb061e21e5', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '68891', '2020-08-30 23:13:32.034021 +00:00', '2020-08-30 23:13:41.411730 +00:00', 'VNBANK68891', '68891', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'fb0b34cc-fa1b-4cb5-b94c-3a4075c9a738');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('a859d282-0b3e-4e57-91e2-dc4d889fb533', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '271927', '2008-03-28 22:59:39.215961 +00:00', '2008-03-28 22:59:45.999908 +00:00', 'VNBANK271927', '271927', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e064b4f8-ea9e-42fc-90a6-438edcf8a49f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('540ab122-877a-45b2-91d6-20c65037f84a', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '334803', '2020-08-21 00:58:37.318193 +00:00', '2020-08-21 00:58:41.621314 +00:00', 'VNBANK334803', '334803', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f097af7e-3e4c-4453-9c50-05b2864cac65');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('44af0c36-abf9-44de-9792-61b1171c8abe', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '968720', '2019-06-16 07:41:49.380902 +00:00', '2019-06-16 07:41:51.302245 +00:00', 'VNBANK968720', '968720', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1d935809-57a3-4614-9e1b-ab6da5e484c7');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0175b2c1-3040-4565-82ad-8d94a6674da9', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '446496', '2020-11-11 09:15:37.377253 +00:00', '2020-11-11 09:15:41.861208 +00:00', 'VNBANK446496', '446496', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'b0070ca0-e812-4a87-9cf8-bf8b1f584be3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('aa4f87ac-a591-4c91-89ea-47c1226cae7d', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '329971', '2024-08-02 18:57:38.637578 +00:00', '2024-08-02 18:57:47.356693 +00:00', 'VNBANK329971', '329971', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a50e341b-c1f0-4d35-863b-ddb243f6c843');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('853cc546-8e7a-45a0-8083-5029b034f4a0', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '44318', '2020-07-03 00:04:16.477332 +00:00', '2020-07-03 00:04:18.211746 +00:00', 'VNBANK44318', '44318', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '6d939dca-517a-46cc-b1cc-026f85f49244');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('28329bd8-8b59-48b7-bc12-c7fcf46931a2', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '713145', '2016-08-04 18:29:43.138404 +00:00', '2016-08-04 18:29:50.493361 +00:00', 'VNBANK713145', '713145', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3270438d-da2d-4b36-8ffd-6c016634f5f9');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('be8f90c3-9a03-416f-80f7-c05fe48b77b2', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '680675', '2010-01-20 06:29:05.545882 +00:00', '2010-01-20 06:29:06.670833 +00:00', 'VNBANK680675', '680675', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ee2dae4b-2f32-4a81-b4fc-839babd5b33e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('60d52dc7-ac8a-4fe8-a4a5-6f0e23ac48e3', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '579410', '2009-01-31 09:17:34.586321 +00:00', '2009-01-31 09:17:38.081595 +00:00', 'VNBANK579410', '579410', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ee653061-d690-4637-968f-439e96edbf80');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f8312286-1ed2-4579-9652-68e91fbec9ad', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '430217', '2015-04-18 22:51:16.098326 +00:00', '2015-04-18 22:51:21.657422 +00:00', 'VNBANK430217', '430217', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'edd9d17a-ecac-4037-9b67-ba30fc8acbf1');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('308d81bc-0103-49ad-98c9-5bb9646e9a80', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '805073', '2010-08-10 02:39:21.419015 +00:00', '2010-08-10 02:39:25.239166 +00:00', 'VNBANK805073', '805073', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'fa45a510-fcdd-4571-895b-d79c265fbfb3');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('1079e8dd-e905-4db9-be51-fbd19e843055', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '73226', '2009-02-28 09:46:15.568769 +00:00', '2009-02-28 09:46:21.261417 +00:00', 'VNBANK73226', '73226', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '7b49203b-7e6d-4da7-be09-386c7723313b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bfa28632-fb6b-448e-9b12-1e5120b5f21c', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '683811', '2009-07-20 00:26:56.314980 +00:00', '2009-07-20 00:26:57.733563 +00:00', 'VNBANK683811', '683811', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '6dccba82-62e2-473f-a43d-89555d779c42');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('87aa1f04-ab78-44de-98cd-1ddf172c90eb', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '470377', '2024-04-18 21:16:07.562438 +00:00', '2024-04-18 21:16:15.085776 +00:00', 'VNBANK470377', '470377', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3f67c0e1-eb07-484d-bc4d-1dc9a0e49c96');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('51ddff1c-f9e3-4a25-906f-1295493de553', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '568069', '2025-05-15 09:01:37.698328 +00:00', '2025-05-15 09:01:43.976830 +00:00', 'VNBANK568069', '568069', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '866d62e1-52db-4720-8fdd-866cd781a893');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('70ad7c1d-1760-4079-b2e9-2431c3cdfbe5', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '788833', '2019-07-07 04:48:10.380418 +00:00', '2019-07-07 04:48:17.007285 +00:00', 'VNBANK788833', '788833', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f7c16443-962d-4fc4-b49a-087c4807eea4');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('b7f4cbbf-7b61-4d47-8f15-8ae94aa12348', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '356515', '2007-05-04 13:52:10.474648 +00:00', '2007-05-04 13:52:18.221900 +00:00', 'VNBANK356515', '356515', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0f6bf56d-889c-46ca-80bc-9f0b338a742f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('24e0ca7b-f398-454e-a7fd-4f848ed56a93', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6b1fd807-2f7b-77a2-ea02-5530cadbe946', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '833332', '2006-08-02 07:58:07.030549 +00:00', '2006-08-02 07:58:09.003445 +00:00', 'VNBANK833332', '833332', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '37a1cc31-f974-4e9c-9fec-62c59fa3ec2e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3a58238b-51d4-4ab6-932d-ac63b243ef39', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '193375', '2018-04-17 15:07:11.166129 +00:00', '2018-04-17 15:07:16.704467 +00:00', 'VNBANK193375', '193375', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '86fb6ccf-6a5e-4d33-87c5-2bf0f0d8d58e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9db7fce1-a74b-4faf-8f53-e008109c1eb2', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '898487', '2025-03-07 08:47:32.789335 +00:00', '2025-03-07 08:47:36.764710 +00:00', 'VNBANK898487', '898487', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '133001a0-6b3a-4578-a6e5-d0be25330fa8');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('ded5a0ee-7121-4b51-96a1-99a09b0e1df8', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 499000, 'VND', 499000, 'VNBANK', '23078', '2019-08-30 09:32:02.989347 +00:00', '2019-08-30 09:32:03.263371 +00:00', 'VNBANK23078', '23078', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '77e1a6df-4f11-4a6a-b837-880e4e068bef');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('efb5a24d-4641-46e9-97a1-116db0df0727', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '61375', '2019-05-18 16:30:05.039579 +00:00', '2019-05-18 16:30:12.565408 +00:00', 'VNBANK61375', '61375', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '81ebca92-0e9f-4711-ad13-2dd9626ead10');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('5fcb4db7-8029-4aaf-8860-586e19006eb7', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '830359', '2013-05-09 16:42:46.227208 +00:00', '2013-05-09 16:42:54.472266 +00:00', 'VNBANK830359', '830359', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '81c5af20-f33d-484a-915e-63dff4d4035b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f658ec7e-7664-42fd-8b96-2210296443b2', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '128046', '2006-09-27 21:18:23.360505 +00:00', '2006-09-27 21:18:30.139222 +00:00', 'VNBANK128046', '128046', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '6eff7c00-3874-4c34-9ca0-967d10f23ae5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('faa437b0-ac61-4ddb-b3f8-f3dd2b54b81e', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '30578', '2020-05-06 03:44:13.291207 +00:00', '2020-05-06 03:44:18.329566 +00:00', 'VNBANK30578', '30578', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a06ff255-2461-4b52-bbb4-6b016dff3fce');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('770536f8-d996-47a9-8c73-7ce98dbd3df1', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '484584', '2024-03-06 04:53:57.960676 +00:00', '2024-03-06 04:54:07.430527 +00:00', 'VNBANK484584', '484584', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'edb1cec9-f458-4cd9-8995-1075c8c6e9cf');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('81a72712-f090-4059-a311-a45d30c2ea89', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '262541', '2007-07-24 21:19:04.774699 +00:00', '2007-07-24 21:19:04.916175 +00:00', 'VNBANK262541', '262541', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '59eee284-2e07-427c-94c4-b3e8546b9f93');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('dfeb2a83-3775-4bd4-ab6a-d1ff00a973d6', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '6eaea212-5351-45c3-3a53-9c9b9a407e1e', '00', '00', 499000, 'VND', 499000, 'VNBANK', '680199', '2021-08-16 08:24:42.555432 +00:00', '2021-08-16 08:24:50.694987 +00:00', 'VNBANK680199', '680199', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '59e2a541-dd6e-4ae9-bf19-18c0375fa543');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d31d5bcc-2dc8-4dcf-bf59-f31b421213d5', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '2e6402f0-d2b0-30ff-dc2e-53e9666d6f1d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '641872', '2019-04-01 18:46:04.082901 +00:00', '2019-04-01 18:46:04.606668 +00:00', 'VNBANK641872', '641872', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'ab98ff20-32e3-4215-aa54-a06aa33a04c5');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('dab90799-8077-4352-bd8c-7d1f6265ca95', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 499000, 'VND', 499000, 'VNBANK', '801429', '2020-03-22 02:01:24.906338 +00:00', '2020-03-22 02:01:27.677096 +00:00', 'VNBANK801429', '801429', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f679a431-d21c-43a8-8677-67e5316c3559');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3479ae21-32f8-4052-a38f-fe100206d265', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '377070', '2020-11-14 22:52:59.370913 +00:00', '2020-11-14 22:53:02.919470 +00:00', 'VNBANK377070', '377070', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'f9bb0bbf-00c7-483a-bb54-4b3e0d35e7a4');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d6eb3def-db68-4338-841e-64933ffc0e6c', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '131712', '2016-11-23 21:21:10.931150 +00:00', '2016-11-23 21:21:12.013653 +00:00', 'VNBANK131712', '131712', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '9f88570e-a141-45c7-8c15-dc5cd37ab08e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3df0c207-3fae-4fdc-a77d-e752e7e54086', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '59208f4f-d6ae-0792-0317-f36822578f81', '00', '00', 499000, 'VND', 499000, 'VNBANK', '993230', '2020-06-10 06:31:47.119128 +00:00', '2020-06-10 06:31:54.319606 +00:00', 'VNBANK993230', '993230', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'a447811b-a936-447a-82c3-8b928ce29a85');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0e961986-80f0-4b37-907d-2281bad8b7a7', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '560358', '2006-02-20 21:07:38.325233 +00:00', '2006-02-20 21:07:44.776893 +00:00', 'VNBANK560358', '560358', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '01a1b186-df51-46eb-9c51-174808543bb1');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d065ae6d-a2e9-48bb-b19e-c55a0187ea02', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'f42a0a9b-1e19-ea1e-f843-7b3304f41d5c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '877724', '2011-04-05 16:33:57.487481 +00:00', '2011-04-05 16:34:04.688459 +00:00', 'VNBANK877724', '877724', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '47457bd5-1745-4bf0-9f32-49d5c94d29ce');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('13d62cd0-9500-45d6-b8d5-9824055aa310', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '169799', '2014-08-05 09:08:05.677755 +00:00', '2014-08-05 09:08:11.503554 +00:00', 'VNBANK169799', '169799', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '5ac75d56-f26c-4ed7-9c41-96bc3ffa1c3c');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('bc82df3e-bb4a-4cf3-8660-0e5d44fbffdd', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '1974945b-162f-c609-9934-c330126caf14', '00', '00', 499000, 'VND', 499000, 'VNBANK', '837417', '2019-04-26 16:58:55.765646 +00:00', '2019-04-26 16:59:02.118639 +00:00', 'VNBANK837417', '837417', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '989505a1-60c0-493f-b71c-68b6fe2e839e');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('3ab451ed-014a-47c5-91e3-c3af9c8d7757', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f9191f86-e66d-e59f-6eea-d0a8092d54a0', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '989875', '2009-01-07 05:02:33.964289 +00:00', '2009-01-07 05:02:41.951803 +00:00', 'VNBANK989875', '989875', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'd2fb481e-ba95-46ce-8005-e7c0d3df58d9');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('8c4c1da9-896f-4ab2-8e10-7ad154d8fff7', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '130443', '2020-02-05 22:05:57.774360 +00:00', '2020-02-05 22:06:05.266627 +00:00', 'VNBANK130443', '130443', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '0ccb6146-589f-4589-852a-c6525541970b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('de8798dc-be63-48b8-a43c-0d2c35e1f353', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'bfa6012d-ce4b-c982-3de6-0d622af861ca', '00', '00', 499000, 'VND', 499000, 'VNBANK', '76496', '2020-09-27 01:06:21.305586 +00:00', '2020-09-27 01:06:26.808826 +00:00', 'VNBANK76496', '76496', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1b369d96-fdf6-45cf-a43e-5fce83fa67d6');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('d1701ffb-cce9-4e26-9943-be77fd9c03c9', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 499000, 'VND', 499000, 'VNBANK', '584984', '2021-07-20 13:46:16.948421 +00:00', '2021-07-20 13:46:26.156200 +00:00', 'VNBANK584984', '584984', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '228d9e45-6531-4e84-81eb-c357dce529fa');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f3472241-889b-4865-892e-e9551da26e5c', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '6f00f4cb-69c8-f3fc-23fe-dcdc65edfddb', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '878849', '2015-01-27 13:18:15.099219 +00:00', '2015-01-27 13:18:18.056833 +00:00', 'VNBANK878849', '878849', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3bdb3bd8-a9c3-4a81-8d8a-44dcf8e19ef7');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('69f62866-f9cf-4f3b-9fb8-c29498787533', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '430499', '2004-03-14 21:06:03.651909 +00:00', '2004-03-14 21:06:13.184307 +00:00', 'VNBANK430499', '430499', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '67a3b563-34e3-4f0b-acc9-026692f7ad1f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('42817928-3942-4af6-a422-e7189178dc31', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '573a0d23-196a-6b35-cf9c-6e168c18596a', '00', '00', 499000, 'VND', 499000, 'VNBANK', '592361', '2021-10-14 09:29:26.199083 +00:00', '2021-10-14 09:29:28.379832 +00:00', 'VNBANK592361', '592361', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '2c33308d-c2ac-481d-a67e-a409c717dc72');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('71b1b885-6c5b-4591-b56b-bec50151d940', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'ad9f9995-484b-9a12-8c25-7bd32527ab3d', '00', '00', 499000, 'VND', 499000, 'VNBANK', '654042', '2021-04-10 12:26:04.143595 +00:00', '2021-04-10 12:26:05.452867 +00:00', 'VNBANK654042', '654042', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '90132a16-618b-4f14-a485-fa3e925f4f9b');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('f707f2a6-73b4-44c1-b30c-a99d214922f9', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8fdd9c28-78e4-b5b4-741d-ccfaec3aa7b6', '00', '00', 499000, 'VND', 499000, 'VNBANK', '949990', '2021-05-09 20:34:52.545085 +00:00', '2021-05-09 20:35:00.097198 +00:00', 'VNBANK949990', '949990', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '52645d6d-7765-4001-b3cf-36f711c285bb');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('9996c843-f10d-4f42-9826-20630d118cb1', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 499000, 'VND', 499000, 'VNBANK', '634203', '2023-09-26 18:13:32.485982 +00:00', '2023-09-26 18:13:40.702733 +00:00', 'VNBANK634203', '634203', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '95b71b28-961f-4fe3-8901-3cc12bd6e1ce');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('2f2fbefd-aac8-4463-8afc-21a2fd4f5ccd', 'Dg12bGtwJHarGR8am1f9jleense2', '64ce3c40-114f-8f4b-50f5-d737cccc2c87', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '974878', '2013-04-05 08:05:21.948123 +00:00', '2013-04-05 08:05:26.818634 +00:00', 'VNBANK974878', '974878', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '4a043bb7-5926-458f-9e61-469a62d7a062');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('6c84f5b3-7c39-49b3-b5c5-5b9ce8e81dcc', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'e40c0cd8-ec50-df48-8ef2-2562a603ef99', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '393811', '2015-04-24 17:33:00.256763 +00:00', '2015-04-24 17:33:01.533489 +00:00', 'VNBANK393811', '393811', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', 'e6e0602d-e5fd-495c-8cc4-6d216795a46f');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('e2f862ed-1da5-4f19-aad0-659c34fbfddf', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'e4db16ca-ecf9-cf22-bcc9-b3eddfbe3cc9', '00', '00', 499000, 'VND', 499000, 'VNBANK', '456411', '2017-01-31 16:32:02.462559 +00:00', '2017-01-31 16:32:03.075549 +00:00', 'VNBANK456411', '456411', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '1e55e07d-cd98-4aaa-a78d-c26133fb38f9');
INSERT INTO public.vnpay_payment (payment_id, user_uid, user_uuid, transaction_status, response_code, total_payment_amount, currency, paid_amount, bank_code, transaction_reference, created_at, received_at, bank_transaction_no, transaction_no, order_description, payment_for, payment_premium_package_id) VALUES ('0c2909e2-1bf2-45fe-8a08-e72166472e2f', 'nCirq4T53BPtub8VnU5VQas14B12', 'aef57c4e-4011-1938-0086-86b46a63617c', '00', '00', 3588000, 'VND', 3588000, 'VNBANK', '857229', '2002-12-21 07:45:44.988424 +00:00', '2002-12-21 07:45:50.906824 +00:00', 'VNBANK857229', '857229', 'Thanh toan cho nang cap tai khoan: Premium Plan', 'Subscription', '3a71c4bd-18b8-4b34-9a9f-0111e7bdc479');

INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', 'e954a102-37e5-495d-970b-73aef3494bc5');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'nCirq4T53BPtub8VnU5VQas14B12', '36d46f5a-151c-49dd-846c-8010b69db08e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'nCirq4T53BPtub8VnU5VQas14B12', '140db242-ba8b-42e1-850b-628d5202711f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '3621742e-a546-4f8e-8d13-9be28d16b0ea');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '49da7006-e632-4246-b641-d14b3e0a9099');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', 'f5b986f4-19d2-4d4e-9c70-ea4e1c2a2c14');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', 'f828567b-4d9e-4fde-9e45-5fe8f168205b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'nCirq4T53BPtub8VnU5VQas14B12', 'a043bc04-1173-494f-9f8a-2ba9844fbba0');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', 'a748a5b2-a42f-409c-9207-04a9e8a594ad');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '25e08245-28fb-4f72-ada7-d0c85de13fec');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'fdf63243-288f-4271-9b06-4c3975e1f0d3');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', 'b393dcd8-4cfa-424e-a3aa-cab5f94e98d9');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', 'cd663b03-2049-4f33-8205-fffe7e4ab4f0');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '27d2e10f-c04e-4cb4-beb2-3cbd99d804ff');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '087a0916-2c4e-4ea2-849d-72cb4bdbb8c6');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'fe09b0cd-8c05-4cc4-871d-7927fda099f1');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', 'a1c4e8a4-277c-4a7b-8893-aac49033ae4f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '709825ec-687b-4019-84c6-6e17d35648dd');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'nCirq4T53BPtub8VnU5VQas14B12', '678140e4-3193-497e-8057-4773974e3411');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'nCirq4T53BPtub8VnU5VQas14B12', 'ff1ddeff-c482-45a4-b5c6-17169e826011');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '2a8ad71c-67f1-4606-bf8e-f2580d89caa3');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '94358d15-386b-440b-802c-c9a9a4c29272');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '10405bf0-f61f-44a0-ae7e-c6fec5e6b1fd');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '5ff6d4df-cd63-48e6-89a9-1bb953177508');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '4e459d6b-e45b-42b4-aaca-b6321fb39d64');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '6dda542c-3edc-4955-a501-114e3c88068c');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '7308b39c-2d0b-4418-a427-cf1ae950208a');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', 'f0316b1b-0f95-4589-bbc6-afd1aa98bd81');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'Dg12bGtwJHarGR8am1f9jleense2', 'ffdf6e79-dbe1-4a83-8171-f73e712eac1b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '927a3862-e211-409a-b5a1-c37dd0298c5a');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'fd176f42-6c32-4609-bbb7-bbd673a95f11');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '212070e2-f5f1-482e-bf19-f8eb53ff3c7f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '9c928b5c-5da6-453c-89b9-768096a233ff');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', 'd98fd52a-2cb1-4aa7-8396-627790a3f921');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '34f19f08-b96e-4e54-b182-c3d0b719fc0b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '54ca9005-dea8-4e4a-a73f-2c3a0d05696f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', 'e774b9c0-42aa-431a-b595-217f29606071');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'f50deaa0-d39a-459f-b77a-36f58210146e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'Dg12bGtwJHarGR8am1f9jleense2', '3e79694e-3f5e-4d4d-877f-8fed581b32da');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', 'f935506e-2ac5-440f-b9a0-b410ddbebf1f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', 'e105cf80-5fc7-4161-b37e-0d993e7d49fc');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '11c35445-e36c-4ed3-8e87-2635a45852dd');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'nCirq4T53BPtub8VnU5VQas14B12', '9d66e490-f03d-44b2-9372-140d3d9a6657');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '66d3280c-0959-4134-a2fc-344f0e385b68');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '1ab4e2cd-6607-468c-84bf-a7e200302065');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '19f4c330-7646-4000-8cf9-ab906f0448a9');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'ceaf1618-92cf-4d15-9d51-da2b002724d1');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '462ec5ec-c535-4d96-a1a8-993fa17f217f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'cc862a1c-0bdd-4ea6-ab43-a6a6a3d319d6');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', 'f6d69956-b9fe-42f7-87db-14324f3dbe9f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '7f4b95e0-42ec-4e88-9654-b977447ba0dd');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', 'fea57cd8-b043-41dc-b65f-bbd3303c3f61');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '5cbd09a4-c44d-4e0a-b338-6b8c4e27e4e8');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '003b0ca0-152d-4e68-beb4-76bfaadb833a');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '738aaa0c-a606-4a74-a86e-a1b9622d7d36');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '56715fd9-c387-43d0-95fa-1ff7a152cca8');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'cAI9FPriFaYdRQR41bx47DfO8mY2', 'a8d842d3-d119-4aea-82c1-ca7859acc98e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'dc659b80-eddc-4ecd-b151-d4c330ada469');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', 'daa89011-ea8f-463f-8538-300ed4b7cb63');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '993810eb-0b00-4b1b-a699-d0e13c9be1d2');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'nCirq4T53BPtub8VnU5VQas14B12', '6b7031c8-c6bc-4175-9ec9-fe3a36f760e8');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '8c2833eb-2169-4767-b869-b5a2468f8d04');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', '8jUtjY22UYTEKxglmbHeUTIuHBu2', 'a0fead72-57b5-4753-acdc-58fbaf94aba3');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '856a901b-a375-4bc6-ae52-f5574307c1ca');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'ce036758-358f-407d-8743-46c094946155');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '9c81f693-b9be-48d8-8074-fbcb93af5b14');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '57bb786b-56d1-4163-9998-a06a7c9e8b2e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '3499ba37-42d9-4c7c-9692-e6075075d63c');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '5cfd01fa-fe50-4e9f-a1ba-465fae50541c');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '857efadc-e1ee-44bc-b209-cfb512b9479b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', '8jUtjY22UYTEKxglmbHeUTIuHBu2', 'df283d6d-da51-44f3-957c-a790ce3f6b3e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '85eaef81-841b-4d65-ae6d-302e555e0090');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'e9ac197d-2b26-4af0-9855-40107c0ef09b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', 'f9369f64-f641-4c4a-92c9-60e8aab44c2b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '4329d10d-1612-4866-a914-63129fd7bfd6');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'nCirq4T53BPtub8VnU5VQas14B12', '361a5be2-726b-4ca6-9dd5-cc33f8172b21');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'ca6a5d57-b328-4a31-a8a0-0721f8052e92');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '9d973527-5e81-41d5-8d82-a5ffde47e9d0');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'd7787a7a-8ef5-4f90-a1d8-e5cb349b2cd2');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'Dg12bGtwJHarGR8am1f9jleense2', '4c818dd4-d2c1-48e0-993a-7c85bc956353');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '1bf47cf7-8d5c-410c-b638-b8c80bb6b342');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'cAI9FPriFaYdRQR41bx47DfO8mY2', 'ec275f1c-6490-4fee-a163-63c141e07d4a');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', 'b1ce830f-229a-44d4-89f6-cac218cd81b9');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '37c048b2-b8f1-4d1c-8353-7a4a7cbf0868');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '95812534-5197-4511-92f6-fd393526f0e6');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '4c390189-7b50-40ed-83ab-94742dacf58e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '3b88866c-4667-4c60-b597-384714ad5b82');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', 'ef3ff4c0-1b6d-41d7-8bcf-422aa7e3c73b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'Dg12bGtwJHarGR8am1f9jleense2', '1ac7449a-a11c-46a4-af8a-1f496db2e91b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '4d650ffa-bc11-4e9f-8d2e-d668d46f2abb');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '25d5af66-cb01-49b7-a699-28f4243cb94b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '24ff2140-7765-4781-9846-7128376d9bc9');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'f21f51cc-6d63-4393-91b1-abc732e237ee');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '5f5b2d13-a6f4-402a-b2f1-6de9060e42d4');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '321fff9b-6231-4c67-a589-b73b79609ef9');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'f7147bf1-49f7-41ed-b3e0-676eecef2ff5');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', 'a34a1e23-4ba0-4009-bcf8-5e088e2a3e0b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'bbe3e7e2-9625-4ac9-8fc9-d0c9714d7981');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '75858aae-ae7c-47f5-8599-8a9d460d3dc5');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'Dg12bGtwJHarGR8am1f9jleense2', 'b06717a2-0460-433a-9e8a-dce70e1efa37');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', 'ce0efd30-5010-4af5-a0fb-a36f4e7c19f9');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '9e6efafa-e975-4561-a042-c682be0d8e56');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '2e86bc41-8fef-493e-81e3-6ac390916e1d');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '512be2da-24d0-4727-a707-69c9a93a2dd7');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '4114563b-620d-4fb7-8472-8f93ce4f0330');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'd9eeacd5-638b-48b6-9e7c-a2bf9e3b628a');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '5d036e74-0528-4248-aebe-b9cd96102193');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'Dg12bGtwJHarGR8am1f9jleense2', '51761e72-cd2e-4a2f-a6e1-a88d2087289a');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'Dg12bGtwJHarGR8am1f9jleense2', '8227f389-79e0-469f-a52b-96e7d331c1ae');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '65c8b269-70c1-42fb-a8f9-de6f495eb7e7');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'fb3b2d24-5141-4287-a705-47f49438a4dd');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '9bb39520-cc76-492c-879f-638229c627e5');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '10c82477-5c83-4d60-9529-074ff41ffc78');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '7d70f009-7a2a-4e19-9150-8057230aa926');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'nCirq4T53BPtub8VnU5VQas14B12', '27bab176-3c8b-461b-b19b-a973e780e062');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '39787f1a-bd76-43da-b487-2b5fce12f449');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '3f1cd93d-9aba-4c99-bd74-1dd1b06b2ee3');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'Dg12bGtwJHarGR8am1f9jleense2', 'ba3224c1-10e5-4800-bdce-4335283ff27e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '9ad41dcd-bf42-4bb9-8dbf-248054863517');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '9533b2b2-60a6-48d8-be08-ab562e2dce3c');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'Dg12bGtwJHarGR8am1f9jleense2', 'bb584674-469c-4573-98a6-7968da68b38b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '73393459-44ac-4409-8e4a-5ba5d6cd74e1');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '625c07b8-291e-4f71-9a8d-ed596618013e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', 'd6debefd-4587-45e6-b192-117b3da60aff');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '284e2dd9-2597-4b14-9dc1-20d7de2d05f4');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', 'ef14e552-8243-484c-a7c0-900a541b128e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '2a3a2d4b-9b81-4120-af01-cca3601885ca');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', 'f2a85fd1-1ebb-4512-b741-827dc906f52b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'b5912506-8f4f-423f-a5a8-aeb2d087166c');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '27b2279d-33c7-4c1f-ac9a-c2816fb3e53a');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '1731e8ee-6cc4-466a-b4b0-8beb1189e340');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'bcd2ac6f-0089-46ab-a638-474354ae729e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '2b998d71-21f3-48f9-981c-23d4d303be38');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '57969f94-90ec-4346-9d5d-430e61e2bdba');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '5dd60519-137f-4ae7-9bc2-f27ed55b844f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '063e1fa5-7e6c-42f8-bf1d-e3ce90ca8245');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '9ce0df69-62f5-46e5-b654-bcf12c91b73b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '3ceadef9-90f5-408b-a8cd-43a359b5cc4e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '5f78d2b5-dc56-4989-acc0-e5e7d3771ad1');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '33c3a54a-db14-45d1-8fb4-2628dbc415bb');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'a550ba00-c20f-4c9e-b02e-eb550c763140');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '07b2e5f4-5623-4ab4-bae6-db5b3f8e986d');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '12fc377e-15e0-4c03-a2c0-2fa22c113d46');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '5f5b0d69-8f6d-4166-af4a-d18eae83f4f9');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', '8jUtjY22UYTEKxglmbHeUTIuHBu2', 'dba418c6-7a68-46b0-beb3-b28dcc3747a1');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '0689d380-e7c4-46c2-ae80-08eaf06657bd');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'f6009a30-77bf-48db-bcad-893c73228de5');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', 'f5048145-be59-43e1-b29b-0ad786f70b07');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '15ce5065-21a4-4d60-be32-31ad568fd734');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', '8jUtjY22UYTEKxglmbHeUTIuHBu2', 'b28bc8ca-1c49-44e2-b4fb-3f3f1d91824b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '328f5f74-761a-44e3-a1da-eeccc8e1303c');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'bf54b452-0a9e-4c9a-82fc-4503c477b503');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', 'fc127fe9-326e-495f-9559-fcdf90922f7f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'd53e0366-ca04-4e8c-aca1-d33ba439dfb9');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '17923856-698f-4b75-b92c-2dde5b524d4b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '97cbb271-dd0f-4f1a-81fd-690704e4a665');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '09e5707d-ff3e-4c7f-84dc-18b777543551');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '4a48c3a0-ca87-4afd-a21e-6fb2c6f77d18');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '8765fd16-b051-4c75-b5de-18106b72647d');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '030a68ad-83af-414e-b206-e94e95b868f0');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', 'c70f06d4-33e7-485e-a478-e672957c5ace');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'c3850334-6169-456a-b270-dffa6fd61abf');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '5156ef57-a4a9-4eab-aa50-dd57bf078ace');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '5cdccb72-3cfb-4813-874f-a25f45edb446');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'dda1b4d5-2db4-4b24-8780-da31866b89d6');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', 'bdcce407-534b-4676-8f67-a887e73e90de');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'cAI9FPriFaYdRQR41bx47DfO8mY2', 'f5301abb-82f9-4efe-b8e9-d9beb5bcbd99');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '94b2d82d-518f-4095-969a-4bc53494f912');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '89c862c2-d6fc-45ef-a6ad-9a6969dc05d4');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '28e9cd80-bc71-4980-8e7d-c2c7c02149e1');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '2ce907b2-3a92-43df-b04d-195853a097c6');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '5940f356-1f06-4334-9e1c-7d2fc2162b35');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '7f423ed1-2ea4-45a9-bed0-206b3922b09a');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', '4oXW9av7xuULl3CwRIU6PU0rcUm1', '3042f7cc-70f5-4bc0-a136-65755984bb1a');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '8e2c26af-40f0-4f91-ad72-d9db988a6372');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', 'b04c8058-9bf5-4b21-81db-f4281f43ee92');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'Dg12bGtwJHarGR8am1f9jleense2', 'a9576346-9e42-4b35-bbb4-9d64602a58cd');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '1fce8743-7777-400c-b1c2-1d6762850647');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '4768712b-85e2-46ca-855e-9fdd43f663b5');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '1373409f-3eb3-46fe-bd9f-de907835e468');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '4ab437b9-2e0c-4fe9-86c2-5647e3f7d520');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '099b3206-2f52-4bfc-955f-c6bbb0f9b253');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '4836b683-bf6c-4f7f-a65f-fa9bb8ed4498');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '7a749eea-f800-4006-b8c9-6758413ecee5');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '40a96c35-75e7-4a96-bc41-91e4f5e6d48b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '419e91a2-1935-4d9c-8609-f4f1f371c5a8');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', 'b34a032f-a174-43ff-9944-0c1613e4cb8e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '70de39c3-75d5-4fb5-ad63-4a7a6f0edc85');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'nCirq4T53BPtub8VnU5VQas14B12', '1cc20c79-1e8e-44f9-b334-ac96e1902ce3');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', '8jUtjY22UYTEKxglmbHeUTIuHBu2', '23c86950-bec5-4818-ac2f-d31330799c05');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'Dg12bGtwJHarGR8am1f9jleense2', 'ec6bfdd7-99a7-4aee-a398-e561334ab931');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', 'a36e7826-dc1c-495b-81cf-dddd19612c63');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('a75fb9c7-d3db-41d3-8e89-265730b5d629', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', '3fd185a0-554e-49d5-a7ec-a50f5e26fa82');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', '17ba34a6-bb50-4062-b4eb-a30fe0f80db9');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'HK0KvF5fZzUYRdAyEzb1gNWjiU62', 'db2d639d-1392-4b64-9aa4-656b0155c14f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', '0f234b7e-cd29-4b32-b21e-695bb742df00');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'bc89db32-7f76-4120-82c7-cdf16a64c895');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', 'a0d0fabd-82f5-4e5a-9426-1bc7ae296d1c');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'b9cca4a0-23e5-4fae-abd6-8e92a6d21698');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '95dd954f-c132-46b2-a709-f41c51cce97d');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('82d991c9-2ed9-4d33-b4d9-be5a6dcaf4ae', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'fc8133ee-5e98-4607-bd94-e35e0d3e0ee4');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '2bc92b9c-3b90-4b45-8be4-b6bdfc3c3d4f');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '3b06a6b7-bad6-4369-845d-fd71c9c9bc10');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', '9c9f11f6-808f-4d72-a27a-8d9a7e6680ae');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8ff4ea92-41f2-4d49-b230-0281874efb2d', 'ZqrT4hQ0yLa3QlwZZITY2CQ6txG2', '35249462-ac28-43f8-bc9a-d4d83d01c391');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'efa94235-3247-4708-87fb-9230fc2ab931');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'aadce037-9438-4d4c-9683-68c7c9f6e631');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'nCirq4T53BPtub8VnU5VQas14B12', 'ae32711a-7d7a-4cd7-ba37-01a98ae34db4');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '577b7524-03cb-43c2-b8c4-e2723e243e54');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '45c2fd5c-1448-4d69-b9c1-893b678f7286');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'MmAkaDuTU6PveDxSNEGvMg2QLsF3', 'a417b631-74fa-4f16-93a5-53f6165f1b1e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'MIRKJL5khfa0PyzpKP2khJrLy6f1', 'fdd21a41-948a-432d-8ca9-5c249b5e6fb7');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'Dg12bGtwJHarGR8am1f9jleense2', 'f68f71e2-036c-4a54-9a39-d9255f1de64c');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'oPoMnzU4ucdCRuhiGophhnL3Stp2', '05c7c91d-43ee-4a11-8896-1e39df529986');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', 'b96493c1-f185-4fbf-8219-87cfd2fe2927');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'ZXUBibqcgxXnRJTiiSvXqJ2DNbc2', '67d0b02e-76e4-41e1-a6fe-3a284bdc0586');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'nCirq4T53BPtub8VnU5VQas14B12', '413f0ac1-7cb9-4b87-8b5c-0fd9f205e98b');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('92f189a3-47d3-478a-b5a7-2832db75e119', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '829b988d-7843-4ea9-8975-3dd18d015070');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '1ffcfc41-41a9-4ce7-bd76-cac061ebf71e');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('6b76ba5c-548f-4dec-86d9-6d32f004f6b9', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '70cad1d1-afa7-41a7-b8b5-5ff1b7fb46d8');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'nCirq4T53BPtub8VnU5VQas14B12', '5b41b4a3-7da1-402e-8e00-386fa69864da');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', 'b2119bc7-6b34-495b-b368-ea7d52360955');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('aa613599-339e-4150-afe7-c11818e51f86', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', 'b3837ba9-3ffb-439f-b189-d622b609b6cb');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', 'Dg12bGtwJHarGR8am1f9jleense2', '04281eaf-472a-443c-a9e1-2f5e93dc3d6d');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'ce6d3ecf-383a-4ff3-ad56-842f9f11bc56');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('dfd2221f-9615-4ca8-9967-27ec7542e991', 'FT38VBSnmKUaCKuA6QwV8voS6NJ2', '86f52c72-f34a-48da-96b2-fa01f1d2490d');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('8e963cdf-2416-4196-bea7-f24a5272964d', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'bf4774ab-0401-4596-b131-050ac7c0f6a5');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'nFmwM1SHRFdGLodbmXvKUOqyUoK2', '721be235-d816-4953-a6ea-c8398137a4da');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'KJAUoOuLbFTUrNLOSHGIzYjI5Z63', '98cd279e-a7d7-4232-807c-ff760da3cbd2');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'nCirq4T53BPtub8VnU5VQas14B12', 'a62d7134-84d1-4e2d-ad79-64d3cfc3ffe5');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('91010d93-3d40-40d6-9b3f-f0f950fe508a', 'iod7SPGlxWUa3JcyCjc1eoSiaBM2', 'd999d402-d420-45e1-90ff-a46ea90cedc0');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'cAI9FPriFaYdRQR41bx47DfO8mY2', '278d694e-c54c-45ec-a29b-a1da84fbbefe');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '263bd7a7-9b7e-4c16-b652-79fc9b847d14');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('00a55f07-0d45-4d32-9f5e-e92777155e56', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', '61aee4d3-75aa-4248-8e58-44b8700343aa');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('4e26b4bd-d406-4641-9d68-3ba8e1c39c97', '4oXW9av7xuULl3CwRIU6PU0rcUm1', 'd834b152-20ab-47e9-bf0a-a5c7706443a7');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('bd157822-862c-4b14-80e0-791fb1f7f1f6', 'WgPbP365QOfkZSfEmu6WG0Tpntx2', '9aa4aadc-2be2-46fa-b0e6-e15f6439b9d2');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('598d78e5-c34f-437f-88fb-31557168c07b', 'Dg12bGtwJHarGR8am1f9jleense2', '4117cc89-1e4c-4d48-b0f7-01f1af388089');
INSERT INTO public.vnpay_payment_courses (course_id, user_uid, payment_id) VALUES ('575bd0a6-afca-439c-bb6f-f1a0caaa27b9', 'M7OzKUnPmraVgbyvKTgDtG35lLq1', 'e5ba8e99-da40-484b-b01c-37e5fd57a592');

CREATE OR REPLACE FUNCTION create_first_point_badge()
	RETURNS TRIGGER 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
	IF (NEW.type = 'course') THEN 
		INSERT INTO achievements(user_id, badge_id, achieved_date)
		SELECT NEW.user_id, b.badge_id, now()
		FROM badges b WHERE badge_name = 'First Course';
	ELSIF (NEW.type = 'problem') THEN
		INSERT INTO achievements(user_id, badge_id, achieved_date)
		SELECT NEW.user_id, b.badge_id, now()
		FROM badges b WHERE badge_name = 'First Problem';
	END IF;
	RETURN NEW;
END;
$BODY$;

CREATE TRIGGER add_point_badge
AFTER INSERT ON leaderboard
FOR EACH ROW
EXECUTE FUNCTION create_first_point_badge();



CREATE OR REPLACE FUNCTION public.create_premium_badge()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
	IF (NEW.payment_for = 'Subscription' AND NEW.transaction_status = '00') THEN
		
		IF NOT EXISTS(	SELECT 1 FROM achievements 
						WHERE user_id = NEW.user_uuid 
						AND badge_id = (	SELECT badge_id 
											FROM badges 
											WHERE badge_name = 'Premium User'
										)
			) THEN 
			INSERT INTO achievements(user_id, badge_id, achieved_date)
			SELECT NEW.user_uuid, b.badge_id, now()
			FROM badges b
			WHERE b.badge_name = 'Premium User';
		END IF;
	END IF;
	
	
	RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.create_premium_badge()
    OWNER TO postgres;


CREATE OR REPLACE TRIGGER add_premium_badge
    AFTER UPDATE 
    ON public.vnpay_payment
    FOR EACH ROW
    EXECUTE FUNCTION public.create_premium_badge();



CREATE OR REPLACE FUNCTION create_point_badge()
	RETURNS TRIGGER 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$

BEGIN
	IF (NEW.type = 'all') THEN 
		RETURN NEW;
	END IF;
	
	IF (NEW.type = 'course') THEN
		IF (NEW.total_course = 5) THEN 
			IF NOT EXISTS(	SELECT 1 FROM achievements 
							WHERE user_id = NEW.user_id AND badge_id = 6
						) THEN
				INSERT INTO achievements(user_id, achieved_date, badge_id)
				VALUES (NEW.user_id, NOW(), 6);
			END IF;
			
		ELSIF (NEW.total_course = 10) THEN
			IF NOT EXISTS(	SELECT 1 FROM achievements 
							WHERE user_id = NEW.user_id AND badge_id = 5
						) THEN
				INSERT INTO achievements(user_id, achieved_date, badge_id)
				VALUES (NEW.user_id, NOW(), 5);
			END IF;
			
		END IF;
		
	ELSIF (NEW.type = 'problem') THEN
		IF (NEW.total_problem = 10) THEN 
			IF NOT EXISTS(	SELECT 1 FROM achievements 
							WHERE user_id = NEW.user_id AND badge_id = 8
						) THEN
				INSERT INTO achievements(user_id, achieved_date, badge_id)
				VALUES (NEW.user_id, NOW(), 8);
			END IF;
		ELSIF (NEW.total_problem = 20) THEN
			IF NOT EXISTS(	SELECT 1 FROM achievements 
							WHERE user_id = NEW.user_id AND badge_id = 7
						) THEN
				INSERT INTO achievements(user_id, achieved_date, badge_id)
				VALUES (NEW.user_id, NOW(), 7);
			END IF;
		END IF;
	END IF;
	
	RETURN NEW;
END;
$BODY$;

CREATE TRIGGER add_higher_point_badge
AFTER UPDATE ON leaderboard
FOR EACH ROW
EXECUTE FUNCTION create_point_badge();



